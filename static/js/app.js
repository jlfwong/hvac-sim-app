"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module2) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            // Used to reproduce behavior of `batchedUpdates` in legacy mode.
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn2(format2) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format2, args);
              }
            }
          }
          function error2(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            /**
             * Checks whether or not this composite component is mounted.
             * @param {ReactClass} publicInstance The instance we want to test.
             * @return {boolean} True if mounted, false otherwise.
             * @protected
             * @final
             */
            isMounted: function(publicInstance) {
              return false;
            },
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            /**
             * Replaces all of the state. Always use this or `setState` to mutate state.
             * You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} completeState Next state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            /**
             * Sets a subset of the state. This only exists because _pendingState is
             * internal. This provides a merging strategy that is not available to deep
             * properties which is confusing. TODO: Expose pendingState or don't use it
             * during the merge.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} partialState Next partial state to be merged with state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} Name of the calling function in the public API.
             * @internal
             */
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign2 = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component2.prototype.isReactComponent = {};
          Component2.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component2.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component2.prototype, methodName, {
                get: function() {
                  warn2("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component2.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign2(pureComponentPrototype, Component2.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init3(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty2.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty2.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement10(type, config2, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config2);
                }
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              self2 = config2.__self === void 0 ? null : config2.__self;
              source = config2.__source === void 0 ? null : config2.__source;
              for (propName in config2) {
                if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps2 = type.defaultProps;
              for (propName in defaultProps2) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps2[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement8(element, config2, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign2({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              var defaultProps2;
              if (element.type && element.type.defaultProps) {
                defaultProps2 = element.type.defaultProps;
              }
              for (propName in config2) {
                if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config2[propName] === void 0 && defaultProps2 !== void 0) {
                    props[propName] = defaultProps2[propName];
                  } else {
                    props[propName] = config2[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement5(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape3(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match3) {
              return escaperLookup[match3];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape3("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                  return c;
                });
              } else if (mappedChild != null) {
                if (isValidElement5(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                      // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                      // eslint-disable-next-line react-internal/safe-string-coercion
                      escapeUserProvidedKey("" + mappedChild.key) + "/"
                    ) : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n2 = 0;
            mapChildren(children, function() {
              n2++;
            });
            return n2;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement5(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext14(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              // As a workaround to support multiple concurrent renderers, we categorize
              // some renderers as primary and others as secondary. We only expect
              // there to be two concurrent renderers at most: React Native (primary) and
              // Fabric (secondary); React DOM (primary) and React ART (secondary).
              // Secondary renderers store their context values on separate fields.
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              // Used to track how many concurrent renderers this context currently
              // supports within in a single renderer. Such as parallel server rendering.
              _threadCount: 0,
              // These are circular
              Provider: null,
              Consumer: null,
              // Add these to use same hidden class in VM as ServerContext
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn2("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error3) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error3;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              // We use these fields to store the result.
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps2;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps2;
                  },
                  set: function(newDefaultProps) {
                    error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps2 = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef6(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error2("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render.name && !render.displayName) {
                    render.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo3(type, compare) {
            {
              if (!isValidElementType(type)) {
                error2("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext17(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState17(initialState2) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState2);
          }
          function useReducer3(reducer, initialArg, init3) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init3);
          }
          function useRef18(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect22(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useInsertionEffect5(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
          }
          function useLayoutEffect5(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback16(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo20(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
          }
          function useDebugValue2(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId8() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match3 = x.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match3 && match3[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn2);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s2 = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
                  c--;
                }
                for (; s2 >= 1 && c >= 0; s2--, c--) {
                  if (sampleLines[s2] !== controlLines[c]) {
                    if (s2 !== 1 || c !== 1) {
                      do {
                        s2--;
                        c--;
                        if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s2 >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty2);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node2, parentType) {
            if (typeof node2 !== "object") {
              return;
            }
            if (isArray(node2)) {
              for (var i = 0; i < node2.length; i++) {
                var child = node2[i];
                if (isValidElement5(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement5(node2)) {
              if (node2._store) {
                node2._store.validated = true;
              }
            } else if (node2) {
              var iteratorFn = getIteratorFn(node2);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node2.entries) {
                  var iterator = iteratorFn.call(node2);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement5(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys3 = Object.keys(fragment.props);
              for (var i = 0; i < keys3.length; i++) {
                var key = keys3[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement10.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn2("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn2("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement8.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module2 && module2[requireString];
                enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error3) {
                popActScope(prevActScopeDepth);
                throw error3;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error3) {
                      popActScope(prevActScopeDepth);
                      reject(error3);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error3) {
                  reject(error3);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i = 0;
                try {
                  for (; i < queue.length; i++) {
                    var callback = queue[i];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error3) {
                  queue = queue.slice(i + 1);
                  throw error3;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children5 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports.Children = Children5;
          exports.Component = Component2;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext14;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef6;
          exports.isValidElement = isValidElement5;
          exports.lazy = lazy;
          exports.memo = memo3;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback16;
          exports.useContext = useContext17;
          exports.useDebugValue = useDebugValue2;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect22;
          exports.useId = useId8;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useInsertionEffect = useInsertionEffect5;
          exports.useLayoutEffect = useLayoutEffect5;
          exports.useMemo = useMemo20;
          exports.useReducer = useReducer3;
          exports.useRef = useRef18;
          exports.useState = useState17;
          exports.useSyncExternalStore = useSyncExternalStore2;
          exports.useTransition = useTransition;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var frameYieldMs = 5;
          function push(heap, node2) {
            var index = heap.length;
            heap.push(node2);
            siftUp(heap, node2, index);
          }
          function peek2(heap) {
            return heap.length === 0 ? null : heap[0];
          }
          function pop(heap) {
            if (heap.length === 0) {
              return null;
            }
            var first = heap[0];
            var last = heap.pop();
            if (last !== first) {
              heap[0] = last;
              siftDown(heap, last, 0);
            }
            return first;
          }
          function siftUp(heap, node2, i) {
            var index = i;
            while (index > 0) {
              var parentIndex = index - 1 >>> 1;
              var parent = heap[parentIndex];
              if (compare(parent, node2) > 0) {
                heap[parentIndex] = node2;
                heap[index] = parent;
                index = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node2, i) {
            var index = i;
            var length2 = heap.length;
            var halfLength = length2 >>> 1;
            while (index < halfLength) {
              var leftIndex = (index + 1) * 2 - 1;
              var left2 = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right2 = heap[rightIndex];
              if (compare(left2, node2) < 0) {
                if (rightIndex < length2 && compare(right2, left2) < 0) {
                  heap[index] = right2;
                  heap[rightIndex] = node2;
                  index = rightIndex;
                } else {
                  heap[index] = left2;
                  heap[leftIndex] = node2;
                  index = leftIndex;
                }
              } else if (rightIndex < length2 && compare(right2, node2) < 0) {
                heap[index] = right2;
                heap[rightIndex] = node2;
                index = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate2 = Date;
            var initialTime = localDate2.now();
            exports.unstable_now = function() {
              return localDate2.now() - initialTime;
            };
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
          var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
          var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
          var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
          function advanceTimers(currentTime) {
            var timer = peek2(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
              } else {
                return;
              }
              timer = peek2(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek2(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek2(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error2) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error2;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek2(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek2(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek2(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek2(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            var startTime2;
            if (typeof options === "object" && options !== null) {
              var delay2 = options.delay;
              if (typeof delay2 === "number" && delay2 > 0) {
                startTime2 = currentTime + delay2;
              } else {
                startTime2 = currentTime;
              }
            } else {
              startTime2 = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime) {
              newTask.sortIndex = startTime2;
              push(timerQueue, newTask);
              if (peek2(taskQueue) === null && newTask === peek2(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek2(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var frameInterval = frameYieldMs;
          var startTime = -1;
          function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
              return false;
            }
            return true;
          }
          function requestPaint() {
          }
          function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              frameInterval = Math.floor(1e3 / fps);
            } else {
              frameInterval = frameYieldMs;
            }
          }
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now();
              startTime = currentTime;
              var hasTimeRemaining = true;
              var hasMoreWork = true;
              try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
              } finally {
                if (hasMoreWork) {
                  schedulePerformWorkUntilDeadline();
                } else {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                }
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var schedulePerformWorkUntilDeadline;
          if (typeof localSetImmediate === "function") {
            schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port.postMessage(null);
            };
          } else {
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          }
          function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              schedulePerformWorkUntilDeadline();
            }
          }
          function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          }
          function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_forceFrameRate = forceFrameRate;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_shouldYield = shouldYieldToHost;
          exports.unstable_wrapCallback = unstable_wrapCallback;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React53 = require_react();
          var Scheduler = require_scheduler();
          var ReactSharedInternals = React53.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          var suppressWarning = false;
          function setSuppressWarning(newSuppressWarning) {
            {
              suppressWarning = newSuppressWarning;
            }
          }
          function warn2(format2) {
            {
              if (!suppressWarning) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format2, args);
              }
            }
          }
          function error2(format2) {
            {
              if (!suppressWarning) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment9 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var ScopeComponent = 21;
          var OffscreenComponent = 22;
          var LegacyHiddenComponent = 23;
          var CacheComponent = 24;
          var TracingMarkerComponent = 25;
          var enableClientRenderFallbackOnTextMismatch = true;
          var enableNewReconciler = false;
          var enableLazyContextPropagation = false;
          var enableLegacyHidden = false;
          var enableSuspenseAvoidThisFallback = false;
          var disableCommentsAsDOMContainers = true;
          var enableCustomElementPropertySupport = false;
          var warnAboutStringRefs = false;
          var enableSchedulingProfiler = true;
          var enableProfilerTimer = true;
          var enableProfilerCommitHooks = true;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i = 0; i < dependencies.length; i++) {
              allNativeEvents.add(dependencies[i]);
            }
          }
          var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkPropStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkFormFieldValueStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error2("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix3 = name.toLowerCase().slice(0, 5);
                  return prefix3 !== "data-" && prefix3 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            // TODO: This prevents the assignment of defaultValue to regular
            // elements (not just inputs). Now that ReactDOMInput assigns to the
            // defaultValue property -- do we need this?
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              RESERVED,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            // Note: there is a special case that prevents it from being written to the DOM
            // on the client side because the browsers are inconsistent. Instead we call focus().
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            // Microdata
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "checked",
            // Note: `option.selected` is not updated if `select.multiple` is
            // disabled with `removeAttribute`. We have special logic for handling this.
            "multiple",
            "muted",
            "selected"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              true,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "capture",
            "download"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              OVERLOADED_BOOLEAN,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              POSITIVE_NUMERIC,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              NUMERIC,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token2) {
            return token2[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              // sanitizeURL
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            // mustUseProperty
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            // sanitizeURL
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              true,
              // sanitizeURL
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node2, name, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node2[propertyName];
              } else {
                {
                  checkAttributeStringCoercion(expected, name);
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node2.hasAttribute(attributeName)) {
                    var value = node2.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node2.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return node2.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node2.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node2, name, expected, isCustomComponentTag) {
            {
              if (!isAttributeNameSafe(name)) {
                return;
              }
              if (!node2.hasAttribute(name)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node2.getAttribute(name);
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node2, name, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name);
            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) {
                  node2.removeAttribute(_attributeName);
                } else {
                  {
                    checkAttributeStringCoercion(value, name);
                  }
                  node2.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node2[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node2[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node2.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node2.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node2.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_CACHE_TYPE = Symbol.for("react.cache");
          var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var assign2 = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match3 = x.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match3 && match3[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn2);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s2 = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
                  c--;
                }
                for (; s2 >= 1 && c >= 0; s2--, c--) {
                  if (sampleLines[s2] !== controlLines[c]) {
                    if (s2 !== 1 || c !== 1) {
                      do {
                        s2--;
                        c--;
                        if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s2 >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node2 = workInProgress2;
              do {
                info += describeFiber(node2);
                node2 = node2.return;
              } while (node2);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init3(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName$1(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case CacheComponent:
                return "Cache";
              case ContextConsumer:
                var context = type;
                return getContextName$1(context) + ".Consumer";
              case ContextProvider:
                var provider = type;
                return getContextName$1(provider._context) + ".Provider";
              case DehydratedFragment:
                return "DehydratedFragment";
              case ForwardRef:
                return getWrappedName$1(type, type.render, "ForwardRef");
              case Fragment9:
                return "Fragment";
              case HostComponent:
                return type;
              case HostPortal:
                return "Portal";
              case HostRoot:
                return "Root";
              case HostText:
                return "Text";
              case LazyComponent:
                return getComponentNameFromType(type);
              case Mode:
                if (type === REACT_STRICT_MODE_TYPE) {
                  return "StrictMode";
                }
                return "Mode";
              case OffscreenComponent:
                return "Offscreen";
              case Profiler:
                return "Profiler";
              case ScopeComponent:
                return "Scope";
              case SuspenseComponent:
                return "Suspense";
              case SuspenseListComponent:
                return "SuspenseList";
              case TracingMarkerComponent:
                return "TracingMarker";
              case ClassComponent:
              case FunctionComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case MemoComponent:
              case SimpleMemoComponent:
                if (typeof type === "function") {
                  return type.displayName || type.name || null;
                }
                if (typeof type === "string") {
                  return type;
                }
                break;
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentNameFromFiber(owner);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function getCurrentFiber() {
            {
              return current;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString2(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value;
              case "object":
                {
                  checkFormFieldValueStringCoercion(value);
                }
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node2) {
            return node2._valueTracker;
          }
          function detachTracker(node2) {
            node2._valueTracker = null;
          }
          function getValueFromNode(node2) {
            var value = "";
            if (!node2) {
              return value;
            }
            if (isCheckable(node2)) {
              value = node2.checked ? "true" : "false";
            } else {
              value = node2.value;
            }
            return value;
          }
          function trackValueOnNode(node2) {
            var valueField = isCheckable(node2) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node2.constructor.prototype, valueField);
            {
              checkFormFieldValueStringCoercion(node2[valueField]);
            }
            var currentValue = "" + node2[valueField];
            if (node2.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get4 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node2, valueField, {
              configurable: true,
              get: function() {
                return get4.call(this);
              },
              set: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node2, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node2);
                delete node2[valueField];
              }
            };
            return tracker;
          }
          function track(node2) {
            if (getTracker(node2)) {
              return;
            }
            node2._valueTracker = trackValueOnNode(node2);
          }
          function updateValueIfChanged(node2) {
            if (!node2) {
              return false;
            }
            var tracker = getTracker(node2);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node2);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement2(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e3) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node2 = element;
            var checked = props.checked;
            var hostProps = assign2({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node2._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node2 = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node2._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node2 = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node2, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node2 = element;
            {
              var controlled = isControlled(props);
              if (!node2._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node2._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node2.value === "" || // We explicitly want to coerce to number here if possible.
                // eslint-disable-next-line
                node2.value != value) {
                  node2.value = toString2(value);
                }
              } else if (node2.value !== toString2(value)) {
                node2.value = toString2(value);
              }
            } else if (type === "submit" || type === "reset") {
              node2.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node2, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node2, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node2.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node2 = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString2(node2._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node2.value) {
                    node2.value = initialValue;
                  }
                }
              }
              {
                node2.defaultValue = initialValue;
              }
            }
            var name = node2.name;
            if (name !== "") {
              node2.name = "";
            }
            {
              node2.defaultChecked = !node2.defaultChecked;
              node2.defaultChecked = !!node2._wrapperState.initialChecked;
            }
            if (name !== "") {
              node2.name = name;
            }
          }
          function restoreControlledState(element, props) {
            var node2 = element;
            updateWrapper(node2, props);
            updateNamedCousins(node2, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name = props.name;
            if (props.type === "radio" && name != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              {
                checkAttributeStringCoercion(name, "name");
              }
              var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
              for (var i = 0; i < group.length; i++) {
                var otherNode = group[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node2, type, value) {
            if (
              // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
              type !== "number" || getActiveElement2(node2.ownerDocument) !== node2
            ) {
              if (value == null) {
                node2.defaultValue = toString2(node2._wrapperState.initialValue);
              } else if (node2.defaultValue !== toString2(value)) {
                node2.defaultValue = toString2(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          var didWarnInvalidInnerHTML = false;
          function validateProps(element, props) {
            {
              if (props.value == null) {
                if (typeof props.children === "object" && props.children !== null) {
                  React53.Children.forEach(props.children, function(child) {
                    if (child == null) {
                      return;
                    }
                    if (typeof child === "string" || typeof child === "number") {
                      return;
                    }
                    if (!didWarnInvalidChild) {
                      didWarnInvalidChild = true;
                      error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                    }
                  });
                } else if (props.dangerouslySetInnerHTML != null) {
                  if (!didWarnInvalidInnerHTML) {
                    didWarnInvalidInnerHTML = true;
                    error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString2(getToStringValue(props.value)));
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i = 0; i < valuePropNames.length; i++) {
                var propName = valuePropNames[i];
                if (props[propName] == null) {
                  continue;
                }
                var propNameIsArray = isArray(props[propName]);
                if (props.multiple && !propNameIsArray) {
                  error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && propNameIsArray) {
                  error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node2, multiple, propValue, setDefaultSelected) {
            var options2 = node2.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i = 0; i < selectedValues.length; i++) {
                selectedValue["$" + selectedValues[i]] = true;
              }
              for (var _i = 0; _i < options2.length; _i++) {
                var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
                if (options2[_i].selected !== selected) {
                  options2[_i].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options2[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString2(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i2 = 0; _i2 < options2.length; _i2++) {
                if (options2[_i2].value === _selectedValue) {
                  options2[_i2].selected = true;
                  if (setDefaultSelected) {
                    options2[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options2[_i2].disabled) {
                  defaultSelected = options2[_i2];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$1(element, props) {
            return assign2({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node2 = element;
            {
              checkSelectPropTypes(props);
            }
            node2._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node2 = element;
            node2.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node2, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node2, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node2 = element;
            var wasMultiple = node2._wrapperState.wasMultiple;
            node2._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node2, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node2, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node2, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node2 = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node2, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$2(element, props) {
            var node2 = element;
            if (props.dangerouslySetInnerHTML != null) {
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
            var hostProps = assign2({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString2(node2._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node2 = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue = props.defaultValue;
              if (children != null) {
                {
                  error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (defaultValue != null) {
                    throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                  if (isArray(children)) {
                    if (children.length > 1) {
                      throw new Error("<textarea> can only have at most one child.");
                    }
                    children = children[0];
                  }
                  defaultValue = children;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node2._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node2 = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString2(value);
              if (newValue !== node2.value) {
                node2.value = newValue;
              }
              if (props.defaultValue == null && node2.defaultValue !== newValue) {
                node2.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node2.defaultValue = toString2(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node2 = element;
            var textContent = node2.textContent;
            if (textContent === node2._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node2.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node2, html) {
            if (node2.namespaceURI === SVG_NAMESPACE) {
              if (!("innerHTML" in node2)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node2.firstChild) {
                  node2.removeChild(node2.firstChild);
                }
                while (svgNode.firstChild) {
                  node2.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node2.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node2, text) {
            if (text) {
              var firstChild = node2.firstChild;
              if (firstChild && firstChild === node2.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node2.textContent = text;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related properties
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix3, key) {
            return prefix3 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes2 = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes2.forEach(function(prefix3) {
              isUnitlessNumber[prefixKey(prefix3, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name, value, isCustomProperty3) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
              return "";
            }
            if (!isCustomProperty3 && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
              return value + "px";
            }
            {
              checkCSSPropertyStringCoercion(value, name);
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string) {
              return string.replace(hyphenPattern, function(_, character2) {
                return character2.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error2(
                "Unsupported style property %s. Did you mean %s?",
                name,
                // As Andi Smith suggests
                // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
                // is converted to lowercase `ms`.
                camelize(name.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error2("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error2("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles2) {
            {
              var serialized = "";
              var delimiter2 = "";
              for (var styleName in styles2) {
                if (!styles2.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles2[styleName];
                if (styleValue != null) {
                  var isCustomProperty3 = styleName.indexOf("--") === 0;
                  serialized += delimiter2 + (isCustomProperty3 ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty3);
                  delimiter2 = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node2, styles2) {
            var style2 = node2.style;
            for (var styleName in styles2) {
              if (!styles2.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty3 = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty3) {
                  warnValidStyle$1(styleName, styles2[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles2[styleName], isCustomProperty3);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty3) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles2) {
            var expanded = {};
            for (var key in styles2) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i = 0; i < longhands.length; i++) {
                expanded[longhands[i]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
            // NOTE: menuitem's close tag should be omitted, but that causes problems.
          };
          var voidElementTags = assign2({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (props.children != null || props.dangerouslySetInnerHTML != null) {
                throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (props.children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (props.style != null && typeof props.style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            // HTML
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            // SVG
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            // state
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            // state
            "aria-hidden": 0,
            // state
            "aria-invalid": 0,
            // state
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            // Widget Attributes
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            // Live Region Attributes
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            // Drag-and-Drop Attributes
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            // Relationship Attributes
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty2.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, eventRegistry) {
              if (hasOwnProperty2.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error2("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          var currentReplayingEvent = null;
          function setReplayingEvent(event) {
            {
              if (currentReplayingEvent !== null) {
                error2("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = event;
          }
          function resetReplayingEvent() {
            {
              if (currentReplayingEvent === null) {
                error2("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = null;
          }
          function isReplayingEvent(event) {
            return event === currentReplayingEvent;
          }
          function getEventTarget3(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (typeof restoreImpl !== "function") {
              throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i = 0; i < queuedTargets.length; i++) {
                restoreStateOfTarget(queuedTargets[i]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn2, bookkeeping) {
            return fn2(bookkeeping);
          };
          var flushSyncImpl = function() {
          };
          var isInsideEventHandler = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushSyncImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn2, a, b) {
            if (isInsideEventHandler) {
              return fn2(a, b);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn2, a, b);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl = _flushSyncImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (listener && typeof listener !== "function") {
              throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM2) {
            try {
              var options = {};
              Object.defineProperty(options, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options, options);
              window.removeEventListener("test", options, options);
            } catch (e3) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e3, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context, funcArgs);
            } catch (error3) {
              this.onError(error3);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e3, f) {
                if (typeof document === "undefined" || document === null) {
                  throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context, funcArgs);
                  didError = false;
                }
                var error3;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error3 = event.error;
                  didSetError = true;
                  if (error3 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error3 != null && typeof error3 === "object") {
                      try {
                        error3._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name ? name : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error3);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error3) {
              hasError = true;
              caughtError = error3;
            }
          };
          function invokeGuardedCallback(name, func, context, a, b, c, d, e3, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e3, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error3 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error3;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error3 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error3;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error3 = caughtError;
              hasError = false;
              caughtError = null;
              return error3;
            } else {
              throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function get3(key) {
            return key._reactInternals;
          }
          function has(key) {
            return key._reactInternals !== void 0;
          }
          function set(key, value) {
            key._reactInternals = value;
          }
          var NoFlags = (
            /*                      */
            0
          );
          var PerformedWork = (
            /*                */
            1
          );
          var Placement = (
            /*                    */
            2
          );
          var Update = (
            /*                       */
            4
          );
          var ChildDeletion = (
            /*                */
            16
          );
          var ContentReset = (
            /*                 */
            32
          );
          var Callback = (
            /*                     */
            64
          );
          var DidCapture = (
            /*                   */
            128
          );
          var ForceClientRender = (
            /*            */
            256
          );
          var Ref = (
            /*                          */
            512
          );
          var Snapshot = (
            /*                     */
            1024
          );
          var Passive = (
            /*                      */
            2048
          );
          var Hydrating = (
            /*                    */
            4096
          );
          var Visibility = (
            /*                   */
            8192
          );
          var StoreConsistency = (
            /*             */
            16384
          );
          var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
          var HostEffectMask = (
            /*               */
            32767
          );
          var Incomplete = (
            /*                   */
            32768
          );
          var ShouldCapture = (
            /*                */
            65536
          );
          var ForceUpdateForLegacySuspense = (
            /* */
            131072
          );
          var Forked = (
            /*                       */
            1048576
          );
          var RefStatic = (
            /*                    */
            2097152
          );
          var LayoutStatic = (
            /*                 */
            4194304
          );
          var PassiveStatic = (
            /*                */
            8388608
          );
          var MountLayoutDev = (
            /*               */
            16777216
          );
          var MountPassiveDev = (
            /*              */
            33554432
          );
          var BeforeMutationMask = (
            // TODO: Remove Update flag from before mutation phase by re-landing Visibility
            // flag logic (see #20043)
            Update | Snapshot | 0
          );
          var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
          var LayoutMask = Update | Callback | Ref | Visibility;
          var PassiveMask = Passive | ChildDeletion;
          var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node2 = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node2;
              do {
                node2 = nextNode;
                if ((node2.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node2.return;
                }
                nextNode = node2.return;
              } while (nextNode);
            } else {
              while (node2.return) {
                node2 = node2.return;
              }
            }
            if (node2.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get3(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a.return !== b.return) {
                a = parentA;
                b = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a.alternate !== b) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
          }
          function findCurrentHostFiberImpl(node2) {
            if (node2.tag === HostComponent || node2.tag === HostText) {
              return node2;
            }
            var child = node2.child;
            while (child !== null) {
              var match3 = findCurrentHostFiberImpl(child);
              if (match3 !== null) {
                return match3;
              }
              child = child.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
          }
          function findCurrentHostFiberWithNoPortalsImpl(node2) {
            if (node2.tag === HostComponent || node2.tag === HostText) {
              return node2;
            }
            var child = node2.child;
            while (child !== null) {
              if (child.tag !== HostPortal) {
                var match3 = findCurrentHostFiberWithNoPortalsImpl(child);
                if (match3 !== null) {
                  return match3;
                }
              }
              child = child.sibling;
            }
            return null;
          }
          var scheduleCallback = Scheduler.unstable_scheduleCallback;
          var cancelCallback = Scheduler.unstable_cancelCallback;
          var shouldYield = Scheduler.unstable_shouldYield;
          var requestPaint = Scheduler.unstable_requestPaint;
          var now3 = Scheduler.unstable_now;
          var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
          var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
          var NormalPriority = Scheduler.unstable_NormalPriority;
          var LowPriority = Scheduler.unstable_LowPriority;
          var IdlePriority = Scheduler.unstable_IdlePriority;
          var unstable_yieldValue = Scheduler.unstable_yieldValue;
          var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
          var rendererID = null;
          var injectedHook = null;
          var injectedProfilingHooks = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              if (enableSchedulingProfiler) {
                internals = assign2({}, internals, {
                  getLaneLabelMap,
                  injectProfilingHooks
                });
              }
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error2("React instrumentation encountered an error: %s.", err);
              }
            }
            if (hook.checkDCE) {
              return true;
            } else {
              return false;
            }
          }
          function onScheduleRoot(root2, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root2, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root2, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root2.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  var schedulerPriority;
                  switch (eventPriority) {
                    case DiscreteEventPriority:
                      schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority;
                      break;
                  }
                  injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onPostCommitRoot(root2) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root2);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            {
              if (typeof unstable_yieldValue === "function") {
                unstable_setDisableYieldValue(newIsStrictMode);
                setSuppressWarning(newIsStrictMode);
              }
              if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                  {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error2("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              }
            }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function getLaneLabelMap() {
            {
              var map2 = /* @__PURE__ */ new Map();
              var lane = 1;
              for (var index2 = 0; index2 < TotalLanes; index2++) {
                var label = getLabelForLane(lane);
                map2.set(lane, label);
                lane *= 2;
              }
              return map2;
            }
          }
          function markCommitStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                injectedProfilingHooks.markCommitStarted(lanes);
              }
            }
          }
          function markCommitStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                injectedProfilingHooks.markCommitStopped();
              }
            }
          }
          function markComponentRenderStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                injectedProfilingHooks.markComponentRenderStarted(fiber);
              }
            }
          }
          function markComponentRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                injectedProfilingHooks.markComponentRenderStopped();
              }
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStopped();
              }
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
              }
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStopped();
              }
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
              }
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
              }
            }
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
              }
            }
          }
          function markLayoutEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                injectedProfilingHooks.markLayoutEffectsStarted(lanes);
              }
            }
          }
          function markLayoutEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                injectedProfilingHooks.markLayoutEffectsStopped();
              }
            }
          }
          function markPassiveEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              }
            }
          }
          function markPassiveEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                injectedProfilingHooks.markPassiveEffectsStopped();
              }
            }
          }
          function markRenderStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                injectedProfilingHooks.markRenderStarted(lanes);
              }
            }
          }
          function markRenderYielded() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                injectedProfilingHooks.markRenderYielded();
              }
            }
          }
          function markRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                injectedProfilingHooks.markRenderStopped();
              }
            }
          }
          function markRenderScheduled(lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                injectedProfilingHooks.markRenderScheduled(lane);
              }
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
              }
            }
          }
          function markStateUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
              }
            }
          }
          var NoMode = (
            /*                         */
            0
          );
          var ConcurrentMode = (
            /*                 */
            1
          );
          var ProfileMode = (
            /*                    */
            2
          );
          var StrictLegacyMode = (
            /*               */
            8
          );
          var StrictEffectsMode = (
            /*              */
            16
          );
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
          }
          var TotalLanes = 31;
          var NoLanes = (
            /*                        */
            0
          );
          var NoLane = (
            /*                          */
            0
          );
          var SyncLane = (
            /*                        */
            1
          );
          var InputContinuousHydrationLane = (
            /*    */
            2
          );
          var InputContinuousLane = (
            /*             */
            4
          );
          var DefaultHydrationLane = (
            /*            */
            8
          );
          var DefaultLane = (
            /*                     */
            16
          );
          var TransitionHydrationLane = (
            /*                */
            32
          );
          var TransitionLanes = (
            /*                       */
            4194240
          );
          var TransitionLane1 = (
            /*                        */
            64
          );
          var TransitionLane2 = (
            /*                        */
            128
          );
          var TransitionLane3 = (
            /*                        */
            256
          );
          var TransitionLane4 = (
            /*                        */
            512
          );
          var TransitionLane5 = (
            /*                        */
            1024
          );
          var TransitionLane6 = (
            /*                        */
            2048
          );
          var TransitionLane7 = (
            /*                        */
            4096
          );
          var TransitionLane8 = (
            /*                        */
            8192
          );
          var TransitionLane9 = (
            /*                        */
            16384
          );
          var TransitionLane10 = (
            /*                       */
            32768
          );
          var TransitionLane11 = (
            /*                       */
            65536
          );
          var TransitionLane12 = (
            /*                       */
            131072
          );
          var TransitionLane13 = (
            /*                       */
            262144
          );
          var TransitionLane14 = (
            /*                       */
            524288
          );
          var TransitionLane15 = (
            /*                       */
            1048576
          );
          var TransitionLane16 = (
            /*                       */
            2097152
          );
          var RetryLanes = (
            /*                            */
            130023424
          );
          var RetryLane1 = (
            /*                             */
            4194304
          );
          var RetryLane2 = (
            /*                             */
            8388608
          );
          var RetryLane3 = (
            /*                             */
            16777216
          );
          var RetryLane4 = (
            /*                             */
            33554432
          );
          var RetryLane5 = (
            /*                             */
            67108864
          );
          var SomeRetryLane = RetryLane1;
          var SelectiveHydrationLane = (
            /*          */
            134217728
          );
          var NonIdleLanes = (
            /*                          */
            268435455
          );
          var IdleHydrationLane = (
            /*               */
            268435456
          );
          var IdleLane = (
            /*                        */
            536870912
          );
          var OffscreenLane = (
            /*                   */
            1073741824
          );
          function getLabelForLane(lane) {
            {
              if (lane & SyncLane) {
                return "Sync";
              }
              if (lane & InputContinuousHydrationLane) {
                return "InputContinuousHydration";
              }
              if (lane & InputContinuousLane) {
                return "InputContinuous";
              }
              if (lane & DefaultHydrationLane) {
                return "DefaultHydration";
              }
              if (lane & DefaultLane) {
                return "Default";
              }
              if (lane & TransitionHydrationLane) {
                return "TransitionHydration";
              }
              if (lane & TransitionLanes) {
                return "Transition";
              }
              if (lane & RetryLanes) {
                return "Retry";
              }
              if (lane & SelectiveHydrationLane) {
                return "SelectiveHydration";
              }
              if (lane & IdleHydrationLane) {
                return "IdleHydration";
              }
              if (lane & IdleLane) {
                return "Idle";
              }
              if (lane & OffscreenLane) {
                return "Offscreen";
              }
            }
          }
          var NoTimestamp = -1;
          var nextTransitionLane = TransitionLane1;
          var nextRetryLane = RetryLane1;
          function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
              case SyncLane:
                return SyncLane;
              case InputContinuousHydrationLane:
                return InputContinuousHydrationLane;
              case InputContinuousLane:
                return InputContinuousLane;
              case DefaultHydrationLane:
                return DefaultHydrationLane;
              case DefaultLane:
                return DefaultLane;
              case TransitionHydrationLane:
                return TransitionHydrationLane;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return lanes & TransitionLanes;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return lanes & RetryLanes;
              case SelectiveHydrationLane:
                return SelectiveHydrationLane;
              case IdleHydrationLane:
                return IdleHydrationLane;
              case IdleLane:
                return IdleLane;
              case OffscreenLane:
                return OffscreenLane;
              default:
                {
                  error2("Should have found matching lanes. This is a bug in React.");
                }
                return lanes;
            }
          }
          function getNextLanes(root2, wipLanes) {
            var pendingLanes = root2.pendingLanes;
            if (pendingLanes === NoLanes) {
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
            // bother waiting until the root is complete.
            (wipLanes & suspendedLanes) === NoLanes) {
              var nextLane = getHighestPriorityLane(nextLanes);
              var wipLane = getHighestPriorityLane(wipLanes);
              if (
                // Tests whether the next lane is equal or lower priority than the wip
                // one. This works because the bits decrease in priority as you go left.
                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
                // only difference between default updates and transition updates is that
                // default updates do not support refresh transitions.
                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
              ) {
                return wipLanes;
              }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
              nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root2.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root2.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index2 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index2;
                nextLanes |= entanglements[index2];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root2, lanes) {
            var eventTimes = root2.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var eventTime = eventTimes[index2];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            switch (lane) {
              case SyncLane:
              case InputContinuousHydrationLane:
              case InputContinuousLane:
                return currentTime + 250;
              case DefaultHydrationLane:
              case DefaultLane:
              case TransitionHydrationLane:
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return currentTime + 5e3;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return NoTimestamp;
              case SelectiveHydrationLane:
              case IdleHydrationLane:
              case IdleLane:
              case OffscreenLane:
                return NoTimestamp;
              default:
                {
                  error2("Should have found matching lanes. This is a bug in React.");
                }
                return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root2, currentTime) {
            var pendingLanes = root2.pendingLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var expirationTime = expirationTimes[index2];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index2] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root2.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root2) {
            return getHighestPriorityLanes(root2.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root2) {
            var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function includesBlockingLane(root2, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
          }
          function includesExpiredLane(root2, lanes) {
            return (lanes & root2.expiredLanes) !== NoLanes;
          }
          function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
              nextTransitionLane = TransitionLane1;
            }
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
              nextRetryLane = RetryLane1;
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a, b) {
            return (a & b) !== NoLanes;
          }
          function isSubsetOfLanes(set2, subset) {
            return (set2 & subset) === subset;
          }
          function mergeLanes(a, b) {
            return a | b;
          }
          function removeLanes(set2, subset) {
            return set2 & ~subset;
          }
          function intersectLanes(a, b) {
            return a & b;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a, b) {
            return a !== NoLane && a < b ? a : b;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i = 0; i < TotalLanes; i++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root2, updateLane, eventTime) {
            root2.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
              root2.suspendedLanes = NoLanes;
              root2.pingedLanes = NoLanes;
            }
            var eventTimes = root2.eventTimes;
            var index2 = laneToIndex(updateLane);
            eventTimes[index2] = eventTime;
          }
          function markRootSuspended(root2, suspendedLanes) {
            root2.suspendedLanes |= suspendedLanes;
            root2.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root2, pingedLanes, eventTime) {
            root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          }
          function markRootFinished(root2, remainingLanes) {
            var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
            root2.pendingLanes = remainingLanes;
            root2.suspendedLanes = NoLanes;
            root2.pingedLanes = NoLanes;
            root2.expiredLanes &= remainingLanes;
            root2.mutableReadLanes &= remainingLanes;
            root2.entangledLanes &= remainingLanes;
            var entanglements = root2.entanglements;
            var eventTimes = root2.eventTimes;
            var expirationTimes = root2.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              entanglements[index2] = NoLanes;
              eventTimes[index2] = NoTimestamp;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root2, entangledLanes) {
            var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
            var entanglements = root2.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              if (
                // Is this one of the newly entangled lanes?
                lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
                entanglements[index2] & entangledLanes
              ) {
                entanglements[index2] |= entangledLanes;
              }
              lanes &= ~lane;
            }
          }
          function getBumpedLaneForHydration(root2, renderLanes2) {
            var renderLane = getHighestPriorityLane(renderLanes2);
            var lane;
            switch (renderLane) {
              case InputContinuousLane:
                lane = InputContinuousHydrationLane;
                break;
              case DefaultLane:
                lane = DefaultHydrationLane;
                break;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                lane = TransitionHydrationLane;
                break;
              case IdleLane:
                lane = IdleHydrationLane;
                break;
              default:
                lane = NoLane;
                break;
            }
            if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
              return NoLane;
            }
            return lane;
          }
          function addFiberToLanesMap(root2, fiber, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
            while (lanes > 0) {
              var index2 = laneToIndex(lanes);
              var lane = 1 << index2;
              var updaters = pendingUpdatersLaneMap[index2];
              updaters.add(fiber);
              lanes &= ~lane;
            }
          }
          function movePendingFibersToMemoized(root2, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
            var memoizedUpdaters = root2.memoizedUpdaters;
            while (lanes > 0) {
              var index2 = laneToIndex(lanes);
              var lane = 1 << index2;
              var updaters = pendingUpdatersLaneMap[index2];
              if (updaters.size > 0) {
                updaters.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  if (alternate === null || !memoizedUpdaters.has(alternate)) {
                    memoizedUpdaters.add(fiber);
                  }
                });
                updaters.clear();
              }
              lanes &= ~lane;
            }
          }
          function getTransitionsForLanes(root2, lanes) {
            {
              return null;
            }
          }
          var DiscreteEventPriority = SyncLane;
          var ContinuousEventPriority = InputContinuousLane;
          var DefaultEventPriority = DefaultLane;
          var IdleEventPriority = IdleLane;
          var currentUpdatePriority = NoLane;
          function getCurrentUpdatePriority() {
            return currentUpdatePriority;
          }
          function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
          }
          function runWithPriority(priority, fn2) {
            var previousPriority = currentUpdatePriority;
            try {
              currentUpdatePriority = priority;
              return fn2();
            } finally {
              currentUpdatePriority = previousPriority;
            }
          }
          function higherEventPriority(a, b) {
            return a !== 0 && a < b ? a : b;
          }
          function lowerEventPriority(a, b) {
            return a === 0 || a > b ? a : b;
          }
          function isHigherEventPriority(a, b) {
            return a !== 0 && a < b;
          }
          function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
              return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
              return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
              return DefaultEventPriority;
            }
            return IdleEventPriority;
          }
          function isRootDehydrated(root2) {
            var currentState = root2.current.memoizedState;
            return currentState.isDehydrated;
          }
          var _attemptSynchronousHydration;
          function setAttemptSynchronousHydration(fn2) {
            _attemptSynchronousHydration = fn2;
          }
          function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn2) {
            attemptContinuousHydration = fn2;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn2) {
            attemptHydrationAtCurrentPriority = fn2;
          }
          var getCurrentUpdatePriority$1;
          function setGetCurrentUpdatePriority(fn2) {
            getCurrentUpdatePriority$1 = fn2;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn2) {
            attemptHydrationAtPriority = fn2;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            // Intentionally camelCase
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (isRootDehydrated(root2)) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function queueExplicitHydrationTarget(target) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
              blockedOn: null,
              target,
              priority: updatePriority
            };
            var i = 0;
            for (; i < queuedExplicitHydrationTargets.length; i++) {
              if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
                break;
              }
            }
            queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
            if (i === 0) {
              attemptExplicitHydrationTarget(queuedTarget);
            }
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn === null) {
                {
                  var nativeEvent = queuedEvent.nativeEvent;
                  var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                  setReplayingEvent(nativeEventClone);
                  nativeEvent.target.dispatchEvent(nativeEventClone);
                  resetReplayingEvent();
                }
              } else {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map2.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i = 1; i < queuedDiscreteEvents.length; i++) {
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEventPriority:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              case DefaultEventPriority:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(DiscreteEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(ContinuousEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            {
              dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
          }
          function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              clearIfContinuousEvent(domEventName, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              nativeEvent.stopPropagation();
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
              while (blockedOn !== null) {
                var fiber = getInstanceFromNode(blockedOn);
                if (fiber !== null) {
                  attemptSynchronousHydration(fiber);
                }
                var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (nextBlockedOn === null) {
                  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                }
                if (nextBlockedOn === blockedOn) {
                  break;
                }
                blockedOn = nextBlockedOn;
              }
              if (blockedOn !== null) {
                nativeEvent.stopPropagation();
              }
              return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          var return_targetInst = null;
          function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget3(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (isRootDehydrated(root2)) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            return_targetInst = targetInst;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message": {
                var schedulerPriority = getCurrentPriorityLevel();
                switch (schedulerPriority) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              }
              default:
                return DefaultEventPriority;
            }
          }
          function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive2) {
            target.addEventListener(eventType, listener, {
              capture: true,
              passive: passive2
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive2) {
            target.addEventListener(eventType, listener, {
              passive: passive2
            });
            return listener;
          }
          var root = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset() {
            root = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start2;
            var startValue = startText;
            var startLength = startValue.length;
            var end2;
            var endValue = getText();
            var endLength = endValue.length;
            for (start2 = 0; start2 < startLength; start2++) {
              if (startValue[start2] !== endValue[start2]) {
                break;
              }
            }
            var minEnd = startLength - start2;
            for (end2 = 1; end2 <= minEnd; end2++) {
              if (startValue[startLength - end2] !== endValue[endLength - end2]) {
                break;
              }
            }
            var sliceTail = end2 > 1 ? 1 - end2 : void 0;
            fallbackText = endValue.slice(start2, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root) {
              return root.value;
            }
            return root.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize5 = Interface[_propName];
                if (normalize5) {
                  this[_propName] = normalize5(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign2(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              /**
               * We release all dispatched `SyntheticEvent`s after each event loop, adding
               * them back into the pool. This allows a way to hold onto a reference that
               * won't be added back into the pool.
               */
              persist: function() {
              },
              /**
               * Checks if this event should be released back into the pool.
               *
               * @return {boolean} True if this should not be released, false otherwise.
               */
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = assign2({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = assign2({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0)
                return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = assign2({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = assign2({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = assign2({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = assign2({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = assign2({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = assign2({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            // Legacy Interface
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = assign2({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = assign2({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = assign2({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = assign2({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : (
                // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                "wheelDeltaX" in event ? -event.wheelDeltaX : 0
              );
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : (
                // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                "wheelDeltaY" in event ? -event.wheelDeltaY : (
                  // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                  "wheelDelta" in event ? -event.wheelDelta : 0
                )
              );
            },
            deltaZ: 0,
            // Browsers without "deltaMode" is reporting in raw wheel delta where one
            // notch on the scroll is always +/- 120, roughly equivalent to pixels.
            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM2 && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM2 && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM2 && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
            !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM2) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget3(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM2) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node2) {
            var state2 = node2._wrapperState;
            if (!state2 || !state2.controlled || node2.type !== "number") {
              return;
            }
            {
              setDefaultValue(node2, "number", node2.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from2;
            var to;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from2 = targetInst;
              to = _related ? getClosestInstanceFromNode(_related) : null;
              if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                  to = null;
                }
              }
            } else {
              from2 = null;
              to = targetInst;
            }
            if (from2 === to) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from2 == null ? win : getNodeFromInstance(from2);
            var toNode = to == null ? win : getNodeFromInstance(to);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from2, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from2, to);
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i = 0; i < keysA.length; i++) {
              var currentKey = keysA[i];
              if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node2) {
            while (node2 && node2.firstChild) {
              node2 = node2.firstChild;
            }
            return node2;
          }
          function getSiblingNode(node2) {
            while (node2) {
              if (node2.nextSibling) {
                return node2.nextSibling;
              }
              node2 = node2.parentNode;
            }
          }
          function getNodeForCharacterOffset(root2, offset3) {
            var node2 = getLeafNode(root2);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node2) {
              if (node2.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node2.textContent.length;
                if (nodeStart <= offset3 && nodeEnd >= offset3) {
                  return {
                    node: node2,
                    offset: offset3 - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node2 = getLeafNode(getSiblingNode(node2));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e3) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length2 = 0;
            var start2 = -1;
            var end2 = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node2 = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next2 = null;
                while (true) {
                  if (node2 === anchorNode && (anchorOffset === 0 || node2.nodeType === TEXT_NODE)) {
                    start2 = length2 + anchorOffset;
                  }
                  if (node2 === focusNode && (focusOffset === 0 || node2.nodeType === TEXT_NODE)) {
                    end2 = length2 + focusOffset;
                  }
                  if (node2.nodeType === TEXT_NODE) {
                    length2 += node2.nodeValue.length;
                  }
                  if ((next2 = node2.firstChild) === null) {
                    break;
                  }
                  parentNode = node2;
                  node2 = next2;
                }
                while (true) {
                  if (node2 === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start2 = length2;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end2 = length2;
                  }
                  if ((next2 = node2.nextSibling) !== null) {
                    break;
                  }
                  node2 = parentNode;
                  parentNode = node2.parentNode;
                }
                node2 = next2;
              }
            if (start2 === -1 || end2 === -1) {
              return null;
            }
            return {
              start: start2,
              end: end2
            };
          }
          function setOffsets(node2, offsets) {
            var doc = node2.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length2 = node2.textContent.length;
            var start2 = Math.min(offsets.start, length2);
            var end2 = offsets.end === void 0 ? start2 : Math.min(offsets.end, length2);
            if (!selection.extend && start2 > end2) {
              var temp = end2;
              end2 = start2;
              start2 = temp;
            }
            var startMarker = getNodeForCharacterOffset(node2, start2);
            var endMarker = getNodeForCharacterOffset(node2, end2);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range2 = doc.createRange();
              range2.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start2 > end2) {
                selection.addRange(range2);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range2.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range2);
              }
            }
          }
          function isTextNode(node2) {
            return node2 && node2.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node2) {
            return node2 && node2.ownerDocument && containsNode(node2.ownerDocument.documentElement, node2);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement2();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement2(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i = 0; i < ancestors.length; i++) {
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start2 = offsets.start;
            var end2 = offsets.end;
            if (end2 === void 0) {
              end2 = start2;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start2;
              input.selectionEnd = Math.min(end2, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM2 && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node2) {
            if ("selectionStart" in node2 && hasSelectionCapabilities(node2)) {
              return {
                start: node2.selectionStart,
                end: node2.selectionEnd
              };
            } else {
              var win = node2.ownerDocument && node2.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement2(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes3 = {};
            prefixes3[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes3["Webkit" + styleProp] = "webkit" + eventName;
            prefixes3["Moz" + styleProp] = "moz" + eventName;
            return prefixes3;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM2) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function registerSimpleEvents() {
            for (var i = 0; i < simpleEventPluginEvents.length; i++) {
              var eventName = simpleEventPluginEvents[i];
              var domEventName = eventName.toLowerCase();
              var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
              // nonDelegatedEvents list in DOMPluginEventSystem.
              // Then we can remove this special list.
              // This is a breaking change that can wait until React 18.
              domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i = dispatchListeners.length - 1; i >= 0; i--) {
                var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i = 0; _i < dispatchListeners.length; _i++) {
                var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i = 0; i < dispatchQueue.length; i++) {
              var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget3(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
              if (!nonDelegatedEvents.has(domEventName)) {
                error2('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            {
              if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                error2('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (domEventName !== "selectionchange") {
                  if (!nonDelegatedEvents.has(domEventName)) {
                    listenToNativeEvent(domEventName, false, rootContainerElement);
                  }
                  listenToNativeEvent(domEventName, true, rootContainerElement);
                }
              });
              var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
              if (ownerDocument !== null) {
                if (!ownerDocument[listeningMarker]) {
                  ownerDocument[listeningMarker] = true;
                  listenToNativeEvent("selectionchange", false, ownerDocument);
                }
              }
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node2 = targetInst;
                mainLoop:
                  while (true) {
                    if (node2 === null) {
                      return;
                    }
                    var nodeTag = node2.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                      var container2 = node2.stateNode.containerInfo;
                      if (isMatchingRootContainer(container2, targetContainerNode)) {
                        break;
                      }
                      if (nodeTag === HostPortal) {
                        var grandNode = node2.return;
                        while (grandNode !== null) {
                          var grandTag = grandNode.tag;
                          if (grandTag === HostRoot || grandTag === HostPortal) {
                            var grandContainer = grandNode.stateNode.containerInfo;
                            if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                              return;
                            }
                          }
                          grandNode = grandNode.return;
                        }
                      }
                      while (container2 !== null) {
                        var parentNode = getClosestInstanceFromNode(container2);
                        if (parentNode === null) {
                          return;
                        }
                        var parentTag = parentNode.tag;
                        if (parentTag === HostComponent || parentTag === HostText) {
                          node2 = ancestorInst = parentNode;
                          continue mainLoop;
                        }
                        container2 = container2.parentNode;
                      }
                    }
                    node2 = node2.return;
                  }
              }
            }
            batchedUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent2(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent2(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent2(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent2(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent2(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent2(nodeA);
              nodeB = getParent2(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from2, to) {
            var common = from2 && to ? getLowestCommonAncestor(from2, to) : null;
            if (from2 !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from2, common, false);
            }
            if (to !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var warnedUnknownTags;
          var validatePropertiesInDevelopment;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              // There are working polyfills for <dialog>. Let people use it.
              dialog: true,
              // Electron ships a custom <webview> tag to display external web content in
              // an isolated frame and process.
              // This tag is not present in non Electron environments such as JSDom which
              // is often used for testing purposes.
              // @see https://electronjs.org/docs/api/webview-tag
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM2 && !document.documentMode;
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names = [];
              attributeNames.forEach(function(name) {
                names.push(name);
              });
              error2("Extra attributes from the server: %s", names);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error2("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          function normalizeMarkupForTextOrAttribute(markup) {
            {
              checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            if (shouldWarnDev) {
              {
                if (!didWarnInvalidHydration) {
                  didWarnInvalidHydration = true;
                  error2('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                }
              }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
              throw new Error("Text content does not match server-rendered HTML.");
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop4() {
          }
          function trapClickOnNonInteractiveElement(node2) {
            node2.onclick = noop4;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i = 0; i < updatePayload.length; i += 2) {
              var propKey = updatePayload[i];
              var propValue = updatePayload[i + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement10(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node2 = domElement;
                  if (props.multiple) {
                    node2.multiple = true;
                  } else if (props.size) {
                    node2.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty2.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = rawProps;
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name = attributes[_i].name.toLowerCase();
                switch (name) {
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
              typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (shouldWarnDev) {
                if (
                  // $FlowFixMe - Should be inferred as not undefined.
                  extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
                ) {
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
              // TODO: Distinguish by namespace here -- for <title>, including it here
              // errs on the side of fewer warnings
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = assign2({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error2("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root2 = rootContainerInstance.documentElement;
                namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container2 = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container2.namespaceURI || null;
                type = container2.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement10(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
              case "img":
                return true;
              default:
                return false;
            }
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === void 0) {
              return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          var localPromise = typeof Promise === "function" ? Promise : void 0;
          var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
          } : scheduleTimeout;
          function handleErrorInNextTick(error3) {
            setTimeout(function() {
              throw error3;
            });
          }
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                if (newProps.autoFocus) {
                  domElement.focus();
                }
                return;
              case "img": {
                if (newProps.src) {
                  domElement.src = newProps.src;
                }
                return;
              }
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container2, child) {
            var parentNode;
            if (container2.nodeType === COMMENT_NODE) {
              parentNode = container2.parentNode;
              parentNode.insertBefore(child, container2);
            } else {
              parentNode = container2;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container2._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container2, child, beforeChild) {
            if (container2.nodeType === COMMENT_NODE) {
              container2.parentNode.insertBefore(child, beforeChild);
            } else {
              container2.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container2, child) {
            if (container2.nodeType === COMMENT_NODE) {
              container2.parentNode.removeChild(child);
            } else {
              container2.removeChild(child);
            }
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node2 = suspenseInstance;
            var depth = 0;
            do {
              var nextNode = node2.nextSibling;
              parentInstance.removeChild(node2);
              if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                var data = nextNode.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                  depth++;
                }
              }
              node2 = nextNode;
            } while (node2);
            retryIfBlockedOn(suspenseInstance);
          }
          function clearSuspenseBoundaryFromContainer(container2, suspenseInstance) {
            if (container2.nodeType === COMMENT_NODE) {
              clearSuspenseBoundary(container2.parentNode, suspenseInstance);
            } else if (container2.nodeType === ELEMENT_NODE) {
              clearSuspenseBoundary(container2, suspenseInstance);
            }
            retryIfBlockedOn(container2);
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainer(container2) {
            if (container2.nodeType === ELEMENT_NODE) {
              container2.textContent = "";
            } else if (container2.nodeType === DOCUMENT_NODE) {
              if (container2.documentElement) {
                container2.removeChild(container2.documentElement);
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest, message, stack;
            if (dataset) {
              digest = dataset.dgst;
              {
                message = dataset.msg;
                stack = dataset.stck;
              }
            }
            {
              return {
                message,
                digest,
                stack
              };
            }
          }
          function registerSuspenseInstanceRetry(instance, callback) {
            instance._reactRetry = callback;
          }
          function getNextHydratable(node2) {
            for (; node2 != null; node2 = node2.nextSibling) {
              var nodeType = node2.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
              if (nodeType === COMMENT_NODE) {
                var nodeData = node2.data;
                if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                  break;
                }
                if (nodeData === SUSPENSE_END_DATA) {
                  return null;
                }
              }
            }
            return node2;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
          }
          function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text);
          }
          function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node2 = suspenseInstance.nextSibling;
            var depth = 0;
            while (node2) {
              if (node2.nodeType === COMMENT_NODE) {
                var data = node2.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node2);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node2 = node2.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node2 = targetInstance.previousSibling;
            var depth = 0;
            while (node2) {
              if (node2.nodeType === COMMENT_NODE) {
                var data = node2.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node2;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node2 = node2.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container2) {
            retryIfBlockedOn(container2);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== "head" && parentType !== "body";
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              var shouldWarnDev = true;
              checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
            }
          }
          function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentNode, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentNode, instance);
                }
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentInstance, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentInstance, instance);
                }
              }
            }
          }
          function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedElement(parentNode, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedText(parentNode, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedElement(parentInstance, type);
              }
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedText(parentInstance, text);
              }
            }
          }
          function errorHydratingContainer(parentContainer) {
            {
              error2("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
            }
          }
          function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
          var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
          function detachDeletedInstance(node2) {
            delete node2[internalInstanceKey];
            delete node2[internalPropsKey];
            delete node2[internalEventHandlersKey];
            delete node2[internalEventHandlerListenersKey];
            delete node2[internalEventHandlesSetKey];
          }
          function precacheFiberNode(hostInst, node2) {
            node2[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node2) {
            node2[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node2) {
            node2[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node2) {
            return !!node2[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node2) {
            var inst = node2[internalInstanceKey] || node2[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            throw new Error("getNodeFromInstance: Invalid argument.");
          }
          function getFiberCurrentPropsFromNode(node2) {
            return node2[internalPropsKey] || null;
          }
          function updateFiberProps(node2, props) {
            node2[internalPropsKey] = props;
          }
          function getEventListenerSet(node2) {
            var elementListenerSet = node2[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node2[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty2);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor2, fiber) {
            if (index < 0) {
              {
                error2("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index]) {
                error2("Unexpected Fiber popped.");
              }
            }
            cursor2.current = valueStack[index];
            valueStack[index] = null;
            {
              fiberStack[index] = null;
            }
            index--;
          }
          function push(cursor2, value, fiber) {
            index++;
            valueStack[index] = cursor2.current;
            {
              fiberStack[index] = fiber;
            }
            cursor2.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (contextStackCursor.current !== emptyContextObject) {
                throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
              push(contextStackCursor, context, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name = getComponentNameFromFiber(fiber) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name);
              }
              return assign2({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push(contextStackCursor, mergedContext, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
              var node2 = fiber;
              do {
                switch (node2.tag) {
                  case HostRoot:
                    return node2.stateNode.context;
                  case ClassComponent: {
                    var Component2 = node2.type;
                    if (isContextProvider(Component2)) {
                      return node2.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node2 = node2.return;
              } while (node2 !== null);
              throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var LegacyRoot = 0;
          var ConcurrentRoot = 1;
          var syncQueue = null;
          var includesLegacySyncCallbacks = false;
          var isFlushingSyncQueue = false;
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
            } else {
              syncQueue.push(callback);
            }
          }
          function scheduleLegacySyncCallback(callback) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback);
          }
          function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
              flushSyncCallbacks();
            }
          }
          function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i = 0;
              var previousUpdatePriority = getCurrentUpdatePriority();
              try {
                var isSync = true;
                var queue = syncQueue;
                setCurrentUpdatePriority(DiscreteEventPriority);
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(isSync);
                  } while (callback !== null);
                }
                syncQueue = null;
                includesLegacySyncCallbacks = false;
              } catch (error3) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i + 1);
                }
                scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                throw error3;
              } finally {
                setCurrentUpdatePriority(previousUpdatePriority);
                isFlushingSyncQueue = false;
              }
            }
            return null;
          }
          var forkStack = [];
          var forkStackIndex = 0;
          var treeForkProvider = null;
          var treeForkCount = 0;
          var idStack = [];
          var idStackIndex = 0;
          var treeContextProvider = null;
          var treeContextId = 1;
          var treeContextOverflow = "";
          function isForkedChild(workInProgress2) {
            warnIfNotHydrating();
            return (workInProgress2.flags & Forked) !== NoFlags;
          }
          function getForksAtLevel(workInProgress2) {
            warnIfNotHydrating();
            return treeForkCount;
          }
          function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id3 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id3.toString(32) + overflow;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index2) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index2 + 1;
            var length2 = getBitLength(totalChildren) + baseLength;
            if (length2 > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id3 = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              treeContextId = 1 << restOfLength | id3;
              treeContextOverflow = overflow;
            } else {
              var newBits = slot << baseLength;
              var _id2 = newBits | baseId;
              var _overflow = baseOverflow;
              treeContextId = 1 << length2 | _id2;
              treeContextOverflow = _overflow;
            }
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            var returnFiber = workInProgress2.return;
            if (returnFiber !== null) {
              var numberOfForks = 1;
              var slotIndex = 0;
              pushTreeFork(workInProgress2, numberOfForks);
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          function getBitLength(number5) {
            return 32 - clz32(number5);
          }
          function getLeadingBit(id3) {
            return 1 << getBitLength(id3) - 1;
          }
          function popTreeContext(workInProgress2) {
            while (workInProgress2 === treeForkProvider) {
              treeForkProvider = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
              treeForkCount = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
            }
            while (workInProgress2 === treeContextProvider) {
              treeContextProvider = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextOverflow = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextId = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
            }
          }
          function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
              return {
                id: treeContextId,
                overflow: treeContextOverflow
              };
            } else {
              return null;
            }
          }
          function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress2;
          }
          function warnIfNotHydrating() {
            {
              if (!getIsHydrating()) {
                error2("Expected to be hydrating. This is a bug in React. Please file an issue.");
              }
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          var didSuspendOrErrorDEV = false;
          var hydrationErrors = null;
          function warnIfHydrating() {
            {
              if (isHydrating) {
                error2("We should not be hydrating here. This is a bug in React. Please file a bug.");
              }
            }
          }
          function markDidThrowWhileHydratingDEV() {
            {
              didSuspendOrErrorDEV = true;
            }
          }
          function didSuspendOrErrorWhileHydratingDEV() {
            {
              return didSuspendOrErrorDEV;
            }
          }
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
          }
          function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
              restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
          }
          function warnUnhydratedInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                  break;
                }
                case HostComponent: {
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotHydrateInstance(
                    returnFiber.type,
                    returnFiber.memoizedProps,
                    returnFiber.stateNode,
                    instance,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  if (suspenseState.dehydrated !== null)
                    didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                  break;
                }
              }
            }
          }
          function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function warnNonhydratedInstance(returnFiber, fiber) {
            {
              if (didSuspendOrErrorDEV) {
                return;
              }
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent: {
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _type,
                        _props,
                        // TODO: Delete this argument when we remove the legacy root API.
                        isConcurrentMode
                      );
                      break;
                    }
                    case HostText: {
                      var _text = fiber.pendingProps;
                      var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableTextInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _text,
                        // TODO: Delete this argument when we remove the legacy root API.
                        _isConcurrentMode
                      );
                      break;
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  var _parentInstance = suspenseState.dehydrated;
                  if (_parentInstance !== null)
                    switch (fiber.tag) {
                      case HostComponent:
                        var _type2 = fiber.type;
                        var _props2 = fiber.pendingProps;
                        didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                        break;
                      case HostText:
                        var _text2 = fiber.pendingProps;
                        didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                        break;
                    }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = getFirstHydratableChild(instance);
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                if (suspenseInstance !== null) {
                  var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                  };
                  fiber.memoizedState = suspenseState;
                  var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                  dehydratedFragment.return = fiber;
                  fiber.child = dehydratedFragment;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              default:
                return false;
            }
          }
          function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
          }
          function throwOnHydrationMismatch(fiber) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              var prevHydrationParentFiber = hydrationParentFiber;
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedContainerTextInstance(
                      parentContainer,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode2
                    );
                    break;
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
              var nextInstance = nextHydratableInstance;
              if (nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                  warnIfUnhydratedTailNodes(fiber);
                  throwOnHydrationMismatch();
                } else {
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
          }
          function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              warnUnhydratedInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
              queueRecoverableErrors(hydrationErrors);
              hydrationErrors = null;
            }
          }
          function getIsHydrating() {
            return isHydrating;
          }
          function queueHydrationError(error3) {
            if (hydrationErrors === null) {
              hydrationErrors = [error3];
            } else {
              hydrationErrors.push(error3);
            }
          }
          var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = null;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node2 = fiber;
              while (node2 !== null) {
                if (node2.mode & StrictLegacyMode) {
                  maybeStrictRoot = node2;
                }
                node2 = node2.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set2) {
              var array = [];
              set2.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
              instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn2("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn2("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn2("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          function resolveDefaultProps(Component2, baseProps) {
            if (Component2 && Component2.defaultProps) {
              var props = assign2({}, baseProps);
              var defaultProps2 = Component2.defaultProps;
              for (var propName in defaultProps2) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps2[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastFullyObservedContext = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, context, nextValue) {
            {
              push(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(context, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
              {
                context._currentValue = currentValue;
              }
            }
          }
          function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
            var node2 = parent;
            while (node2 !== null) {
              var alternate = node2.alternate;
              if (!isSubsetOfLanes(node2.childLanes, renderLanes2)) {
                node2.childLanes = mergeLanes(node2.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
              if (node2 === propagationRoot) {
                break;
              }
              node2 = node2.return;
            }
            {
              if (node2 !== propagationRoot) {
                error2("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function propagateContextChange(workInProgress2, context, renderLanes2) {
            {
              propagateContextChange_eager(workInProgress2, context, renderLanes2);
            }
          }
          function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list2 = fiber.dependencies;
              if (list2 !== null) {
                nextFiber = fiber.child;
                var dependency = list2.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context) {
                    if (fiber.tag === ClassComponent) {
                      var lane = pickArbitraryLane(renderLanes2);
                      var update = createUpdate(NoTimestamp, lane);
                      update.tag = ForceUpdate;
                      var updateQueue = fiber.updateQueue;
                      if (updateQueue === null)
                        ;
                      else {
                        var sharedQueue = updateQueue.shared;
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                          update.next = update;
                        } else {
                          update.next = pending.next;
                          pending.next = update;
                        }
                        sharedQueue.pending = update;
                      }
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                    list2.lanes = mergeLanes(list2.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else if (fiber.tag === DehydratedFragment) {
                var parentSuspense = fiber.return;
                if (parentSuspense === null) {
                  throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                }
                parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                var _alternate = parentSuspense.alternate;
                if (_alternate !== null) {
                  _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                nextFiber = fiber.sibling;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              {
                var firstContext = dependencies.firstContext;
                if (firstContext !== null) {
                  if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                    markWorkInProgressReceivedUpdate();
                  }
                  dependencies.firstContext = null;
                }
              }
            }
          }
          function readContext(context) {
            {
              if (isDisallowedContextReadInDEV) {
                error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            var value = context._currentValue;
            if (lastFullyObservedContext === context)
              ;
            else {
              var contextItem = {
                context,
                memoizedValue: value,
                next: null
              };
              if (lastContextDependency === null) {
                if (currentlyRenderingFiber === null) {
                  throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return value;
          }
          var concurrentQueues = null;
          function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
              concurrentQueues = [queue];
            } else {
              concurrentQueues.push(queue);
            }
          }
          function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
              for (var i = 0; i < concurrentQueues.length; i++) {
                var queue = concurrentQueues[i];
                var lastInterleavedUpdate = queue.interleaved;
                if (lastInterleavedUpdate !== null) {
                  queue.interleaved = null;
                  var firstInterleavedUpdate = lastInterleavedUpdate.next;
                  var lastPendingUpdate = queue.pending;
                  if (lastPendingUpdate !== null) {
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = firstInterleavedUpdate;
                    lastInterleavedUpdate.next = firstPendingUpdate;
                  }
                  queue.pending = lastInterleavedUpdate;
                }
              }
              concurrentQueues = null;
            }
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
          }
          function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node2 = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node2 = parent;
              parent = parent.return;
            }
            if (node2.tag === HostRoot) {
              var root2 = node2.stateNode;
              return root2;
            } else {
              return null;
            }
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: NoLanes
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone3 = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone3;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return null;
            }
            var sharedQueue = updateQueue.shared;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
              var pending = sharedQueue.pending;
              if (pending === null) {
                update.next = update;
              } else {
                update.next = pending.next;
                pending.next = update;
              }
              sharedQueue.pending = update;
              return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
              return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
          }
          function entangleTransitions(root2, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
              var queueLanes = sharedQueue.lanes;
              queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              sharedQueue.lanes = newQueueLanes;
              markRootEntangled(root2, newQueueLanes);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone3 = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone3;
                    } else {
                      newLast.next = clone3;
                      newLast = clone3;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return assign2({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone3 = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone3;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone3;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                  var callback = update.callback;
                  if (callback !== null && // If the update was already committed, we should not queue its
                  // callback again.
                  update.lane !== NoLane) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update];
                    } else {
                      effects.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              var lastInterleaved = queue.shared.interleaved;
              if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                  newLanes = mergeLanes(newLanes, interleaved.lane);
                  interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
              } else if (firstBaseUpdate === null) {
                queue.shared.lanes = NoLanes;
              }
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context) {
            if (typeof callback !== "function") {
              throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
            }
            callback.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i = 0; i < effects.length; i++) {
                var effect5 = effects[i];
                var callback = effect5.callback;
                if (callback !== null) {
                  effect5.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var emptyRefsObject = new React53.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  partialState = getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get3(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get3(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get3(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markForceUpdateScheduled(fiber, lane);
              }
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                if (shouldUpdate === void 0) {
                  error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (instance.contextTypes) {
                  error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray(_state))) {
                error2("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = (
                  // Allow null for conditional declaration
                  contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
                );
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance = new ctor(props, context);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            var state2 = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state2 === null) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                var fiberFlags = Update;
                {
                  fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= fiberFlags;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags = Update;
                {
                  _fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags2 = Update;
                {
                  _fiberFlags2 |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags2 |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags2;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
            // both before and after `shouldComponentUpdate` has been called. Not ideal,
            // but I'm loath to refactor this function. This only happens for memoized
            // components so it's not that common.
            enableLazyContextPropagation;
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (typeof child._store !== "object") {
                throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
              child._store.validated = true;
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
                // because these cannot be automatically converted to an arrow function
                // using a codemod. Therefore, we don't have to warn about string refs again.
                !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error2('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (ownerFiber.tag !== ClassComponent) {
                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
                var resolvedInst = inst;
                {
                  checkPropStringCoercion(mixedRef, "ref");
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = resolvedInst.refs;
                  if (refs === emptyRefsObject) {
                    refs = resolvedInst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (typeof mixedRef !== "string") {
                  throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
                if (!element._owner) {
                  throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init3 = lazyType._init;
            return init3(payload);
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone3 = createWorkInProgress(fiber, pendingProps);
              clone3.index = 0;
              clone3.sibling = null;
              return clone3;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                newFiber.flags |= Forked;
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags |= Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags |= Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
              }
              if (current2 !== null) {
                if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
                isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
                // We need to do this after the Hot Reloading check above,
                // because hot reloading has different semantics than prod because
                // it doesn't resuspend. So we can't let the call below suspend.
                typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment9) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init3 = newChild._init;
                    return createChild(returnFiber, init3(payload), lanes);
                  }
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init3 = newChild._init;
                    return updateSlot(returnFiber, oldFiber, init3(payload), lanes);
                  }
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init3 = newChild._init;
                    return updateFromMap(existingChildren, returnFiber, newIdx, init3(payload), lanes);
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                  case REACT_LAZY_TYPE:
                    var payload = child._payload;
                    var init3 = child._init;
                    warnOnInvalidKey(init3(payload), knownKeys, returnFiber);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i = 0; i < newChildren.length; i++) {
                  var child = newChildren[i];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                if (getIsHydrating()) {
                  var _numberOfForks = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks2 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks2);
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (typeof iteratorFn !== "function") {
                throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
              {
                if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
                newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (newChildren == null) {
                throw new Error("An iterable object provided no iterator.");
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                if (getIsHydrating()) {
                  var _numberOfForks3 = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks3);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks4 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks4);
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  var elementType = element.type;
                  if (elementType === REACT_FRAGMENT_TYPE) {
                    if (child.tag === Fragment9) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                  } else {
                    if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                    isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                    // We need to do this after the Hot Reloading check above,
                    // because hot reloading has different semantics than prod because
                    // it doesn't resuspend. So we can't let the call below suspend.
                    typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing = useFiber(child, element.props);
                      _existing.ref = coerceRef(returnFiber, child, element);
                      _existing.return = returnFiber;
                      {
                        _existing._debugSource = element._source;
                        _existing._debugOwner = element._owner;
                      }
                      return _existing;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init3 = newChild._init;
                    return reconcileChildFibers2(returnFiber, currentFirstChild, init3(payload), lanes);
                }
                if (isArray(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (current2 !== null && workInProgress2.child !== current2.child) {
              throw new Error("Resuming work not yet implemented.");
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c) {
            if (c === NO_CONTEXT) {
              throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
            return c;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
              return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            {
              return true;
            }
          }
          function findFirstSuspended(row) {
            var node2 = row;
            while (node2 !== null) {
              if (node2.tag === SuspenseComponent) {
                var state2 = node2.memoizedState;
                if (state2 !== null) {
                  var dehydrated = state2.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node2;
                  }
                }
              } else if (node2.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
              // keep track of whether it suspended or not.
              node2.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node2.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node2;
                }
              } else if (node2.child !== null) {
                node2.child.return = node2;
                node2 = node2.child;
                continue;
              }
              if (node2 === row) {
                return null;
              }
              while (node2.sibling === null) {
                if (node2.return === null || node2.return === row) {
                  return null;
                }
                node2 = node2.return;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
            }
            return null;
          }
          var NoFlags$1 = (
            /*   */
            0
          );
          var HasEffect = (
            /* */
            1
          );
          var Insertion7 = (
            /*  */
            2
          );
          var Layout = (
            /*    */
            4
          );
          var Passive$1 = (
            /*   */
            8
          );
          var workInProgressSources = [];
          function resetWorkInProgressVersions() {
            for (var i = 0; i < workInProgressSources.length; i++) {
              var mutableSource = workInProgressSources[i];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function registerMutableSourceForHydration(root2, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version = getVersion(mutableSource._source);
            if (root2.mutableSourceEagerHydrationData == null) {
              root2.mutableSourceEagerHydrationData = [mutableSource, version];
            } else {
              root2.mutableSourceEagerHydrationData.push(mutableSource, version);
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnUncachedGetSnapshot;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var localIdCounter = 0;
          var globalClientIdCounter = 0;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !isArray(deps)) {
                error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component2(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                  throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component2(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
              // and creates false positives. To make this work in legacy mode, we'd
              // need to mark fibers that commit in an incomplete state, somehow. For
              // now I'll disable the warning that most of the bugs that would trigger
              // it are either exclusive to concurrent mode or exist in both.
              (current2.mode & ConcurrentMode) !== NoMode) {
                error2("Internal React error: Expected static flag was missing. Please notify the React team.");
              }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
              throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            } else {
              workInProgress2.flags &= ~(Passive | Update);
            }
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (nextCurrentHook === null) {
                throw new Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null,
              stores: null
            };
          }
          function basicStateReducer(state2, action) {
            return typeof action === "function" ? action(state2) : action;
          }
          function mountReducer(reducer, initialArg, init3) {
            var hook = mountWorkInProgressHook();
            var initialState2;
            if (init3 !== void 0) {
              initialState2 = init3(initialArg);
            } else {
              initialState2 = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState2;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState2
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init3) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone3 = {
                    lane: updateLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone3;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone3;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.hasEagerState) {
                    newState = update.eagerState;
                  } else {
                    var action = update.action;
                    newState = reducer(newState, action);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                var interleavedLane = interleaved.lane;
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                markSkippedUpdateLanes(interleavedLane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (baseQueue === null) {
              queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init3) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating2 = getIsHydrating();
            if (isHydrating2) {
              if (getServerSnapshot === void 0) {
                throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
              }
              nextSnapshot = getServerSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  if (nextSnapshot !== getServerSnapshot()) {
                    error2("The result of getServerSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
            } else {
              nextSnapshot = getSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  var cachedSnapshot = getSnapshot();
                  if (!objectIs(nextSnapshot, cachedSnapshot)) {
                    error2("The result of getSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
              var root2 = getWorkInProgressRoot();
              if (root2 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root2, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
              value: nextSnapshot,
              getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
              hook.memoizedState = nextSnapshot;
              markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
            // checking whether we scheduled a subscription effect above.
            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= Passive;
              pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
              var root2 = getWorkInProgressRoot();
              if (root2 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root2, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            return nextSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
              getSnapshot,
              value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.stores = [check];
            } else {
              var stores = componentUpdateQueue.stores;
              if (stores === null) {
                componentUpdateQueue.stores = [check];
              } else {
                stores.push(check);
              }
            }
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          }
          function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
              }
            };
            return subscribe(handleStoreChange);
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error3) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
          function mountState(initialState2) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState2 === "function") {
              initialState2 = initialState2();
            }
            hook.memoizedState = hook.baseState = initialState2;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState2
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState2) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState2) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create, destroy, deps) {
            var effect5 = {
              tag,
              create,
              destroy,
              deps,
              // Circular
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect5.next = effect5;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect5.next = effect5;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect5;
                effect5.next = firstEffect;
                componentUpdateQueue.lastEffect = effect5;
              }
            }
            return effect5;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
              var _ref2 = {
                current: initialValue
              };
              hook.memoizedState = _ref2;
              return _ref2;
            }
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
          }
          function mountEffect(create, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
            } else {
              return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
            }
          }
          function updateEffect(create, deps) {
            return updateEffectImpl(Passive, Passive$1, create, deps);
          }
          function mountInsertionEffect(create, deps) {
            return mountEffectImpl(Update, Insertion7, create, deps);
          }
          function updateInsertionEffect(create, deps) {
            return updateEffectImpl(Update, Insertion7, create, deps);
          }
          function mountLayoutEffect(create, deps) {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create, deps);
          }
          function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
          }
          function imperativeHandleEffect(create, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value;
            return value;
          }
          function updateDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
          function rerenderDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
              hook.memoizedState = value;
              return value;
            } else {
              var prevValue = currentHook.memoizedState;
              return updateDeferredValueImpl(hook, prevValue, value);
            }
          }
          function updateDeferredValueImpl(hook, prevValue, value) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
              if (!objectIs(value, prevValue)) {
                var deferredLane = claimNextTransitionLane();
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                markSkippedUpdateLanes(deferredLane);
                hook.baseState = true;
              }
              return prevValue;
            } else {
              if (hook.baseState) {
                hook.baseState = false;
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = value;
              return value;
            }
          }
          function startTransition(setPending, callback, options2) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
              ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              setPending(false);
              callback();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$2.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start2 = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start2;
            return [isPending, start2];
          }
          function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start2 = hook.memoizedState;
            return [isPending, start2];
          }
          function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start2 = hook.memoizedState;
            return [isPending, start2];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function mountId() {
            var hook = mountWorkInProgressHook();
            var root2 = getWorkInProgressRoot();
            var identifierPrefix = root2.identifierPrefix;
            var id3;
            if (getIsHydrating()) {
              var treeId = getTreeId();
              id3 = ":" + identifierPrefix + "R" + treeId;
              var localId = localIdCounter++;
              if (localId > 0) {
                id3 += "H" + localId.toString(32);
              }
              id3 += ":";
            } else {
              var globalClientId = globalClientIdCounter++;
              id3 = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
            }
            hook.memoizedState = id3;
            return id3;
          }
          function updateId() {
            var hook = updateWorkInProgressHook();
            var id3 = hook.memoizedState;
            return id3;
          }
          function dispatchReducerAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitionUpdate(root2, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function dispatchSetState(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var alternate = fiber.alternate;
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update.hasEagerState = true;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                      return;
                    }
                  } catch (error3) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitionUpdate(root2, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
          }
          function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
          }
          function entangleTransitionUpdate(root2, queue, lane) {
            if (isTransitionLane(lane)) {
              var queueLanes = queue.lanes;
              queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              queue.lanes = newQueueLanes;
              markRootEntangled(root2, newQueueLanes);
            }
          }
          function markUpdateInDevTools(fiber, lane, action) {
            {
              markStateUpdateScheduled(fiber, lane);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var layoutEffectStartTime = -1;
          var profilerStartTime = -1;
          var passiveEffectStartTime = -1;
          var currentUpdateIsNested = false;
          var nestedUpdateScheduled = false;
          function isCurrentUpdateNested() {
            return currentUpdateIsNested;
          }
          function markNestedUpdateScheduled() {
            {
              nestedUpdateScheduled = true;
            }
          }
          function resetNestedUpdateFlag() {
            {
              currentUpdateIsNested = false;
              nestedUpdateScheduled = false;
            }
          }
          function syncNestedUpdateFlag() {
            {
              currentUpdateIsNested = nestedUpdateScheduled;
              nestedUpdateScheduled = false;
            }
          }
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
              var elapsedTime = now$1() - layoutEffectStartTime;
              layoutEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root2 = parentFiber.stateNode;
                    root2.effectDuration += elapsedTime;
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.effectDuration += elapsedTime;
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
              var elapsedTime = now$1() - passiveEffectStartTime;
              passiveEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root2 = parentFiber.stateNode;
                    if (root2 !== null) {
                      root2.passiveEffectDuration += elapsedTime;
                    }
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    if (parentStateNode !== null) {
                      parentStateNode.passiveEffectDuration += elapsedTime;
                    }
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
          }
          function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          function createCapturedValueAtFiber(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source),
              digest: null
            };
          }
          function createCapturedValue(value, digest, stack) {
            return {
              value,
              source: null,
              stack: stack != null ? stack : null,
              digest: digest != null ? digest : null
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error3 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error3 != null && error3._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error3);
                }
                var componentName = source ? getComponentNameFromFiber(source) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                if (boundary.tag === HostRoot) {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                } else {
                  var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error3);
              }
            } catch (e3) {
              setTimeout(function() {
                throw e3;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error3 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error3);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                return getDerivedStateFromError(error$1);
              };
              update.callback = function() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                    }
                  }
                }
              };
            }
            return update;
          }
          function attachPingListener(root2, wakeable, lanes) {
            var pingCache = root2.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root2.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
              {
                if (isDevToolsPresent) {
                  restorePendingUpdaters(root2, lanes);
                }
              }
              wakeable.then(ping, ping);
            }
          }
          function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
              var updateQueue = /* @__PURE__ */ new Set();
              updateQueue.add(wakeable);
              suspenseBoundary.updateQueue = updateQueue;
            } else {
              wakeables.add(wakeable);
            }
          }
          function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
          }
          function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node2 = returnFiber;
            do {
              if (node2.tag === SuspenseComponent && shouldCaptureSuspense(node2)) {
                return node2;
              }
              node2 = node2.return;
            } while (node2 !== null);
            return null;
          }
          function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
              if (suspenseBoundary === returnFiber) {
                suspenseBoundary.flags |= ShouldCapture;
              } else {
                suspenseBoundary.flags |= DidCapture;
                sourceFiber.flags |= ForceUpdateForLegacySuspense;
                sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(NoTimestamp, SyncLane);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update, SyncLane);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
              }
              return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
          }
          function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root2, rootRenderLanes);
              }
            }
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              resetSuspendedComponent(sourceFiber);
              {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                  markDidThrowWhileHydratingDEV();
                }
              }
              var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (suspenseBoundary !== null) {
                suspenseBoundary.flags &= ~ForceClientRender;
                markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                if (suspenseBoundary.mode & ConcurrentMode) {
                  attachPingListener(root2, wakeable, rootRenderLanes);
                }
                attachRetryListener(suspenseBoundary, root2, wakeable);
                return;
              } else {
                if (!includesSyncLane(rootRenderLanes)) {
                  attachPingListener(root2, wakeable, rootRenderLanes);
                  renderDidSuspendDelayIfPossible();
                  return;
                }
                var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                value = uncaughtSuspenseError;
              }
            } else {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
                var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (_suspenseBoundary !== null) {
                  if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                    _suspenseBoundary.flags |= ForceClientRender;
                  }
                  markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                  queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                  return;
                }
              }
            }
            value = createCapturedValueAtFiber(value, sourceFiber);
            renderDidError(value);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function getSuspendedCache() {
            {
              return null;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var render2 = Component2.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            if (current2 === null) {
              var type = Component2.type;
              if (isSimpleFunctionComponent(type) && Component2.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
              Component2.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(type)
                  );
                }
              }
              var child = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component2.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(_type)
                );
              }
            }
            var currentChild = current2.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext) {
              var prevProps = currentChild.memoizedProps;
              var compare = Component2.compare;
              compare = compare !== null ? compare : shallowEqual;
              if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    outerMemoType = init3(payload);
                  } catch (x) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      // Resolved (SimpleMemoComponent has no defaultProps)
                      "prop",
                      getComponentNameFromType(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
              workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                workInProgress2.pendingProps = nextProps = prevProps;
                if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || enableLegacyHidden) {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var spawnedCachePool = null;
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes,
                  cachePool: spawnedCachePool,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState;
                workInProgress2.updateQueue = null;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref;
              {
                workInProgress2.flags |= RefStatic;
              }
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              switch (shouldError(workInProgress2)) {
                case false: {
                  var _instance = workInProgress2.stateNode;
                  var ctor = workInProgress2.type;
                  var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                  var state2 = tempInstance.state;
                  _instance.updater.enqueueSetState(_instance, state2, null);
                  break;
                }
                case true: {
                  workInProgress2.flags |= DidCapture;
                  workInProgress2.flags |= ShouldCapture;
                  var error$1 = new Error("Simulated error coming from DevTools");
                  var lane = pickArbitraryLane(renderLanes2);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  break;
                }
              }
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
              constructClassInstance(workInProgress2, Component2, nextProps);
              mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component2, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component2, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                markComponentRenderStarted(workInProgress2);
              }
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    instance.render();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                setIsRendering(false);
              }
              {
                markComponentRenderStopped();
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component2, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root2 = workInProgress2.stateNode;
            if (root2.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
            } else if (root2.context) {
              pushTopLevelContextObject(workInProgress2, root2.context, false);
            }
            pushHostContainer(workInProgress2, root2.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            if (current2 === null) {
              throw new Error("Should have a current fiber. This is a bug in React.");
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var root2 = workInProgress2.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
              var overrideState = {
                element: nextChildren,
                isDehydrated: false,
                cache: nextState.cache,
                pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                transitions: nextState.transitions
              };
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = overrideState;
              workInProgress2.memoizedState = overrideState;
              if (workInProgress2.flags & ForceClientRender) {
                var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
              } else if (nextChildren !== prevChildren) {
                var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
              } else {
                enterHydrationState(workInProgress2);
                var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                workInProgress2.child = child;
                var node2 = child;
                while (node2) {
                  node2.flags = node2.flags & ~Placement | Hydrating;
                  node2 = node2.sibling;
                }
              }
            } else {
              resetHydrationState();
              if (nextChildren === prevChildren) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress2.flags |= ForceClientRender;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init3 = lazyComponent._init;
            var Component2 = init3(payload);
            workInProgress2.type = Component2;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component2);
            var resolvedProps = resolveDefaultProps(Component2, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component2);
                  workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
                }
                child = updateFunctionComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
                }
                child = updateClassComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
                }
                child = updateForwardRef(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(Component2)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component2,
                  resolveDefaultProps(Component2.type, resolvedProps),
                  // The inner type can have defaults too
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component2 + ". " + ("Lazy element type must resolve to a class or function." + hint));
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component2, nextProps);
            mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component2, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            var hasId;
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              if (Component2.prototype && typeof Component2.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (
              // Run these checks in production only if the flag is off.
              // Eventually we'll delete this branch altogether.
              typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
            ) {
              {
                var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component2)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component2, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    value = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
                    hasId = checkDidRenderIdHook();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress2);
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component2);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component2) {
            {
              if (Component2) {
                if (Component2.childContextTypes) {
                  error2("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component2.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error2("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2,
              cachePool: getSuspendedCache(),
              transitions: null
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            var cachePool = null;
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
              cachePool,
              transitions: prevOffscreenState.transitions
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null) {
                var dehydrated = suspenseState.dehydrated;
                if (dehydrated !== null) {
                  return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                }
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var _dehydrated = prevState.dehydrated;
                if (_dehydrated !== null) {
                  return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
                }
              }
              if (showFallback) {
                var _nextFallbackChildren = nextProps.fallback;
                var _nextPrimaryChildren = nextProps.children;
                var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                var _primaryChildFragment2 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              } else {
                var _nextPrimaryChildren2 = nextProps.children;
                var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment3;
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode2 = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode2);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode2 = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode2 & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode2, renderLanes2, null);
            } else {
              primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode2);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode2, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode2, renderLanes2) {
            return createFiberFromOffscreen(offscreenProps, mode2, NoLanes, null);
          }
          function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              var deletions = workInProgress2.deletions;
              if (deletions === null) {
                workInProgress2.deletions = [currentFallbackChildFragment];
                workInProgress2.flags |= ChildDeletion;
              } else {
                deletions.push(currentFallbackChildFragment);
              }
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode2 = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if (
              // In legacy mode, we commit the primary tree as if it successfully
              // completed, even though it's in an inconsistent state.
              (mode2 & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
              // already cloned. In legacy mode, the only case where this isn't true is
              // when DevTools forces us to display a fallback; we skip the first render
              // pass entirely and go straight to rendering the fallback. (In Concurrent
              // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
              // only codepath.)
              workInProgress2.child !== currentPrimaryChildFragment
            ) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              workInProgress2.deletions = null;
            } else {
              primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
              primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode2, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
            if (recoverableError !== null) {
              queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            var nextProps = workInProgress2.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress2.memoizedState = null;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var fiberMode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
              reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            }
            return fallbackChildFragment;
          }
          function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              {
                error2("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
              }
              workInProgress2.lanes = laneToLanes(SyncLane);
            } else if (isSuspenseInstanceFallback(suspenseInstance)) {
              workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
            } else {
              workInProgress2.lanes = laneToLanes(OffscreenLane);
            }
            return null;
          }
          function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
            if (!didSuspend) {
              warnIfHydrating();
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                return retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  // TODO: When we delete legacy mode, we should make this error argument
                  // required — every concurrent mode path that causes hydration to
                  // de-opt to client rendering should have an error message.
                  null
                );
              }
              if (isSuspenseInstanceFallback(suspenseInstance)) {
                var digest, message, stack;
                {
                  var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                  digest = _getSuspenseInstanceF.digest;
                  message = _getSuspenseInstanceF.message;
                  stack = _getSuspenseInstanceF.stack;
                }
                var error3;
                if (message) {
                  error3 = new Error(message);
                } else {
                  error3 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                }
                var capturedValue = createCapturedValue(error3, digest, stack);
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
              }
              var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
              if (didReceiveUpdate || hasContextChanged2) {
                var root2 = getWorkInProgressRoot();
                if (root2 !== null) {
                  var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
                  if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                    suspenseState.retryLane = attemptHydrationAtLane;
                    var eventTime = NoTimestamp;
                    enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                    scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);
                  }
                }
                renderDidSuspendDelayIfPossible();
                var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
              } else if (isSuspenseInstancePending(suspenseInstance)) {
                workInProgress2.flags |= DidCapture;
                workInProgress2.child = current2.child;
                var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                registerSuspenseInstanceRetry(suspenseInstance, retry);
                return null;
              } else {
                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                primaryChildFragment.flags |= Hydrating;
                return primaryChildFragment;
              }
            } else {
              if (workInProgress2.flags & ForceClientRender) {
                workInProgress2.flags &= ~ForceClientRender;
                var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
              } else if (workInProgress2.memoizedState !== null) {
                workInProgress2.child = current2.child;
                workInProgress2.flags |= DidCapture;
                return null;
              } else {
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment4 = workInProgress2.child;
                _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              }
            }
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node2 = firstChild;
            while (node2 !== null) {
              if (node2.tag === SuspenseComponent) {
                var state2 = node2.memoizedState;
                if (state2 !== null) {
                  scheduleSuspenseWorkOnFiber(node2, renderLanes2, workInProgress2);
                }
              } else if (node2.tag === SuspenseListComponent) {
                scheduleSuspenseWorkOnFiber(node2, renderLanes2, workInProgress2);
              } else if (node2.child !== null) {
                node2.child.return = node2;
                node2 = node2.child;
                continue;
              }
              if (node2 === workInProgress2) {
                return;
              }
              while (node2.sibling === null) {
                if (node2.return === null || node2.return === workInProgress2) {
                  return;
                }
                node2 = node2.return;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index2) {
            {
              var isAnArray = isArray(childSlot);
              var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
              if (isAnArray || isIterable) {
                var type = isAnArray ? "array" : "iterable";
                error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    if (!validateSuspenseListNestedChild(children[i], i)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    tail,
                    lastContentRow,
                    tailMode
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    // isBackwards
                    _tail,
                    null,
                    // last
                    tailMode
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    null,
                    // tail
                    null,
                    // last
                    void 0
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, context, newValue);
            {
              if (oldProps !== null) {
                var oldValue = oldProps.value;
                if (objectIs(oldValue, newValue)) {
                  if (oldProps.children === newProps.children && !hasContextChanged()) {
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  }
                } else {
                  propagateContextChange(workInProgress2, context, renderLanes2);
                }
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render2 = newProps.children;
            {
              if (typeof render2 !== "function") {
                error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context);
            {
              markComponentRenderStarted(workInProgress2);
            }
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render2(newValue);
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
            }
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              {
                return null;
              }
            }
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [current2];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(current2);
              }
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            var updateLanes = current2.lanes;
            if (includesSomeLane(updateLanes, renderLanes2)) {
              return true;
            }
            return false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2);
                var root2 = workInProgress2.stateNode;
                resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  pushContextProvider(workInProgress2);
                }
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                var context = workInProgress2.type._context;
                pushProvider(workInProgress2, context, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (hasChildWork) {
                    workInProgress2.flags |= Update;
                  }
                  {
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                }
                break;
              case SuspenseComponent: {
                var state2 = workInProgress2.memoizedState;
                if (state2 !== null) {
                  if (state2.dehydrated !== null) {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    workInProgress2.flags |= DidCapture;
                    return null;
                  }
                  var primaryChildFragment = workInProgress2.child;
                  var primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    if (child !== null) {
                      return child.sibling;
                    } else {
                      return null;
                    }
                  }
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork) {
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  }
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null) {
                  renderState.rendering = null;
                  renderState.tail = null;
                  renderState.lastEffect = null;
                }
                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                if (_hasChildWork) {
                  break;
                } else {
                  return null;
                }
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                workInProgress2.lanes = NoLanes;
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
              workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else {
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
                // may not be work scheduled on `current`, so we check for this flag.
                (workInProgress2.flags & DidCapture) === NoFlags) {
                  didReceiveUpdate = false;
                  return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                }
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
              if (getIsHydrating() && isForkedChild(workInProgress2)) {
                var slotIndex = workInProgress2.index;
                var numberOfForks = getForksAtLevel();
                pushTreeId(workInProgress2, numberOfForks, slotIndex);
              }
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
              }
              case FunctionComponent: {
                var Component2 = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === Component2 ? unresolvedProps : resolveDefaultProps(Component2, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, Component2, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment9:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node2 = workInProgress2.child;
              while (node2 !== null) {
                if (node2.tag === HostComponent || node2.tag === HostText) {
                  appendInitialChild(parent, node2.stateNode);
                } else if (node2.tag === HostPortal)
                  ;
                else if (node2.child !== null) {
                  node2.child.return = node2;
                  node2 = node2.child;
                  continue;
                }
                if (node2 === workInProgress2) {
                  return;
                }
                while (node2.sibling === null) {
                  if (node2.return === null || node2.return === workInProgress2) {
                    return;
                  }
                  node2 = node2.return;
                }
                node2.sibling.return = node2.return;
                node2 = node2.sibling;
              }
            };
            updateHostContainer = function(current2, workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var actualDuration = completedWork.actualDuration;
                var treeBaseDuration = completedWork.selfBaseDuration;
                var child = completedWork.child;
                while (child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                  subtreeFlags |= child.subtreeFlags;
                  subtreeFlags |= child.flags;
                  actualDuration += child.actualDuration;
                  treeBaseDuration += child.treeBaseDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
                completedWork.treeBaseDuration = treeBaseDuration;
              } else {
                var _child = completedWork.child;
                while (_child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                  subtreeFlags |= _child.subtreeFlags;
                  subtreeFlags |= _child.flags;
                  _child.return = completedWork;
                  _child = _child.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            } else {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var _treeBaseDuration = completedWork.selfBaseDuration;
                var _child2 = completedWork.child;
                while (_child2 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                  subtreeFlags |= _child2.subtreeFlags & StaticMask;
                  subtreeFlags |= _child2.flags & StaticMask;
                  _treeBaseDuration += _child2.treeBaseDuration;
                  _child2 = _child2.sibling;
                }
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else {
                var _child3 = completedWork.child;
                while (_child3 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                  subtreeFlags |= _child3.subtreeFlags & StaticMask;
                  subtreeFlags |= _child3.flags & StaticMask;
                  _child3.return = completedWork;
                  _child3 = _child3.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
              warnIfUnhydratedTailNodes(workInProgress2);
              resetHydrationState();
              workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
              return false;
            }
            var wasHydrated = popHydrationState(workInProgress2);
            if (nextState !== null && nextState.dehydrated !== null) {
              if (current2 === null) {
                if (!wasHydrated) {
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                }
                prepareToHydrateHostSuspenseInstance(workInProgress2);
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var isTimedOutSuspense = nextState !== null;
                    if (isTimedOutSuspense) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              } else {
                resetHydrationState();
                if ((workInProgress2.flags & DidCapture) === NoFlags) {
                  workInProgress2.memoizedState = null;
                }
                workInProgress2.flags |= Update;
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var _isTimedOutSuspense = nextState !== null;
                    if (_isTimedOutSuspense) {
                      var _primaryChildFragment = workInProgress2.child;
                      if (_primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              }
            } else {
              upgradeHydrationErrorsToRecoverable();
              return true;
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment9:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                bubbleProperties(workInProgress2);
                return null;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostRoot: {
                var fiberRoot = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else {
                    if (current2 !== null) {
                      var prevState = current2.memoizedState;
                      if (
                        // Check if this is a client root
                        !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                        (workInProgress2.flags & ForceClientRender) !== NoFlags
                      ) {
                        workInProgress2.flags |= Snapshot;
                        upgradeHydrationErrorsToRecoverable();
                      }
                    }
                  }
                }
                updateHostContainer(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                  var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                  if (!fallthroughToNormalSuspensePath) {
                    if (workInProgress2.flags & ShouldCapture) {
                      return workInProgress2;
                    } else {
                      return null;
                    }
                  }
                }
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
                if (nextDidTimeout !== prevDidTimeout) {
                  if (nextDidTimeout) {
                    var _offscreenFiber2 = workInProgress2.child;
                    _offscreenFiber2.flags |= Visibility;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                      var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                      if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                        renderDidSuspend();
                      } else {
                        renderDidSuspendDelayIfPossible();
                      }
                    }
                  }
                }
                var wakeables = workInProgress2.updateQueue;
                if (wakeables !== null) {
                  workInProgress2.flags |= Update;
                }
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    if (nextDidTimeout) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(current2, workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                bubbleProperties(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThenables = suspended.updateQueue;
                          if (newThenables !== null) {
                            workInProgress2.updateQueue = newThenables;
                            workInProgress2.flags |= Update;
                          }
                          workInProgress2.subtreeFlags = NoFlags;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now3() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThenables = _suspended.updateQueue;
                      if (_newThenables !== null) {
                        workInProgress2.updateQueue = _newThenables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        bubbleProperties(workInProgress2);
                        return null;
                      }
                    } else if (
                      // The time it took to render last row is greater than the remaining
                      // time we have to render. So rendering one more row would likely
                      // exceed it.
                      now3() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                    ) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next2 = renderState.tail;
                  renderState.rendering = next2;
                  renderState.tail = next2.sibling;
                  renderState.renderingStartTime = now3();
                  next2.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next2;
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                var _nextState = workInProgress2.memoizedState;
                var nextIsHidden = _nextState !== null;
                if (current2 !== null) {
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding — it only pre-renders.
                  !enableLegacyHidden) {
                    workInProgress2.flags |= Visibility;
                  }
                }
                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                  bubbleProperties(workInProgress2);
                } else {
                  if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                    bubbleProperties(workInProgress2);
                    {
                      if (workInProgress2.subtreeFlags & (Placement | Update)) {
                        workInProgress2.flags |= Visibility;
                      }
                    }
                  }
                }
                return null;
              }
              case CacheComponent: {
                return null;
              }
              case TracingMarkerComponent: {
                return null;
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function unwindWork(current2, workInProgress2, renderLanes2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                var root2 = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                  workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var suspenseState = workInProgress2.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                  if (workInProgress2.alternate === null) {
                    throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                  }
                  resetHydrationState();
                }
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              case CacheComponent:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                var root2 = interruptedWork.stateNode;
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                var context = interruptedWork.type._context;
                popProvider(context, interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var offscreenSubtreeIsHidden = false;
          var offscreenSubtreeWasHidden = false;
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var nextEffect = null;
          var inProgressLanes = null;
          var inProgressRoot = null;
          function reportUncaughtErrorInDEV(error3) {
            {
              invokeGuardedCallback(null, function() {
                throw error3;
              });
              clearCaughtError();
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            if (current2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                instance.componentWillUnmount();
              } finally {
                recordLayoutEffectDuration(current2);
              }
            } else {
              instance.componentWillUnmount();
            }
          };
          function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
            try {
              commitHookEffectListMount(Layout, current2);
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            try {
              callComponentWillUnmountWithTimer(current2, instance);
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentDidMount();
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              commitAttachRef(current2);
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                var retVal;
                try {
                  if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      retVal = ref(null);
                    } finally {
                      recordLayoutEffectDuration(current2);
                    }
                  } else {
                    retVal = ref(null);
                  }
                } catch (error3) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error3);
                }
                {
                  if (typeof retVal === "function") {
                    error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function commitBeforeMutationEffects(root2, firstChild) {
            focusedInstanceHandle = prepareForCommit(root2.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
          }
          function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitBeforeMutationEffects_complete();
              }
            }
          }
          function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                commitBeforeMutationEffectsOnFiber(fiber);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot) !== NoFlags) {
              setCurrentFiber(finishedWork);
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  break;
                }
                case ClassComponent: {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    var snapshot2 = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot2 === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot2;
                  }
                  break;
                }
                case HostRoot: {
                  {
                    var root2 = finishedWork.stateNode;
                    clearContainer(root2.containerInfo);
                  }
                  break;
                }
                case HostComponent:
                case HostText:
                case HostPortal:
                case IncompleteClassComponent:
                  break;
                default: {
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              resetCurrentFiber();
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect5 = firstEffect;
              do {
                if ((effect5.tag & flags) === flags) {
                  var destroy = effect5.destroy;
                  effect5.destroy = void 0;
                  if (destroy !== void 0) {
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStarted(finishedWork);
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStarted(finishedWork);
                      }
                    }
                    {
                      if ((flags & Insertion7) !== NoFlags$1) {
                        setIsRunningInsertionEffect(true);
                      }
                    }
                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                    {
                      if ((flags & Insertion7) !== NoFlags$1) {
                        setIsRunningInsertionEffect(false);
                      }
                    }
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStopped();
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStopped();
                      }
                    }
                  }
                }
                effect5 = effect5.next;
              } while (effect5 !== firstEffect);
            }
          }
          function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect5 = firstEffect;
              do {
                if ((effect5.tag & flags) === flags) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStarted(finishedWork);
                    }
                  }
                  var create = effect5.create;
                  {
                    if ((flags & Insertion7) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  effect5.destroy = create();
                  {
                    if ((flags & Insertion7) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStopped();
                    }
                  }
                  {
                    var destroy = effect5.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var hookName = void 0;
                      if ((effect5.tag & Layout) !== NoFlags) {
                        hookName = "useLayoutEffect";
                      } else if ((effect5.tag & Insertion7) !== NoFlags) {
                        hookName = "useInsertionEffect";
                      } else {
                        hookName = "useEffect";
                      }
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error2("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                    }
                  }
                }
                effect5 = effect5.next;
              } while (effect5 !== firstEffect);
            }
          }
          function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
              if ((finishedWork.flags & Update) !== NoFlags) {
                switch (finishedWork.tag) {
                  case Profiler: {
                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                    var _finishedWork$memoize = finishedWork.memoizedProps, id3 = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                    var commitTime2 = getCommitTime();
                    var phase = finishedWork.alternate === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onPostCommit === "function") {
                      onPostCommit(id3, phase, passiveEffectDuration, commitTime2);
                    }
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root2 = parentFiber.stateNode;
                            root2.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                    break;
                  }
                }
              }
            }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  if (!offscreenSubtreeWasHidden) {
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    }
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = finishedWork.stateNode;
                  if (finishedWork.flags & Update) {
                    if (!offscreenSubtreeWasHidden) {
                      if (current2 === null) {
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidMount();
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidMount();
                        }
                      } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                        var prevState = current2.memoizedState;
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        }
                      }
                    }
                  }
                  var updateQueue = finishedWork.updateQueue;
                  if (updateQueue !== null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                  }
                  break;
                }
                case HostRoot: {
                  var _updateQueue = finishedWork.updateQueue;
                  if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) {
                      switch (finishedWork.child.tag) {
                        case HostComponent:
                          _instance = getPublicInstance(finishedWork.child.stateNode);
                          break;
                        case ClassComponent:
                          _instance = finishedWork.child.stateNode;
                          break;
                      }
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                  }
                  break;
                }
                case HostComponent: {
                  var _instance2 = finishedWork.stateNode;
                  if (current2 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                  }
                  break;
                }
                case HostText: {
                  break;
                }
                case HostPortal: {
                  break;
                }
                case Profiler: {
                  {
                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                    var effectDuration = finishedWork.stateNode.effectDuration;
                    var commitTime2 = getCommitTime();
                    var phase = current2 === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onRender === "function") {
                      onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                    }
                    {
                      if (typeof onCommit === "function") {
                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                      }
                      enqueuePendingPassiveProfilerEffect(finishedWork);
                      var parentFiber = finishedWork.return;
                      outer:
                        while (parentFiber !== null) {
                          switch (parentFiber.tag) {
                            case HostRoot:
                              var root2 = parentFiber.stateNode;
                              root2.effectDuration += effectDuration;
                              break outer;
                            case Profiler:
                              var parentStateNode = parentFiber.stateNode;
                              parentStateNode.effectDuration += effectDuration;
                              break outer;
                          }
                          parentFiber = parentFiber.return;
                        }
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                }
                case SuspenseListComponent:
                case IncompleteClassComponent:
                case ScopeComponent:
                case OffscreenComponent:
                case LegacyHiddenComponent:
                case TracingMarkerComponent: {
                  break;
                }
                default:
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (!offscreenSubtreeWasHidden) {
              {
                if (finishedWork.flags & Ref) {
                  commitAttachRef(finishedWork);
                }
              }
            }
          }
          function reappearLayoutEffectsOnFiber(node2) {
            switch (node2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (node2.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    safelyCallCommitHookLayoutEffectListMount(node2, node2.return);
                  } finally {
                    recordLayoutEffectDuration(node2);
                  }
                } else {
                  safelyCallCommitHookLayoutEffectListMount(node2, node2.return);
                }
                break;
              }
              case ClassComponent: {
                var instance = node2.stateNode;
                if (typeof instance.componentDidMount === "function") {
                  safelyCallComponentDidMount(node2, node2.return, instance);
                }
                safelyAttachRef(node2, node2.return);
                break;
              }
              case HostComponent: {
                safelyAttachRef(node2, node2.return);
                break;
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
              var node2 = finishedWork;
              while (true) {
                if (node2.tag === HostComponent) {
                  if (hostSubtreeRoot === null) {
                    hostSubtreeRoot = node2;
                    try {
                      var instance = node2.stateNode;
                      if (isHidden) {
                        hideInstance(instance);
                      } else {
                        unhideInstance(node2.stateNode, node2.memoizedProps);
                      }
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                } else if (node2.tag === HostText) {
                  if (hostSubtreeRoot === null) {
                    try {
                      var _instance3 = node2.stateNode;
                      if (isHidden) {
                        hideTextInstance(_instance3);
                      } else {
                        unhideTextInstance(_instance3, node2.memoizedProps);
                      }
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                } else if ((node2.tag === OffscreenComponent || node2.tag === LegacyHiddenComponent) && node2.memoizedState !== null && node2 !== finishedWork)
                  ;
                else if (node2.child !== null) {
                  node2.child.return = node2;
                  node2 = node2.child;
                  continue;
                }
                if (node2 === finishedWork) {
                  return;
                }
                while (node2.sibling === null) {
                  if (node2.return === null || node2.return === finishedWork) {
                    return;
                  }
                  if (hostSubtreeRoot === node2) {
                    hostSubtreeRoot = null;
                  }
                  node2 = node2.return;
                }
                if (hostSubtreeRoot === node2) {
                  hostSubtreeRoot = null;
                }
                node2.sibling.return = node2.return;
                node2 = node2.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                var retVal;
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(instanceToUse);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  retVal = ref(instanceToUse);
                }
                {
                  if (typeof retVal === "function") {
                    error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                  }
                }
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.return = null;
            }
            fiber.return = null;
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              fiber.alternate = null;
              detachFiberAfterEffects(alternate);
            }
            {
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              if (fiber.tag === HostComponent) {
                var hostInstance = fiber.stateNode;
                if (hostInstance !== null) {
                  detachDeletedInstance(hostInstance);
                }
              }
              fiber.stateNode = null;
              {
                fiber._debugOwner = null;
              }
              {
                fiber.return = null;
                fiber.dependencies = null;
                fiber.memoizedProps = null;
                fiber.memoizedState = null;
                fiber.pendingProps = null;
                fiber.stateNode = null;
                fiber.updateQueue = null;
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node2 = fiber;
            siblings:
              while (true) {
                while (node2.sibling === null) {
                  if (node2.return === null || isHostParent(node2.return)) {
                    return null;
                  }
                  node2 = node2.return;
                }
                node2.sibling.return = node2.return;
                node2 = node2.sibling;
                while (node2.tag !== HostComponent && node2.tag !== HostText && node2.tag !== DehydratedFragment) {
                  if (node2.flags & Placement) {
                    continue siblings;
                  }
                  if (node2.child === null || node2.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node2.child.return = node2;
                    node2 = node2.child;
                  }
                }
                if (!(node2.flags & Placement)) {
                  return node2.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
              case HostComponent: {
                var parent = parentFiber.stateNode;
                if (parentFiber.flags & ContentReset) {
                  resetTextContent(parent);
                  parentFiber.flags &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              }
              case HostRoot:
              case HostPortal: {
                var _parent = parentFiber.stateNode.containerInfo;
                var _before = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                break;
              }
              default:
                throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
            var tag = node2.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node2.stateNode;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node2.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node2, before, parent) {
            var tag = node2.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node2.stateNode;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node2.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          var hostParent = null;
          var hostParentIsContainer = false;
          function commitDeletionEffects(root2, returnFiber, deletedFiber) {
            {
              var parent = returnFiber;
              findParent:
                while (parent !== null) {
                  switch (parent.tag) {
                    case HostComponent: {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break findParent;
                    }
                    case HostRoot: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                    case HostPortal: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                  }
                  parent = parent.return;
                }
              if (hostParent === null) {
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            var child = parent.child;
            while (child !== null) {
              commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
              child = child.sibling;
            }
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
              case HostComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                }
              }
              case HostText: {
                {
                  var prevHostParent = hostParent;
                  var prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      removeChildFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      removeChild(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case DehydratedFragment: {
                {
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                {
                  var _prevHostParent = hostParent;
                  var _prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = _prevHostParent;
                  hostParentIsContainer = _prevHostParentIsContainer;
                }
                return;
              }
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  var updateQueue = deletedFiber.updateQueue;
                  if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                      var firstEffect = lastEffect.next;
                      var effect5 = firstEffect;
                      do {
                        var _effect = effect5, destroy = _effect.destroy, tag = _effect.tag;
                        if (destroy !== void 0) {
                          if ((tag & Insertion7) !== NoFlags$1) {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          } else if ((tag & Layout) !== NoFlags$1) {
                            {
                              markComponentLayoutEffectUnmountStarted(deletedFiber);
                            }
                            if (deletedFiber.mode & ProfileMode) {
                              startLayoutEffectTimer();
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                              recordLayoutEffectDuration(deletedFiber);
                            } else {
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            }
                            {
                              markComponentLayoutEffectUnmountStopped();
                            }
                          }
                        }
                        effect5 = effect5.next;
                      } while (effect5 !== firstEffect);
                    }
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ClassComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var instance = deletedFiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ScopeComponent: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case OffscreenComponent: {
                if (
                  // TODO: Remove this dead flag
                  deletedFiber.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                }
                break;
              }
              default: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
            }
          }
          function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  retryCache.add(wakeable);
                  {
                    if (isDevToolsPresent) {
                      if (inProgressLanes !== null && inProgressRoot !== null) {
                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                      } else {
                        throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                      }
                    }
                  }
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function commitMutationEffects(root2, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root2;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root2);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                try {
                  commitDeletionEffects(root2, parentFiber, childToDelete);
                } catch (error3) {
                  captureCommitPhaseError(childToDelete, parentFiber, error3);
                }
              }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
              var child = parentFiber.child;
              while (child !== null) {
                setCurrentFiber(child);
                commitMutationEffectsOnFiber(child, root2);
                child = child.sibling;
              }
            }
            setCurrentFiber(prevDebugFiber);
          }
          function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  try {
                    commitHookEffectListUnmount(Insertion7 | HasEffect, finishedWork, finishedWork.return);
                    commitHookEffectListMount(Insertion7 | HasEffect, finishedWork);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                    recordLayoutEffectDuration(finishedWork);
                  } else {
                    try {
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                return;
              }
              case HostComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                {
                  if (finishedWork.flags & ContentReset) {
                    var instance = finishedWork.stateNode;
                    try {
                      resetTextContent(instance);
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                  if (flags & Update) {
                    var _instance4 = finishedWork.stateNode;
                    if (_instance4 != null) {
                      var newProps = finishedWork.memoizedProps;
                      var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                      var type = finishedWork.type;
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        try {
                          commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                        } catch (error3) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostText: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (finishedWork.stateNode === null) {
                      throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps;
                    var oldText = current2 !== null ? current2.memoizedProps : newText;
                    try {
                      commitTextUpdate(textInstance, oldText, newText);
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                }
                return;
              }
              case HostRoot: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (current2 !== null) {
                      var prevRootState = current2.memoizedState;
                      if (prevRootState.isDehydrated) {
                        try {
                          commitHydratedContainer(root2.containerInfo);
                        } catch (error3) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
              case SuspenseComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                var offscreenFiber = finishedWork.child;
                if (offscreenFiber.flags & Visibility) {
                  var offscreenInstance = offscreenFiber.stateNode;
                  var newState = offscreenFiber.memoizedState;
                  var isHidden = newState !== null;
                  offscreenInstance.isHidden = isHidden;
                  if (isHidden) {
                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                    if (!wasHidden) {
                      markCommitTimeOfFallback();
                    }
                  }
                }
                if (flags & Update) {
                  try {
                    commitSuspenseCallback(finishedWork);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case OffscreenComponent: {
                var _wasHidden = current2 !== null && current2.memoizedState !== null;
                if (
                  // TODO: Remove this dead flag
                  finishedWork.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                }
                commitReconciliationEffects(finishedWork);
                if (flags & Visibility) {
                  var _offscreenInstance = finishedWork.stateNode;
                  var _newState = finishedWork.memoizedState;
                  var _isHidden = _newState !== null;
                  var offscreenBoundary = finishedWork;
                  _offscreenInstance.isHidden = _isHidden;
                  {
                    if (_isHidden) {
                      if (!_wasHidden) {
                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                          nextEffect = offscreenBoundary;
                          var offscreenChild = offscreenBoundary.child;
                          while (offscreenChild !== null) {
                            nextEffect = offscreenChild;
                            disappearLayoutEffects_begin(offscreenChild);
                            offscreenChild = offscreenChild.sibling;
                          }
                        }
                      }
                    }
                  }
                  {
                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                  }
                }
                return;
              }
              case SuspenseListComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case ScopeComponent: {
                return;
              }
              default: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
              try {
                commitPlacement(finishedWork);
              } catch (error3) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error3);
              }
              finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
              finishedWork.flags &= ~Hydrating;
            }
          }
          function commitLayoutEffects(finishedWork, root2, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root2;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root2, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent && isModernRoot) {
                var isHidden = fiber.memoizedState !== null;
                var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                if (newOffscreenSubtreeIsHidden) {
                  commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                  continue;
                } else {
                  var current2 = fiber.alternate;
                  var wasHidden = current2 !== null && current2.memoizedState !== null;
                  var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                  var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                  if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                    nextEffect = fiber;
                    reappearLayoutEffects_begin(fiber);
                  }
                  var child = firstChild;
                  while (child !== null) {
                    nextEffect = child;
                    commitLayoutEffects_begin(
                      child,
                      // New root; bubble back up to here and stop.
                      root2,
                      committedLanes
                    );
                    child = child.sibling;
                  }
                  nextEffect = fiber;
                  offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                  continue;
                }
              }
              if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
              }
            }
          }
          function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & LayoutMask) !== NoFlags) {
                var current2 = fiber.alternate;
                setCurrentFiber(fiber);
                try {
                  commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent: {
                  if (fiber.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout, fiber, fiber.return);
                    } finally {
                      recordLayoutEffectDuration(fiber);
                    }
                  } else {
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  }
                  break;
                }
                case ClassComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
                case HostComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  break;
                }
                case OffscreenComponent: {
                  var isHidden = fiber.memoizedState !== null;
                  if (isHidden) {
                    disappearLayoutEffects_complete(subtreeRoot);
                    continue;
                  }
                  break;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                disappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent) {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  reappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                reappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                reappearLayoutEffectsOnFiber(fiber);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
          }
          function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
              }
            }
          }
          function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                try {
                  commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  } finally {
                    recordPassiveEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
          }
          function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                var deletions = fiber.deletions;
                if (deletions !== null) {
                  for (var i = 0; i < deletions.length; i++) {
                    var fiberToDelete = deletions[i];
                    nextEffect = fiberToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                  }
                  {
                    var previousFiber = fiber.alternate;
                    if (previousFiber !== null) {
                      var detachedChild = previousFiber.child;
                      if (detachedChild !== null) {
                        previousFiber.child = null;
                        do {
                          var detachedSibling = detachedChild.sibling;
                          detachedChild.sibling = null;
                          detachedChild = detachedSibling;
                        } while (detachedChild !== null);
                      }
                    }
                  }
                  nextEffect = fiber;
                }
              }
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffects_complete();
              }
            }
          }
          function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentFiber();
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                  recordPassiveEffectDuration(finishedWork);
                } else {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
              resetCurrentFiber();
              var child = fiber.child;
              if (child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var sibling = fiber.sibling;
              var returnFiber = fiber.return;
              {
                detachFiberAfterEffects(fiber);
                if (fiber === deletedSubtreeRoot) {
                  nextEffect = null;
                  return;
                }
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                return;
              }
              nextEffect = returnFiber;
            }
          }
          function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (current2.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                  recordPassiveEffectDuration(current2);
                } else {
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                }
                break;
              }
            }
          }
          function invokeLayoutEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Layout | HasEffect, fiber);
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  try {
                    instance.componentDidMount();
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                  break;
                }
              }
            }
          }
          function invokeLayoutEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                }
              }
            }
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor("selector.role");
            TEST_NAME_TYPE = symbolFor("selector.test_id");
            TEXT_TYPE = symbolFor("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
          function isLegacyActEnvironment(fiber) {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              var jestIsDefined = typeof jest !== "undefined";
              return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
          }
          function isConcurrentActEnvironment() {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                error2("The current testing environment is not configured to support act(...)");
              }
              return isReactActEnvironmentGlobal;
            }
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
          var NoContext = (
            /*             */
            0
          );
          var BatchedContext = (
            /*               */
            1
          );
          var RenderContext = (
            /*                */
            2
          );
          var CommitContext = (
            /*                */
            4
          );
          var RootInProgress = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var RootDidNotComplete = 6;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootInProgress;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootInterleavedUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var workInProgressRootConcurrentErrors = null;
          var workInProgressRootRecoverableErrors = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          var workInProgressTransitions = null;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now3() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveProfilerEffects = [];
          var pendingPassiveTransitions = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var isFlushingPassiveEffects = false;
          var didScheduleUpdateDuringPassiveEffects = false;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var rootWithPassiveNestedUpdates = null;
          var currentEventTime = NoTimestamp;
          var currentEventTransitionLane = NoLanes;
          var isRunningInsertionEffect = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now3();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now3();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode2 = fiber.mode;
            if ((mode2 & ConcurrentMode) === NoMode) {
              return SyncLane;
            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
              return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (ReactCurrentBatchConfig$3.transition !== null) {
                var transition3 = ReactCurrentBatchConfig$3.transition;
                if (!transition3._updatedFibers) {
                  transition3._updatedFibers = /* @__PURE__ */ new Set();
                }
                transition3._updatedFibers.add(fiber);
              }
              if (currentEventTransitionLane === NoLane) {
                currentEventTransitionLane = claimNextTransitionLane();
              }
              return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
              return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
          }
          function requestRetryLane(fiber) {
            var mode2 = fiber.mode;
            if ((mode2 & ConcurrentMode) === NoMode) {
              return SyncLane;
            }
            return claimNextRetryLane();
          }
          function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
              if (isRunningInsertionEffect) {
                error2("useInsertionEffect must not schedule updates.");
              }
            }
            {
              if (isFlushingPassiveEffects) {
                didScheduleUpdateDuringPassiveEffects = true;
              }
            }
            markRootUpdated(root2, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
              warnAboutRenderPhaseUpdatesInDEV(fiber);
            } else {
              {
                if (isDevToolsPresent) {
                  addFiberToLanesMap(root2, fiber, lane);
                }
              }
              warnIfUpdatesNotWrappedWithActDEV(fiber);
              if (root2 === workInProgressRoot) {
                if ((executionContext & RenderContext) === NoContext) {
                  workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                }
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspended$1(root2, workInProgressRootRenderLanes);
                }
              }
              ensureRootIsScheduled(root2, eventTime);
              if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
            var current2 = root2.current;
            current2.lanes = lane;
            markRootUpdated(root2, lane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
          function isUnsafeClassRenderPhaseUpdate(fiber) {
            return (
              // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
              // decided not to enable it.
              (executionContext & RenderContext) !== NoContext
            );
          }
          function ensureRootIsScheduled(root2, currentTime) {
            var existingCallbackNode = root2.callbackNode;
            markStarvedLanesAsExpired(root2, currentTime);
            var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback$1(existingCallbackNode);
              }
              root2.callbackNode = null;
              root2.callbackPriority = NoLane;
              return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root2.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
            // Scheduler task, rather than an `act` task, cancel it and re-scheduled
            // on the `act` queue.
            !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
              {
                if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                  error2("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              return;
            }
            if (existingCallbackNode != null) {
              cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
              if (root2.tag === LegacyRoot) {
                if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                  ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                }
                scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
              } else {
                scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
              }
              {
                if (ReactCurrentActQueue$1.current !== null) {
                  ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                } else {
                  scheduleMicrotask(function() {
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                      flushSyncCallbacks();
                    }
                  });
                }
              }
              newCallbackNode = null;
            } else {
              var schedulerPriorityLevel;
              switch (lanesToEventPriority(nextLanes)) {
                case DiscreteEventPriority:
                  schedulerPriorityLevel = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriorityLevel = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriorityLevel = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriorityLevel = IdlePriority;
                  break;
                default:
                  schedulerPriorityLevel = NormalPriority;
                  break;
              }
              newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
            }
            root2.callbackPriority = newCallbackPriority;
            root2.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root2, didTimeout) {
            {
              resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var originalCallbackNode = root2.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root2.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
            if (exitStatus !== RootInProgress) {
              if (exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                if (errorRetryLanes !== NoLanes) {
                  lanes = errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now3());
                throw fatalError;
              }
              if (exitStatus === RootDidNotComplete) {
                markRootSuspended$1(root2, lanes);
              } else {
                var renderWasConcurrent = !includesBlockingLane(root2, lanes);
                var finishedWork = root2.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                  exitStatus = renderRootSync(root2, lanes);
                  if (exitStatus === RootErrored) {
                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                    if (_errorRetryLanes !== NoLanes) {
                      lanes = _errorRetryLanes;
                      exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                    }
                  }
                  if (exitStatus === RootFatalErrored) {
                    var _fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root2, NoLanes);
                    markRootSuspended$1(root2, lanes);
                    ensureRootIsScheduled(root2, now3());
                    throw _fatalError;
                  }
                }
                root2.finishedWork = finishedWork;
                root2.finishedLanes = lanes;
                finishConcurrentRender(root2, exitStatus, lanes);
              }
            }
            ensureRootIsScheduled(root2, now3());
            if (root2.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root2);
            }
            return null;
          }
          function recoverFromConcurrentError(root2, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root2)) {
              var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
              rootWorkInProgress.flags |= ForceClientRender;
              {
                errorHydratingContainer(root2.containerInfo);
              }
            }
            var exitStatus = renderRootSync(root2, errorRetryLanes);
            if (exitStatus !== RootErrored) {
              var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
              if (errorsFromSecondAttempt !== null) {
                queueRecoverableErrors(errorsFromSecondAttempt);
              }
            }
            return exitStatus;
          }
          function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
              workInProgressRootRecoverableErrors = errors;
            } else {
              workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
          }
          function finishConcurrentRender(root2, exitStatus, lanes) {
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              case RootErrored: {
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
                !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now3();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root2, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root2.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root2, suspendedLanes);
                      break;
                    }
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now3() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootCompleted: {
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            var node2 = finishedWork;
            while (true) {
              if (node2.flags & StoreConsistency) {
                var updateQueue = node2.updateQueue;
                if (updateQueue !== null) {
                  var checks = updateQueue.stores;
                  if (checks !== null) {
                    for (var i = 0; i < checks.length; i++) {
                      var check = checks[i];
                      var getSnapshot = check.getSnapshot;
                      var renderedValue = check.value;
                      try {
                        if (!objectIs(getSnapshot(), renderedValue)) {
                          return false;
                        }
                      } catch (error3) {
                        return false;
                      }
                    }
                  }
                }
              }
              var child = node2.child;
              if (node2.subtreeFlags & StoreConsistency && child !== null) {
                child.return = node2;
                node2 = child;
                continue;
              }
              if (node2 === finishedWork) {
                return true;
              }
              while (node2.sibling === null) {
                if (node2.return === null || node2.return === finishedWork) {
                  return true;
                }
                node2 = node2.return;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
            }
            return true;
          }
          function markRootSuspended$1(root2, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root2, suspendedLanes);
          }
          function performSyncWorkOnRoot(root2) {
            {
              syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root2, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
              ensureRootIsScheduled(root2, now3());
              return null;
            }
            var exitStatus = renderRootSync(root2, lanes);
            if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now3());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            var finishedWork = root2.current.alternate;
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root2, now3());
            return null;
          }
          function flushRoot(root2, lanes) {
            if (lanes !== NoLanes) {
              markRootEntangled(root2, mergeLanes(lanes, SyncLane));
              ensureRootIsScheduled(root2, now3());
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                resetRenderTimer();
                flushSyncCallbacks();
              }
            }
          }
          function batchedUpdates$1(fn2, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn2(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function discreteUpdates(fn2, a, b, c, d) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              return fn2(a, b, c, d);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              if (executionContext === NoContext) {
                resetRenderTimer();
              }
            }
          }
          function flushSync(fn2) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              if (fn2) {
                return fn2();
              } else {
                return void 0;
              }
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              executionContext = prevExecutionContext;
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushSyncCallbacks();
              }
            }
          }
          function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
          }
          function pushRenderLanes(fiber, lanes) {
            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root2, lanes) {
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            var timeoutHandle = root2.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root2.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                var current2 = interruptedWork.alternate;
                unwindInterruptedWork(current2, interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root2;
            var rootWorkInProgress = createWorkInProgress(root2.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
          }
          function handleError(root2, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                if (enableSchedulingProfiler) {
                  markComponentRenderStopped();
                  if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                    var wakeable = thrownValue;
                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                  } else {
                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                  }
                }
                throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now3();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError(error3) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
              workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
              workInProgressRootConcurrentErrors = [error3];
            } else {
              workInProgressRootConcurrentErrors.push(error3);
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
          }
          function renderRootSync(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root2.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root2, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              prepareFreshStack(root2, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root2.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root2, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              resetRenderTimer();
              prepareFreshStack(root2, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              {
                markRenderYielded();
              }
              return RootInProgress;
            } else {
              {
                markRenderStopped();
              }
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next2;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next2 === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next2;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next2 = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next2 = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next2 = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next2 !== null) {
                  workInProgress = next2;
                  return;
                }
              } else {
                var _next = unwindWork(current2, completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.flags |= Incomplete;
                  returnFiber.subtreeFlags = NoFlags;
                  returnFiber.deletions = null;
                } else {
                  workInProgressRootExitStatus = RootDidNotComplete;
                  workInProgress = null;
                  return;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function commitRoot(root2, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
            } finally {
              ReactCurrentBatchConfig$3.transition = prevTransition;
              setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
          }
          function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var finishedWork = root2.finishedWork;
            var lanes = root2.finishedLanes;
            {
              markCommitStarted(lanes);
            }
            if (finishedWork === null) {
              {
                markCommitStopped();
              }
              return null;
            } else {
              {
                if (lanes === NoLanes) {
                  error2("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                }
              }
            }
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            if (finishedWork === root2.current) {
              throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
            root2.callbackNode = null;
            root2.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root2, remainingLanes);
            if (root2 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                pendingPassiveTransitions = transitions;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              ReactCurrentBatchConfig$3.transition = null;
              var previousPriority = getCurrentUpdatePriority();
              setCurrentUpdatePriority(DiscreteEventPriority);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              ReactCurrentOwner$2.current = null;
              var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
              {
                recordCommitTime();
              }
              commitMutationEffects(root2, finishedWork, lanes);
              resetAfterCommit(root2.containerInfo);
              root2.current = finishedWork;
              {
                markLayoutEffectsStarted(lanes);
              }
              commitLayoutEffects(finishedWork, root2, lanes);
              {
                markLayoutEffectsStopped();
              }
              requestPaint();
              executionContext = prevExecutionContext;
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            } else {
              root2.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root2;
              pendingPassiveEffectsLanes = lanes;
            } else {
              {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
              }
            }
            remainingLanes = root2.pendingLanes;
            if (remainingLanes === NoLanes) {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                commitDoubleInvokeEffectsInDEV(root2.current, false);
              }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              if (isDevToolsPresent) {
                root2.memoizedUpdaters.clear();
              }
            }
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root2, now3());
            if (recoverableErrors !== null) {
              var onRecoverableError = root2.onRecoverableError;
              for (var i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                var componentStack = recoverableError.stack;
                var digest = recoverableError.digest;
                onRecoverableError(recoverableError.value, {
                  componentStack,
                  digest
                });
              }
            }
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var error$1 = firstUncaughtError;
              firstUncaughtError = null;
              throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
              flushPassiveEffects();
            }
            remainingLanes = root2.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
              {
                markNestedUpdateScheduled();
              }
              if (root2 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root2;
              }
            } else {
              nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
              markCommitStopped();
            }
            return null;
          }
          function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
              var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
              var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              var previousPriority = getCurrentUpdatePriority();
              try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(priority);
                return flushPassiveEffectsImpl();
              } finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
              }
            }
            return false;
          }
          function enqueuePendingPassiveProfilerEffect(fiber) {
            {
              pendingPassiveProfilerEffects.push(fiber);
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root2 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Cannot flush passive effects while already rendering.");
            }
            {
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            {
              markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root2.current);
            commitPassiveMountEffects(root2, root2.current, lanes, transitions);
            {
              var profilerEffects = pendingPassiveProfilerEffects;
              pendingPassiveProfilerEffects = [];
              for (var i = 0; i < profilerEffects.length; i++) {
                var _fiber = profilerEffects[i];
                commitPassiveEffectDurations(root2, _fiber);
              }
            }
            {
              markPassiveEffectsStopped();
            }
            {
              commitDoubleInvokeEffectsInDEV(root2.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
              if (didScheduleUpdateDuringPassiveEffects) {
                if (root2 === rootWithPassiveNestedUpdates) {
                  nestedPassiveUpdateCount++;
                } else {
                  nestedPassiveUpdateCount = 0;
                  rootWithPassiveNestedUpdates = root2;
                }
              } else {
                nestedPassiveUpdateCount = 0;
              }
              isFlushingPassiveEffects = false;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root2);
            {
              var stateNode = root2.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error3) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error3;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
            var errorInfo = createCapturedValueAtFiber(error3, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root2 = enqueueUpdate(rootFiber, update, SyncLane);
            var eventTime = requestEventTime();
            if (root2 !== null) {
              markRootUpdated(root2, SyncLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
            }
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
              reportUncaughtErrorInDEV(error$1);
              setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
              return;
            }
            var fiber = null;
            {
              fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  var root2 = enqueueUpdate(fiber, update, SyncLane);
                  var eventTime = requestEventTime();
                  if (root2 !== null) {
                    markRootUpdated(root2, SyncLane, eventTime);
                    ensureRootIsScheduled(root2, eventTime);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
            {
              error2("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
            }
          }
          function pingSuspendedRoot(root2, wakeable, pingedLanes) {
            var pingCache = root2.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root2, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
            if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now3() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root2, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root2 !== null) {
              markRootUpdated(root2, retryLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
            }
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
              case SuspenseComponent:
                retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                if (suspenseState !== null) {
                  retryLane = suspenseState.retryLane;
                }
                break;
              case SuspenseListComponent:
                retryCache = boundaryFiber.stateNode;
                break;
              default:
                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
                error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
              setCurrentFiber(fiber);
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
              }
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
              }
              resetCurrentFiber();
            }
          }
          function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
              var current2 = firstChild;
              var subtreeRoot = null;
              while (current2 !== null) {
                var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                  current2 = current2.child;
                } else {
                  if ((current2.flags & fiberFlags) !== NoFlags) {
                    invokeEffectFn(current2);
                  }
                  if (current2.sibling !== null) {
                    current2 = current2.sibling;
                  } else {
                    current2 = subtreeRoot = current2.return;
                  }
                }
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & ConcurrentMode)) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                return;
              }
              var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(current2, unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                    originalError._suppressLogging = true;
                  }
                }
                throw originalError;
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                      error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          function restorePendingUpdaters(root2, lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                memoizedUpdaters.forEach(function(schedulingFiber) {
                  addFiberToLanesMap(root2, schedulingFiber, lanes);
                });
              }
            }
          }
          var fakeActCallbackNode = {};
          function scheduleCallback$1(priorityLevel, callback) {
            {
              var actQueue = ReactCurrentActQueue$1.current;
              if (actQueue !== null) {
                actQueue.push(callback);
                return fakeActCallbackNode;
              } else {
                return scheduleCallback(priorityLevel, callback);
              }
            }
          }
          function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
              return;
            }
            return cancelCallback(callbackNode);
          }
          function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
              if (fiber.mode & ConcurrentMode) {
                if (!isConcurrentActEnvironment()) {
                  return;
                }
              } else {
                if (!isLegacyActEnvironment()) {
                  return;
                }
                if (executionContext !== NoContext) {
                  return;
                }
                if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                  return;
                }
              }
              if (ReactCurrentActQueue$1.current === null) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
            {
              if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                error2("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
              }
            }
          }
          function setIsRunningInsertionEffect(isRunning) {
            {
              isRunningInsertionEffect = isRunning;
            }
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root2, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root2, element) {
            {
              if (root2.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync(function() {
                updateContainer(element, root2, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (_root !== null) {
                  scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                }
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root2, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types2 = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root2.current, types2, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types2.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node2 = fiber;
              while (true) {
                switch (node2.tag) {
                  case HostComponent:
                    hostInstances.add(node2.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node2.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node2.stateNode.containerInfo);
                    return;
                }
                if (node2.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node2 = node2.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node2 = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node2.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node2.stateNode);
                } else if (node2.child !== null) {
                  node2.child.return = node2;
                  node2 = node2.child;
                  continue;
                }
                if (node2 === fiber) {
                  return foundHostInstances;
                }
                while (node2.sibling === null) {
                  if (node2.return === null || node2.return === fiber) {
                    return foundHostInstances;
                  }
                  node2 = node2.return;
                }
                node2.sibling.return = node2.return;
                node2 = node2.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e3) {
              hasBadMapPolyfill = true;
            }
          }
          function FiberNode(tag, pendingProps, key, mode2) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode2;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode2) {
            return new FiberNode(tag, pendingProps, key, mode2);
          };
          function shouldConstruct$1(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component2) {
            if (typeof Component2 === "function") {
              return shouldConstruct$1(Component2) ? ClassComponent : FunctionComponent;
            } else if (Component2 !== void 0 && Component2 !== null) {
              var $$typeof = Component2.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.flags = current2.flags & StaticMask;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= StaticMask | Placement;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode2;
            if (tag === ConcurrentRoot) {
              mode2 = ConcurrentMode;
              if (isStrictMode === true) {
                mode2 |= StrictLegacyMode;
                {
                  mode2 |= StrictEffectsMode;
                }
              }
            } else {
              mode2 = NoMode;
            }
            if (isDevToolsPresent) {
              mode2 |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode2);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode2, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode2, lanes, key);
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode2 |= StrictLegacyMode;
                    if ((mode2 & ConcurrentMode) !== NoMode) {
                      mode2 |= StrictEffectsMode;
                    }
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode2, lanes, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode2, lanes, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode2, lanes, key);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode2, lanes, key);
                  case REACT_LEGACY_HIDDEN_TYPE:
                  case REACT_SCOPE_TYPE:
                  case REACT_CACHE_TYPE:
                  case REACT_TRACING_MARKER_TYPE:
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode2);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode2, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode2, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode2, lanes, key) {
            var fiber = createFiber(Fragment9, elements, key, mode2);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode2, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error2('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode2 | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode2, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode2);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode2, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode2);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode2, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode2);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
              isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
          }
          function createFiberFromText(content, mode2, lanes) {
            var fiber = createFiber(HostText, content, null, mode2);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            return fiber;
          }
          function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
          }
          function createFiberFromPortal(portal, mode2, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode2);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              // Used by persistent updates
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.subtreeFlags = source.subtreeFlags;
            target.deletions = source.deletions;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.effectDuration = 0;
              this.passiveEffectDuration = 0;
            }
            {
              this.memoizedUpdaters = /* @__PURE__ */ new Set();
              var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
              for (var _i = 0; _i < TotalLanes; _i++) {
                pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
              }
            }
            {
              switch (tag) {
                case ConcurrentRoot:
                  this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
            root2.current = uninitializedFiber;
            uninitializedFiber.stateNode = root2;
            {
              var _initialState = {
                element: initialChildren,
                isDehydrated: hydrate2,
                cache: null,
                // not enabled yet
                transitions: null,
                pendingSuspenseBoundaries: null
              };
              uninitializedFiber.memoizedState = _initialState;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root2;
          }
          var ReactVersion = "18.2.0";
          function createPortal2(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            {
              checkKeyStringCoercion(key);
            }
            return {
              // This tag allow us to uniquely identify this as a React Portal
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get3(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component2 = fiber.type;
              if (isContextProvider(Component2)) {
                return processChildContext(fiber, Component2, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get3(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  throw new Error("Unable to find node on an unmounted component.");
                } else {
                  var keys3 = Object.keys(component).join(",");
                  throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys3);
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictLegacyMode) {
                var componentName = getComponentNameFromFiber(fiber) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictLegacyMode) {
                      error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          }
          function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = true;
            var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root2.context = getContextForSubtree(null);
            var current2 = root2.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current2);
            var update = createUpdate(eventTime, lane);
            update.callback = callback !== void 0 && callback !== null ? callback : null;
            enqueueUpdate(current2, update, lane);
            scheduleInitialHydrationOnRoot(root2, lane, eventTime);
            return root2;
          }
          function updateContainer(element, container2, parentComponent, callback) {
            {
              onScheduleRoot(container2, element);
            }
            var current$1 = container2.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
              markRenderScheduled(lane);
            }
            var context = getContextForSubtree(parentComponent);
            if (container2.context === null) {
              container2.context = context;
            } else {
              container2.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(current$1, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
              entangleTransitions(root2, current$1, lane);
            }
            return lane;
          }
          function getPublicRootInstance(container2) {
            var containerFiber = container2.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
              case HostRoot: {
                var root2 = fiber.stateNode;
                if (isRootDehydrated(root2)) {
                  var lanes = getHighestPriorityPendingLanes(root2);
                  flushRoot(root2, lanes);
                }
                break;
              }
              case SuspenseComponent: {
                flushSync(function() {
                  var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                  if (root3 !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
                  }
                });
                var retryLane = SyncLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
              }
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = SelectiveHydrationLane;
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = requestUpdateLane(fiber);
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          var shouldErrorImpl = function(fiber) {
            return null;
          };
          function shouldError(fiber) {
            return shouldErrorImpl(fiber);
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setErrorHandler = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index2) {
              var key = path[index2];
              var updated = isArray(obj) ? obj.slice() : assign2({}, obj);
              if (index2 + 1 === path.length) {
                if (isArray(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
              var oldKey = oldPath[index2];
              var updated = isArray(obj) ? obj.slice() : assign2({}, obj);
              if (index2 + 1 === oldPath.length) {
                var newKey = newPath[index2];
                updated[newKey] = updated[oldKey];
                if (isArray(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  // $FlowFixMe number or string is fine here
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index2 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn2("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i = 0; i < newPath.length - 1; i++) {
                  if (oldPath[i] !== newPath[i]) {
                    warn2("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index2, value) {
              if (index2 >= path.length) {
                return value;
              }
              var key = path[index2];
              var updated = isArray(obj) ? obj.slice() : assign2({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id3) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id3 > 0) {
                currentHook2 = currentHook2.next;
                id3--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id3, path, value) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateDeletePath = function(fiber, id3, path) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateRenamePath = function(fiber, id3, oldPath, newPath) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            scheduleUpdate = function(fiber) {
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            setErrorHandler = function(newShouldErrorImpl) {
              shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setErrorHandler,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              // React Refresh
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              // Enables DevTools to append owner stacks to error messages in DEV mode.
              getCurrentFiber: getCurrentFiberForDevTools,
              // Enables DevTools to detect reconciler version rather than renderer version
              // which may not match for third party renderers.
              reconcilerVersion: ReactVersion
            });
          }
          var defaultOnRecoverableError = typeof reportError === "function" ? (
            // In modern browsers, reportError will dispatch an error event,
            // emulating an uncaught JavaScript error.
            reportError
          ) : function(error3) {
            console["error"](error3);
          };
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root2 = this._internalRoot;
            if (root2 === null) {
              throw new Error("Cannot update an unmounted root.");
            }
            {
              if (typeof arguments[1] === "function") {
                error2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              } else if (isValidContainer(arguments[1])) {
                error2("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
              } else if (typeof arguments[1] !== "undefined") {
                error2("You passed a second argument to root.render(...) but it only accepts one argument.");
              }
              var container2 = root2.containerInfo;
              if (container2.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root2.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container2) {
                    error2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root2, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root2 = this._internalRoot;
            if (root2 !== null) {
              this._internalRoot = null;
              var container2 = root2.containerInfo;
              {
                if (isAlreadyRendering()) {
                  error2("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
                }
              }
              flushSync(function() {
                updateContainer(null, root2, null, null);
              });
              unmarkContainerAsRoot(container2);
            }
          };
          function createRoot2(container2, options2) {
            if (!isValidContainer(container2)) {
              throw new Error("createRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container2);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options2 !== null && options2 !== void 0) {
              {
                if (options2.hydrate) {
                  warn2("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
                } else {
                  if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                    error2("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                  }
                }
              }
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
              if (options2.transitionCallbacks !== void 0) {
                transitionCallbacks = options2.transitionCallbacks;
              }
            }
            var root2 = createContainer(container2, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root2.current, container2);
            var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root2);
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function scheduleHydration(target) {
            if (target) {
              queueExplicitHydrationTarget(target);
            }
          }
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
          function hydrateRoot(container2, initialChildren, options2) {
            if (!isValidContainer(container2)) {
              throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container2);
            {
              if (initialChildren === void 0) {
                error2("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
              }
            }
            var hydrationCallbacks = options2 != null ? options2 : null;
            var mutableSources = options2 != null && options2.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            if (options2 !== null && options2 !== void 0) {
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
            }
            var root2 = createHydrationContainer(initialChildren, null, container2, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root2.current, container2);
            listenToAllSupportedEvents(container2);
            if (mutableSources) {
              for (var i = 0; i < mutableSources.length; i++) {
                var mutableSource = mutableSources[i];
                registerMutableSourceForHydration(root2, mutableSource);
              }
            }
            return new ReactDOMHydrationRoot(root2);
          }
          function isValidContainer(node2) {
            return !!(node2 && (node2.nodeType === ELEMENT_NODE || node2.nodeType === DOCUMENT_NODE || node2.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
          }
          function isValidContainerLegacy(node2) {
            return !!(node2 && (node2.nodeType === ELEMENT_NODE || node2.nodeType === DOCUMENT_NODE || node2.nodeType === DOCUMENT_FRAGMENT_NODE || node2.nodeType === COMMENT_NODE && node2.nodeValue === " react-mount-point-unstable "));
          }
          function warnIfReactDOMContainerInDEV(container2) {
            {
              if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
                error2("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
              }
              if (isContainerMarkedAsRoot(container2)) {
                if (container2._reactRootContainer) {
                  error2("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
                } else {
                  error2("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
                }
              }
            }
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          {
            topLevelUpdateWarnings = function(container2) {
              if (container2._reactRootContainer && container2.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container2._reactRootContainer.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container2) {
                    error2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container2._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container2);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
                error2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container2) {
            if (!container2) {
              return null;
            }
            if (container2.nodeType === DOCUMENT_NODE) {
              return container2.documentElement;
            } else {
              return container2.firstChild;
            }
          }
          function noopOnRecoverableError() {
          }
          function legacyCreateRootFromDOMContainer(container2, initialChildren, parentComponent, callback, isHydrationContainer) {
            if (isHydrationContainer) {
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root2);
                  originalCallback.call(instance);
                };
              }
              var root2 = createHydrationContainer(
                initialChildren,
                callback,
                container2,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container2._reactRootContainer = root2;
              markContainerAsRoot(root2.current, container2);
              var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
              listenToAllSupportedEvents(rootContainerElement);
              flushSync();
              return root2;
            } else {
              var rootSibling;
              while (rootSibling = container2.lastChild) {
                container2.removeChild(rootSibling);
              }
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(_root);
                  _originalCallback.call(instance);
                };
              }
              var _root = createContainer(
                container2,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container2._reactRootContainer = _root;
              markContainerAsRoot(_root.current, container2);
              var _rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
              listenToAllSupportedEvents(_rootContainerElement);
              flushSync(function() {
                updateContainer(initialChildren, _root, parentComponent, callback);
              });
              return _root;
            }
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container2, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container2);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var maybeRoot = container2._reactRootContainer;
            var root2;
            if (!maybeRoot) {
              root2 = legacyCreateRootFromDOMContainer(container2, children, parentComponent, callback, forceHydrate);
            } else {
              root2 = maybeRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root2);
                  originalCallback.call(instance);
                };
              }
              updateContainer(children, root2, parentComponent, callback);
            }
            return getPublicRootInstance(root2);
          }
          function findDOMNode(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container2, callback) {
            {
              error2("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container2, true, callback);
          }
          function render(element, container2, callback) {
            {
              error2("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container2, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            {
              error2("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(containerNode)) {
              throw new Error("Target container is not a DOM element.");
            }
            if (parentComponent == null || !has(parentComponent)) {
              throw new Error("parentComponent must be a valid React Component");
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode(container2) {
            if (!isValidContainerLegacy(container2)) {
              throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container2._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container2);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              flushSync(function() {
                legacyRenderSubtreeIntoContainer(null, null, container2, false, function() {
                  container2._reactRootContainer = null;
                  unmarkContainerAsRoot(container2);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container2);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container2.nodeType === ELEMENT_NODE && isValidContainerLegacy(container2.parentNode) && !!container2.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptSynchronousHydration(attemptSynchronousHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setGetCurrentUpdatePriority(getCurrentUpdatePriority);
          setAttemptHydrationAtPriority(runWithPriority);
          {
            if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
            Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
            Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
          function createPortal$1(children, container2) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            return createPortal2(children, container2, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          var Internals = {
            usingClientEntryPoint: false,
            // Keep in sync with ReactTestUtils.js.
            // This is an array for better minification.
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
          };
          function createRoot$1(container2, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error2('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return createRoot2(container2, options2);
          }
          function hydrateRoot$1(container2, initialChildren, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error2('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return hydrateRoot(container2, initialChildren, options2);
          }
          function flushSync$1(fn2) {
            {
              if (isAlreadyRendering()) {
                error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
            }
            return flushSync(fn2);
          }
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM2 && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.createRoot = createRoot$1;
          exports.findDOMNode = findDOMNode;
          exports.flushSync = flushSync$1;
          exports.hydrate = hydrate;
          exports.hydrateRoot = hydrateRoot$1;
          exports.render = render;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module2) {
      "use strict";
      if (false) {
        checkDCE();
        module2.exports = null;
      } else {
        module2.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m = require_react_dom();
      if (false) {
        exports.createRoot = m.createRoot;
        exports.hydrateRoot = m.hydrateRoot;
      } else {
        i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.createRoot(c, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c, h, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.hydrateRoot(c, h, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
      }
      var i;
    }
  });

  // node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment9 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal3 = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement7(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment9;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal3;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement7;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/hoist-non-react-statics/node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_is_development();
      }
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module2) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys3 = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys3 = keys3.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i = 0; i < keys3.length; ++i) {
            var key = keys3[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e3) {
              }
            }
          }
        }
        return targetComponent;
      }
      module2.exports = hoistNonReactStatics;
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React53 = require_react();
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactSharedInternals = React53.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error2(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init3(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var assign2 = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match3 = x.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match3 && match3[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn2);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s2 = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
                  c--;
                }
                for (; s2 >= 1 && c >= 0; s2--, c--) {
                  if (sampleLines[s2] !== controlLines[c]) {
                    if (s2 !== 1 || c !== 1) {
                      do {
                        s2--;
                        c--;
                        if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s2 >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty2);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown;
          var specialPropRefWarningShown;
          var didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty2.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty2.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function warnIfStringRefCannotBeAutoConverted(config2, self2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          function defineKeyPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingKey = function() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }
          }
          function defineRefPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingRef = function() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, "ref", {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function jsxDEV(type, config2, maybeKey, source, self2) {
            {
              var propName;
              var props = {};
              var key = null;
              var ref = null;
              if (maybeKey !== void 0) {
                {
                  checkKeyStringCoercion(maybeKey);
                }
                key = "" + maybeKey;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              if (hasValidRef(config2)) {
                ref = config2.ref;
                warnIfStringRefCannotBeAutoConverted(config2, self2);
              }
              for (propName in config2) {
                if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
              if (type && type.defaultProps) {
                var defaultProps2 = type.defaultProps;
                for (propName in defaultProps2) {
                  if (props[propName] === void 0) {
                    props[propName] = defaultProps2[propName];
                  }
                }
              }
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
              return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function isValidElement5(object) {
            {
              return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
          }
          function getDeclarationErrorAddendum() {
            {
              if (ReactCurrentOwner$1.current) {
                var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                if (name) {
                  return "\n\nCheck the render method of `" + name + "`.";
                }
              }
              return "";
            }
          }
          function getSourceInfoErrorAddendum(source) {
            {
              if (source !== void 0) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                var lineNumber = source.lineNumber;
                return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
              }
              return "";
            }
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                  info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
              }
              return info;
            }
          }
          function validateExplicitKey(element, parentType) {
            {
              if (!element._store || element._store.validated || element.key != null) {
                return;
              }
              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              var childOwner = "";
              if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
              }
              setCurrentlyValidatingElement$1(element);
              error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node2, parentType) {
            {
              if (typeof node2 !== "object") {
                return;
              }
              if (isArray(node2)) {
                for (var i = 0; i < node2.length; i++) {
                  var child = node2[i];
                  if (isValidElement5(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement5(node2)) {
                if (node2._store) {
                  node2._store.validated = true;
                }
              } else if (node2) {
                var iteratorFn = getIteratorFn(node2);
                if (typeof iteratorFn === "function") {
                  if (iteratorFn !== node2.entries) {
                    var iterator = iteratorFn.call(node2);
                    var step;
                    while (!(step = iterator.next()).done) {
                      if (isValidElement5(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys3 = Object.keys(fragment.props);
              for (var i = 0; i < keys3.length; i++) {
                var key = keys3[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
            {
              var validType = isValidElementType(type);
              if (!validType) {
                var info = "";
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendum(source);
                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                  typeString = "null";
                } else if (isArray(type)) {
                  typeString = "array";
                } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                  typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                  info = " Did you accidentally export a JSX literal instead of a component?";
                } else {
                  typeString = typeof type;
                }
                error2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
              var element = jsxDEV(type, props, key, source, self2);
              if (element == null) {
                return element;
              }
              if (validType) {
                var children = props.children;
                if (children !== void 0) {
                  if (isStaticChildren) {
                    if (isArray(children)) {
                      for (var i = 0; i < children.length; i++) {
                        validateChildKeys(children[i], type);
                      }
                      if (Object.freeze) {
                        Object.freeze(children);
                      }
                    } else {
                      error2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                    }
                  } else {
                    validateChildKeys(children, type);
                  }
                }
              }
              if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }
              return element;
            }
          }
          function jsxWithValidationStatic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, true);
            }
          }
          function jsxWithValidationDynamic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, false);
            }
          }
          var jsx44 = jsxWithValidationDynamic;
          var jsxs14 = jsxWithValidationStatic;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.jsx = jsx44;
          exports.jsxs = jsxs14;
        })();
      }
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // node_modules/lodash.mergewith/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.mergewith/index.js"(exports, module2) {
      var LARGE_ARRAY_SIZE = 200;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var MAX_SAFE_INTEGER = 9007199254740991;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var asyncTag = "[object AsyncFunction]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var nullTag = "[object Null]";
      var objectTag = "[object Object]";
      var proxyTag = "[object Proxy]";
      var regexpTag = "[object RegExp]";
      var setTag2 = "[object Set]";
      var stringTag = "[object String]";
      var undefinedTag = "[object Undefined]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag2] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e3) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object);
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var Symbol2 = root.Symbol;
      var Uint8Array2 = root.Uint8Array;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var objectCreate = Object.create;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var splice = arrayProto.splice;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e3) {
        }
      }();
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var nativeMax = Math.max;
      var nativeNow = Date.now;
      var Map2 = getNative(root, "Map");
      var nativeCreate = getNative(Object, "create");
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      function Hash(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function Stack2(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length2)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length2 = array.length;
        while (length2--) {
          if (eq(array[length2][0], key)) {
            return length2;
          }
        }
        return -1;
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      var baseFor = createBaseFor();
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction5(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack2());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction5(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity2), func + "");
      }
      var baseSetToString = !defineProperty ? identity2 : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
        buffer.copy(result);
        return result;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function copyArray(source, array) {
        var index = -1, length2 = source.length;
        array || (array = Array(length2));
        while (++index < length2) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length2 = props.length;
        while (++index < length2) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard2 = length2 > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
          if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
            customizer = length2 < 3 ? void 0 : customizer;
            length2 = 1;
          }
          object = Object(object);
          while (++index < length2) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
          while (length2--) {
            var key = props[fromRight ? length2 : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e3) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function isIndex(value, length2) {
        var type = typeof value;
        length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
        return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start2, transform2) {
        start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index = -1, length2 = nativeMax(args.length - start2, 0), array = Array(length2);
          while (++index < length2) {
            array[index] = args[start2 + index];
          }
          index = -1;
          var otherArgs = Array(start2 + 1);
          while (++index < start2) {
            otherArgs[index] = args[index];
          }
          otherArgs[start2] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setToString = shortOut(baseSetToString);
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction5(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      function isFunction5(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var mergeWith6 = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      function constant(value) {
        return function() {
          return value;
        };
      }
      function identity2(value) {
        return value;
      }
      function stubFalse() {
        return false;
      }
      module2.exports = mergeWith6;
    }
  });

  // node_modules/react-fast-compare/index.js
  var require_react_fast_compare = __commonJS({
    "node_modules/react-fast-compare/index.js"(exports, module2) {
      var hasElementType = typeof Element !== "undefined";
      var hasMap = typeof Map === "function";
      var hasSet = typeof Set === "function";
      var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
      function equal(a, b) {
        if (a === b)
          return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor)
            return false;
          var length2, i, keys3;
          if (Array.isArray(a)) {
            length2 = a.length;
            if (length2 != b.length)
              return false;
            for (i = length2; i-- !== 0; )
              if (!equal(a[i], b[i]))
                return false;
            return true;
          }
          var it;
          if (hasMap && a instanceof Map && b instanceof Map) {
            if (a.size !== b.size)
              return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!b.has(i.value[0]))
                return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!equal(i.value[1], b.get(i.value[0])))
                return false;
            return true;
          }
          if (hasSet && a instanceof Set && b instanceof Set) {
            if (a.size !== b.size)
              return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!b.has(i.value[0]))
                return false;
            return true;
          }
          if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
            length2 = a.length;
            if (length2 != b.length)
              return false;
            for (i = length2; i-- !== 0; )
              if (a[i] !== b[i])
                return false;
            return true;
          }
          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function")
            return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function")
            return a.toString() === b.toString();
          keys3 = Object.keys(a);
          length2 = keys3.length;
          if (length2 !== Object.keys(b).length)
            return false;
          for (i = length2; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys3[i]))
              return false;
          if (hasElementType && a instanceof Element)
            return false;
          for (i = length2; i-- !== 0; ) {
            if ((keys3[i] === "_owner" || keys3[i] === "__v" || keys3[i] === "__o") && a.$$typeof) {
              continue;
            }
            if (!equal(a[keys3[i]], b[keys3[i]]))
              return false;
          }
          return true;
        }
        return a !== a && b !== b;
      }
      module2.exports = function isEqual2(a, b) {
        try {
          return equal(a, b);
        } catch (error2) {
          if ((error2.message || "").match(/stack|recursion/i)) {
            console.warn("react-fast-compare cannot handle circular refs");
            return false;
          }
          throw error2;
        }
      };
    }
  });

  // node_modules/framer-motion/node_modules/@emotion/memoize/dist/memoize.browser.cjs.js
  var require_memoize_browser_cjs = __commonJS({
    "node_modules/framer-motion/node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function memoize5(fn2) {
        var cache = {};
        return function(arg) {
          if (cache[arg] === void 0)
            cache[arg] = fn2(arg);
          return cache[arg];
        };
      }
      exports.default = memoize5;
    }
  });

  // node_modules/framer-motion/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js
  var require_is_prop_valid_browser_cjs = __commonJS({
    "node_modules/framer-motion/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _interopDefault(ex) {
        return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
      }
      var memoize5 = _interopDefault(require_memoize_browser_cjs());
      var reactPropsRegex2 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
      var index = memoize5(
        function(prop) {
          return reactPropsRegex2.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
        }
        /* Z+1 */
      );
      exports.default = index;
    }
  });

  // node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development2 = __commonJS({
    "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment9 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal3 = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement7(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment9;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal3;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement7;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/prop-types/node_modules/react-is/index.js
  var require_react_is2 = __commonJS({
    "node_modules/prop-types/node_modules/react-is/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_is_development2();
      }
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module2) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
            return test2[n2];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from2;
        var to = toObject(target);
        var symbols;
        for (var s2 = 1; s2 < arguments.length; s2++) {
          from2 = Object(arguments[s2]);
          for (var key in from2) {
            if (hasOwnProperty2.call(from2, key)) {
              to[key] = from2[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from2);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from2, symbols[i])) {
                to[symbols[i]] = from2[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module2.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module2) {
      module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = require_has();
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error2;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error2 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error2 = ex;
              }
              if (error2 && !(error2 instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
                loggedTypeFailures[error2.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location + " type: " + error2.message + (stack != null ? stack : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module2.exports = checkPropTypes;
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
      "use strict";
      var ReactIs = require_react_is2();
      var assign2 = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has = require_has();
      var checkPropTypes = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module2.exports = function(isValidElement5, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function PropTypeError(message, data) {
          this.message = message;
          this.data = data && typeof data === "object" ? data : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                { expectedType }
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i = 0; i < propValue.length; i++) {
              var error2 = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement5(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
              if (is(propValue, expectedValues[i])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error2 = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error2 instanceof Error) {
                  return error2;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
              var checker2 = arrayOfTypeCheckers[i2];
              var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function invalidValidatorError(componentName, location, propFullName, key, type) {
          return new PropTypeError(
            (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
          );
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign2({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement5(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module2) {
      if (true) {
        ReactIs = require_react_is2();
        throwOnDirectAccess = true;
        module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module2.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports, module2) {
      (function() {
        "use strict";
        var hasOwn2 = {}.hasOwnProperty;
        function classNames2() {
          var classes = "";
          for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              classes = appendClass(classes, parseValue(arg));
            }
          }
          return classes;
        }
        function parseValue(arg) {
          if (typeof arg === "string" || typeof arg === "number") {
            return arg;
          }
          if (typeof arg !== "object") {
            return "";
          }
          if (Array.isArray(arg)) {
            return classNames2.apply(null, arg);
          }
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            return arg.toString();
          }
          var classes = "";
          for (var key in arg) {
            if (hasOwn2.call(arg, key) && arg[key]) {
              classes = appendClass(classes, key);
            }
          }
          return classes;
        }
        function appendClass(value, newClass) {
          if (!newClass) {
            return value;
          }
          if (value) {
            return value + " " + newClass;
          }
          return value + newClass;
        }
        if (typeof module2 !== "undefined" && module2.exports) {
          classNames2.default = classNames2;
          module2.exports = classNames2;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames2;
          });
        } else {
          window.classNames = classNames2;
        }
      })();
    }
  });

  // node_modules/@visx/shape/node_modules/d3-path/dist/d3-path.js
  var require_d3_path = __commonJS({
    "node_modules/@visx/shape/node_modules/d3-path/dist/d3-path.js"(exports, module2) {
      (function(global2, factory2) {
        typeof exports === "object" && typeof module2 !== "undefined" ? factory2(exports) : typeof define === "function" && define.amd ? define(["exports"], factory2) : (global2 = global2 || self, factory2(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
        function Path() {
          this._x0 = this._y0 = // start of current subpath
          this._x1 = this._y1 = null;
          this._ = "";
        }
        function path() {
          return new Path();
        }
        Path.prototype = path.prototype = {
          constructor: Path,
          moveTo: function(x, y) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
          },
          closePath: function() {
            if (this._x1 !== null) {
              this._x1 = this._x0, this._y1 = this._y0;
              this._ += "Z";
            }
          },
          lineTo: function(x, y) {
            this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
          },
          quadraticCurveTo: function(x1, y1, x, y) {
            this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
          },
          bezierCurveTo: function(x1, y1, x2, y2, x, y) {
            this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
          },
          arcTo: function(x1, y1, x2, y2, r3) {
            x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r3 = +r3;
            var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
            if (r3 < 0)
              throw new Error("negative radius: " + r3);
            if (this._x1 === null) {
              this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
            } else if (!(l01_2 > epsilon))
              ;
            else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r3) {
              this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
            } else {
              var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r3 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
              if (Math.abs(t01 - 1) > epsilon) {
                this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
              }
              this._ += "A" + r3 + "," + r3 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
            }
          },
          arc: function(x, y, r3, a0, a1, ccw) {
            x = +x, y = +y, r3 = +r3, ccw = !!ccw;
            var dx = r3 * Math.cos(a0), dy = r3 * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
            if (r3 < 0)
              throw new Error("negative radius: " + r3);
            if (this._x1 === null) {
              this._ += "M" + x0 + "," + y0;
            } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
              this._ += "L" + x0 + "," + y0;
            }
            if (!r3)
              return;
            if (da < 0)
              da = da % tau + tau;
            if (da > tauEpsilon) {
              this._ += "A" + r3 + "," + r3 + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r3 + "," + r3 + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
            } else if (da > epsilon) {
              this._ += "A" + r3 + "," + r3 + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r3 * Math.cos(a1)) + "," + (this._y1 = y + r3 * Math.sin(a1));
            }
          },
          rect: function(x, y, w, h) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
          },
          toString: function() {
            return this._;
          }
        };
        exports2.path = path;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@visx/shape/node_modules/d3-shape/dist/d3-shape.js
  var require_d3_shape = __commonJS({
    "node_modules/@visx/shape/node_modules/d3-shape/dist/d3-shape.js"(exports, module2) {
      (function(global2, factory2) {
        typeof exports === "object" && typeof module2 !== "undefined" ? factory2(exports, require_d3_path()) : typeof define === "function" && define.amd ? define(["exports", "d3-path"], factory2) : (global2 = global2 || self, factory2(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Path) {
        "use strict";
        function constant(x2) {
          return function constant2() {
            return x2;
          };
        }
        var abs2 = Math.abs;
        var atan2 = Math.atan2;
        var cos = Math.cos;
        var max2 = Math.max;
        var min2 = Math.min;
        var sin = Math.sin;
        var sqrt = Math.sqrt;
        var epsilon = 1e-12;
        var pi = Math.PI;
        var halfPi = pi / 2;
        var tau = 2 * pi;
        function acos(x2) {
          return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
        }
        function asin(x2) {
          return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
        }
        function arcInnerRadius(d) {
          return d.innerRadius;
        }
        function arcOuterRadius(d) {
          return d.outerRadius;
        }
        function arcStartAngle(d) {
          return d.startAngle;
        }
        function arcEndAngle(d) {
          return d.endAngle;
        }
        function arcPadAngle(d) {
          return d && d.padAngle;
        }
        function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
          var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t4 = y32 * x10 - x32 * y10;
          if (t4 * t4 < epsilon)
            return;
          t4 = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t4;
          return [x0 + t4 * x10, y0 + t4 * y10];
        }
        function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
          var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r3 = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max2(0, r3 * r3 * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
          if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
            cx0 = cx1, cy0 = cy1;
          return {
            cx: cx0,
            cy: cy0,
            x01: -ox,
            y01: -oy,
            x11: cx0 * (r1 / r3 - 1),
            y11: cy0 * (r1 / r3 - 1)
          };
        }
        function arc() {
          var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
          function arc2() {
            var buffer, r3, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs2(a1 - a0), cw = a1 > a0;
            if (!context)
              context = buffer = d3Path.path();
            if (r1 < r0)
              r3 = r1, r1 = r0, r0 = r3;
            if (!(r1 > epsilon))
              context.moveTo(0, 0);
            else if (da > tau - epsilon) {
              context.moveTo(r1 * cos(a0), r1 * sin(a0));
              context.arc(0, 0, r1, a0, a1, !cw);
              if (r0 > epsilon) {
                context.moveTo(r0 * cos(a1), r0 * sin(a1));
                context.arc(0, 0, r0, a1, a0, cw);
              }
            } else {
              var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min2(abs2(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;
              if (rp > epsilon) {
                var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
                if ((da0 -= p0 * 2) > epsilon)
                  p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
                else
                  da0 = 0, a00 = a10 = (a0 + a1) / 2;
                if ((da1 -= p1 * 2) > epsilon)
                  p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
                else
                  da1 = 0, a01 = a11 = (a0 + a1) / 2;
              }
              var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
              if (rc > epsilon) {
                var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
                if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
                  var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                  rc0 = min2(rc, (r0 - lc) / (kc - 1));
                  rc1 = min2(rc, (r1 - lc) / (kc + 1));
                }
              }
              if (!(da1 > epsilon))
                context.moveTo(x01, y01);
              else if (rc1 > epsilon) {
                t03 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
                t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
                context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
                if (rc1 < rc)
                  context.arc(t03.cx, t03.cy, rc1, atan2(t03.y01, t03.x01), atan2(t13.y01, t13.x01), !cw);
                else {
                  context.arc(t03.cx, t03.cy, rc1, atan2(t03.y01, t03.x01), atan2(t03.y11, t03.x11), !cw);
                  context.arc(0, 0, r1, atan2(t03.cy + t03.y11, t03.cx + t03.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
                  context.arc(t13.cx, t13.cy, rc1, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw);
                }
              } else
                context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
              if (!(r0 > epsilon) || !(da0 > epsilon))
                context.lineTo(x10, y10);
              else if (rc0 > epsilon) {
                t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
                t13 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
                context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
                if (rc0 < rc)
                  context.arc(t03.cx, t03.cy, rc0, atan2(t03.y01, t03.x01), atan2(t13.y01, t13.x01), !cw);
                else {
                  context.arc(t03.cx, t03.cy, rc0, atan2(t03.y01, t03.x01), atan2(t03.y11, t03.x11), !cw);
                  context.arc(0, 0, r0, atan2(t03.cy + t03.y11, t03.cx + t03.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), cw);
                  context.arc(t13.cx, t13.cy, rc0, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw);
                }
              } else
                context.arc(0, 0, r0, a10, a00, cw);
            }
            context.closePath();
            if (buffer)
              return context = null, buffer + "" || null;
          }
          arc2.centroid = function() {
            var r3 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
            return [cos(a2) * r3, sin(a2) * r3];
          };
          arc2.innerRadius = function(_) {
            return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : innerRadius;
          };
          arc2.outerRadius = function(_) {
            return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : outerRadius;
          };
          arc2.cornerRadius = function(_) {
            return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : cornerRadius;
          };
          arc2.padRadius = function(_) {
            return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc2) : padRadius;
          };
          arc2.startAngle = function(_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc2) : startAngle;
          };
          arc2.endAngle = function(_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc2) : endAngle;
          };
          arc2.padAngle = function(_) {
            return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc2) : padAngle;
          };
          arc2.context = function(_) {
            return arguments.length ? (context = _ == null ? null : _, arc2) : context;
          };
          return arc2;
        }
        function Linear(context) {
          this._context = context;
        }
        Linear.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
              default:
                this._context.lineTo(x2, y2);
                break;
            }
          }
        };
        function curveLinear(context) {
          return new Linear(context);
        }
        function x(p) {
          return p[0];
        }
        function y(p) {
          return p[1];
        }
        function line3() {
          var x$1 = x, y$1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;
          function line4(data) {
            var i, n2 = data.length, d, defined0 = false, buffer;
            if (context == null)
              output = curve(buffer = d3Path.path());
            for (i = 0; i <= n2; ++i) {
              if (!(i < n2 && defined(d = data[i], i, data)) === defined0) {
                if (defined0 = !defined0)
                  output.lineStart();
                else
                  output.lineEnd();
              }
              if (defined0)
                output.point(+x$1(d, i, data), +y$1(d, i, data));
            }
            if (buffer)
              return output = null, buffer + "" || null;
          }
          line4.x = function(_) {
            return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line4) : x$1;
          };
          line4.y = function(_) {
            return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line4) : y$1;
          };
          line4.defined = function(_) {
            return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line4) : defined;
          };
          line4.curve = function(_) {
            return arguments.length ? (curve = _, context != null && (output = curve(context)), line4) : curve;
          };
          line4.context = function(_) {
            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line4) : context;
          };
          return line4;
        }
        function area() {
          var x0 = x, x1 = null, y0 = constant(0), y1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;
          function area2(data) {
            var i, j, k2, n2 = data.length, d, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
            if (context == null)
              output = curve(buffer = d3Path.path());
            for (i = 0; i <= n2; ++i) {
              if (!(i < n2 && defined(d = data[i], i, data)) === defined0) {
                if (defined0 = !defined0) {
                  j = i;
                  output.areaStart();
                  output.lineStart();
                } else {
                  output.lineEnd();
                  output.lineStart();
                  for (k2 = i - 1; k2 >= j; --k2) {
                    output.point(x0z[k2], y0z[k2]);
                  }
                  output.lineEnd();
                  output.areaEnd();
                }
              }
              if (defined0) {
                x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
                output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
              }
            }
            if (buffer)
              return output = null, buffer + "" || null;
          }
          function arealine() {
            return line3().defined(defined).curve(curve).context(context);
          }
          area2.x = function(_) {
            return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area2) : x0;
          };
          area2.x0 = function(_) {
            return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area2) : x0;
          };
          area2.x1 = function(_) {
            return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area2) : x1;
          };
          area2.y = function(_) {
            return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area2) : y0;
          };
          area2.y0 = function(_) {
            return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area2) : y0;
          };
          area2.y1 = function(_) {
            return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area2) : y1;
          };
          area2.lineX0 = area2.lineY0 = function() {
            return arealine().x(x0).y(y0);
          };
          area2.lineY1 = function() {
            return arealine().x(x0).y(y1);
          };
          area2.lineX1 = function() {
            return arealine().x(x1).y(y0);
          };
          area2.defined = function(_) {
            return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area2) : defined;
          };
          area2.curve = function(_) {
            return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
          };
          area2.context = function(_) {
            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
          };
          return area2;
        }
        function descending3(a2, b) {
          return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
        }
        function identity2(d) {
          return d;
        }
        function pie() {
          var value = identity2, sortValues = descending3, sort = null, startAngle = constant(0), endAngle = constant(tau), padAngle = constant(0);
          function pie2(data) {
            var i, n2 = data.length, j, k2, sum2 = 0, index = new Array(n2), arcs = new Array(n2), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n2, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
            for (i = 0; i < n2; ++i) {
              if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
                sum2 += v;
              }
            }
            if (sortValues != null)
              index.sort(function(i2, j2) {
                return sortValues(arcs[i2], arcs[j2]);
              });
            else if (sort != null)
              index.sort(function(i2, j2) {
                return sort(data[i2], data[j2]);
              });
            for (i = 0, k2 = sum2 ? (da - n2 * pa) / sum2 : 0; i < n2; ++i, a0 = a1) {
              j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
                data: data[j],
                index: i,
                value: v,
                startAngle: a0,
                endAngle: a1,
                padAngle: p
              };
            }
            return arcs;
          }
          pie2.value = function(_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie2) : value;
          };
          pie2.sortValues = function(_) {
            return arguments.length ? (sortValues = _, sort = null, pie2) : sortValues;
          };
          pie2.sort = function(_) {
            return arguments.length ? (sort = _, sortValues = null, pie2) : sort;
          };
          pie2.startAngle = function(_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie2) : startAngle;
          };
          pie2.endAngle = function(_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie2) : endAngle;
          };
          pie2.padAngle = function(_) {
            return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie2) : padAngle;
          };
          return pie2;
        }
        var curveRadialLinear = curveRadial(curveLinear);
        function Radial(curve) {
          this._curve = curve;
        }
        Radial.prototype = {
          areaStart: function() {
            this._curve.areaStart();
          },
          areaEnd: function() {
            this._curve.areaEnd();
          },
          lineStart: function() {
            this._curve.lineStart();
          },
          lineEnd: function() {
            this._curve.lineEnd();
          },
          point: function(a2, r3) {
            this._curve.point(r3 * Math.sin(a2), r3 * -Math.cos(a2));
          }
        };
        function curveRadial(curve) {
          function radial(context) {
            return new Radial(curve(context));
          }
          radial._curve = curve;
          return radial;
        }
        function lineRadial(l2) {
          var c2 = l2.curve;
          l2.angle = l2.x, delete l2.x;
          l2.radius = l2.y, delete l2.y;
          l2.curve = function(_) {
            return arguments.length ? c2(curveRadial(_)) : c2()._curve;
          };
          return l2;
        }
        function lineRadial$1() {
          return lineRadial(line3().curve(curveRadialLinear));
        }
        function areaRadial() {
          var a2 = area().curve(curveRadialLinear), c2 = a2.curve, x0 = a2.lineX0, x1 = a2.lineX1, y0 = a2.lineY0, y1 = a2.lineY1;
          a2.angle = a2.x, delete a2.x;
          a2.startAngle = a2.x0, delete a2.x0;
          a2.endAngle = a2.x1, delete a2.x1;
          a2.radius = a2.y, delete a2.y;
          a2.innerRadius = a2.y0, delete a2.y0;
          a2.outerRadius = a2.y1, delete a2.y1;
          a2.lineStartAngle = function() {
            return lineRadial(x0());
          }, delete a2.lineX0;
          a2.lineEndAngle = function() {
            return lineRadial(x1());
          }, delete a2.lineX1;
          a2.lineInnerRadius = function() {
            return lineRadial(y0());
          }, delete a2.lineY0;
          a2.lineOuterRadius = function() {
            return lineRadial(y1());
          }, delete a2.lineY1;
          a2.curve = function(_) {
            return arguments.length ? c2(curveRadial(_)) : c2()._curve;
          };
          return a2;
        }
        function pointRadial(x2, y2) {
          return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
        }
        var slice2 = Array.prototype.slice;
        function linkSource(d) {
          return d.source;
        }
        function linkTarget(d) {
          return d.target;
        }
        function link(curve) {
          var source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null;
          function link2() {
            var buffer, argv = slice2.call(arguments), s3 = source.apply(this, argv), t4 = target.apply(this, argv);
            if (!context)
              context = buffer = d3Path.path();
            curve(context, +x$1.apply(this, (argv[0] = s3, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t4, argv)), +y$1.apply(this, argv));
            if (buffer)
              return context = null, buffer + "" || null;
          }
          link2.source = function(_) {
            return arguments.length ? (source = _, link2) : source;
          };
          link2.target = function(_) {
            return arguments.length ? (target = _, link2) : target;
          };
          link2.x = function(_) {
            return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), link2) : x$1;
          };
          link2.y = function(_) {
            return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), link2) : y$1;
          };
          link2.context = function(_) {
            return arguments.length ? (context = _ == null ? null : _, link2) : context;
          };
          return link2;
        }
        function curveHorizontal(context, x0, y0, x1, y1) {
          context.moveTo(x0, y0);
          context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
        }
        function curveVertical(context, x0, y0, x1, y1) {
          context.moveTo(x0, y0);
          context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
        }
        function curveRadial$1(context, x0, y0, x1, y1) {
          var p0 = pointRadial(x0, y0), p1 = pointRadial(x0, y0 = (y0 + y1) / 2), p2 = pointRadial(x1, y0), p3 = pointRadial(x1, y1);
          context.moveTo(p0[0], p0[1]);
          context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
        }
        function linkHorizontal() {
          return link(curveHorizontal);
        }
        function linkVertical() {
          return link(curveVertical);
        }
        function linkRadial() {
          var l2 = link(curveRadial$1);
          l2.angle = l2.x, delete l2.x;
          l2.radius = l2.y, delete l2.y;
          return l2;
        }
        var circle = {
          draw: function(context, size2) {
            var r3 = Math.sqrt(size2 / pi);
            context.moveTo(r3, 0);
            context.arc(0, 0, r3, 0, tau);
          }
        };
        var cross = {
          draw: function(context, size2) {
            var r3 = Math.sqrt(size2 / 5) / 2;
            context.moveTo(-3 * r3, -r3);
            context.lineTo(-r3, -r3);
            context.lineTo(-r3, -3 * r3);
            context.lineTo(r3, -3 * r3);
            context.lineTo(r3, -r3);
            context.lineTo(3 * r3, -r3);
            context.lineTo(3 * r3, r3);
            context.lineTo(r3, r3);
            context.lineTo(r3, 3 * r3);
            context.lineTo(-r3, 3 * r3);
            context.lineTo(-r3, r3);
            context.lineTo(-3 * r3, r3);
            context.closePath();
          }
        };
        var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;
        var diamond = {
          draw: function(context, size2) {
            var y2 = Math.sqrt(size2 / tan30_2), x2 = y2 * tan30;
            context.moveTo(0, -y2);
            context.lineTo(x2, 0);
            context.lineTo(0, y2);
            context.lineTo(-x2, 0);
            context.closePath();
          }
        };
        var ka = 0.8908130915292852, kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10), kx = Math.sin(tau / 10) * kr, ky = -Math.cos(tau / 10) * kr;
        var star = {
          draw: function(context, size2) {
            var r3 = Math.sqrt(size2 * ka), x2 = kx * r3, y2 = ky * r3;
            context.moveTo(0, -r3);
            context.lineTo(x2, y2);
            for (var i = 1; i < 5; ++i) {
              var a2 = tau * i / 5, c2 = Math.cos(a2), s3 = Math.sin(a2);
              context.lineTo(s3 * r3, -c2 * r3);
              context.lineTo(c2 * x2 - s3 * y2, s3 * x2 + c2 * y2);
            }
            context.closePath();
          }
        };
        var square = {
          draw: function(context, size2) {
            var w = Math.sqrt(size2), x2 = -w / 2;
            context.rect(x2, x2, w, w);
          }
        };
        var sqrt3 = Math.sqrt(3);
        var triangle = {
          draw: function(context, size2) {
            var y2 = -Math.sqrt(size2 / (sqrt3 * 3));
            context.moveTo(0, y2 * 2);
            context.lineTo(-sqrt3 * y2, -y2);
            context.lineTo(sqrt3 * y2, -y2);
            context.closePath();
          }
        };
        var c = -0.5, s2 = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3;
        var wye = {
          draw: function(context, size2) {
            var r3 = Math.sqrt(size2 / a), x0 = r3 / 2, y0 = r3 * k, x1 = x0, y1 = r3 * k + r3, x2 = -x1, y2 = y1;
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.lineTo(c * x0 - s2 * y0, s2 * x0 + c * y0);
            context.lineTo(c * x1 - s2 * y1, s2 * x1 + c * y1);
            context.lineTo(c * x2 - s2 * y2, s2 * x2 + c * y2);
            context.lineTo(c * x0 + s2 * y0, c * y0 - s2 * x0);
            context.lineTo(c * x1 + s2 * y1, c * y1 - s2 * x1);
            context.lineTo(c * x2 + s2 * y2, c * y2 - s2 * x2);
            context.closePath();
          }
        };
        var symbols = [
          circle,
          cross,
          diamond,
          square,
          star,
          triangle,
          wye
        ];
        function symbol() {
          var type = constant(circle), size2 = constant(64), context = null;
          function symbol2() {
            var buffer;
            if (!context)
              context = buffer = d3Path.path();
            type.apply(this, arguments).draw(context, +size2.apply(this, arguments));
            if (buffer)
              return context = null, buffer + "" || null;
          }
          symbol2.type = function(_) {
            return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol2) : type;
          };
          symbol2.size = function(_) {
            return arguments.length ? (size2 = typeof _ === "function" ? _ : constant(+_), symbol2) : size2;
          };
          symbol2.context = function(_) {
            return arguments.length ? (context = _ == null ? null : _, symbol2) : context;
          };
          return symbol2;
        }
        function noop4() {
        }
        function point2(that, x2, y2) {
          that._context.bezierCurveTo(
            (2 * that._x0 + that._x1) / 3,
            (2 * that._y0 + that._y1) / 3,
            (that._x0 + 2 * that._x1) / 3,
            (that._y0 + 2 * that._y1) / 3,
            (that._x0 + 4 * that._x1 + x2) / 6,
            (that._y0 + 4 * that._y1 + y2) / 6
          );
        }
        function Basis(context) {
          this._context = context;
        }
        Basis.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._y0 = this._y1 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 3:
                point2(this, this._x1, this._y1);
              case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
            }
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
              default:
                point2(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = x2;
            this._y0 = this._y1, this._y1 = y2;
          }
        };
        function basis2(context) {
          return new Basis(context);
        }
        function BasisClosed(context) {
          this._context = context;
        }
        BasisClosed.prototype = {
          areaStart: noop4,
          areaEnd: noop4,
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 1: {
                this._context.moveTo(this._x2, this._y2);
                this._context.closePath();
                break;
              }
              case 2: {
                this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
                this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
                this._context.closePath();
                break;
              }
              case 3: {
                this.point(this._x2, this._y2);
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                break;
              }
            }
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._x2 = x2, this._y2 = y2;
                break;
              case 1:
                this._point = 2;
                this._x3 = x2, this._y3 = y2;
                break;
              case 2:
                this._point = 3;
                this._x4 = x2, this._y4 = y2;
                this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
                break;
              default:
                point2(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = x2;
            this._y0 = this._y1, this._y1 = y2;
          }
        };
        function basisClosed(context) {
          return new BasisClosed(context);
        }
        function BasisOpen(context) {
          this._context = context;
        }
        BasisOpen.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._y0 = this._y1 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line || this._line !== 0 && this._point === 3)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
                this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
                break;
              case 3:
                this._point = 4;
              default:
                point2(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = x2;
            this._y0 = this._y1, this._y1 = y2;
          }
        };
        function basisOpen(context) {
          return new BasisOpen(context);
        }
        function Bundle(context, beta) {
          this._basis = new Basis(context);
          this._beta = beta;
        }
        Bundle.prototype = {
          lineStart: function() {
            this._x = [];
            this._y = [];
            this._basis.lineStart();
          },
          lineEnd: function() {
            var x2 = this._x, y2 = this._y, j = x2.length - 1;
            if (j > 0) {
              var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t4;
              while (++i <= j) {
                t4 = i / j;
                this._basis.point(
                  this._beta * x2[i] + (1 - this._beta) * (x0 + t4 * dx),
                  this._beta * y2[i] + (1 - this._beta) * (y0 + t4 * dy)
                );
              }
            }
            this._x = this._y = null;
            this._basis.lineEnd();
          },
          point: function(x2, y2) {
            this._x.push(+x2);
            this._y.push(+y2);
          }
        };
        var bundle = function custom(beta) {
          function bundle2(context) {
            return beta === 1 ? new Basis(context) : new Bundle(context, beta);
          }
          bundle2.beta = function(beta2) {
            return custom(+beta2);
          };
          return bundle2;
        }(0.85);
        function point$1(that, x2, y2) {
          that._context.bezierCurveTo(
            that._x1 + that._k * (that._x2 - that._x0),
            that._y1 + that._k * (that._y2 - that._y0),
            that._x2 + that._k * (that._x1 - x2),
            that._y2 + that._k * (that._y1 - y2),
            that._x2,
            that._y2
          );
        }
        function Cardinal(context, tension) {
          this._context = context;
          this._k = (1 - tension) / 6;
        }
        Cardinal.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 2:
                this._context.lineTo(this._x2, this._y2);
                break;
              case 3:
                point$1(this, this._x1, this._y1);
                break;
            }
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                this._x1 = x2, this._y1 = y2;
                break;
              case 2:
                this._point = 3;
              default:
                point$1(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var cardinal = function custom(tension) {
          function cardinal2(context) {
            return new Cardinal(context, tension);
          }
          cardinal2.tension = function(tension2) {
            return custom(+tension2);
          };
          return cardinal2;
        }(0);
        function CardinalClosed(context, tension) {
          this._context = context;
          this._k = (1 - tension) / 6;
        }
        CardinalClosed.prototype = {
          areaStart: noop4,
          areaEnd: noop4,
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 1: {
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
              case 2: {
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
              case 3: {
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
              }
            }
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._x3 = x2, this._y3 = y2;
                break;
              case 1:
                this._point = 2;
                this._context.moveTo(this._x4 = x2, this._y4 = y2);
                break;
              case 2:
                this._point = 3;
                this._x5 = x2, this._y5 = y2;
                break;
              default:
                point$1(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var cardinalClosed = function custom(tension) {
          function cardinal2(context) {
            return new CardinalClosed(context, tension);
          }
          cardinal2.tension = function(tension2) {
            return custom(+tension2);
          };
          return cardinal2;
        }(0);
        function CardinalOpen(context, tension) {
          this._context = context;
          this._k = (1 - tension) / 6;
        }
        CardinalOpen.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line || this._line !== 0 && this._point === 3)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                break;
              case 3:
                this._point = 4;
              default:
                point$1(this, x2, y2);
                break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var cardinalOpen = function custom(tension) {
          function cardinal2(context) {
            return new CardinalOpen(context, tension);
          }
          cardinal2.tension = function(tension2) {
            return custom(+tension2);
          };
          return cardinal2;
        }(0);
        function point$2(that, x2, y2) {
          var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
          if (that._l01_a > epsilon) {
            var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
            x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
            y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
          }
          if (that._l23_a > epsilon) {
            var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
            x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
            y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
          }
          that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
        }
        function CatmullRom(context, alpha2) {
          this._context = context;
          this._alpha = alpha2;
        }
        CatmullRom.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
            this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 2:
                this._context.lineTo(this._x2, this._y2);
                break;
              case 3:
                this.point(this._x2, this._y2);
                break;
            }
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            if (this._point) {
              var x23 = this._x2 - x2, y23 = this._y2 - y2;
              this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
              default:
                point$2(this, x2, y2);
                break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var catmullRom = function custom(alpha2) {
          function catmullRom2(context) {
            return alpha2 ? new CatmullRom(context, alpha2) : new Cardinal(context, 0);
          }
          catmullRom2.alpha = function(alpha3) {
            return custom(+alpha3);
          };
          return catmullRom2;
        }(0.5);
        function CatmullRomClosed(context, alpha2) {
          this._context = context;
          this._alpha = alpha2;
        }
        CatmullRomClosed.prototype = {
          areaStart: noop4,
          areaEnd: noop4,
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
            this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 1: {
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
              case 2: {
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
              }
              case 3: {
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
              }
            }
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            if (this._point) {
              var x23 = this._x2 - x2, y23 = this._y2 - y2;
              this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
              case 0:
                this._point = 1;
                this._x3 = x2, this._y3 = y2;
                break;
              case 1:
                this._point = 2;
                this._context.moveTo(this._x4 = x2, this._y4 = y2);
                break;
              case 2:
                this._point = 3;
                this._x5 = x2, this._y5 = y2;
                break;
              default:
                point$2(this, x2, y2);
                break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var catmullRomClosed = function custom(alpha2) {
          function catmullRom2(context) {
            return alpha2 ? new CatmullRomClosed(context, alpha2) : new CardinalClosed(context, 0);
          }
          catmullRom2.alpha = function(alpha3) {
            return custom(+alpha3);
          };
          return catmullRom2;
        }(0.5);
        function CatmullRomOpen(context, alpha2) {
          this._context = context;
          this._alpha = alpha2;
        }
        CatmullRomOpen.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
            this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
          },
          lineEnd: function() {
            if (this._line || this._line !== 0 && this._point === 3)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            if (this._point) {
              var x23 = this._x2 - x2, y23 = this._y2 - y2;
              this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
              case 0:
                this._point = 1;
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                break;
              case 3:
                this._point = 4;
              default:
                point$2(this, x2, y2);
                break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
          }
        };
        var catmullRomOpen = function custom(alpha2) {
          function catmullRom2(context) {
            return alpha2 ? new CatmullRomOpen(context, alpha2) : new CardinalOpen(context, 0);
          }
          catmullRom2.alpha = function(alpha3) {
            return custom(+alpha3);
          };
          return catmullRom2;
        }(0.5);
        function LinearClosed(context) {
          this._context = context;
        }
        LinearClosed.prototype = {
          areaStart: noop4,
          areaEnd: noop4,
          lineStart: function() {
            this._point = 0;
          },
          lineEnd: function() {
            if (this._point)
              this._context.closePath();
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            if (this._point)
              this._context.lineTo(x2, y2);
            else
              this._point = 1, this._context.moveTo(x2, y2);
          }
        };
        function linearClosed(context) {
          return new LinearClosed(context);
        }
        function sign(x2) {
          return x2 < 0 ? -1 : 1;
        }
        function slope3(that, x2, y2) {
          var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
          return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
        }
        function slope2(that, t4) {
          var h = that._x1 - that._x0;
          return h ? (3 * (that._y1 - that._y0) / h - t4) / 2 : t4;
        }
        function point$3(that, t03, t13) {
          var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
          that._context.bezierCurveTo(x0 + dx, y0 + dx * t03, x1 - dx, y1 - dx * t13, x1, y1);
        }
        function MonotoneX(context) {
          this._context = context;
        }
        MonotoneX.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            switch (this._point) {
              case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
              case 3:
                point$3(this, this._t0, slope2(this, this._t0));
                break;
            }
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            var t13 = NaN;
            x2 = +x2, y2 = +y2;
            if (x2 === this._x1 && y2 === this._y1)
              return;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                point$3(this, slope2(this, t13 = slope3(this, x2, y2)), t13);
                break;
              default:
                point$3(this, this._t0, t13 = slope3(this, x2, y2));
                break;
            }
            this._x0 = this._x1, this._x1 = x2;
            this._y0 = this._y1, this._y1 = y2;
            this._t0 = t13;
          }
        };
        function MonotoneY(context) {
          this._context = new ReflectContext(context);
        }
        (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
          MonotoneX.prototype.point.call(this, y2, x2);
        };
        function ReflectContext(context) {
          this._context = context;
        }
        ReflectContext.prototype = {
          moveTo: function(x2, y2) {
            this._context.moveTo(y2, x2);
          },
          closePath: function() {
            this._context.closePath();
          },
          lineTo: function(x2, y2) {
            this._context.lineTo(y2, x2);
          },
          bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
            this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
          }
        };
        function monotoneX2(context) {
          return new MonotoneX(context);
        }
        function monotoneY2(context) {
          return new MonotoneY(context);
        }
        function Natural(context) {
          this._context = context;
        }
        Natural.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x = [];
            this._y = [];
          },
          lineEnd: function() {
            var x2 = this._x, y2 = this._y, n2 = x2.length;
            if (n2) {
              this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
              if (n2 === 2) {
                this._context.lineTo(x2[1], y2[1]);
              } else {
                var px3 = controlPoints(x2), py = controlPoints(y2);
                for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
                  this._context.bezierCurveTo(px3[0][i0], py[0][i0], px3[1][i0], py[1][i0], x2[i1], y2[i1]);
                }
              }
            }
            if (this._line || this._line !== 0 && n2 === 1)
              this._context.closePath();
            this._line = 1 - this._line;
            this._x = this._y = null;
          },
          point: function(x2, y2) {
            this._x.push(+x2);
            this._y.push(+y2);
          }
        };
        function controlPoints(x2) {
          var i, n2 = x2.length - 1, m, a2 = new Array(n2), b = new Array(n2), r3 = new Array(n2);
          a2[0] = 0, b[0] = 2, r3[0] = x2[0] + 2 * x2[1];
          for (i = 1; i < n2 - 1; ++i)
            a2[i] = 1, b[i] = 4, r3[i] = 4 * x2[i] + 2 * x2[i + 1];
          a2[n2 - 1] = 2, b[n2 - 1] = 7, r3[n2 - 1] = 8 * x2[n2 - 1] + x2[n2];
          for (i = 1; i < n2; ++i)
            m = a2[i] / b[i - 1], b[i] -= m, r3[i] -= m * r3[i - 1];
          a2[n2 - 1] = r3[n2 - 1] / b[n2 - 1];
          for (i = n2 - 2; i >= 0; --i)
            a2[i] = (r3[i] - a2[i + 1]) / b[i];
          b[n2 - 1] = (x2[n2] + a2[n2 - 1]) / 2;
          for (i = 0; i < n2 - 1; ++i)
            b[i] = 2 * x2[i + 1] - a2[i + 1];
          return [a2, b];
        }
        function natural(context) {
          return new Natural(context);
        }
        function Step2(context, t4) {
          this._context = context;
          this._t = t4;
        }
        Step2.prototype = {
          areaStart: function() {
            this._line = 0;
          },
          areaEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._x = this._y = NaN;
            this._point = 0;
          },
          lineEnd: function() {
            if (0 < this._t && this._t < 1 && this._point === 2)
              this._context.lineTo(this._x, this._y);
            if (this._line || this._line !== 0 && this._point === 1)
              this._context.closePath();
            if (this._line >= 0)
              this._t = 1 - this._t, this._line = 1 - this._line;
          },
          point: function(x2, y2) {
            x2 = +x2, y2 = +y2;
            switch (this._point) {
              case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
              default: {
                if (this._t <= 0) {
                  this._context.lineTo(this._x, y2);
                  this._context.lineTo(x2, y2);
                } else {
                  var x1 = this._x * (1 - this._t) + x2 * this._t;
                  this._context.lineTo(x1, this._y);
                  this._context.lineTo(x1, y2);
                }
                break;
              }
            }
            this._x = x2, this._y = y2;
          }
        };
        function step(context) {
          return new Step2(context, 0.5);
        }
        function stepBefore2(context) {
          return new Step2(context, 0);
        }
        function stepAfter2(context) {
          return new Step2(context, 1);
        }
        function none(series, order2) {
          if (!((n2 = series.length) > 1))
            return;
          for (var i = 1, j, s0, s1 = series[order2[0]], n2, m = s1.length; i < n2; ++i) {
            s0 = s1, s1 = series[order2[i]];
            for (j = 0; j < m; ++j) {
              s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
            }
          }
        }
        function none$1(series) {
          var n2 = series.length, o = new Array(n2);
          while (--n2 >= 0)
            o[n2] = n2;
          return o;
        }
        function stackValue(d, key) {
          return d[key];
        }
        function stack() {
          var keys3 = constant([]), order2 = none$1, offset3 = none, value = stackValue;
          function stack2(data) {
            var kz = keys3.apply(this, arguments), i, m = data.length, n2 = kz.length, sz = new Array(n2), oz;
            for (i = 0; i < n2; ++i) {
              for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
                si[j] = sij = [0, +value(data[j], ki, j, data)];
                sij.data = data[j];
              }
              si.key = ki;
            }
            for (i = 0, oz = order2(sz); i < n2; ++i) {
              sz[oz[i]].index = i;
            }
            offset3(sz, oz);
            return sz;
          }
          stack2.keys = function(_) {
            return arguments.length ? (keys3 = typeof _ === "function" ? _ : constant(slice2.call(_)), stack2) : keys3;
          };
          stack2.value = function(_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack2) : value;
          };
          stack2.order = function(_) {
            return arguments.length ? (order2 = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice2.call(_)), stack2) : order2;
          };
          stack2.offset = function(_) {
            return arguments.length ? (offset3 = _ == null ? none : _, stack2) : offset3;
          };
          return stack2;
        }
        function expand(series, order2) {
          if (!((n2 = series.length) > 0))
            return;
          for (var i, n2, j = 0, m = series[0].length, y2; j < m; ++j) {
            for (y2 = i = 0; i < n2; ++i)
              y2 += series[i][j][1] || 0;
            if (y2)
              for (i = 0; i < n2; ++i)
                series[i][j][1] /= y2;
          }
          none(series, order2);
        }
        function diverging(series, order2) {
          if (!((n2 = series.length) > 0))
            return;
          for (var i, j = 0, d, dy, yp, yn, n2, m = series[order2[0]].length; j < m; ++j) {
            for (yp = yn = 0, i = 0; i < n2; ++i) {
              if ((dy = (d = series[order2[i]][j])[1] - d[0]) > 0) {
                d[0] = yp, d[1] = yp += dy;
              } else if (dy < 0) {
                d[1] = yn, d[0] = yn += dy;
              } else {
                d[0] = 0, d[1] = dy;
              }
            }
          }
        }
        function silhouette(series, order2) {
          if (!((n2 = series.length) > 0))
            return;
          for (var j = 0, s0 = series[order2[0]], n2, m = s0.length; j < m; ++j) {
            for (var i = 0, y2 = 0; i < n2; ++i)
              y2 += series[i][j][1] || 0;
            s0[j][1] += s0[j][0] = -y2 / 2;
          }
          none(series, order2);
        }
        function wiggle(series, order2) {
          if (!((n2 = series.length) > 0) || !((m = (s0 = series[order2[0]]).length) > 0))
            return;
          for (var y2 = 0, j = 1, s0, m, n2; j < m; ++j) {
            for (var i = 0, s1 = 0, s22 = 0; i < n2; ++i) {
              var si = series[order2[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
              for (var k2 = 0; k2 < i; ++k2) {
                var sk = series[order2[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
                s3 += skj0 - skj1;
              }
              s1 += sij0, s22 += s3 * sij0;
            }
            s0[j - 1][1] += s0[j - 1][0] = y2;
            if (s1)
              y2 -= s22 / s1;
          }
          s0[j - 1][1] += s0[j - 1][0] = y2;
          none(series, order2);
        }
        function appearance(series) {
          var peaks = series.map(peak);
          return none$1(series).sort(function(a2, b) {
            return peaks[a2] - peaks[b];
          });
        }
        function peak(series) {
          var i = -1, j = 0, n2 = series.length, vi2, vj = -Infinity;
          while (++i < n2)
            if ((vi2 = +series[i][1]) > vj)
              vj = vi2, j = i;
          return j;
        }
        function ascending3(series) {
          var sums = series.map(sum);
          return none$1(series).sort(function(a2, b) {
            return sums[a2] - sums[b];
          });
        }
        function sum(series) {
          var s3 = 0, i = -1, n2 = series.length, v;
          while (++i < n2)
            if (v = +series[i][1])
              s3 += v;
          return s3;
        }
        function descending$1(series) {
          return ascending3(series).reverse();
        }
        function insideOut(series) {
          var n2 = series.length, i, j, sums = series.map(sum), order2 = appearance(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
          for (i = 0; i < n2; ++i) {
            j = order2[i];
            if (top2 < bottom2) {
              top2 += sums[j];
              tops.push(j);
            } else {
              bottom2 += sums[j];
              bottoms.push(j);
            }
          }
          return bottoms.reverse().concat(tops);
        }
        function reverse(series) {
          return none$1(series).reverse();
        }
        exports2.arc = arc;
        exports2.area = area;
        exports2.areaRadial = areaRadial;
        exports2.curveBasis = basis2;
        exports2.curveBasisClosed = basisClosed;
        exports2.curveBasisOpen = basisOpen;
        exports2.curveBundle = bundle;
        exports2.curveCardinal = cardinal;
        exports2.curveCardinalClosed = cardinalClosed;
        exports2.curveCardinalOpen = cardinalOpen;
        exports2.curveCatmullRom = catmullRom;
        exports2.curveCatmullRomClosed = catmullRomClosed;
        exports2.curveCatmullRomOpen = catmullRomOpen;
        exports2.curveLinear = curveLinear;
        exports2.curveLinearClosed = linearClosed;
        exports2.curveMonotoneX = monotoneX2;
        exports2.curveMonotoneY = monotoneY2;
        exports2.curveNatural = natural;
        exports2.curveStep = step;
        exports2.curveStepAfter = stepAfter2;
        exports2.curveStepBefore = stepBefore2;
        exports2.line = line3;
        exports2.lineRadial = lineRadial$1;
        exports2.linkHorizontal = linkHorizontal;
        exports2.linkRadial = linkRadial;
        exports2.linkVertical = linkVertical;
        exports2.pie = pie;
        exports2.pointRadial = pointRadial;
        exports2.radialArea = areaRadial;
        exports2.radialLine = lineRadial$1;
        exports2.stack = stack;
        exports2.stackOffsetDiverging = diverging;
        exports2.stackOffsetExpand = expand;
        exports2.stackOffsetNone = none;
        exports2.stackOffsetSilhouette = silhouette;
        exports2.stackOffsetWiggle = wiggle;
        exports2.stackOrderAppearance = appearance;
        exports2.stackOrderAscending = ascending3;
        exports2.stackOrderDescending = descending$1;
        exports2.stackOrderInsideOut = insideOut;
        exports2.stackOrderNone = none$1;
        exports2.stackOrderReverse = reverse;
        exports2.symbol = symbol;
        exports2.symbolCircle = circle;
        exports2.symbolCross = cross;
        exports2.symbolDiamond = diamond;
        exports2.symbolSquare = square;
        exports2.symbolStar = star;
        exports2.symbolTriangle = triangle;
        exports2.symbolWye = wye;
        exports2.symbols = symbols;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/reduce-css-calc/node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "node_modules/reduce-css-calc/node_modules/balanced-match/index.js"(exports, module2) {
      module2.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r3 = range2(a, b, str);
        return r3 && {
          start: r3[0],
          end: r3[1],
          pre: str.slice(0, r3[0]),
          body: str.slice(r3[0] + a.length, r3[1]),
          post: str.slice(r3[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range2;
      function range2(a, b, str) {
        var begs, beg, left2, right2, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          begs = [];
          left2 = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left2) {
                left2 = beg;
                right2 = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left2, right2];
          }
        }
        return result;
      }
    }
  });

  // node_modules/balanced-match/index.js
  var require_balanced_match2 = __commonJS({
    "node_modules/balanced-match/index.js"(exports, module2) {
      "use strict";
      module2.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r3 = range2(a, b, str);
        return r3 && {
          start: r3[0],
          end: r3[1],
          pre: str.slice(0, r3[0]),
          body: str.slice(r3[0] + a.length, r3[1]),
          post: str.slice(r3[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range2;
      function range2(a, b, str) {
        var begs, beg, left2, right2, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left2 = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left2) {
                left2 = beg;
                right2 = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left2, right2];
          }
        }
        return result;
      }
    }
  });

  // node_modules/reduce-function-call/index.js
  var require_reduce_function_call = __commonJS({
    "node_modules/reduce-function-call/index.js"(exports, module2) {
      var balanced = require_balanced_match2();
      module2.exports = reduceFunctionCall;
      function reduceFunctionCall(string, functionRE, callback) {
        var call = string;
        return getFunctionCalls(string, functionRE).reduce(function(string2, obj) {
          return string2.replace(obj.functionIdentifier + "(" + obj.matches.body + ")", evalFunctionCall(obj.matches.body, obj.functionIdentifier, callback, call, functionRE));
        }, string);
      }
      function getFunctionCalls(call, functionRE) {
        var expressions = [];
        var fnRE = typeof functionRE === "string" ? new RegExp("\\b(" + functionRE + ")\\(") : functionRE;
        do {
          var searchMatch = fnRE.exec(call);
          if (!searchMatch) {
            return expressions;
          }
          if (searchMatch[1] === void 0) {
            throw new Error("Missing the first couple of parenthesis to get the function identifier in " + functionRE);
          }
          var fn2 = searchMatch[1];
          var startIndex = searchMatch.index;
          var matches = balanced("(", ")", call.substring(startIndex));
          if (!matches || matches.start !== searchMatch[0].length - 1) {
            throw new SyntaxError(fn2 + "(): missing closing ')' in the value '" + call + "'");
          }
          expressions.push({ matches, functionIdentifier: fn2 });
          call = matches.post;
        } while (fnRE.test(call));
        return expressions;
      }
      function evalFunctionCall(string, functionIdentifier, callback, call, functionRE) {
        return callback(reduceFunctionCall(string, functionRE, callback), functionIdentifier, call);
      }
    }
  });

  // node_modules/math-expression-evaluator/src/math_function.js
  var require_math_function = __commonJS({
    "node_modules/math-expression-evaluator/src/math_function.js"(exports, module2) {
      "use strict";
      var Mexp = function(parsed) {
        this.value = parsed;
      };
      Mexp.math = {
        isDegree: true,
        // mode of calculator
        acos: function(x) {
          return Mexp.math.isDegree ? 180 / Math.PI * Math.acos(x) : Math.acos(x);
        },
        add: function(a, b) {
          return a + b;
        },
        asin: function(x) {
          return Mexp.math.isDegree ? 180 / Math.PI * Math.asin(x) : Math.asin(x);
        },
        atan: function(x) {
          return Mexp.math.isDegree ? 180 / Math.PI * Math.atan(x) : Math.atan(x);
        },
        acosh: function(x) {
          return Math.log(x + Math.sqrt(x * x - 1));
        },
        asinh: function(x) {
          return Math.log(x + Math.sqrt(x * x + 1));
        },
        atanh: function(x) {
          return Math.log((1 + x) / (1 - x));
        },
        C: function(n2, r3) {
          var pro = 1;
          var other = n2 - r3;
          var choice = r3;
          if (choice < other) {
            choice = other;
            other = r3;
          }
          for (var i = choice + 1; i <= n2; i++) {
            pro *= i;
          }
          return pro / Mexp.math.fact(other);
        },
        changeSign: function(x) {
          return -x;
        },
        cos: function(x) {
          if (Mexp.math.isDegree)
            x = Mexp.math.toRadian(x);
          return Math.cos(x);
        },
        cosh: function(x) {
          return (Math.pow(Math.E, x) + Math.pow(Math.E, -1 * x)) / 2;
        },
        div: function(a, b) {
          return a / b;
        },
        fact: function(n2) {
          if (n2 % 1 !== 0)
            return "NaN";
          var pro = 1;
          for (var i = 2; i <= n2; i++) {
            pro *= i;
          }
          return pro;
        },
        inverse: function(x) {
          return 1 / x;
        },
        log: function(i) {
          return Math.log(i) / Math.log(10);
        },
        mod: function(a, b) {
          return a % b;
        },
        mul: function(a, b) {
          return a * b;
        },
        P: function(n2, r3) {
          var pro = 1;
          for (var i = Math.floor(n2) - Math.floor(r3) + 1; i <= Math.floor(n2); i++) {
            pro *= i;
          }
          return pro;
        },
        Pi: function(low, high, ex) {
          var pro = 1;
          for (var i = low; i <= high; i++) {
            pro *= Number(ex.postfixEval({
              n: i
            }));
          }
          return pro;
        },
        pow10x: function(e3) {
          var x = 1;
          while (e3--) {
            x *= 10;
          }
          return x;
        },
        sigma: function(low, high, ex) {
          var sum = 0;
          for (var i = low; i <= high; i++) {
            sum += Number(ex.postfixEval({
              n: i
            }));
          }
          return sum;
        },
        sin: function(x) {
          if (Mexp.math.isDegree)
            x = Mexp.math.toRadian(x);
          return Math.sin(x);
        },
        sinh: function(x) {
          return (Math.pow(Math.E, x) - Math.pow(Math.E, -1 * x)) / 2;
        },
        sub: function(a, b) {
          return a - b;
        },
        tan: function(x) {
          if (Mexp.math.isDegree)
            x = Mexp.math.toRadian(x);
          return Math.tan(x);
        },
        tanh: function(x) {
          return Mexp.sinha(x) / Mexp.cosha(x);
        },
        toRadian: function(x) {
          return x * Math.PI / 180;
        },
        and: function(a, b) {
          return a & b;
        }
      };
      Mexp.Exception = function(message) {
        this.message = message;
      };
      module2.exports = Mexp;
    }
  });

  // node_modules/math-expression-evaluator/src/lexer.js
  var require_lexer = __commonJS({
    "node_modules/math-expression-evaluator/src/lexer.js"(exports, module2) {
      "use strict";
      var Mexp = require_math_function();
      function inc(arr, val) {
        for (var i2 = 0; i2 < arr.length; i2++) {
          arr[i2] += val;
        }
        return arr;
      }
      var tokens2 = [
        { token: "sin", show: "sin", type: 0, value: Mexp.math.sin },
        { token: "cos", show: "cos", type: 0, value: Mexp.math.cos },
        { token: "tan", show: "tan", type: 0, value: Mexp.math.tan },
        { token: "pi", show: "&pi;", type: 3, value: "PI" },
        { token: "(", show: "(", type: 4, value: "(" },
        { token: ")", show: ")", type: 5, value: ")" },
        { token: "P", show: "P", type: 10, value: Mexp.math.P },
        { token: "C", show: "C", type: 10, value: Mexp.math.C },
        { token: " ", show: " ", type: 14, value: " ".anchor },
        { token: "asin", show: "asin", type: 0, value: Mexp.math.asin },
        { token: "acos", show: "acos", type: 0, value: Mexp.math.acos },
        { token: "atan", show: "atan", type: 0, value: Mexp.math.atan },
        { token: "7", show: "7", type: 1, value: "7" },
        { token: "8", show: "8", type: 1, value: "8" },
        { token: "9", show: "9", type: 1, value: "9" },
        { token: "int", show: "Int", type: 0, value: Math.floor },
        { token: "cosh", show: "cosh", type: 0, value: Mexp.math.cosh },
        { token: "acosh", show: "acosh", type: 0, value: Mexp.math.acosh },
        { token: "ln", show: " ln", type: 0, value: Math.log },
        { token: "^", show: "^", type: 10, value: Math.pow },
        { token: "root", show: "root", type: 0, value: Math.sqrt },
        { token: "4", show: "4", type: 1, value: "4" },
        { token: "5", show: "5", type: 1, value: "5" },
        { token: "6", show: "6", type: 1, value: "6" },
        { token: "/", show: "&divide;", type: 2, value: Mexp.math.div },
        { token: "!", show: "!", type: 7, value: Mexp.math.fact },
        { token: "tanh", show: "tanh", type: 0, value: Mexp.math.tanh },
        { token: "atanh", show: "atanh", type: 0, value: Mexp.math.atanh },
        { token: "Mod", show: " Mod ", type: 2, value: Mexp.math.mod },
        { token: "1", show: "1", type: 1, value: "1" },
        { token: "2", show: "2", type: 1, value: "2" },
        { token: "3", show: "3", type: 1, value: "3" },
        { token: "*", show: "&times;", type: 2, value: Mexp.math.mul },
        { token: "sinh", show: "sinh", type: 0, value: Mexp.math.sinh },
        { token: "asinh", show: "asinh", type: 0, value: Mexp.math.asinh },
        { token: "e", show: "e", type: 3, value: "E" },
        { token: "log", show: " log", type: 0, value: Mexp.math.log },
        { token: "0", show: "0", type: 1, value: "0" },
        { token: ".", show: ".", type: 6, value: "." },
        { token: "+", show: "+", type: 9, value: Mexp.math.add },
        { token: "-", show: "-", type: 9, value: Mexp.math.sub },
        { token: ",", show: ",", type: 11, value: "," },
        { token: "Sigma", show: "&Sigma;", type: 12, value: Mexp.math.sigma },
        { token: "n", show: "n", type: 13, value: "n" },
        { token: "Pi", show: "&Pi;", type: 12, value: Mexp.math.Pi },
        { token: "pow", show: "pow", type: 8, value: Math.pow, numberOfArguments: 2 },
        { token: "&", show: "&", type: 9, value: Mexp.math.and }
      ];
      var preced = {
        0: 11,
        1: 0,
        2: 3,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 11,
        8: 11,
        9: 1,
        10: 10,
        11: 0,
        12: 11,
        13: 0,
        14: -1,
        15: 11
        // will be filtered after lexer
      };
      for (i = 0; i < tokens2.length; i++) {
        tokens2[i].precedence = preced[tokens2[i].type];
      }
      var i;
      var type0 = {
        0: true,
        1: true,
        3: true,
        4: true,
        6: true,
        8: true,
        9: true,
        12: true,
        13: true,
        14: true,
        15: true
      };
      var type1 = {
        0: true,
        1: true,
        2: true,
        3: true,
        4: true,
        5: true,
        6: true,
        7: true,
        8: true,
        9: true,
        10: true,
        11: true,
        12: true,
        13: true,
        15: true
      };
      var type1Asterick = {
        0: true,
        3: true,
        4: true,
        8: true,
        12: true,
        13: true,
        15: true
      };
      var empty = {};
      var type3Asterick = {
        0: true,
        1: true,
        3: true,
        4: true,
        6: true,
        8: true,
        12: true,
        13: true,
        15: true
      };
      var type6 = {
        1: true
      };
      var newAr = [
        [],
        [
          "1",
          "2",
          "3",
          "7",
          "8",
          "9",
          "4",
          "5",
          "6",
          "+",
          "-",
          "*",
          "/",
          "(",
          ")",
          "^",
          "!",
          "P",
          "C",
          "e",
          "0",
          ".",
          ",",
          "n",
          " ",
          "&"
        ],
        ["pi", "ln", "Pi"],
        ["sin", "cos", "tan", "Del", "int", "Mod", "log", "pow"],
        ["asin", "acos", "atan", "cosh", "root", "tanh", "sinh"],
        ["acosh", "atanh", "asinh", "Sigma"]
      ];
      function match3(str1, str2, i2, x) {
        for (var f = 0; f < x; f++) {
          if (str1[i2 + f] !== str2[f]) {
            return false;
          }
        }
        return true;
      }
      Mexp.tokenTypes = {
        FUNCTION_WITH_ONE_ARG: 0,
        NUMBER: 1,
        BINARY_OPERATOR_HIGH_PRECENDENCE: 2,
        CONSTANT: 3,
        OPENING_PARENTHESIS: 4,
        CLOSING_PARENTHESIS: 5,
        DECIMAL: 6,
        POSTFIX_FUNCTION_WITH_ONE_ARG: 7,
        FUNCTION_WITH_N_ARGS: 8,
        BINARY_OPERATOR_LOW_PRECENDENCE: 9,
        BINARY_OPERATOR_PERMUTATION: 10,
        COMMA: 11,
        EVALUATED_FUNCTION: 12,
        EVALUATED_FUNCTION_PARAMETER: 13,
        SPACE: 14
      };
      Mexp.addToken = function(newTokens) {
        for (var i2 = 0; i2 < newTokens.length; i2++) {
          var x = newTokens[i2].token.length;
          var temp = -1;
          if (newTokens[i2].type === Mexp.tokenTypes.FUNCTION_WITH_N_ARGS && newTokens[i2].numberOfArguments === void 0) {
            newTokens[i2].numberOfArguments = 2;
          }
          newAr[x] = newAr[x] || [];
          for (var y = 0; y < newAr[x].length; y++) {
            if (newTokens[i2].token === newAr[x][y]) {
              temp = indexOfToken(newAr[x][y], tokens2);
              break;
            }
          }
          if (temp === -1) {
            tokens2.push(newTokens[i2]);
            newTokens[i2].precedence = preced[newTokens[i2].type];
            if (newAr.length <= newTokens[i2].token.length) {
              newAr[newTokens[i2].token.length] = [];
            }
            newAr[newTokens[i2].token.length].push(newTokens[i2].token);
          } else {
            tokens2[temp] = newTokens[i2];
            newTokens[i2].precedence = preced[newTokens[i2].type];
          }
        }
      };
      function indexOfToken(key, tokens3) {
        for (var search = 0; search < tokens3.length; search++) {
          if (tokens3[search].token === key)
            return search;
        }
        return -1;
      }
      function tokenize(string) {
        var nodes = [];
        var length2 = string.length;
        var key, x, y;
        for (var i2 = 0; i2 < length2; i2++) {
          if (i2 < length2 - 1 && string[i2] === " " && string[i2 + 1] === " ") {
            continue;
          }
          key = "";
          for (x = string.length - i2 > newAr.length - 2 ? newAr.length - 1 : string.length - i2; x > 0; x--) {
            if (newAr[x] === void 0)
              continue;
            for (y = 0; y < newAr[x].length; y++) {
              if (match3(string, newAr[x][y], i2, x)) {
                key = newAr[x][y];
                y = newAr[x].length;
                x = 0;
              }
            }
          }
          i2 += key.length - 1;
          if (key === "") {
            throw new Mexp.Exception("Can't understand after " + string.slice(i2));
          }
          nodes.push(tokens2[indexOfToken(key, tokens2)]);
        }
        return nodes;
      }
      var changeSignObj = {
        value: Mexp.math.changeSign,
        type: 0,
        pre: 21,
        show: "-"
      };
      var closingParObj = {
        value: ")",
        show: ")",
        type: 5,
        pre: 0
      };
      var openingParObj = {
        value: "(",
        type: 4,
        pre: 0,
        show: "("
      };
      Mexp.lex = function(inp, tokens3) {
        "use strict";
        var str = [openingParObj];
        var ptc = [];
        var inpStr = inp;
        var allowed = type0;
        var bracToClose = 0;
        var asterick = empty;
        var prevKey = "";
        var i2;
        if (typeof tokens3 !== "undefined") {
          Mexp.addToken(tokens3);
        }
        var obj = {};
        var nodes = tokenize(inpStr);
        for (i2 = 0; i2 < nodes.length; i2++) {
          var node2 = nodes[i2];
          if (node2.type === 14) {
            if (i2 > 0 && i2 < nodes.length - 1 && nodes[i2 + 1].type === 1 && (nodes[i2 - 1].type === 1 || nodes[i2 - 1].type === 6)) {
              throw new Mexp.Exception("Unexpected Space");
            }
            continue;
          }
          var cToken = node2.token;
          var cType = node2.type;
          var cEv = node2.value;
          var cPre = node2.precedence;
          var cShow = node2.show;
          var pre = str[str.length - 1];
          var j;
          for (j = ptc.length; j--; ) {
            if (ptc[j] === 0) {
              if ([0, 2, 3, 4, 5, 9, 11, 12, 13].indexOf(cType) !== -1) {
                if (allowed[cType] !== true) {
                  throw new Mexp.Exception(cToken + " is not allowed after " + prevKey);
                }
                str.push(closingParObj);
                allowed = type1;
                asterick = type3Asterick;
                ptc.pop();
              }
            } else
              break;
          }
          if (allowed[cType] !== true) {
            throw new Mexp.Exception(cToken + " is not allowed after " + prevKey);
          }
          if (asterick[cType] === true) {
            cType = 2;
            cEv = Mexp.math.mul;
            cShow = "&times;";
            cPre = 3;
            i2 = i2 - 1;
          }
          obj = {
            value: cEv,
            type: cType,
            pre: cPre,
            show: cShow,
            numberOfArguments: node2.numberOfArguments
          };
          if (cType === 0) {
            allowed = type0;
            asterick = empty;
            inc(ptc, 2);
            str.push(obj);
            if (nodes[i2 + 1].type !== 4) {
              str.push(openingParObj);
              ptc.push(2);
            }
          } else if (cType === 1) {
            if (pre.type === 1) {
              pre.value += cEv;
              inc(ptc, 1);
            } else {
              str.push(obj);
            }
            allowed = type1;
            asterick = type1Asterick;
          } else if (cType === 2) {
            allowed = type0;
            asterick = empty;
            inc(ptc, 2);
            str.push(obj);
          } else if (cType === 3) {
            str.push(obj);
            allowed = type1;
            asterick = type3Asterick;
          } else if (cType === 4) {
            inc(ptc, 1);
            bracToClose++;
            allowed = type0;
            asterick = empty;
            str.push(obj);
          } else if (cType === 5) {
            if (!bracToClose) {
              throw new Mexp.Exception("Closing parenthesis are more than opening one, wait What!!!");
            }
            bracToClose--;
            allowed = type1;
            asterick = type3Asterick;
            str.push(obj);
            inc(ptc, 1);
          } else if (cType === 6) {
            if (pre.hasDec) {
              throw new Mexp.Exception("Two decimals are not allowed in one number");
            }
            if (pre.type !== 1) {
              pre = {
                value: 0,
                type: 1,
                pre: 0
              };
              str.push(pre);
            }
            allowed = type6;
            inc(ptc, 1);
            asterick = empty;
            pre.value += cEv;
            pre.hasDec = true;
          } else if (cType === 7) {
            allowed = type1;
            asterick = type3Asterick;
            inc(ptc, 1);
            str.push(obj);
          }
          if (cType === 8) {
            allowed = type0;
            asterick = empty;
            inc(ptc, node2.numberOfArguments + 2);
            str.push(obj);
            if (nodes[i2 + 1].type !== 4) {
              str.push(openingParObj);
              ptc.push(node2.numberOfArguments + 2);
            }
          } else if (cType === 9) {
            if (pre.type === 9) {
              if (pre.value === Mexp.math.add) {
                pre.value = cEv;
                pre.show = cShow;
                inc(ptc, 1);
              } else if (pre.value === Mexp.math.sub && cShow === "-") {
                pre.value = Mexp.math.add;
                pre.show = "+";
                inc(ptc, 1);
              }
            } else if (pre.type !== 5 && pre.type !== 7 && pre.type !== 1 && pre.type !== 3 && pre.type !== 13) {
              if (cToken === "-") {
                allowed = type0;
                asterick = empty;
                inc(ptc, 2).push(2);
                str.push(changeSignObj);
                str.push(openingParObj);
              }
            } else {
              str.push(obj);
              inc(ptc, 2);
            }
            allowed = type0;
            asterick = empty;
          } else if (cType === 10) {
            allowed = type0;
            asterick = empty;
            inc(ptc, 2);
            str.push(obj);
          } else if (cType === 11) {
            allowed = type0;
            asterick = empty;
            str.push(obj);
          } else if (cType === 12) {
            allowed = type0;
            asterick = empty;
            inc(ptc, 6);
            str.push(obj);
            if (nodes[i2 + 1].type !== 4) {
              str.push(openingParObj);
              ptc.push(6);
            }
          } else if (cType === 13) {
            allowed = type1;
            asterick = type3Asterick;
            str.push(obj);
          }
          inc(ptc, -1);
          prevKey = cToken;
        }
        for (j = ptc.length; j--; ) {
          str.push(closingParObj);
        }
        if (allowed[5] !== true) {
          throw new Mexp.Exception("complete the expression");
        }
        while (bracToClose--) {
          str.push(closingParObj);
        }
        str.push(closingParObj);
        return new Mexp(str);
      };
      module2.exports = Mexp;
    }
  });

  // node_modules/math-expression-evaluator/src/postfix.js
  var require_postfix = __commonJS({
    "node_modules/math-expression-evaluator/src/postfix.js"(exports, module2) {
      var Mexp = require_lexer();
      Mexp.prototype.toPostfix = function() {
        "use strict";
        var post = [], elem, popped, prep, pre, ele;
        var stack = [{ value: "(", type: 4, pre: 0 }];
        var arr = this.value;
        for (var i = 1; i < arr.length; i++) {
          if (arr[i].type === 1 || arr[i].type === 3 || arr[i].type === 13) {
            if (arr[i].type === 1)
              arr[i].value = Number(arr[i].value);
            post.push(arr[i]);
          } else if (arr[i].type === 4) {
            stack.push(arr[i]);
          } else if (arr[i].type === 5) {
            while ((popped = stack.pop()).type !== 4) {
              post.push(popped);
            }
          } else if (arr[i].type === 11) {
            while ((popped = stack.pop()).type !== 4) {
              post.push(popped);
            }
            stack.push(popped);
          } else {
            elem = arr[i];
            pre = elem.pre;
            ele = stack[stack.length - 1];
            prep = ele.pre;
            var flag = ele.value == "Math.pow" && elem.value == "Math.pow";
            if (pre > prep)
              stack.push(elem);
            else {
              while (prep >= pre && !flag || flag && pre < prep) {
                popped = stack.pop();
                ele = stack[stack.length - 1];
                post.push(popped);
                prep = ele.pre;
                flag = elem.value == "Math.pow" && ele.value == "Math.pow";
              }
              stack.push(elem);
            }
          }
        }
        return new Mexp(post);
      };
      module2.exports = Mexp;
    }
  });

  // node_modules/math-expression-evaluator/src/postfix_evaluator.js
  var require_postfix_evaluator = __commonJS({
    "node_modules/math-expression-evaluator/src/postfix_evaluator.js"(exports, module2) {
      var Mexp = require_postfix();
      Mexp.prototype.postfixEval = function(UserDefined) {
        "use strict";
        UserDefined = UserDefined || {};
        UserDefined.PI = Math.PI;
        UserDefined.E = Math.E;
        var stack = [], pop1, pop2, pop3;
        var disp = [];
        var temp = "";
        var arr = this.value;
        var bool = typeof UserDefined.n !== "undefined";
        for (var i = 0; i < arr.length; i++) {
          if (arr[i].type === 1) {
            stack.push({ value: arr[i].value, type: 1 });
          } else if (arr[i].type === 3) {
            stack.push({ value: UserDefined[arr[i].value], type: 1 });
          } else if (arr[i].type === 0) {
            if (typeof stack[stack.length - 1].type === "undefined") {
              stack[stack.length - 1].value.push(arr[i]);
            } else
              stack[stack.length - 1].value = arr[i].value(stack[stack.length - 1].value);
          } else if (arr[i].type === 7) {
            if (typeof stack[stack.length - 1].type === "undefined") {
              stack[stack.length - 1].value.push(arr[i]);
            } else
              stack[stack.length - 1].value = arr[i].value(stack[stack.length - 1].value);
          } else if (arr[i].type === 8) {
            var popped = [];
            for (var x = 0; x < arr[i].numberOfArguments; x++) {
              popped.push(stack.pop().value);
            }
            stack.push({ type: 1, value: arr[i].value.apply(arr[i], popped.reverse()) });
          } else if (arr[i].type === 10) {
            pop1 = stack.pop();
            pop2 = stack.pop();
            if (typeof pop2.type === "undefined") {
              pop2.value = pop2.concat(pop1);
              pop2.value.push(arr[i]);
              stack.push(pop2);
            } else if (typeof pop1.type === "undefined") {
              pop1.unshift(pop2);
              pop1.push(arr[i]);
              stack.push(pop1);
            } else {
              stack.push({ type: 1, value: arr[i].value(pop2.value, pop1.value) });
            }
          } else if (arr[i].type === 2 || arr[i].type === 9) {
            pop1 = stack.pop();
            pop2 = stack.pop();
            if (typeof pop2.type === "undefined") {
              pop2 = pop2.concat(pop1);
              pop2.push(arr[i]);
              stack.push(pop2);
            } else if (typeof pop1.type === "undefined") {
              pop1.unshift(pop2);
              pop1.push(arr[i]);
              stack.push(pop1);
            } else {
              stack.push({ type: 1, value: arr[i].value(pop2.value, pop1.value) });
            }
          } else if (arr[i].type === 12) {
            pop1 = stack.pop();
            if (typeof pop1.type !== "undefined") {
              pop1 = [pop1];
            }
            pop2 = stack.pop();
            pop3 = stack.pop();
            stack.push({ type: 1, value: arr[i].value(pop3.value, pop2.value, new Mexp(pop1)) });
          } else if (arr[i].type === 13) {
            if (bool) {
              stack.push({ value: UserDefined[arr[i].value], type: 3 });
            } else
              stack.push([arr[i]]);
          }
        }
        if (stack.length > 1) {
          throw new Mexp.Exception("Uncaught Syntax error");
        }
        return stack[0].value > 1e15 ? "Infinity" : parseFloat(stack[0].value.toFixed(15));
      };
      Mexp.eval = function(str, tokens2, obj) {
        if (typeof tokens2 === "undefined") {
          return this.lex(str).toPostfix().postfixEval();
        } else if (typeof obj === "undefined") {
          if (typeof tokens2.length !== "undefined")
            return this.lex(str, tokens2).toPostfix().postfixEval();
          else
            return this.lex(str).toPostfix().postfixEval(tokens2);
        } else
          return this.lex(str, tokens2).toPostfix().postfixEval(obj);
      };
      module2.exports = Mexp;
    }
  });

  // node_modules/math-expression-evaluator/src/formula_evaluator.js
  var require_formula_evaluator = __commonJS({
    "node_modules/math-expression-evaluator/src/formula_evaluator.js"(exports, module2) {
      var Mexp = require_postfix_evaluator();
      Mexp.prototype.formulaEval = function() {
        "use strict";
        var stack = [], pop1, pop2, pop3;
        var disp = [];
        var temp = "";
        var arr = this.value;
        for (var i = 0; i < arr.length; i++) {
          if (arr[i].type === 1 || arr[i].type === 3) {
            disp.push({ value: arr[i].type === 3 ? arr[i].show : arr[i].value, type: 1 });
          } else if (arr[i].type === 13) {
            disp.push({ value: arr[i].show, type: 1 });
          } else if (arr[i].type === 0) {
            disp[disp.length - 1] = { value: arr[i].show + (arr[i].show != "-" ? "(" : "") + disp[disp.length - 1].value + (arr[i].show != "-" ? ")" : ""), type: 0 };
          } else if (arr[i].type === 7) {
            disp[disp.length - 1] = { value: (disp[disp.length - 1].type != 1 ? "(" : "") + disp[disp.length - 1].value + (disp[disp.length - 1].type != 1 ? ")" : "") + arr[i].show, type: 7 };
          } else if (arr[i].type === 10) {
            pop1 = disp.pop();
            pop2 = disp.pop();
            if (arr[i].show === "P" || arr[i].show === "C")
              disp.push({ value: "<sup>" + pop2.value + "</sup>" + arr[i].show + "<sub>" + pop1.value + "</sub>", type: 10 });
            else
              disp.push({ value: (pop2.type != 1 ? "(" : "") + pop2.value + (pop2.type != 1 ? ")" : "") + "<sup>" + pop1.value + "</sup>", type: 1 });
          } else if (arr[i].type === 2 || arr[i].type === 9) {
            pop1 = disp.pop();
            pop2 = disp.pop();
            disp.push({ value: (pop2.type != 1 ? "(" : "") + pop2.value + (pop2.type != 1 ? ")" : "") + arr[i].show + (pop1.type != 1 ? "(" : "") + pop1.value + (pop1.type != 1 ? ")" : ""), type: arr[i].type });
          } else if (arr[i].type === 12) {
            pop1 = disp.pop();
            pop2 = disp.pop();
            pop3 = disp.pop();
            disp.push({ value: arr[i].show + "(" + pop3.value + "," + pop2.value + "," + pop1.value + ")", type: 12 });
          }
        }
        return disp[0].value;
      };
      module2.exports = Mexp;
    }
  });

  // node_modules/reduce-css-calc/index.js
  var require_reduce_css_calc = __commonJS({
    "node_modules/reduce-css-calc/index.js"(exports, module2) {
      var balanced = require_balanced_match();
      var reduceFunctionCall = require_reduce_function_call();
      var mexp = require_formula_evaluator();
      var MAX_STACK = 100;
      var NESTED_CALC_RE = /(\+|\-|\*|\\|[^a-z]|)(\s*)(\()/g;
      var stack;
      module2.exports = reduceCSSCalc2;
      function reduceCSSCalc2(value, decimalPrecision) {
        stack = 0;
        decimalPrecision = Math.pow(10, decimalPrecision === void 0 ? 5 : decimalPrecision);
        value = value.replace(/\n+/g, " ");
        function evaluateExpression(expression, functionIdentifier, call) {
          if (stack++ > MAX_STACK) {
            stack = 0;
            throw new Error("Call stack overflow for " + call);
          }
          if (expression === "") {
            throw new Error(functionIdentifier + "(): '" + call + "' must contain a non-whitespace string");
          }
          expression = evaluateNestedExpression(expression, call);
          var units = getUnitsInExpression(expression);
          if (units.length > 1 || expression.indexOf("var(") > -1) {
            return functionIdentifier + "(" + expression + ")";
          }
          var unit2 = units[0] || "";
          if (unit2 === "%") {
            expression = expression.replace(/\b[0-9\.]+%/g, function(percent2) {
              return parseFloat(percent2.slice(0, -1)) * 0.01;
            });
          }
          var toEvaluate = expression.replace(new RegExp(unit2, "gi"), "");
          var result;
          try {
            result = mexp.eval(toEvaluate);
          } catch (e3) {
            return functionIdentifier + "(" + expression + ")";
          }
          if (unit2 === "%") {
            result *= 100;
          }
          if (functionIdentifier.length || unit2 === "%") {
            result = Math.round(result * decimalPrecision) / decimalPrecision;
          }
          result += unit2;
          return result;
        }
        function evaluateNestedExpression(expression, call) {
          expression = expression.replace(/((?:\-[a-z]+\-)?calc)/g, "");
          var evaluatedPart = "";
          var nonEvaluatedPart = expression;
          var matches;
          while (matches = NESTED_CALC_RE.exec(nonEvaluatedPart)) {
            if (matches[0].index > 0) {
              evaluatedPart += nonEvaluatedPart.substring(0, matches[0].index);
            }
            var balancedExpr = balanced("(", ")", nonEvaluatedPart.substring([0].index));
            if (balancedExpr.body === "") {
              throw new Error("'" + expression + "' must contain a non-whitespace string");
            }
            var evaluated = evaluateExpression(balancedExpr.body, "", call);
            evaluatedPart += balancedExpr.pre + evaluated;
            nonEvaluatedPart = balancedExpr.post;
          }
          return evaluatedPart + nonEvaluatedPart;
        }
        return reduceFunctionCall(value, /((?:\-[a-z]+\-)?calc)\(/, evaluateExpression);
      }
      function getUnitsInExpression(expression) {
        var uniqueUnits = [];
        var uniqueLowerCaseUnits = [];
        var unitRegEx = /[\.0-9]([%a-z]+)/gi;
        var matches = unitRegEx.exec(expression);
        while (matches) {
          if (!matches || !matches[1]) {
            continue;
          }
          if (uniqueLowerCaseUnits.indexOf(matches[1].toLowerCase()) === -1) {
            uniqueUnits.push(matches[1]);
            uniqueLowerCaseUnits.push(matches[1].toLowerCase());
          }
          matches = unitRegEx.exec(expression);
        }
        return uniqueUnits;
      }
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module2) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module2.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module2) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module2.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module2) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module2.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e3) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module2.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module2) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      module2.exports = objectToString2;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString2 = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
      }
      module2.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module2) {
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module2.exports = isObject2;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports, module2) {
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction5(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module2.exports = isFunction5;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports, module2) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module2.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports, module2) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module2.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports, module2) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      module2.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports, module2) {
      var isFunction5 = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction5(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module2.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports, module2) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module2.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports, module2) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module2.exports = getNative;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports, module2) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module2.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module2.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports, module2) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      module2.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      module2.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module2.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports, module2) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module2.exports = Hash;
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports, module2) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module2.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports, module2) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module2.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports, module2) {
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length2 = array.length;
        while (length2--) {
          if (eq(array[length2][0], key)) {
            return length2;
          }
        }
        return -1;
      }
      module2.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module2.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module2.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module2.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module2.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports, module2) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module2.exports = ListCache;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module2.exports = Map2;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports, module2) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module2.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports, module2) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module2.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports, module2) {
      var isKeyable = require_isKeyable();
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module2.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module2.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module2.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      module2.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports, module2) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module2.exports = MapCache;
    }
  });

  // node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/lodash/memoize.js"(exports, module2) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize5(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize5.Cache || MapCache)();
        return memoized;
      }
      memoize5.Cache = MapCache;
      module2.exports = memoize5;
    }
  });

  // node_modules/@visx/shape/lib/shapes/Line.js
  var require_Line = __commonJS({
    "node_modules/@visx/shape/lib/shapes/Line.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.default = Line3;
      var _react = _interopRequireDefault(require_react());
      var _classnames = _interopRequireDefault(require_classnames());
      var _excluded19 = ["from", "to", "fill", "className", "innerRef"];
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _extends27() {
        _extends27 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends27.apply(this, arguments);
      }
      function _objectWithoutPropertiesLoose19(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function Line3(_ref) {
        var _ref$from = _ref.from, from2 = _ref$from === void 0 ? {
          x: 0,
          y: 0
        } : _ref$from, _ref$to = _ref.to, to = _ref$to === void 0 ? {
          x: 1,
          y: 1
        } : _ref$to, _ref$fill = _ref.fill, fill2 = _ref$fill === void 0 ? "transparent" : _ref$fill, className = _ref.className, innerRef = _ref.innerRef, restProps = _objectWithoutPropertiesLoose19(_ref, _excluded19);
        var isRectilinear = from2.x === to.x || from2.y === to.y;
        return /* @__PURE__ */ _react.default.createElement("line", _extends27({
          ref: innerRef,
          className: (0, _classnames.default)("visx-line", className),
          x1: from2.x,
          y1: from2.y,
          x2: to.x,
          y2: to.y,
          fill: fill2,
          shapeRendering: isRectilinear ? "crispEdges" : "auto"
        }, restProps));
      }
    }
  });

  // node_modules/debounce/index.js
  var require_debounce = __commonJS({
    "node_modules/debounce/index.js"(exports, module2) {
      function debounce3(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        if (null == wait)
          wait = 100;
        function later() {
          var last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              context = args = null;
            }
          }
        }
        ;
        var debounced = function() {
          context = this;
          args = arguments;
          timestamp = Date.now();
          var callNow = immediate && !timeout;
          if (!timeout)
            timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
          return result;
        };
        debounced.clear = function() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
        };
        debounced.flush = function() {
          if (timeout) {
            result = func.apply(context, args);
            context = args = null;
            clearTimeout(timeout);
            timeout = null;
          }
        };
        return debounced;
      }
      debounce3.debounce = debounce3;
      module2.exports = debounce3;
    }
  });

  // src/app/app.tsx
  var import_client2 = __toESM(require_client());
  var import_react130 = __toESM(require_react());

  // node_modules/@emotion/react/dist/emotion-element-43c6fea0.browser.esm.js
  var React2 = __toESM(require_react());
  var import_react = __toESM(require_react());

  // node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? false : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (true) {
        var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
        if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
          console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
        }
        this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
      }
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e3) {
          if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
            console.error('There was a problem inserting the following rule: "' + rule + '"', e3);
          }
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush2() {
      this.tags.forEach(function(tag) {
        return tag.parentNode && tag.parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
      if (true) {
        this._alreadyInsertedOrderInsensitiveRule = false;
      }
    };
    return StyleSheet2;
  }();

  // node_modules/stylis/src/Enum.js
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";

  // node_modules/stylis/src/Utility.js
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end2) {
    return value.slice(begin, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }

  // node_modules/stylis/src/Tokenizer.js
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root, parent, type, props, children, length2) {
    return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root, props) {
    return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end2) {
    return substr(characters, begin, end2);
  }
  function token(type) {
    switch (type) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        case type:
          return position;
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek()))
      next();
    return slice(index, position);
  }

  // node_modules/stylis/src/Parser.js
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset3 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference2 = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            case 0:
            case 125:
              scanning = 0;
            case 59 + offset3:
              if (ampersand == -1)
                characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            case 59:
              characters2 += ";";
            default:
              append(reference2 = ruleset(characters2, root, parent, index, offset3, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset3 === 0)
                  parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                  }
          }
          index = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            case 38:
              ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index, offset3, rules, points, type, props, children, length2) {
    var post = offset3 - 1;
    var rule = offset3 === 0 ? rules : [""];
    var size2 = sizeof(rule);
    for (var i = 0, j = 0, k = 0; i < index; ++i)
      for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size2; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node(value, root, parent, offset3 === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root, parent) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root, parent, length2) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }

  // node_modules/stylis/src/Serializer.js
  function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length)
          break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }

  // node_modules/stylis/src/Middleware.js
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection[i](element, index, children, callback) || "";
      return output;
    };
  }

  // node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
  var weakMemoize = function weakMemoize2(func) {
    var cache = /* @__PURE__ */ new WeakMap();
    return function(arg) {
      if (cache.has(arg)) {
        return cache.get(arg);
      }
      var ret = func(arg);
      cache.set(arg, ret);
      return ret;
    };
  };

  // node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
  function memoize(fn2) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache[arg] === void 0)
        cache[arg] = fn2(arg);
      return cache[arg];
    };
  }

  // node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index] = 1;
          }
          parsed[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }
        default:
          parsed[index] += from(character2);
      }
    } while (character2 = next());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value, parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent)
        return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
  var isIgnoringComment = function isIgnoringComment2(element) {
    return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
  };
  var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
    return function(element, index, children) {
      if (element.type !== "rule" || cache.compat)
        return;
      var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
      if (unsafePseudoClasses) {
        var isNested = !!element.parent;
        var commentContainer = isNested ? element.parent.children : (
          // global rule at the root level
          children
        );
        for (var i = commentContainer.length - 1; i >= 0; i--) {
          var node2 = commentContainer[i];
          if (node2.line < element.line) {
            break;
          }
          if (node2.column < element.column) {
            if (isIgnoringComment(node2)) {
              return;
            }
            break;
          }
        }
        unsafePseudoClasses.forEach(function(unsafePseudoClass) {
          console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
        });
      }
    };
  };
  var isImportRule = function isImportRule2(element) {
    return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
  };
  var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
    for (var i = index - 1; i >= 0; i--) {
      if (!isImportRule(children[i])) {
        return true;
      }
    }
    return false;
  };
  var nullifyElement = function nullifyElement2(element) {
    element.type = "";
    element.value = "";
    element["return"] = "";
    element.children = "";
    element.props = "";
  };
  var incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
    if (!isImportRule(element)) {
      return;
    }
    if (element.parent) {
      console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
      nullifyElement(element);
    } else if (isPrependedWithRegularRules(index, children)) {
      console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
      nullifyElement(element);
    }
  };
  function prefix(value, length2) {
    switch (hash(value, length2)) {
      case 5103:
        return WEBKIT + "print-" + value + value;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
      case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
      case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
      case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6)
          switch (charat(value, length2 + 1)) {
            case 109:
              if (charat(value, length2 + 4) !== 45)
                break;
            case 102:
              return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
            case 115:
              return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
          }
        break;
      case 4949:
        if (charat(value, length2 + 1) !== 115)
          break;
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      case 5936:
        switch (charat(value, length2 + 11)) {
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"])
        switch (element.type) {
          case DECLARATION:
            element["return"] = prefix(element.value, element.length);
            break;
          case KEYFRAMES:
            return serialize([copy(element, {
              value: replace(element.value, "@", "@" + WEBKIT)
            })], callback);
          case RULESET:
            if (element.length)
              return combine(element.props, function(value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  case ":read-only":
                  case ":read-write":
                    return serialize([copy(element, {
                      props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                    })], callback);
                  case "::placeholder":
                    return serialize([copy(element, {
                      props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                    })], callback);
                }
                return "";
              });
        }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options) {
    var key = options.key;
    if (!key) {
      throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
    }
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    if (true) {
      if (/[^a-z-]/.test(key)) {
        throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
      }
    }
    var inserted = {};
    var container2;
    var nodesToHydrate = [];
    {
      container2 = options.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    if (true) {
      omnipresentPlugins.push(createUnsafeSelectorsAlarm({
        get compat() {
          return cache.compat;
        }
      }), incorrectImportAlarm);
    }
    {
      var currentSheet;
      var finalizingPlugins = [stringify, true ? function(element) {
        if (!element.root) {
          if (element["return"]) {
            currentSheet.insert(element["return"]);
          } else if (element.value && element.type !== COMMENT) {
            currentSheet.insert(element.value + "{}");
          }
        }
      } : rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles2) {
        return serialize(compile(styles2), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        if (serialized.map !== void 0) {
          currentSheet = {
            insert: function insert2(rule) {
              sheet.insert(rule + serialized.map);
            }
          };
        }
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache.inserted[serialized.name] = true;
        }
      };
    }
    var cache = {
      key,
      sheet: new StyleSheet({
        key,
        container: container2,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
  };

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
  var isBrowser = true;
  function getRegisteredStyles(registered, registeredStyles, classNames2) {
    var rawClassName = "";
    classNames2.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser === false) && cache.registered[className] === void 0
    ) {
      cache.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
    registerStyles(cache, serialized, isStringTag);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };

  // node_modules/@emotion/hash/dist/emotion-hash.esm.js
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }

  // node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  // node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
  var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
  var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match3, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  if (true) {
    contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    contentValues = ["normal", "none", "initial", "inherit", "unset"];
    oldProcessStyleValue = processStyleValue;
    msPattern = /^-ms-/;
    hyphenPattern = /-(.)/g;
    hyphenatedCache = {};
    processStyleValue = function processStyleValue3(key, value) {
      if (key === "content") {
        if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
          throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
        }
      }
      var processed = oldProcessStyleValue(key, value);
      if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
        hyphenatedCache[key] = true;
        console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
          return _char.toUpperCase();
        }) + "?");
      }
      return processed;
    };
  }
  var contentValuePattern;
  var contentValues;
  var oldProcessStyleValue;
  var msPattern;
  var hyphenPattern;
  var hyphenatedCache;
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    if (interpolation.__emotion_styles !== void 0) {
      if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
        throw new Error(noComponentSelectorMessage);
      }
      return interpolation;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }
        if (interpolation.styles !== void 0) {
          var next2 = interpolation.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles2 = interpolation.styles + ";";
          if (interpolation.map !== void 0) {
            styles2 += interpolation.map;
          }
          return styles2;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (true) {
          console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
        }
        break;
      }
      case "string":
        if (true) {
          var matched = [];
          var replaced = interpolation.replace(animationRegex, function(match3, p1, p2) {
            var fakeVarName = "animation" + matched.length;
            matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
            return "${" + fakeVarName + "}";
          });
          if (matched.length) {
            console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
          }
        }
        break;
    }
    if (registered == null) {
      return interpolation;
    }
    var cached = registered[interpolation];
    return cached !== void 0 ? cached : interpolation;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var _key in obj) {
        var value = obj[_key];
        if (typeof value !== "object") {
          if (registered != null && registered[value] !== void 0) {
            string += _key + "{" + registered[value] + "}";
          } else if (isProcessableValue(value)) {
            string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
          }
        } else {
          if (_key === "NO_COMPONENT_SELECTOR" && true) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (_key) {
              case "animation":
              case "animationName": {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }
              default: {
                if (_key === "undefined") {
                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                }
                string += _key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
  var sourceMapPattern;
  if (true) {
    sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
  }
  var cursor;
  var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles2 = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles2 += handleInterpolation(mergedProps, registered, strings);
    } else {
      if (strings[0] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles2 += strings[0];
    }
    for (var i = 1; i < args.length; i++) {
      styles2 += handleInterpolation(mergedProps, registered, args[i]);
      if (stringMode) {
        if (strings[i] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }
        styles2 += strings[i];
      }
    }
    var sourceMap;
    if (true) {
      styles2 = styles2.replace(sourceMapPattern, function(match4) {
        sourceMap = match4;
        return "";
      });
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match3;
    while ((match3 = labelPattern.exec(styles2)) !== null) {
      identifierName += "-" + // $FlowFixMe we know it's not null
      match3[1];
    }
    var name = murmur2(styles2) + identifierName;
    if (true) {
      return {
        name,
        styles: styles2,
        map: sourceMap,
        next: cursor,
        toString: function toString2() {
          return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
        }
      };
    }
    return {
      name,
      styles: styles2,
      next: cursor
    };
  };

  // node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
  var React = __toESM(require_react());
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
  var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;

  // node_modules/@emotion/react/dist/emotion-element-43c6fea0.browser.esm.js
  var isBrowser2 = true;
  var hasOwn = {}.hasOwnProperty;
  var EmotionCacheContext = /* @__PURE__ */ React2.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
      key: "css"
    }) : null
  );
  if (true) {
    EmotionCacheContext.displayName = "EmotionCacheContext";
  }
  var CacheProvider = EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
      var cache = (0, import_react.useContext)(EmotionCacheContext);
      return func(props, cache, ref);
    });
  };
  if (!isBrowser2) {
    withEmotionCache = function withEmotionCache3(func) {
      return function(props) {
        var cache = (0, import_react.useContext)(EmotionCacheContext);
        if (cache === null) {
          cache = createCache({
            key: "css"
          });
          return /* @__PURE__ */ React2.createElement(EmotionCacheContext.Provider, {
            value: cache
          }, func(props, cache));
        } else {
          return func(props, cache);
        }
      };
    };
  }
  var ThemeContext = /* @__PURE__ */ React2.createContext({});
  if (true) {
    ThemeContext.displayName = "EmotionThemeContext";
  }
  var getTheme = function getTheme2(outerTheme, theme3) {
    if (typeof theme3 === "function") {
      var mergedTheme = theme3(outerTheme);
      if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
        throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
      }
      return mergedTheme;
    }
    if (theme3 == null || typeof theme3 !== "object" || Array.isArray(theme3)) {
      throw new Error("[ThemeProvider] Please make your theme prop a plain object");
    }
    return _extends({}, outerTheme, theme3);
  };
  var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
    return weakMemoize(function(theme3) {
      return getTheme(outerTheme, theme3);
    });
  });
  var ThemeProvider = function ThemeProvider2(props) {
    var theme3 = React2.useContext(ThemeContext);
    if (props.theme !== theme3) {
      theme3 = createCacheWithTheme(theme3)(props.theme);
    }
    return /* @__PURE__ */ React2.createElement(ThemeContext.Provider, {
      value: theme3
    }, props.children);
  };
  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
  var Insertion = function Insertion2(_ref) {
    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache, serialized, isStringTag);
    });
    return null;
  };
  var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
      cssProp = cache.registered[cssProp];
    }
    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
    if (serialized.name.indexOf("-") === -1) {
      var labelFromStack = props[labelPropName];
      if (labelFromStack) {
        serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
      }
    }
    className += cache.key + "-" + serialized.name;
    var newProps = {};
    for (var key in props) {
      if (hasOwn.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
        newProps[key] = props[key];
      }
    }
    newProps.ref = ref;
    newProps.className = className;
    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(Insertion, {
      cache,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), /* @__PURE__ */ React2.createElement(WrappedComponent, newProps));
  });
  if (true) {
    Emotion.displayName = "EmotionCssPropInternal";
  }

  // node_modules/@emotion/react/dist/emotion-react.browser.esm.js
  var React3 = __toESM(require_react());
  var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
  var pkg = {
    name: "@emotion/react",
    version: "11.11.4",
    main: "dist/emotion-react.cjs.js",
    module: "dist/emotion-react.esm.js",
    browser: {
      "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
    },
    exports: {
      ".": {
        module: {
          worker: "./dist/emotion-react.worker.esm.js",
          browser: "./dist/emotion-react.browser.esm.js",
          "default": "./dist/emotion-react.esm.js"
        },
        "import": "./dist/emotion-react.cjs.mjs",
        "default": "./dist/emotion-react.cjs.js"
      },
      "./jsx-runtime": {
        module: {
          worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
          browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
        },
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
      },
      "./_isolated-hnrs": {
        module: {
          worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
          browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
        },
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
      },
      "./jsx-dev-runtime": {
        module: {
          worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
          browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
        },
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
      },
      "./package.json": "./package.json",
      "./types/css-prop": "./types/css-prop.d.ts",
      "./macro": {
        types: {
          "import": "./macro.d.mts",
          "default": "./macro.d.ts"
        },
        "default": "./macro.js"
      }
    },
    types: "types/index.d.ts",
    files: [
      "src",
      "dist",
      "jsx-runtime",
      "jsx-dev-runtime",
      "_isolated-hnrs",
      "types/*.d.ts",
      "macro.*"
    ],
    sideEffects: false,
    author: "Emotion Contributors",
    license: "MIT",
    scripts: {
      "test:typescript": "dtslint types"
    },
    dependencies: {
      "@babel/runtime": "^7.18.3",
      "@emotion/babel-plugin": "^11.11.0",
      "@emotion/cache": "^11.11.0",
      "@emotion/serialize": "^1.1.3",
      "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
      "@emotion/utils": "^1.2.1",
      "@emotion/weak-memoize": "^0.3.1",
      "hoist-non-react-statics": "^3.3.1"
    },
    peerDependencies: {
      react: ">=16.8.0"
    },
    peerDependenciesMeta: {
      "@types/react": {
        optional: true
      }
    },
    devDependencies: {
      "@definitelytyped/dtslint": "0.0.112",
      "@emotion/css": "11.11.2",
      "@emotion/css-prettifier": "1.1.3",
      "@emotion/server": "11.11.0",
      "@emotion/styled": "11.11.0",
      "html-tag-names": "^1.1.2",
      react: "16.14.0",
      "svg-tag-names": "^1.1.1",
      typescript: "^4.5.5"
    },
    repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
    publishConfig: {
      access: "public"
    },
    "umd:main": "dist/emotion-react.umd.min.js",
    preconstruct: {
      entrypoints: [
        "./index.js",
        "./jsx-runtime.js",
        "./jsx-dev-runtime.js",
        "./_isolated-hnrs.js"
      ],
      umdName: "emotionReact",
      exports: {
        envConditions: [
          "browser",
          "worker"
        ],
        extra: {
          "./types/css-prop": "./types/css-prop.d.ts",
          "./macro": {
            types: {
              "import": "./macro.d.mts",
              "default": "./macro.d.ts"
            },
            "default": "./macro.js"
          }
        }
      }
    }
  };
  var warnedAboutCssPropForGlobal = false;
  var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
    if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
    // probably using the custom createElement which
    // means it will be turned into a className prop
    // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
    (props.className || props.css)) {
      console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
      warnedAboutCssPropForGlobal = true;
    }
    var styles2 = props.styles;
    var serialized = serializeStyles([styles2], void 0, React3.useContext(ThemeContext));
    if (!isBrowser2) {
      var _ref;
      var serializedNames = serialized.name;
      var serializedStyles = serialized.styles;
      var next2 = serialized.next;
      while (next2 !== void 0) {
        serializedNames += " " + next2.name;
        serializedStyles += next2.styles;
        next2 = next2.next;
      }
      var shouldCache = cache.compat === true;
      var rules = cache.insert("", {
        name: serializedNames,
        styles: serializedStyles
      }, cache.sheet, shouldCache);
      if (shouldCache) {
        return null;
      }
      return /* @__PURE__ */ React3.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
        __html: rules
      }, _ref.nonce = cache.sheet.nonce, _ref));
    }
    var sheetRef = React3.useRef();
    useInsertionEffectWithLayoutFallback(function() {
      var key = cache.key + "-global";
      var sheet = new cache.sheet.constructor({
        key,
        nonce: cache.sheet.nonce,
        container: cache.sheet.container,
        speedy: cache.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache.sheet.tags.length) {
        sheet.before = cache.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache]);
    useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache.insert("", serialized, sheet, false);
    }, [cache, serialized.name]);
    return null;
  });
  if (true) {
    Global.displayName = "EmotionGlobal";
  }
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  var keyframes = function keyframes2() {
    var insertable = css.apply(void 0, arguments);
    var name = "animation-" + insertable.name;
    return {
      name,
      styles: "@keyframes " + name + "{" + insertable.styles + "}",
      anim: 1,
      toString: function toString2() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  };
  var classnames = function classnames2(args) {
    var len = args.length;
    var i = 0;
    var cls = "";
    for (; i < len; i++) {
      var arg = args[i];
      if (arg == null)
        continue;
      var toAdd = void 0;
      switch (typeof arg) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(arg)) {
            toAdd = classnames2(arg);
          } else {
            if (arg.styles !== void 0 && arg.name !== void 0) {
              console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
            }
            toAdd = "";
            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += " ");
                toAdd += k;
              }
            }
          }
          break;
        }
        default: {
          toAdd = arg;
        }
      }
      if (toAdd) {
        cls && (cls += " ");
        cls += toAdd;
      }
    }
    return cls;
  };
  function merge(registered, css4, className) {
    var registeredStyles = [];
    var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css4(registeredStyles);
  }
  var Insertion3 = function Insertion4(_ref) {
    var cache = _ref.cache, serializedArr = _ref.serializedArr;
    useInsertionEffectAlwaysWithSyncFallback(function() {
      for (var i = 0; i < serializedArr.length; i++) {
        insertStyles(cache, serializedArr[i], false);
      }
    });
    return null;
  };
  var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache) {
    var hasRendered = false;
    var serializedArr = [];
    var css4 = function css5() {
      if (hasRendered && true) {
        throw new Error("css can only be used during render");
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var serialized = serializeStyles(args, cache.registered);
      serializedArr.push(serialized);
      registerStyles(cache, serialized, false);
      return cache.key + "-" + serialized.name;
    };
    var cx17 = function cx18() {
      if (hasRendered && true) {
        throw new Error("cx can only be used during render");
      }
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return merge(cache.registered, css4, classnames(args));
    };
    var content = {
      css: css4,
      cx: cx17,
      theme: React3.useContext(ThemeContext)
    };
    var ele = props.children(content);
    hasRendered = true;
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(Insertion3, {
      cache,
      serializedArr
    }), ele);
  });
  if (true) {
    ClassNames.displayName = "EmotionClassNames";
  }
  if (true) {
    isBrowser6 = true;
    isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
    if (isBrowser6 && !isTestEnv) {
      globalContext = // $FlowIgnore
      typeof globalThis !== "undefined" ? globalThis : isBrowser6 ? window : global;
      globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
      if (globalContext[globalKey]) {
        console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
      }
      globalContext[globalKey] = true;
    }
  }
  var isBrowser6;
  var isTestEnv;
  var globalContext;
  var globalKey;

  // node_modules/@chakra-ui/css-reset/dist/chunk-B4LBJQ3X.mjs
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
  var css2 = String.raw;
  var vhPolyfill = css2`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`;
  var CSSPolyfill = () => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Global, { styles: vhPolyfill });
  var CSSReset = ({ scope = "" }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    Global,
    {
      styles: css2`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${scope} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${scope} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${scope} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${scope} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${scope} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${scope} :where(b, strong) {
        font-weight: bold;
      }

      ${scope} small {
        font-size: 80%;
      }

      ${scope} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${scope} sub {
        bottom: -0.25em;
      }

      ${scope} sup {
        top: -0.5em;
      }

      ${scope} img {
        border-style: none;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${scope} :where(button, input) {
        overflow: visible;
      }

      ${scope} :where(button, select) {
        text-transform: none;
      }

      ${scope} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${scope} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${scope} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${scope} progress {
        vertical-align: baseline;
      }

      ${scope} textarea {
        overflow: auto;
      }

      ${scope} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${scope} input[type="number"]::-webkit-inner-spin-button,
      ${scope} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${scope} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${scope} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${scope} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${scope} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${scope} details {
        display: block;
      }

      ${scope} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${scope} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${scope} button {
        background: transparent;
        padding: 0;
      }

      ${scope} fieldset {
        margin: 0;
        padding: 0;
      }

      ${scope} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${scope} textarea {
        resize: vertical;
      }

      ${scope} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${scope} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${scope} table {
        border-collapse: collapse;
      }

      ${scope} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${scope} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${scope} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${scope} select::-ms-expand {
        display: none;
      }

      ${vhPolyfill}
    `
    }
  );

  // node_modules/@chakra-ui/react-context/dist/index.mjs
  var import_react3 = __toESM(require_react(), 1);
  function getErrorMessage(hook, provider) {
    return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
  }
  function createContext2(options = {}) {
    const {
      name,
      strict = true,
      hookName = "useContext",
      providerName = "Provider",
      errorMessage,
      defaultValue
    } = options;
    const Context = (0, import_react3.createContext)(defaultValue);
    Context.displayName = name;
    function useContext17() {
      var _a7;
      const context = (0, import_react3.useContext)(Context);
      if (!context && strict) {
        const error2 = new Error(
          errorMessage != null ? errorMessage : getErrorMessage(hookName, providerName)
        );
        error2.name = "ContextError";
        (_a7 = Error.captureStackTrace) == null ? void 0 : _a7.call(Error, error2, useContext17);
        throw error2;
      }
      return context;
    }
    return [Context.Provider, useContext17, Context];
  }

  // node_modules/@chakra-ui/portal/dist/chunk-HK66PB7M.mjs
  var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
  var [PortalManagerContextProvider, usePortalManager] = createContext2({
    strict: false,
    name: "PortalManagerContext"
  });
  function PortalManager(props) {
    const { children, zIndex } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(PortalManagerContextProvider, { value: { zIndex }, children });
  }
  PortalManager.displayName = "PortalManager";

  // node_modules/@chakra-ui/react-use-safe-layout-effect/dist/index.mjs
  var import_react4 = __toESM(require_react(), 1);
  var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? import_react4.useLayoutEffect : import_react4.useEffect;

  // node_modules/@chakra-ui/portal/dist/chunk-34PD6CUK.mjs
  var import_react_dom = __toESM(require_react_dom(), 1);
  var import_react5 = __toESM(require_react(), 1);
  var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
  var [PortalContextProvider, usePortalContext] = createContext2({
    strict: false,
    name: "PortalContext"
  });
  var PORTAL_CLASSNAME = "chakra-portal";
  var PORTAL_SELECTOR = `.chakra-portal`;
  var Container = (props) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    "div",
    {
      className: "chakra-portal-zIndex",
      style: {
        position: "absolute",
        zIndex: props.zIndex,
        top: 0,
        left: 0,
        right: 0
        // NB: Don't add `bottom: 0`, it makes the entire app unusable
        // @see https://github.com/chakra-ui/chakra-ui/issues/3201
      },
      children: props.children
    }
  );
  var DefaultPortal = (props) => {
    const { appendToParentPortal, children } = props;
    const [tempNode, setTempNode] = (0, import_react5.useState)(null);
    const portal = (0, import_react5.useRef)(null);
    const [, forceUpdate] = (0, import_react5.useState)({});
    (0, import_react5.useEffect)(() => forceUpdate({}), []);
    const parentPortal = usePortalContext();
    const manager = usePortalManager();
    useSafeLayoutEffect(() => {
      if (!tempNode)
        return;
      const doc = tempNode.ownerDocument;
      const host = appendToParentPortal ? parentPortal != null ? parentPortal : doc.body : doc.body;
      if (!host)
        return;
      portal.current = doc.createElement("div");
      portal.current.className = PORTAL_CLASSNAME;
      host.appendChild(portal.current);
      forceUpdate({});
      const portalNode = portal.current;
      return () => {
        if (host.contains(portalNode)) {
          host.removeChild(portalNode);
        }
      };
    }, [tempNode]);
    const _children = (manager == null ? void 0 : manager.zIndex) ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Container, { zIndex: manager == null ? void 0 : manager.zIndex, children }) : children;
    return portal.current ? (0, import_react_dom.createPortal)(
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(PortalContextProvider, { value: portal.current, children: _children }),
      portal.current
    ) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "span",
      {
        ref: (el) => {
          if (el)
            setTempNode(el);
        }
      }
    );
  };
  var ContainerPortal = (props) => {
    const { children, containerRef, appendToParentPortal } = props;
    const containerEl = containerRef.current;
    const host = containerEl != null ? containerEl : typeof window !== "undefined" ? document.body : void 0;
    const portal = (0, import_react5.useMemo)(() => {
      const node2 = containerEl == null ? void 0 : containerEl.ownerDocument.createElement("div");
      if (node2)
        node2.className = PORTAL_CLASSNAME;
      return node2;
    }, [containerEl]);
    const [, forceUpdate] = (0, import_react5.useState)({});
    useSafeLayoutEffect(() => forceUpdate({}), []);
    useSafeLayoutEffect(() => {
      if (!portal || !host)
        return;
      host.appendChild(portal);
      return () => {
        host.removeChild(portal);
      };
    }, [portal, host]);
    if (host && portal) {
      return (0, import_react_dom.createPortal)(
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(PortalContextProvider, { value: appendToParentPortal ? portal : null, children }),
        portal
      );
    }
    return null;
  };
  function Portal(props) {
    const portalProps = {
      appendToParentPortal: true,
      ...props
    };
    const { containerRef, ...rest } = portalProps;
    return containerRef ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(ContainerPortal, { containerRef, ...rest }) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(DefaultPortal, { ...rest });
  }
  Portal.className = PORTAL_CLASSNAME;
  Portal.selector = PORTAL_SELECTOR;
  Portal.displayName = "Portal";

  // node_modules/@chakra-ui/system/dist/chunk-UIGT7YZF.mjs
  var import_react7 = __toESM(require_react(), 1);
  function useTheme2() {
    const theme3 = (0, import_react7.useContext)(
      ThemeContext
    );
    if (!theme3) {
      throw Error(
        "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
      );
    }
    return theme3;
  }

  // node_modules/@chakra-ui/color-mode/dist/chunk-UQDW7KKV.mjs
  var import_react8 = __toESM(require_react(), 1);
  var ColorModeContext = (0, import_react8.createContext)({});
  ColorModeContext.displayName = "ColorModeContext";
  function useColorMode() {
    const context = (0, import_react8.useContext)(ColorModeContext);
    if (context === void 0) {
      throw new Error("useColorMode must be used within a ColorModeProvider");
    }
    return context;
  }

  // node_modules/@chakra-ui/color-mode/dist/chunk-X7ZBZ4KW.mjs
  var classNames = {
    light: "chakra-ui-light",
    dark: "chakra-ui-dark"
  };
  function getColorModeUtils(options = {}) {
    const { preventTransition = true } = options;
    const utils = {
      setDataset: (value) => {
        const cleanup = preventTransition ? utils.preventTransition() : void 0;
        document.documentElement.dataset.theme = value;
        document.documentElement.style.colorScheme = value;
        cleanup == null ? void 0 : cleanup();
      },
      setClassName(dark) {
        document.body.classList.add(dark ? classNames.dark : classNames.light);
        document.body.classList.remove(dark ? classNames.light : classNames.dark);
      },
      query() {
        return window.matchMedia("(prefers-color-scheme: dark)");
      },
      getSystemTheme(fallback) {
        var _a7;
        const dark = (_a7 = utils.query().matches) != null ? _a7 : fallback === "dark";
        return dark ? "dark" : "light";
      },
      addListener(fn2) {
        const mql = utils.query();
        const listener = (e3) => {
          fn2(e3.matches ? "dark" : "light");
        };
        if (typeof mql.addListener === "function")
          mql.addListener(listener);
        else
          mql.addEventListener("change", listener);
        return () => {
          if (typeof mql.removeListener === "function")
            mql.removeListener(listener);
          else
            mql.removeEventListener("change", listener);
        };
      },
      preventTransition() {
        const css4 = document.createElement("style");
        css4.appendChild(
          document.createTextNode(
            `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
          )
        );
        document.head.appendChild(css4);
        return () => {
          ;
          (() => window.getComputedStyle(document.body))();
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              document.head.removeChild(css4);
            });
          });
        };
      }
    };
    return utils;
  }

  // node_modules/@chakra-ui/color-mode/dist/chunk-44OWBZ77.mjs
  var STORAGE_KEY = "chakra-ui-color-mode";
  function createLocalStorageManager(key) {
    return {
      ssr: false,
      type: "localStorage",
      get(init3) {
        if (!(globalThis == null ? void 0 : globalThis.document))
          return init3;
        let value;
        try {
          value = localStorage.getItem(key) || init3;
        } catch (e3) {
        }
        return value || init3;
      },
      set(value) {
        try {
          localStorage.setItem(key, value);
        } catch (e3) {
        }
      }
    };
  }
  var localStorageManager = createLocalStorageManager(STORAGE_KEY);
  function parseCookie(cookie, key) {
    const match3 = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
    return match3 == null ? void 0 : match3[2];
  }
  function createCookieStorageManager(key, cookie) {
    return {
      ssr: !!cookie,
      type: "cookie",
      get(init3) {
        if (cookie)
          return parseCookie(cookie, key);
        if (!(globalThis == null ? void 0 : globalThis.document))
          return init3;
        return parseCookie(document.cookie, key) || init3;
      },
      set(value) {
        document.cookie = `${key}=${value}; max-age=31536000; path=/`;
      }
    };
  }
  var cookieStorageManager = createCookieStorageManager(STORAGE_KEY);

  // node_modules/@chakra-ui/color-mode/dist/chunk-AMBGAKG2.mjs
  var import_react9 = __toESM(require_react(), 1);
  var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
  var noop = () => {
  };
  function getTheme3(manager, fallback) {
    return manager.type === "cookie" && manager.ssr ? manager.get(fallback) : fallback;
  }
  function ColorModeProvider(props) {
    const {
      value,
      children,
      options: {
        useSystemColorMode,
        initialColorMode,
        disableTransitionOnChange
      } = {},
      colorModeManager = localStorageManager
    } = props;
    const defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
    const [colorMode, rawSetColorMode] = (0, import_react9.useState)(
      () => getTheme3(colorModeManager, defaultColorMode)
    );
    const [resolvedColorMode, setResolvedColorMode] = (0, import_react9.useState)(
      () => getTheme3(colorModeManager)
    );
    const { getSystemTheme, setClassName, setDataset, addListener } = (0, import_react9.useMemo)(
      () => getColorModeUtils({ preventTransition: disableTransitionOnChange }),
      [disableTransitionOnChange]
    );
    const resolvedValue = initialColorMode === "system" && !colorMode ? resolvedColorMode : colorMode;
    const setColorMode = (0, import_react9.useCallback)(
      (value2) => {
        const resolved = value2 === "system" ? getSystemTheme() : value2;
        rawSetColorMode(resolved);
        setClassName(resolved === "dark");
        setDataset(resolved);
        colorModeManager.set(resolved);
      },
      [colorModeManager, getSystemTheme, setClassName, setDataset]
    );
    useSafeLayoutEffect(() => {
      if (initialColorMode === "system") {
        setResolvedColorMode(getSystemTheme());
      }
    }, []);
    (0, import_react9.useEffect)(() => {
      const managerValue = colorModeManager.get();
      if (managerValue) {
        setColorMode(managerValue);
        return;
      }
      if (initialColorMode === "system") {
        setColorMode("system");
        return;
      }
      setColorMode(defaultColorMode);
    }, [colorModeManager, defaultColorMode, initialColorMode, setColorMode]);
    const toggleColorMode = (0, import_react9.useCallback)(() => {
      setColorMode(resolvedValue === "dark" ? "light" : "dark");
    }, [resolvedValue, setColorMode]);
    (0, import_react9.useEffect)(() => {
      if (!useSystemColorMode)
        return;
      return addListener(setColorMode);
    }, [useSystemColorMode, addListener, setColorMode]);
    const context = (0, import_react9.useMemo)(
      () => ({
        colorMode: value != null ? value : resolvedValue,
        toggleColorMode: value ? noop : toggleColorMode,
        setColorMode: value ? noop : setColorMode,
        forced: value !== void 0
      }),
      [resolvedValue, toggleColorMode, setColorMode, value]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ColorModeContext.Provider, { value: context, children });
  }
  ColorModeProvider.displayName = "ColorModeProvider";
  function DarkMode(props) {
    const context = (0, import_react9.useMemo)(
      () => ({
        colorMode: "dark",
        toggleColorMode: noop,
        setColorMode: noop,
        forced: true
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ColorModeContext.Provider, { value: context, ...props });
  }
  DarkMode.displayName = "DarkMode";
  function LightMode(props) {
    const context = (0, import_react9.useMemo)(
      () => ({
        colorMode: "light",
        toggleColorMode: noop,
        setColorMode: noop,
        forced: true
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ColorModeContext.Provider, { value: context, ...props });
  }
  LightMode.displayName = "LightMode";

  // node_modules/@chakra-ui/system/dist/chunk-7FWEOSAE.mjs
  function useChakra() {
    const colorModeResult = useColorMode();
    const theme3 = useTheme2();
    return { ...colorModeResult, theme: theme3 };
  }

  // node_modules/@chakra-ui/shared-utils/dist/index.mjs
  var cx = (...classNames2) => classNames2.filter(Boolean).join(" ");
  function isObject(value) {
    const type = typeof value;
    return value != null && (type === "object" || type === "function") && !Array.isArray(value);
  }
  function runIfFn(valueOrFn, ...args) {
    return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
  }
  var isFunction = (value) => typeof value === "function";
  var dataAttr = (condition) => condition ? "" : void 0;
  var ariaAttr = (condition) => condition ? true : void 0;
  function callAllHandlers(...fns) {
    return function func(event) {
      fns.some((fn2) => {
        fn2 == null ? void 0 : fn2(event);
        return event == null ? void 0 : event.defaultPrevented;
      });
    };
  }

  // node_modules/@chakra-ui/styled-system/dist/index.mjs
  var import_lodash = __toESM(require_lodash(), 1);
  var import_lodash2 = __toESM(require_lodash(), 1);
  var import_lodash3 = __toESM(require_lodash(), 1);
  var import_lodash4 = __toESM(require_lodash(), 1);
  var isImportant = (value) => /!(important)?$/.test(value);
  var withoutImportant = (value) => typeof value === "string" ? value.replace(/!(important)?$/, "").trim() : value;
  var tokenToCSSVar = (scale3, value) => (theme3) => {
    const valueStr = String(value);
    const important = isImportant(valueStr);
    const valueWithoutImportant = withoutImportant(valueStr);
    const key = scale3 ? `${scale3}.${valueWithoutImportant}` : valueWithoutImportant;
    let transformed = isObject(theme3.__cssMap) && key in theme3.__cssMap ? theme3.__cssMap[key].varRef : value;
    transformed = withoutImportant(transformed);
    return important ? `${transformed} !important` : transformed;
  };
  function createTransform(options) {
    const { scale: scale3, transform: transform2, compose: compose2 } = options;
    const fn2 = (value, theme3) => {
      var _a7;
      const _value = tokenToCSSVar(scale3, value)(theme3);
      let result = (_a7 = transform2 == null ? void 0 : transform2(_value, theme3)) != null ? _a7 : _value;
      if (compose2) {
        result = compose2(result, theme3);
      }
      return result;
    };
    return fn2;
  }
  var pipe = (...fns) => (v) => fns.reduce((a, b) => b(a), v);
  function toConfig(scale3, transform2) {
    return (property) => {
      const result = { property, scale: scale3 };
      result.transform = createTransform({
        scale: scale3,
        transform: transform2
      });
      return result;
    };
  }
  var getRtl = ({ rtl, ltr }) => (theme3) => theme3.direction === "rtl" ? rtl : ltr;
  function logical(options) {
    const { property, scale: scale3, transform: transform2 } = options;
    return {
      scale: scale3,
      property: getRtl(property),
      transform: scale3 ? createTransform({
        scale: scale3,
        compose: transform2
      }) : transform2
    };
  }
  var transformTemplate = [
    "rotate(var(--chakra-rotate, 0))",
    "scaleX(var(--chakra-scale-x, 1))",
    "scaleY(var(--chakra-scale-y, 1))",
    "skewX(var(--chakra-skew-x, 0))",
    "skewY(var(--chakra-skew-y, 0))"
  ];
  function getTransformTemplate() {
    return [
      "translateX(var(--chakra-translate-x, 0))",
      "translateY(var(--chakra-translate-y, 0))",
      ...transformTemplate
    ].join(" ");
  }
  function getTransformGpuTemplate() {
    return [
      "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
      ...transformTemplate
    ].join(" ");
  }
  var filterTemplate = {
    "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
    filter: [
      "var(--chakra-blur)",
      "var(--chakra-brightness)",
      "var(--chakra-contrast)",
      "var(--chakra-grayscale)",
      "var(--chakra-hue-rotate)",
      "var(--chakra-invert)",
      "var(--chakra-saturate)",
      "var(--chakra-sepia)",
      "var(--chakra-drop-shadow)"
    ].join(" ")
  };
  var backdropFilterTemplate = {
    backdropFilter: [
      "var(--chakra-backdrop-blur)",
      "var(--chakra-backdrop-brightness)",
      "var(--chakra-backdrop-contrast)",
      "var(--chakra-backdrop-grayscale)",
      "var(--chakra-backdrop-hue-rotate)",
      "var(--chakra-backdrop-invert)",
      "var(--chakra-backdrop-opacity)",
      "var(--chakra-backdrop-saturate)",
      "var(--chakra-backdrop-sepia)"
    ].join(" "),
    "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
  };
  function getRingTemplate(value) {
    return {
      "--chakra-ring-offset-shadow": `var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)`,
      "--chakra-ring-shadow": `var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)`,
      "--chakra-ring-width": value,
      boxShadow: [
        `var(--chakra-ring-offset-shadow)`,
        `var(--chakra-ring-shadow)`,
        `var(--chakra-shadow, 0 0 #0000)`
      ].join(", ")
    };
  }
  var flexDirectionTemplate = {
    "row-reverse": {
      space: "--chakra-space-x-reverse",
      divide: "--chakra-divide-x-reverse"
    },
    "column-reverse": {
      space: "--chakra-space-y-reverse",
      divide: "--chakra-divide-y-reverse"
    }
  };
  var directionMap = {
    "to-t": "to top",
    "to-tr": "to top right",
    "to-r": "to right",
    "to-br": "to bottom right",
    "to-b": "to bottom",
    "to-bl": "to bottom left",
    "to-l": "to left",
    "to-tl": "to top left"
  };
  var valueSet = new Set(Object.values(directionMap));
  var globalSet = /* @__PURE__ */ new Set([
    "none",
    "-moz-initial",
    "inherit",
    "initial",
    "revert",
    "unset"
  ]);
  var trimSpace = (str) => str.trim();
  function parseGradient(value, theme3) {
    if (value == null || globalSet.has(value))
      return value;
    const prevent = isCSSFunction(value) || globalSet.has(value);
    if (!prevent)
      return `url('${value}')`;
    const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
    const results = regex.exec(value);
    const type = results == null ? void 0 : results[1];
    const values = results == null ? void 0 : results[2];
    if (!type || !values)
      return value;
    const _type = type.includes("-gradient") ? type : `${type}-gradient`;
    const [maybeDirection, ...stops] = values.split(",").map(trimSpace).filter(Boolean);
    if ((stops == null ? void 0 : stops.length) === 0)
      return value;
    const direction2 = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
    stops.unshift(direction2);
    const _values = stops.map((stop) => {
      if (valueSet.has(stop))
        return stop;
      const firstStop = stop.indexOf(" ");
      const [_color, _stop] = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop];
      const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
      const key = `colors.${_color}`;
      const color22 = key in theme3.__cssMap ? theme3.__cssMap[key].varRef : _color;
      return _stopOrFunc ? [
        color22,
        ...Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]
      ].join(" ") : color22;
    });
    return `${_type}(${_values.join(", ")})`;
  }
  var isCSSFunction = (value) => {
    return typeof value === "string" && value.includes("(") && value.includes(")");
  };
  var gradientTransform = (value, theme3) => parseGradient(value, theme3 != null ? theme3 : {});
  function isCssVar(value) {
    return /^var\(--.+\)$/.test(value);
  }
  var analyzeCSSValue = (value) => {
    const num = parseFloat(value.toString());
    const unit2 = value.toString().replace(String(num), "");
    return { unitless: !unit2, value: num, unit: unit2 };
  };
  var wrap = (str) => (value) => `${str}(${value})`;
  var transformFunctions = {
    filter(value) {
      return value !== "auto" ? value : filterTemplate;
    },
    backdropFilter(value) {
      return value !== "auto" ? value : backdropFilterTemplate;
    },
    ring(value) {
      return getRingTemplate(transformFunctions.px(value));
    },
    bgClip(value) {
      return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
    },
    transform(value) {
      if (value === "auto")
        return getTransformTemplate();
      if (value === "auto-gpu")
        return getTransformGpuTemplate();
      return value;
    },
    vh(value) {
      return value === "$100vh" ? "var(--chakra-vh)" : value;
    },
    px(value) {
      if (value == null)
        return value;
      const { unitless } = analyzeCSSValue(value);
      return unitless || typeof value === "number" ? `${value}px` : value;
    },
    fraction(value) {
      return !(typeof value === "number") || value > 1 ? value : `${value * 100}%`;
    },
    float(value, theme3) {
      const map2 = { left: "right", right: "left" };
      return theme3.direction === "rtl" ? map2[value] : value;
    },
    degree(value) {
      if (isCssVar(value) || value == null)
        return value;
      const unitless = typeof value === "string" && !value.endsWith("deg");
      return typeof value === "number" || unitless ? `${value}deg` : value;
    },
    gradient: gradientTransform,
    blur: wrap("blur"),
    opacity: wrap("opacity"),
    brightness: wrap("brightness"),
    contrast: wrap("contrast"),
    dropShadow: wrap("drop-shadow"),
    grayscale: wrap("grayscale"),
    hueRotate: (value) => wrap("hue-rotate")(transformFunctions.degree(value)),
    invert: wrap("invert"),
    saturate: wrap("saturate"),
    sepia: wrap("sepia"),
    bgImage(value) {
      if (value == null)
        return value;
      const prevent = isCSSFunction(value) || globalSet.has(value);
      return !prevent ? `url(${value})` : value;
    },
    outline(value) {
      const isNoneOrZero = String(value) === "0" || String(value) === "none";
      return value !== null && isNoneOrZero ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: value };
    },
    flexDirection(value) {
      var _a7;
      const { space: space2, divide: divide22 } = (_a7 = flexDirectionTemplate[value]) != null ? _a7 : {};
      const result = { flexDirection: value };
      if (space2)
        result[space2] = 1;
      if (divide22)
        result[divide22] = 1;
      return result;
    }
  };
  var t = {
    borderWidths: toConfig("borderWidths"),
    borderStyles: toConfig("borderStyles"),
    colors: toConfig("colors"),
    borders: toConfig("borders"),
    gradients: toConfig("gradients", transformFunctions.gradient),
    radii: toConfig("radii", transformFunctions.px),
    space: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
    spaceT: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
    degreeT(property) {
      return { property, transform: transformFunctions.degree };
    },
    prop(property, scale3, transform2) {
      return {
        property,
        scale: scale3,
        ...scale3 && {
          transform: createTransform({ scale: scale3, transform: transform2 })
        }
      };
    },
    propT(property, transform2) {
      return { property, transform: transform2 };
    },
    sizes: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.px)),
    sizesT: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.fraction)),
    shadows: toConfig("shadows"),
    logical,
    blur: toConfig("blur", transformFunctions.blur)
  };
  var background = {
    background: t.colors("background"),
    backgroundColor: t.colors("backgroundColor"),
    backgroundImage: t.gradients("backgroundImage"),
    backgroundSize: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundAttachment: true,
    backgroundClip: { transform: transformFunctions.bgClip },
    bgSize: t.prop("backgroundSize"),
    bgPosition: t.prop("backgroundPosition"),
    bg: t.colors("background"),
    bgColor: t.colors("backgroundColor"),
    bgPos: t.prop("backgroundPosition"),
    bgRepeat: t.prop("backgroundRepeat"),
    bgAttachment: t.prop("backgroundAttachment"),
    bgGradient: t.gradients("backgroundImage"),
    bgClip: { transform: transformFunctions.bgClip }
  };
  Object.assign(background, {
    bgImage: background.backgroundImage,
    bgImg: background.backgroundImage
  });
  var border = {
    border: t.borders("border"),
    borderWidth: t.borderWidths("borderWidth"),
    borderStyle: t.borderStyles("borderStyle"),
    borderColor: t.colors("borderColor"),
    borderRadius: t.radii("borderRadius"),
    borderTop: t.borders("borderTop"),
    borderBlockStart: t.borders("borderBlockStart"),
    borderTopLeftRadius: t.radii("borderTopLeftRadius"),
    borderStartStartRadius: t.logical({
      scale: "radii",
      property: {
        ltr: "borderTopLeftRadius",
        rtl: "borderTopRightRadius"
      }
    }),
    borderEndStartRadius: t.logical({
      scale: "radii",
      property: {
        ltr: "borderBottomLeftRadius",
        rtl: "borderBottomRightRadius"
      }
    }),
    borderTopRightRadius: t.radii("borderTopRightRadius"),
    borderStartEndRadius: t.logical({
      scale: "radii",
      property: {
        ltr: "borderTopRightRadius",
        rtl: "borderTopLeftRadius"
      }
    }),
    borderEndEndRadius: t.logical({
      scale: "radii",
      property: {
        ltr: "borderBottomRightRadius",
        rtl: "borderBottomLeftRadius"
      }
    }),
    borderRight: t.borders("borderRight"),
    borderInlineEnd: t.borders("borderInlineEnd"),
    borderBottom: t.borders("borderBottom"),
    borderBlockEnd: t.borders("borderBlockEnd"),
    borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
    borderBottomRightRadius: t.radii("borderBottomRightRadius"),
    borderLeft: t.borders("borderLeft"),
    borderInlineStart: {
      property: "borderInlineStart",
      scale: "borders"
    },
    borderInlineStartRadius: t.logical({
      scale: "radii",
      property: {
        ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
        rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
      }
    }),
    borderInlineEndRadius: t.logical({
      scale: "radii",
      property: {
        ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
        rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
      }
    }),
    borderX: t.borders(["borderLeft", "borderRight"]),
    borderInline: t.borders("borderInline"),
    borderY: t.borders(["borderTop", "borderBottom"]),
    borderBlock: t.borders("borderBlock"),
    borderTopWidth: t.borderWidths("borderTopWidth"),
    borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
    borderTopColor: t.colors("borderTopColor"),
    borderBlockStartColor: t.colors("borderBlockStartColor"),
    borderTopStyle: t.borderStyles("borderTopStyle"),
    borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
    borderBottomWidth: t.borderWidths("borderBottomWidth"),
    borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
    borderBottomColor: t.colors("borderBottomColor"),
    borderBlockEndColor: t.colors("borderBlockEndColor"),
    borderBottomStyle: t.borderStyles("borderBottomStyle"),
    borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
    borderLeftWidth: t.borderWidths("borderLeftWidth"),
    borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
    borderLeftColor: t.colors("borderLeftColor"),
    borderInlineStartColor: t.colors("borderInlineStartColor"),
    borderLeftStyle: t.borderStyles("borderLeftStyle"),
    borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
    borderRightWidth: t.borderWidths("borderRightWidth"),
    borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
    borderRightColor: t.colors("borderRightColor"),
    borderInlineEndColor: t.colors("borderInlineEndColor"),
    borderRightStyle: t.borderStyles("borderRightStyle"),
    borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
    borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
    borderBottomRadius: t.radii([
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]),
    borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
    borderRightRadius: t.radii([
      "borderTopRightRadius",
      "borderBottomRightRadius"
    ])
  };
  Object.assign(border, {
    rounded: border.borderRadius,
    roundedTop: border.borderTopRadius,
    roundedTopLeft: border.borderTopLeftRadius,
    roundedTopRight: border.borderTopRightRadius,
    roundedTopStart: border.borderStartStartRadius,
    roundedTopEnd: border.borderStartEndRadius,
    roundedBottom: border.borderBottomRadius,
    roundedBottomLeft: border.borderBottomLeftRadius,
    roundedBottomRight: border.borderBottomRightRadius,
    roundedBottomStart: border.borderEndStartRadius,
    roundedBottomEnd: border.borderEndEndRadius,
    roundedLeft: border.borderLeftRadius,
    roundedRight: border.borderRightRadius,
    roundedStart: border.borderInlineStartRadius,
    roundedEnd: border.borderInlineEndRadius,
    borderStart: border.borderInlineStart,
    borderEnd: border.borderInlineEnd,
    borderTopStartRadius: border.borderStartStartRadius,
    borderTopEndRadius: border.borderStartEndRadius,
    borderBottomStartRadius: border.borderEndStartRadius,
    borderBottomEndRadius: border.borderEndEndRadius,
    borderStartRadius: border.borderInlineStartRadius,
    borderEndRadius: border.borderInlineEndRadius,
    borderStartWidth: border.borderInlineStartWidth,
    borderEndWidth: border.borderInlineEndWidth,
    borderStartColor: border.borderInlineStartColor,
    borderEndColor: border.borderInlineEndColor,
    borderStartStyle: border.borderInlineStartStyle,
    borderEndStyle: border.borderInlineEndStyle
  });
  var color = {
    color: t.colors("color"),
    textColor: t.colors("color"),
    fill: t.colors("fill"),
    stroke: t.colors("stroke")
  };
  var effect = {
    boxShadow: t.shadows("boxShadow"),
    mixBlendMode: true,
    blendMode: t.prop("mixBlendMode"),
    backgroundBlendMode: true,
    bgBlendMode: t.prop("backgroundBlendMode"),
    opacity: true
  };
  Object.assign(effect, {
    shadow: effect.boxShadow
  });
  var filter = {
    filter: { transform: transformFunctions.filter },
    blur: t.blur("--chakra-blur"),
    brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
    contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
    hueRotate: t.propT("--chakra-hue-rotate", transformFunctions.hueRotate),
    invert: t.propT("--chakra-invert", transformFunctions.invert),
    saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
    dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
    backdropFilter: { transform: transformFunctions.backdropFilter },
    backdropBlur: t.blur("--chakra-backdrop-blur"),
    backdropBrightness: t.propT(
      "--chakra-backdrop-brightness",
      transformFunctions.brightness
    ),
    backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
    backdropHueRotate: t.propT(
      "--chakra-backdrop-hue-rotate",
      transformFunctions.hueRotate
    ),
    backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
    backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
  };
  var flexbox = {
    alignItems: true,
    alignContent: true,
    justifyItems: true,
    justifyContent: true,
    flexWrap: true,
    flexDirection: { transform: transformFunctions.flexDirection },
    flex: true,
    flexFlow: true,
    flexGrow: true,
    flexShrink: true,
    flexBasis: t.sizes("flexBasis"),
    justifySelf: true,
    alignSelf: true,
    order: true,
    placeItems: true,
    placeContent: true,
    placeSelf: true,
    gap: t.space("gap"),
    rowGap: t.space("rowGap"),
    columnGap: t.space("columnGap")
  };
  Object.assign(flexbox, {
    flexDir: flexbox.flexDirection
  });
  var grid = {
    gridGap: t.space("gridGap"),
    gridColumnGap: t.space("gridColumnGap"),
    gridRowGap: t.space("gridRowGap"),
    gridColumn: true,
    gridRow: true,
    gridAutoFlow: true,
    gridAutoColumns: true,
    gridColumnStart: true,
    gridColumnEnd: true,
    gridRowStart: true,
    gridRowEnd: true,
    gridAutoRows: true,
    gridTemplate: true,
    gridTemplateColumns: true,
    gridTemplateRows: true,
    gridTemplateAreas: true,
    gridArea: true
  };
  var interactivity = {
    appearance: true,
    cursor: true,
    resize: true,
    userSelect: true,
    pointerEvents: true,
    outline: { transform: transformFunctions.outline },
    outlineOffset: true,
    outlineColor: t.colors("outlineColor")
  };
  var layout = {
    width: t.sizesT("width"),
    inlineSize: t.sizesT("inlineSize"),
    height: t.sizes("height"),
    blockSize: t.sizes("blockSize"),
    boxSize: t.sizes(["width", "height"]),
    minWidth: t.sizes("minWidth"),
    minInlineSize: t.sizes("minInlineSize"),
    minHeight: t.sizes("minHeight"),
    minBlockSize: t.sizes("minBlockSize"),
    maxWidth: t.sizes("maxWidth"),
    maxInlineSize: t.sizes("maxInlineSize"),
    maxHeight: t.sizes("maxHeight"),
    maxBlockSize: t.sizes("maxBlockSize"),
    overflow: true,
    overflowX: true,
    overflowY: true,
    overscrollBehavior: true,
    overscrollBehaviorX: true,
    overscrollBehaviorY: true,
    display: true,
    aspectRatio: true,
    hideFrom: {
      scale: "breakpoints",
      transform: (value, theme3) => {
        var _a7, _b5, _c3;
        const breakpoint = (_c3 = (_b5 = (_a7 = theme3.__breakpoints) == null ? void 0 : _a7.get(value)) == null ? void 0 : _b5.minW) != null ? _c3 : value;
        const mq = `@media screen and (min-width: ${breakpoint})`;
        return { [mq]: { display: "none" } };
      }
    },
    hideBelow: {
      scale: "breakpoints",
      transform: (value, theme3) => {
        var _a7, _b5, _c3;
        const breakpoint = (_c3 = (_b5 = (_a7 = theme3.__breakpoints) == null ? void 0 : _a7.get(value)) == null ? void 0 : _b5._minW) != null ? _c3 : value;
        const mq = `@media screen and (max-width: ${breakpoint})`;
        return { [mq]: { display: "none" } };
      }
    },
    verticalAlign: true,
    boxSizing: true,
    boxDecorationBreak: true,
    float: t.propT("float", transformFunctions.float),
    objectFit: true,
    objectPosition: true,
    visibility: true,
    isolation: true
  };
  Object.assign(layout, {
    w: layout.width,
    h: layout.height,
    minW: layout.minWidth,
    maxW: layout.maxWidth,
    minH: layout.minHeight,
    maxH: layout.maxHeight,
    overscroll: layout.overscrollBehavior,
    overscrollX: layout.overscrollBehaviorX,
    overscrollY: layout.overscrollBehaviorY
  });
  var list = {
    listStyleType: true,
    listStylePosition: true,
    listStylePos: t.prop("listStylePosition"),
    listStyleImage: true,
    listStyleImg: t.prop("listStyleImage")
  };
  function get(obj, path, fallback, index) {
    const key = typeof path === "string" ? path.split(".") : [path];
    for (index = 0; index < key.length; index += 1) {
      if (!obj)
        break;
      obj = obj[key[index]];
    }
    return obj === void 0 ? fallback : obj;
  }
  var memoize2 = (fn2) => {
    const cache = /* @__PURE__ */ new WeakMap();
    const memoizedFn = (obj, path, fallback, index) => {
      if (typeof obj === "undefined") {
        return fn2(obj, path, fallback);
      }
      if (!cache.has(obj)) {
        cache.set(obj, /* @__PURE__ */ new Map());
      }
      const map2 = cache.get(obj);
      if (map2.has(path)) {
        return map2.get(path);
      }
      const value = fn2(obj, path, fallback, index);
      map2.set(path, value);
      return value;
    };
    return memoizedFn;
  };
  var memoizedGet = memoize2(get);
  var srOnly = {
    border: "0px",
    clip: "rect(0, 0, 0, 0)",
    width: "1px",
    height: "1px",
    margin: "-1px",
    padding: "0px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    position: "absolute"
  };
  var srFocusable = {
    position: "static",
    width: "auto",
    height: "auto",
    clip: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    whiteSpace: "normal"
  };
  var getWithPriority = (theme3, key, styles2) => {
    const result = {};
    const obj = memoizedGet(theme3, key, {});
    for (const prop in obj) {
      const isInStyles = prop in styles2 && styles2[prop] != null;
      if (!isInStyles)
        result[prop] = obj[prop];
    }
    return result;
  };
  var others = {
    srOnly: {
      transform(value) {
        if (value === true)
          return srOnly;
        if (value === "focusable")
          return srFocusable;
        return {};
      }
    },
    layerStyle: {
      processResult: true,
      transform: (value, theme3, styles2) => getWithPriority(theme3, `layerStyles.${value}`, styles2)
    },
    textStyle: {
      processResult: true,
      transform: (value, theme3, styles2) => getWithPriority(theme3, `textStyles.${value}`, styles2)
    },
    apply: {
      processResult: true,
      transform: (value, theme3, styles2) => getWithPriority(theme3, value, styles2)
    }
  };
  var position2 = {
    position: true,
    pos: t.prop("position"),
    zIndex: t.prop("zIndex", "zIndices"),
    inset: t.spaceT("inset"),
    insetX: t.spaceT(["left", "right"]),
    insetInline: t.spaceT("insetInline"),
    insetY: t.spaceT(["top", "bottom"]),
    insetBlock: t.spaceT("insetBlock"),
    top: t.spaceT("top"),
    insetBlockStart: t.spaceT("insetBlockStart"),
    bottom: t.spaceT("bottom"),
    insetBlockEnd: t.spaceT("insetBlockEnd"),
    left: t.spaceT("left"),
    insetInlineStart: t.logical({
      scale: "space",
      property: { ltr: "left", rtl: "right" }
    }),
    right: t.spaceT("right"),
    insetInlineEnd: t.logical({
      scale: "space",
      property: { ltr: "right", rtl: "left" }
    })
  };
  Object.assign(position2, {
    insetStart: position2.insetInlineStart,
    insetEnd: position2.insetInlineEnd
  });
  var ring = {
    ring: { transform: transformFunctions.ring },
    ringColor: t.colors("--chakra-ring-color"),
    ringOffset: t.prop("--chakra-ring-offset-width"),
    ringOffsetColor: t.colors("--chakra-ring-offset-color"),
    ringInset: t.prop("--chakra-ring-inset")
  };
  var space = {
    margin: t.spaceT("margin"),
    marginTop: t.spaceT("marginTop"),
    marginBlockStart: t.spaceT("marginBlockStart"),
    marginRight: t.spaceT("marginRight"),
    marginInlineEnd: t.spaceT("marginInlineEnd"),
    marginBottom: t.spaceT("marginBottom"),
    marginBlockEnd: t.spaceT("marginBlockEnd"),
    marginLeft: t.spaceT("marginLeft"),
    marginInlineStart: t.spaceT("marginInlineStart"),
    marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
    marginInline: t.spaceT("marginInline"),
    marginY: t.spaceT(["marginTop", "marginBottom"]),
    marginBlock: t.spaceT("marginBlock"),
    padding: t.space("padding"),
    paddingTop: t.space("paddingTop"),
    paddingBlockStart: t.space("paddingBlockStart"),
    paddingRight: t.space("paddingRight"),
    paddingBottom: t.space("paddingBottom"),
    paddingBlockEnd: t.space("paddingBlockEnd"),
    paddingLeft: t.space("paddingLeft"),
    paddingInlineStart: t.space("paddingInlineStart"),
    paddingInlineEnd: t.space("paddingInlineEnd"),
    paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
    paddingInline: t.space("paddingInline"),
    paddingY: t.space(["paddingTop", "paddingBottom"]),
    paddingBlock: t.space("paddingBlock")
  };
  Object.assign(space, {
    m: space.margin,
    mt: space.marginTop,
    mr: space.marginRight,
    me: space.marginInlineEnd,
    marginEnd: space.marginInlineEnd,
    mb: space.marginBottom,
    ml: space.marginLeft,
    ms: space.marginInlineStart,
    marginStart: space.marginInlineStart,
    mx: space.marginX,
    my: space.marginY,
    p: space.padding,
    pt: space.paddingTop,
    py: space.paddingY,
    px: space.paddingX,
    pb: space.paddingBottom,
    pl: space.paddingLeft,
    ps: space.paddingInlineStart,
    paddingStart: space.paddingInlineStart,
    pr: space.paddingRight,
    pe: space.paddingInlineEnd,
    paddingEnd: space.paddingInlineEnd
  });
  var textDecoration = {
    textDecorationColor: t.colors("textDecorationColor"),
    textDecoration: true,
    textDecor: { property: "textDecoration" },
    textDecorationLine: true,
    textDecorationStyle: true,
    textDecorationThickness: true,
    textUnderlineOffset: true,
    textShadow: t.shadows("textShadow")
  };
  var transform = {
    clipPath: true,
    transform: t.propT("transform", transformFunctions.transform),
    transformOrigin: true,
    translateX: t.spaceT("--chakra-translate-x"),
    translateY: t.spaceT("--chakra-translate-y"),
    skewX: t.degreeT("--chakra-skew-x"),
    skewY: t.degreeT("--chakra-skew-y"),
    scaleX: t.prop("--chakra-scale-x"),
    scaleY: t.prop("--chakra-scale-y"),
    scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
    rotate: t.degreeT("--chakra-rotate")
  };
  var transition = {
    transition: true,
    transitionDelay: true,
    animation: true,
    willChange: true,
    transitionDuration: t.prop("transitionDuration", "transition.duration"),
    transitionProperty: t.prop("transitionProperty", "transition.property"),
    transitionTimingFunction: t.prop(
      "transitionTimingFunction",
      "transition.easing"
    )
  };
  var typography = {
    fontFamily: t.prop("fontFamily", "fonts"),
    fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
    fontWeight: t.prop("fontWeight", "fontWeights"),
    lineHeight: t.prop("lineHeight", "lineHeights"),
    letterSpacing: t.prop("letterSpacing", "letterSpacings"),
    textAlign: true,
    fontStyle: true,
    textIndent: true,
    wordBreak: true,
    overflowWrap: true,
    textOverflow: true,
    textTransform: true,
    whiteSpace: true,
    isTruncated: {
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
      }
    },
    noOfLines: {
      static: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitBoxOrient: "vertical",
        //@ts-ignore
        WebkitLineClamp: "var(--chakra-line-clamp)"
      },
      property: "--chakra-line-clamp"
    }
  };
  var scroll = {
    scrollBehavior: true,
    scrollSnapAlign: true,
    scrollSnapStop: true,
    scrollSnapType: true,
    // scroll margin
    scrollMargin: t.spaceT("scrollMargin"),
    scrollMarginTop: t.spaceT("scrollMarginTop"),
    scrollMarginBottom: t.spaceT("scrollMarginBottom"),
    scrollMarginLeft: t.spaceT("scrollMarginLeft"),
    scrollMarginRight: t.spaceT("scrollMarginRight"),
    scrollMarginX: t.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
    scrollMarginY: t.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
    // scroll padding
    scrollPadding: t.spaceT("scrollPadding"),
    scrollPaddingTop: t.spaceT("scrollPaddingTop"),
    scrollPaddingBottom: t.spaceT("scrollPaddingBottom"),
    scrollPaddingLeft: t.spaceT("scrollPaddingLeft"),
    scrollPaddingRight: t.spaceT("scrollPaddingRight"),
    scrollPaddingX: t.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
    scrollPaddingY: t.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
  };
  function resolveReference(operand) {
    if (isObject(operand) && operand.reference) {
      return operand.reference;
    }
    return String(operand);
  }
  var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
  var add = (...operands) => `calc(${toExpression("+", ...operands)})`;
  var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
  var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
  var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
  var negate = (x) => {
    const value = resolveReference(x);
    if (value != null && !Number.isNaN(parseFloat(value))) {
      return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
    }
    return multiply(value, -1);
  };
  var calc = Object.assign(
    (x) => ({
      add: (...operands) => calc(add(x, ...operands)),
      subtract: (...operands) => calc(subtract(x, ...operands)),
      multiply: (...operands) => calc(multiply(x, ...operands)),
      divide: (...operands) => calc(divide(x, ...operands)),
      negate: () => calc(negate(x)),
      toString: () => x.toString()
    }),
    {
      add,
      subtract,
      multiply,
      divide,
      negate
    }
  );
  function replaceWhiteSpace(value, replaceValue = "-") {
    return value.replace(/\s+/g, replaceValue);
  }
  function escape(value) {
    const valueStr = replaceWhiteSpace(value.toString());
    return escapeSymbol(escapeDot(valueStr));
  }
  function escapeDot(value) {
    if (value.includes("\\."))
      return value;
    const isDecimal2 = !Number.isInteger(parseFloat(value.toString()));
    return isDecimal2 ? value.replace(".", `\\.`) : value;
  }
  function escapeSymbol(value) {
    return value.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
  }
  function addPrefix(value, prefix2 = "") {
    return [prefix2, value].filter(Boolean).join("-");
  }
  function toVarReference(name, fallback) {
    return `var(${name}${fallback ? `, ${fallback}` : ""})`;
  }
  function toVarDefinition(value, prefix2 = "") {
    return escape(`--${addPrefix(value, prefix2)}`);
  }
  function cssVar(name, fallback, cssVarPrefix) {
    const cssVariable = toVarDefinition(name, cssVarPrefix);
    return {
      variable: cssVariable,
      reference: toVarReference(cssVariable, fallback)
    };
  }
  function defineCssVars(scope, keys22) {
    const vars2 = {};
    for (const key of keys22) {
      if (Array.isArray(key)) {
        const [name, fallback] = key;
        vars2[name] = cssVar(`${scope}-${name}`, fallback);
        continue;
      }
      vars2[key] = cssVar(`${scope}-${key}`);
    }
    return vars2;
  }
  function getLastItem(array) {
    const length2 = array == null ? 0 : array.length;
    return length2 ? array[length2 - 1] : void 0;
  }
  function analyzeCSSValue2(value) {
    const num = parseFloat(value.toString());
    const unit2 = value.toString().replace(String(num), "");
    return { unitless: !unit2, value: num, unit: unit2 };
  }
  function px(value) {
    if (value == null)
      return value;
    const { unitless } = analyzeCSSValue2(value);
    return unitless || typeof value === "number" ? `${value}px` : value;
  }
  var sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
  var sortBps = (breakpoints3) => Object.fromEntries(Object.entries(breakpoints3).sort(sortByBreakpointValue));
  function normalize(breakpoints3) {
    const sorted = sortBps(breakpoints3);
    return Object.assign(Object.values(sorted), sorted);
  }
  function keys(breakpoints3) {
    const value = Object.keys(sortBps(breakpoints3));
    return new Set(value);
  }
  function subtract2(value) {
    var _a7;
    if (!value)
      return value;
    value = (_a7 = px(value)) != null ? _a7 : value;
    const OFFSET = -0.02;
    return typeof value === "number" ? `${value + OFFSET}` : value.replace(/(\d+\.?\d*)/u, (m) => `${parseFloat(m) + OFFSET}`);
  }
  function toMediaQueryString(min2, max2) {
    const query = ["@media screen"];
    if (min2)
      query.push("and", `(min-width: ${px(min2)})`);
    if (max2)
      query.push("and", `(max-width: ${px(max2)})`);
    return query.join(" ");
  }
  function analyzeBreakpoints(breakpoints3) {
    var _a7;
    if (!breakpoints3)
      return null;
    breakpoints3.base = (_a7 = breakpoints3.base) != null ? _a7 : "0px";
    const normalized = normalize(breakpoints3);
    const queries = Object.entries(breakpoints3).sort(sortByBreakpointValue).map(([breakpoint, minW], index, entry) => {
      var _a24;
      let [, maxW] = (_a24 = entry[index + 1]) != null ? _a24 : [];
      maxW = parseFloat(maxW) > 0 ? subtract2(maxW) : void 0;
      return {
        _minW: subtract2(minW),
        breakpoint,
        minW,
        maxW,
        maxWQuery: toMediaQueryString(null, maxW),
        minWQuery: toMediaQueryString(minW),
        minMaxQuery: toMediaQueryString(minW, maxW)
      };
    });
    const _keys = keys(breakpoints3);
    const _keysArr = Array.from(_keys.values());
    return {
      keys: _keys,
      normalized,
      isResponsive(test2) {
        const keys22 = Object.keys(test2);
        return keys22.length > 0 && keys22.every((key) => _keys.has(key));
      },
      asObject: sortBps(breakpoints3),
      asArray: normalize(breakpoints3),
      details: queries,
      get(key) {
        return queries.find((q) => q.breakpoint === key);
      },
      media: [
        null,
        ...normalized.map((minW) => toMediaQueryString(minW)).slice(1)
      ],
      /**
       * Converts the object responsive syntax to array syntax
       *
       * @example
       * toArrayValue({ base: 1, sm: 2, md: 3 }) // => [1, 2, 3]
       */
      toArrayValue(test2) {
        if (!isObject(test2)) {
          throw new Error("toArrayValue: value must be an object");
        }
        const result = _keysArr.map((bp) => {
          var _a24;
          return (_a24 = test2[bp]) != null ? _a24 : null;
        });
        while (getLastItem(result) === null) {
          result.pop();
        }
        return result;
      },
      /**
       * Converts the array responsive syntax to object syntax
       *
       * @example
       * toObjectValue([1, 2, 3]) // => { base: 1, sm: 2, md: 3 }
       */
      toObjectValue(test2) {
        if (!Array.isArray(test2)) {
          throw new Error("toObjectValue: value must be an array");
        }
        return test2.reduce((acc, value, index) => {
          const key = _keysArr[index];
          if (key != null && value != null)
            acc[key] = value;
          return acc;
        }, {});
      }
    };
  }
  var state = {
    hover: (str, post) => `${str}:hover ${post}, ${str}[data-hover] ${post}`,
    focus: (str, post) => `${str}:focus ${post}, ${str}[data-focus] ${post}`,
    focusVisible: (str, post) => `${str}:focus-visible ${post}`,
    focusWithin: (str, post) => `${str}:focus-within ${post}`,
    active: (str, post) => `${str}:active ${post}, ${str}[data-active] ${post}`,
    disabled: (str, post) => `${str}:disabled ${post}, ${str}[data-disabled] ${post}`,
    invalid: (str, post) => `${str}:invalid ${post}, ${str}[data-invalid] ${post}`,
    checked: (str, post) => `${str}:checked ${post}, ${str}[data-checked] ${post}`,
    indeterminate: (str, post) => `${str}:indeterminate ${post}, ${str}[aria-checked=mixed] ${post}, ${str}[data-indeterminate] ${post}`,
    readOnly: (str, post) => `${str}:read-only ${post}, ${str}[readonly] ${post}, ${str}[data-read-only] ${post}`,
    expanded: (str, post) => `${str}:read-only ${post}, ${str}[aria-expanded=true] ${post}, ${str}[data-expanded] ${post}`,
    placeholderShown: (str, post) => `${str}:placeholder-shown ${post}`
  };
  var toGroup = (fn2) => merge2((v) => fn2(v, "&"), "[role=group]", "[data-group]", ".group");
  var toPeer = (fn2) => merge2((v) => fn2(v, "~ &"), "[data-peer]", ".peer");
  var merge2 = (fn2, ...selectors) => selectors.map(fn2).join(", ");
  var pseudoSelectors = {
    /**
     * Styles for CSS selector `&:hover`
     */
    _hover: "&:hover, &[data-hover]",
    /**
     * Styles for CSS Selector `&:active`
     */
    _active: "&:active, &[data-active]",
    /**
     * Styles for CSS selector `&:focus`
     *
     */
    _focus: "&:focus, &[data-focus]",
    /**
     * Styles for the highlighted state.
     */
    _highlighted: "&[data-highlighted]",
    /**
     * Styles to apply when a child of this element has received focus
     * - CSS Selector `&:focus-within`
     */
    _focusWithin: "&:focus-within",
    /**
     * Styles to apply when this element has received focus via tabbing
     * - CSS Selector `&:focus-visible`
     */
    _focusVisible: "&:focus-visible, &[data-focus-visible]",
    /**
     * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
     * - `&[aria-disabled=true]`
     * - `&:disabled`
     * - `&[data-disabled]`
     * - `&[disabled]`
     */
    _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
    /**
     * Styles for CSS Selector `&:readonly`
     */
    _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
    /**
     * Styles for CSS selector `&::before`
     *
     * NOTE:When using this, ensure the `content` is wrapped in a backtick.
     * @example
     * ```jsx
     * <Box _before={{content:`""` }}/>
     * ```
     */
    _before: "&::before",
    /**
     * Styles for CSS selector `&::after`
     *
     * NOTE:When using this, ensure the `content` is wrapped in a backtick.
     * @example
     * ```jsx
     * <Box _after={{content:`""` }}/>
     * ```
     */
    _after: "&::after",
    /**
     * Styles for CSS selector `&:empty`
     */
    _empty: "&:empty",
    /**
     * Styles to apply when the ARIA attribute `aria-expanded` is `true`
     * - CSS selector `&[aria-expanded=true]`
     */
    _expanded: "&[aria-expanded=true], &[data-expanded]",
    /**
     * Styles to apply when the ARIA attribute `aria-checked` is `true`
     * - CSS selector `&[aria-checked=true]`
     */
    _checked: "&[aria-checked=true], &[data-checked]",
    /**
     * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
     * - CSS selector `&[aria-grabbed=true]`
     */
    _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
    /**
     * Styles for CSS Selector `&[aria-pressed=true]`
     * Typically used to style the current "pressed" state of toggle buttons
     */
    _pressed: "&[aria-pressed=true], &[data-pressed]",
    /**
     * Styles to apply when the ARIA attribute `aria-invalid` is `true`
     * - CSS selector `&[aria-invalid=true]`
     */
    _invalid: "&[aria-invalid=true], &[data-invalid]",
    /**
     * Styles for the valid state
     * - CSS selector `&[data-valid], &[data-state=valid]`
     */
    _valid: "&[data-valid], &[data-state=valid]",
    /**
     * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
     * Useful for styling loading states
     */
    _loading: "&[data-loading], &[aria-busy=true]",
    /**
     * Styles to apply when the ARIA attribute `aria-selected` is `true`
     *
     * - CSS selector `&[aria-selected=true]`
     */
    _selected: "&[aria-selected=true], &[data-selected]",
    /**
     * Styles for CSS Selector `[hidden=true]`
     */
    _hidden: "&[hidden], &[data-hidden]",
    /**
     * Styles for CSS Selector `&:-webkit-autofill`
     */
    _autofill: "&:-webkit-autofill",
    /**
     * Styles for CSS Selector `&:nth-child(even)`
     */
    _even: "&:nth-of-type(even)",
    /**
     * Styles for CSS Selector `&:nth-child(odd)`
     */
    _odd: "&:nth-of-type(odd)",
    /**
     * Styles for CSS Selector `&:first-of-type`
     */
    _first: "&:first-of-type",
    /**
     * Styles for CSS selector `&::first-letter`
     *
     * NOTE: This selector is only applied for block-level elements and not preceded by an image or table.
     * @example
     * ```jsx
     * <Text _firstLetter={{ textDecoration: 'underline' }}>Once upon a time</Text>
     * ```
     */
    _firstLetter: "&::first-letter",
    /**
     * Styles for CSS Selector `&:last-of-type`
     */
    _last: "&:last-of-type",
    /**
     * Styles for CSS Selector `&:not(:first-of-type)`
     */
    _notFirst: "&:not(:first-of-type)",
    /**
     * Styles for CSS Selector `&:not(:last-of-type)`
     */
    _notLast: "&:not(:last-of-type)",
    /**
     * Styles for CSS Selector `&:visited`
     */
    _visited: "&:visited",
    /**
     * Used to style the active link in a navigation
     * Styles for CSS Selector `&[aria-current=page]`
     */
    _activeLink: "&[aria-current=page]",
    /**
     * Used to style the current step within a process
     * Styles for CSS Selector `&[aria-current=step]`
     */
    _activeStep: "&[aria-current=step]",
    /**
     * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
     * - CSS selector `&[aria-checked=mixed]`
     */
    _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
    /**
     * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
     */
    _groupHover: toGroup(state.hover),
    /**
     * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
     */
    _peerHover: toPeer(state.hover),
    /**
     * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
     */
    _groupFocus: toGroup(state.focus),
    /**
     * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
     */
    _peerFocus: toPeer(state.focus),
    /**
     * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
     */
    _groupFocusVisible: toGroup(state.focusVisible),
    /**
     * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
     */
    _peerFocusVisible: toPeer(state.focusVisible),
    /**
     * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
     */
    _groupActive: toGroup(state.active),
    /**
     * Styles to apply when a sibling element with `.peer` or `data-peer` is active
     */
    _peerActive: toPeer(state.active),
    /**
     * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
     */
    _groupDisabled: toGroup(state.disabled),
    /**
     *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
     */
    _peerDisabled: toPeer(state.disabled),
    /**
     *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
     */
    _groupInvalid: toGroup(state.invalid),
    /**
     *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
     */
    _peerInvalid: toPeer(state.invalid),
    /**
     * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
     */
    _groupChecked: toGroup(state.checked),
    /**
     * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
     */
    _peerChecked: toPeer(state.checked),
    /**
     *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
     */
    _groupFocusWithin: toGroup(state.focusWithin),
    /**
     *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
     */
    _peerFocusWithin: toPeer(state.focusWithin),
    /**
     * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
     */
    _peerPlaceholderShown: toPeer(state.placeholderShown),
    /**
     * Styles for CSS Selector `&::placeholder`.
     */
    _placeholder: "&::placeholder",
    /**
     * Styles for CSS Selector `&:placeholder-shown`.
     */
    _placeholderShown: "&:placeholder-shown",
    /**
     * Styles for CSS Selector `&:fullscreen`.
     */
    _fullScreen: "&:fullscreen",
    /**
     * Styles for CSS Selector `&::selection`
     */
    _selection: "&::selection",
    /**
     * Styles for CSS Selector `[dir=rtl] &`
     * It is applied when a parent element or this element has `dir="rtl"`
     */
    _rtl: "[dir=rtl] &, &[dir=rtl]",
    /**
     * Styles for CSS Selector `[dir=ltr] &`
     * It is applied when a parent element or this element has `dir="ltr"`
     */
    _ltr: "[dir=ltr] &, &[dir=ltr]",
    /**
     * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
     * It is used when the user has requested the system use a light or dark color theme.
     */
    _mediaDark: "@media (prefers-color-scheme: dark)",
    /**
     * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
     * It is used when the user has requested the system to reduce the amount of animations.
     */
    _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
    /**
     * Styles for when `data-theme` is applied to any parent of
     * this component or element.
     */
    _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
    /**
     * Styles for when `data-theme` is applied to any parent of
     * this component or element.
     */
    _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
    /**
     * Styles for the CSS Selector `&[data-orientation=horizontal]`
     */
    _horizontal: "&[data-orientation=horizontal]",
    /**
     * Styles for the CSS Selector `&[data-orientation=vertical]`
     */
    _vertical: "&[data-orientation=vertical]"
  };
  var pseudoPropNames = Object.keys(
    pseudoSelectors
  );
  function tokenToCssVar(token2, prefix2) {
    return cssVar(String(token2).replace(/\./g, "-"), void 0, prefix2);
  }
  function createThemeVars(flatTokens, options) {
    let cssVars2 = {};
    const cssMap = {};
    for (const [token2, tokenValue] of Object.entries(flatTokens)) {
      const { isSemantic, value } = tokenValue;
      const { variable, reference: reference2 } = tokenToCssVar(token2, options == null ? void 0 : options.cssVarPrefix);
      if (!isSemantic) {
        if (token2.startsWith("space")) {
          const keys22 = token2.split(".");
          const [firstKey, ...referenceKeys] = keys22;
          const negativeLookupKey = `${firstKey}.-${referenceKeys.join(".")}`;
          const negativeValue = calc.negate(value);
          const negatedReference = calc.negate(reference2);
          cssMap[negativeLookupKey] = {
            value: negativeValue,
            var: variable,
            varRef: negatedReference
          };
        }
        cssVars2[variable] = value;
        cssMap[token2] = {
          value,
          var: variable,
          varRef: reference2
        };
        continue;
      }
      const lookupToken = (maybeToken) => {
        const scale3 = String(token2).split(".")[0];
        const withScale = [scale3, maybeToken].join(".");
        const resolvedTokenValue = flatTokens[withScale];
        if (!resolvedTokenValue)
          return maybeToken;
        const { reference: reference22 } = tokenToCssVar(withScale, options == null ? void 0 : options.cssVarPrefix);
        return reference22;
      };
      const normalizedValue = isObject(value) ? value : { default: value };
      cssVars2 = (0, import_lodash.default)(
        cssVars2,
        Object.entries(normalizedValue).reduce(
          (acc, [conditionAlias, conditionValue]) => {
            var _a7, _b5;
            if (!conditionValue)
              return acc;
            const tokenReference = lookupToken(`${conditionValue}`);
            if (conditionAlias === "default") {
              acc[variable] = tokenReference;
              return acc;
            }
            const conditionSelector = (_b5 = (_a7 = pseudoSelectors) == null ? void 0 : _a7[conditionAlias]) != null ? _b5 : conditionAlias;
            acc[conditionSelector] = { [variable]: tokenReference };
            return acc;
          },
          {}
        )
      );
      cssMap[token2] = {
        value: reference2,
        var: variable,
        varRef: reference2
      };
    }
    return {
      cssVars: cssVars2,
      cssMap
    };
  }
  function omit(object, keysToOmit = []) {
    const clone3 = Object.assign({}, object);
    for (const key of keysToOmit) {
      if (key in clone3) {
        delete clone3[key];
      }
    }
    return clone3;
  }
  function pick(object, keysToPick) {
    const result = {};
    for (const key of keysToPick) {
      if (key in object) {
        result[key] = object[key];
      }
    }
    return result;
  }
  function isObject5(value) {
    return typeof value === "object" && value != null && !Array.isArray(value);
  }
  function walkObject(target, predicate, options = {}) {
    const { stop, getKey } = options;
    function inner(value, path = []) {
      var _a7;
      if (isObject5(value) || Array.isArray(value)) {
        const result = {};
        for (const [prop, child] of Object.entries(value)) {
          const key = (_a7 = getKey == null ? void 0 : getKey(prop)) != null ? _a7 : prop;
          const childPath = [...path, key];
          if (stop == null ? void 0 : stop(value, childPath)) {
            return predicate(value, path);
          }
          result[key] = inner(child, childPath);
        }
        return result;
      }
      return predicate(value, path);
    }
    return inner(target);
  }
  var tokens = [
    "colors",
    "borders",
    "borderWidths",
    "borderStyles",
    "fonts",
    "fontSizes",
    "fontWeights",
    "gradients",
    "letterSpacings",
    "lineHeights",
    "radii",
    "space",
    "shadows",
    "sizes",
    "zIndices",
    "transition",
    "blur",
    "breakpoints"
  ];
  function extractTokens(theme3) {
    const _tokens = tokens;
    return pick(theme3, _tokens);
  }
  function extractSemanticTokens(theme3) {
    return theme3.semanticTokens;
  }
  function omitVars(rawTheme) {
    const { __cssMap, __cssVars, __breakpoints, ...cleanTheme } = rawTheme;
    return cleanTheme;
  }
  var isSemanticCondition = (key) => pseudoPropNames.includes(key) || "default" === key;
  function flattenTokens({
    tokens: tokens2,
    semanticTokens: semanticTokens2
  }) {
    const result = {};
    walkObject(tokens2, (value, path) => {
      if (value == null)
        return;
      result[path.join(".")] = { isSemantic: false, value };
    });
    walkObject(
      semanticTokens2,
      (value, path) => {
        if (value == null)
          return;
        result[path.join(".")] = { isSemantic: true, value };
      },
      {
        stop: (value) => Object.keys(value).every(isSemanticCondition)
      }
    );
    return result;
  }
  function toCSSVar(rawTheme) {
    var _a7;
    const theme3 = omitVars(rawTheme);
    const tokens2 = extractTokens(theme3);
    const semanticTokens2 = extractSemanticTokens(theme3);
    const flatTokens = flattenTokens({ tokens: tokens2, semanticTokens: semanticTokens2 });
    const cssVarPrefix = (_a7 = theme3.config) == null ? void 0 : _a7.cssVarPrefix;
    const {
      /**
       * This is more like a dictionary of tokens users will type `green.500`,
       * and their equivalent css variable.
       */
      cssMap,
      /**
       * The extracted css variables will be stored here, and used in
       * the emotion's <Global/> component to attach variables to `:root`
       */
      cssVars: cssVars2
    } = createThemeVars(flatTokens, { cssVarPrefix });
    const defaultCssVars = {
      "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-ring-offset-width": "0px",
      "--chakra-ring-offset-color": "#fff",
      "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
      "--chakra-ring-offset-shadow": "0 0 #0000",
      "--chakra-ring-shadow": "0 0 #0000",
      "--chakra-space-x-reverse": "0",
      "--chakra-space-y-reverse": "0"
    };
    Object.assign(theme3, {
      __cssVars: { ...defaultCssVars, ...cssVars2 },
      __cssMap: cssMap,
      __breakpoints: analyzeBreakpoints(theme3.breakpoints)
    });
    return theme3;
  }
  var systemProps = (0, import_lodash3.default)(
    {},
    background,
    border,
    color,
    flexbox,
    layout,
    filter,
    ring,
    interactivity,
    grid,
    others,
    position2,
    effect,
    space,
    scroll,
    typography,
    textDecoration,
    transform,
    list,
    transition
  );
  var layoutSystem = Object.assign({}, space, layout, flexbox, grid, position2);
  var layoutPropNames = Object.keys(
    layoutSystem
  );
  var propNames = [...Object.keys(systemProps), ...pseudoPropNames];
  var styleProps = { ...systemProps, ...pseudoSelectors };
  var isStyleProp = (prop) => prop in styleProps;
  var expandResponsive = (styles2) => (theme3) => {
    if (!theme3.__breakpoints)
      return styles2;
    const { isResponsive, toArrayValue, media: medias } = theme3.__breakpoints;
    const computedStyles = {};
    for (const key in styles2) {
      let value = runIfFn(styles2[key], theme3);
      if (value == null)
        continue;
      value = isObject(value) && isResponsive(value) ? toArrayValue(value) : value;
      if (!Array.isArray(value)) {
        computedStyles[key] = value;
        continue;
      }
      const queries = value.slice(0, medias.length).length;
      for (let index = 0; index < queries; index += 1) {
        const media = medias == null ? void 0 : medias[index];
        if (!media) {
          computedStyles[key] = value[index];
          continue;
        }
        computedStyles[media] = computedStyles[media] || {};
        if (value[index] == null) {
          continue;
        }
        computedStyles[media][key] = value[index];
      }
    }
    return computedStyles;
  };
  function splitByComma(value) {
    const chunks = [];
    let chunk = "";
    let inParens = false;
    for (let i = 0; i < value.length; i++) {
      const char2 = value[i];
      if (char2 === "(") {
        inParens = true;
        chunk += char2;
      } else if (char2 === ")") {
        inParens = false;
        chunk += char2;
      } else if (char2 === "," && !inParens) {
        chunks.push(chunk);
        chunk = "";
      } else {
        chunk += char2;
      }
    }
    chunk = chunk.trim();
    if (chunk) {
      chunks.push(chunk);
    }
    return chunks;
  }
  function isCssVar2(value) {
    return /^var\(--.+\)$/.test(value);
  }
  var isCSSVariableTokenValue = (key, value) => key.startsWith("--") && typeof value === "string" && !isCssVar2(value);
  var resolveTokenValue = (theme3, value) => {
    var _a7, _b5;
    if (value == null)
      return value;
    const getVar = (val) => {
      var _a24, _b22;
      return (_b22 = (_a24 = theme3.__cssMap) == null ? void 0 : _a24[val]) == null ? void 0 : _b22.varRef;
    };
    const getValue = (val) => {
      var _a24;
      return (_a24 = getVar(val)) != null ? _a24 : val;
    };
    const [tokenValue, fallbackValue] = splitByComma(value);
    value = (_b5 = (_a7 = getVar(tokenValue)) != null ? _a7 : getValue(fallbackValue)) != null ? _b5 : getValue(value);
    return value;
  };
  function getCss(options) {
    const { configs = {}, pseudos = {}, theme: theme3 } = options;
    const css22 = (stylesOrFn, nested = false) => {
      var _a7, _b5, _c3;
      const _styles = runIfFn(stylesOrFn, theme3);
      const styles2 = expandResponsive(_styles)(theme3);
      let computedStyles = {};
      for (let key in styles2) {
        const valueOrFn = styles2[key];
        let value = runIfFn(valueOrFn, theme3);
        if (key in pseudos) {
          key = pseudos[key];
        }
        if (isCSSVariableTokenValue(key, value)) {
          value = resolveTokenValue(theme3, value);
        }
        let config2 = configs[key];
        if (config2 === true) {
          config2 = { property: key };
        }
        if (isObject(value)) {
          computedStyles[key] = (_a7 = computedStyles[key]) != null ? _a7 : {};
          computedStyles[key] = (0, import_lodash2.default)(
            {},
            computedStyles[key],
            css22(value, true)
          );
          continue;
        }
        let rawValue = (_c3 = (_b5 = config2 == null ? void 0 : config2.transform) == null ? void 0 : _b5.call(config2, value, theme3, _styles)) != null ? _c3 : value;
        rawValue = (config2 == null ? void 0 : config2.processResult) ? css22(rawValue, true) : rawValue;
        const configProperty = runIfFn(config2 == null ? void 0 : config2.property, theme3);
        if (!nested && (config2 == null ? void 0 : config2.static)) {
          const staticStyles = runIfFn(config2.static, theme3);
          computedStyles = (0, import_lodash2.default)({}, computedStyles, staticStyles);
        }
        if (configProperty && Array.isArray(configProperty)) {
          for (const property of configProperty) {
            computedStyles[property] = rawValue;
          }
          continue;
        }
        if (configProperty) {
          if (configProperty === "&" && isObject(rawValue)) {
            computedStyles = (0, import_lodash2.default)({}, computedStyles, rawValue);
          } else {
            computedStyles[configProperty] = rawValue;
          }
          continue;
        }
        if (isObject(rawValue)) {
          computedStyles = (0, import_lodash2.default)({}, computedStyles, rawValue);
          continue;
        }
        computedStyles[key] = rawValue;
      }
      return computedStyles;
    };
    return css22;
  }
  var css3 = (styles2) => (theme3) => {
    const cssFn = getCss({
      theme: theme3,
      pseudos: pseudoSelectors,
      configs: systemProps
    });
    return cssFn(styles2);
  };
  function defineStyle(styles2) {
    return styles2;
  }
  function defineStyleConfig(config2) {
    return config2;
  }
  function createMultiStyleConfigHelpers(parts) {
    return {
      definePartsStyle(config2) {
        return config2;
      },
      defineMultiStyleConfig(config2) {
        return { parts, ...config2 };
      }
    };
  }
  function normalize2(value, toArray) {
    if (Array.isArray(value))
      return value;
    if (isObject(value))
      return toArray(value);
    if (value != null)
      return [value];
  }
  function getNextIndex(values, i) {
    for (let j = i + 1; j < values.length; j++) {
      if (values[j] != null)
        return j;
    }
    return -1;
  }
  function createResolver(theme3) {
    const breakpointUtil = theme3.__breakpoints;
    return function resolver(config2, prop, value, props) {
      var _a7, _b5;
      if (!breakpointUtil)
        return;
      const result = {};
      const normalized = normalize2(value, breakpointUtil.toArrayValue);
      if (!normalized)
        return result;
      const len = normalized.length;
      const isSingle = len === 1;
      const isMultipart = !!config2.parts;
      for (let i = 0; i < len; i++) {
        const key = breakpointUtil.details[i];
        const nextKey = breakpointUtil.details[getNextIndex(normalized, i)];
        const query = toMediaQueryString(key.minW, nextKey == null ? void 0 : nextKey._minW);
        const styles2 = runIfFn((_a7 = config2[prop]) == null ? void 0 : _a7[normalized[i]], props);
        if (!styles2)
          continue;
        if (isMultipart) {
          (_b5 = config2.parts) == null ? void 0 : _b5.forEach((part) => {
            (0, import_lodash4.default)(result, {
              [part]: isSingle ? styles2[part] : { [query]: styles2[part] }
            });
          });
          continue;
        }
        if (!isMultipart) {
          if (isSingle)
            (0, import_lodash4.default)(result, styles2);
          else
            result[query] = styles2;
          continue;
        }
        result[query] = styles2;
      }
      return result;
    };
  }
  function resolveStyleConfig(config2) {
    return (props) => {
      var _a7;
      const { variant, size: size2, theme: theme3 } = props;
      const recipe = createResolver(theme3);
      return (0, import_lodash4.default)(
        {},
        runIfFn((_a7 = config2.baseStyle) != null ? _a7 : {}, props),
        recipe(config2, "sizes", size2, props),
        recipe(config2, "variants", variant, props)
      );
    };
  }
  function getCSSVar(theme3, scale3, value) {
    var _a7, _b5, _c3;
    return (_c3 = (_b5 = (_a7 = theme3.__cssMap) == null ? void 0 : _a7[`${scale3}.${value}`]) == null ? void 0 : _b5.varRef) != null ? _c3 : value;
  }
  function omitThemingProps(props) {
    return omit(props, ["styleConfig", "size", "variant", "colorScheme"]);
  }

  // node_modules/@chakra-ui/theme/dist/chunk-P56GPN75.mjs
  var requiredChakraThemeKeys = [
    "borders",
    "breakpoints",
    "colors",
    "components",
    "config",
    "direction",
    "fonts",
    "fontSizes",
    "fontWeights",
    "letterSpacings",
    "lineHeights",
    "radii",
    "shadows",
    "sizes",
    "space",
    "styles",
    "transition",
    "zIndices"
  ];
  function isChakraTheme(unit2) {
    if (!isObject(unit2)) {
      return false;
    }
    return requiredChakraThemeKeys.every(
      (propertyName) => Object.prototype.hasOwnProperty.call(unit2, propertyName)
    );
  }

  // node_modules/@chakra-ui/theme/dist/chunk-SIH73G3H.mjs
  var transitionProperty = {
    common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
    colors: "background-color, border-color, color, fill, stroke",
    dimensions: "width, height",
    position: "left, right, top, bottom",
    background: "background-color, background-image, background-position"
  };
  var transitionTimingFunction = {
    "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
    "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
  };
  var transitionDuration = {
    "ultra-fast": "50ms",
    faster: "100ms",
    fast: "150ms",
    normal: "200ms",
    slow: "300ms",
    slower: "400ms",
    "ultra-slow": "500ms"
  };
  var transition2 = {
    property: transitionProperty,
    easing: transitionTimingFunction,
    duration: transitionDuration
  };
  var transition_default = transition2;

  // node_modules/@chakra-ui/theme/dist/chunk-45VJLTIL.mjs
  var zIndices = {
    hide: -1,
    auto: "auto",
    base: 0,
    docked: 10,
    dropdown: 1e3,
    sticky: 1100,
    banner: 1200,
    overlay: 1300,
    modal: 1400,
    popover: 1500,
    skipLink: 1600,
    toast: 1700,
    tooltip: 1800
  };
  var z_index_default = zIndices;

  // node_modules/@chakra-ui/theme/dist/chunk-B75T2J64.mjs
  var borders = {
    none: 0,
    "1px": "1px solid",
    "2px": "2px solid",
    "4px": "4px solid",
    "8px": "8px solid"
  };
  var borders_default = borders;

  // node_modules/@chakra-ui/theme/dist/chunk-TXLFBUTF.mjs
  var breakpoints = {
    base: "0em",
    sm: "30em",
    md: "48em",
    lg: "62em",
    xl: "80em",
    "2xl": "96em"
  };
  var breakpoints_default = breakpoints;

  // node_modules/@chakra-ui/theme/dist/chunk-E47HH2QS.mjs
  var colors = {
    transparent: "transparent",
    current: "currentColor",
    black: "#000000",
    white: "#FFFFFF",
    whiteAlpha: {
      50: "rgba(255, 255, 255, 0.04)",
      100: "rgba(255, 255, 255, 0.06)",
      200: "rgba(255, 255, 255, 0.08)",
      300: "rgba(255, 255, 255, 0.16)",
      400: "rgba(255, 255, 255, 0.24)",
      500: "rgba(255, 255, 255, 0.36)",
      600: "rgba(255, 255, 255, 0.48)",
      700: "rgba(255, 255, 255, 0.64)",
      800: "rgba(255, 255, 255, 0.80)",
      900: "rgba(255, 255, 255, 0.92)"
    },
    blackAlpha: {
      50: "rgba(0, 0, 0, 0.04)",
      100: "rgba(0, 0, 0, 0.06)",
      200: "rgba(0, 0, 0, 0.08)",
      300: "rgba(0, 0, 0, 0.16)",
      400: "rgba(0, 0, 0, 0.24)",
      500: "rgba(0, 0, 0, 0.36)",
      600: "rgba(0, 0, 0, 0.48)",
      700: "rgba(0, 0, 0, 0.64)",
      800: "rgba(0, 0, 0, 0.80)",
      900: "rgba(0, 0, 0, 0.92)"
    },
    gray: {
      50: "#F7FAFC",
      100: "#EDF2F7",
      200: "#E2E8F0",
      300: "#CBD5E0",
      400: "#A0AEC0",
      500: "#718096",
      600: "#4A5568",
      700: "#2D3748",
      800: "#1A202C",
      900: "#171923"
    },
    red: {
      50: "#FFF5F5",
      100: "#FED7D7",
      200: "#FEB2B2",
      300: "#FC8181",
      400: "#F56565",
      500: "#E53E3E",
      600: "#C53030",
      700: "#9B2C2C",
      800: "#822727",
      900: "#63171B"
    },
    orange: {
      50: "#FFFAF0",
      100: "#FEEBC8",
      200: "#FBD38D",
      300: "#F6AD55",
      400: "#ED8936",
      500: "#DD6B20",
      600: "#C05621",
      700: "#9C4221",
      800: "#7B341E",
      900: "#652B19"
    },
    yellow: {
      50: "#FFFFF0",
      100: "#FEFCBF",
      200: "#FAF089",
      300: "#F6E05E",
      400: "#ECC94B",
      500: "#D69E2E",
      600: "#B7791F",
      700: "#975A16",
      800: "#744210",
      900: "#5F370E"
    },
    green: {
      50: "#F0FFF4",
      100: "#C6F6D5",
      200: "#9AE6B4",
      300: "#68D391",
      400: "#48BB78",
      500: "#38A169",
      600: "#2F855A",
      700: "#276749",
      800: "#22543D",
      900: "#1C4532"
    },
    teal: {
      50: "#E6FFFA",
      100: "#B2F5EA",
      200: "#81E6D9",
      300: "#4FD1C5",
      400: "#38B2AC",
      500: "#319795",
      600: "#2C7A7B",
      700: "#285E61",
      800: "#234E52",
      900: "#1D4044"
    },
    blue: {
      50: "#ebf8ff",
      100: "#bee3f8",
      200: "#90cdf4",
      300: "#63b3ed",
      400: "#4299e1",
      500: "#3182ce",
      600: "#2b6cb0",
      700: "#2c5282",
      800: "#2a4365",
      900: "#1A365D"
    },
    cyan: {
      50: "#EDFDFD",
      100: "#C4F1F9",
      200: "#9DECF9",
      300: "#76E4F7",
      400: "#0BC5EA",
      500: "#00B5D8",
      600: "#00A3C4",
      700: "#0987A0",
      800: "#086F83",
      900: "#065666"
    },
    purple: {
      50: "#FAF5FF",
      100: "#E9D8FD",
      200: "#D6BCFA",
      300: "#B794F4",
      400: "#9F7AEA",
      500: "#805AD5",
      600: "#6B46C1",
      700: "#553C9A",
      800: "#44337A",
      900: "#322659"
    },
    pink: {
      50: "#FFF5F7",
      100: "#FED7E2",
      200: "#FBB6CE",
      300: "#F687B3",
      400: "#ED64A6",
      500: "#D53F8C",
      600: "#B83280",
      700: "#97266D",
      800: "#702459",
      900: "#521B41"
    },
    linkedin: {
      50: "#E8F4F9",
      100: "#CFEDFB",
      200: "#9BDAF3",
      300: "#68C7EC",
      400: "#34B3E4",
      500: "#00A0DC",
      600: "#008CC9",
      700: "#0077B5",
      800: "#005E93",
      900: "#004471"
    },
    facebook: {
      50: "#E8F4F9",
      100: "#D9DEE9",
      200: "#B7C2DA",
      300: "#6482C0",
      400: "#4267B2",
      500: "#385898",
      600: "#314E89",
      700: "#29487D",
      800: "#223B67",
      900: "#1E355B"
    },
    messenger: {
      50: "#D0E6FF",
      100: "#B9DAFF",
      200: "#A2CDFF",
      300: "#7AB8FF",
      400: "#2E90FF",
      500: "#0078FF",
      600: "#0063D1",
      700: "#0052AC",
      800: "#003C7E",
      900: "#002C5C"
    },
    whatsapp: {
      50: "#dffeec",
      100: "#b9f5d0",
      200: "#90edb3",
      300: "#65e495",
      400: "#3cdd78",
      500: "#22c35e",
      600: "#179848",
      700: "#0c6c33",
      800: "#01421c",
      900: "#001803"
    },
    twitter: {
      50: "#E5F4FD",
      100: "#C8E9FB",
      200: "#A8DCFA",
      300: "#83CDF7",
      400: "#57BBF5",
      500: "#1DA1F2",
      600: "#1A94DA",
      700: "#1681BF",
      800: "#136B9E",
      900: "#0D4D71"
    },
    telegram: {
      50: "#E3F2F9",
      100: "#C5E4F3",
      200: "#A2D4EC",
      300: "#7AC1E4",
      400: "#47A9DA",
      500: "#0088CC",
      600: "#007AB8",
      700: "#006BA1",
      800: "#005885",
      900: "#003F5E"
    }
  };
  var colors_default = colors;

  // node_modules/@chakra-ui/theme/dist/chunk-VIVTPWHP.mjs
  var radii = {
    none: "0",
    sm: "0.125rem",
    base: "0.25rem",
    md: "0.375rem",
    lg: "0.5rem",
    xl: "0.75rem",
    "2xl": "1rem",
    "3xl": "1.5rem",
    full: "9999px"
  };
  var radius_default = radii;

  // node_modules/@chakra-ui/theme/dist/chunk-IZUFFCXS.mjs
  var shadows = {
    xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
    sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
    base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
    md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
    lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
    xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
    "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
    outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
    inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
    none: "none",
    "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
  };
  var shadows_default = shadows;

  // node_modules/@chakra-ui/theme/dist/chunk-HQ6WXDYV.mjs
  var blur = {
    none: 0,
    sm: "4px",
    base: "8px",
    md: "12px",
    lg: "16px",
    xl: "24px",
    "2xl": "40px",
    "3xl": "64px"
  };
  var blur_default = blur;

  // node_modules/@chakra-ui/theme/dist/chunk-6XA2KDUD.mjs
  var typography2 = {
    letterSpacings: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    lineHeights: {
      normal: "normal",
      none: 1,
      shorter: 1.25,
      short: 1.375,
      base: 1.5,
      tall: 1.625,
      taller: "2",
      "3": ".75rem",
      "4": "1rem",
      "5": "1.25rem",
      "6": "1.5rem",
      "7": "1.75rem",
      "8": "2rem",
      "9": "2.25rem",
      "10": "2.5rem"
    },
    fontWeights: {
      hairline: 100,
      thin: 200,
      light: 300,
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700,
      extrabold: 800,
      black: 900
    },
    fonts: {
      heading: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
      body: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
      mono: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
    },
    fontSizes: {
      "3xs": "0.45rem",
      "2xs": "0.625rem",
      xs: "0.75rem",
      sm: "0.875rem",
      md: "1rem",
      lg: "1.125rem",
      xl: "1.25rem",
      "2xl": "1.5rem",
      "3xl": "1.875rem",
      "4xl": "2.25rem",
      "5xl": "3rem",
      "6xl": "3.75rem",
      "7xl": "4.5rem",
      "8xl": "6rem",
      "9xl": "8rem"
    }
  };
  var typography_default = typography2;

  // node_modules/@chakra-ui/theme/dist/chunk-V7WMN6TQ.mjs
  var spacing = {
    px: "1px",
    0.5: "0.125rem",
    1: "0.25rem",
    1.5: "0.375rem",
    2: "0.5rem",
    2.5: "0.625rem",
    3: "0.75rem",
    3.5: "0.875rem",
    4: "1rem",
    5: "1.25rem",
    6: "1.5rem",
    7: "1.75rem",
    8: "2rem",
    9: "2.25rem",
    10: "2.5rem",
    12: "3rem",
    14: "3.5rem",
    16: "4rem",
    20: "5rem",
    24: "6rem",
    28: "7rem",
    32: "8rem",
    36: "9rem",
    40: "10rem",
    44: "11rem",
    48: "12rem",
    52: "13rem",
    56: "14rem",
    60: "15rem",
    64: "16rem",
    72: "18rem",
    80: "20rem",
    96: "24rem"
  };

  // node_modules/@chakra-ui/theme/dist/chunk-NJCYBKFH.mjs
  var largeSizes = {
    max: "max-content",
    min: "min-content",
    full: "100%",
    "3xs": "14rem",
    "2xs": "16rem",
    xs: "20rem",
    sm: "24rem",
    md: "28rem",
    lg: "32rem",
    xl: "36rem",
    "2xl": "42rem",
    "3xl": "48rem",
    "4xl": "56rem",
    "5xl": "64rem",
    "6xl": "72rem",
    "7xl": "80rem",
    "8xl": "90rem",
    prose: "60ch"
  };
  var container = {
    sm: "640px",
    md: "768px",
    lg: "1024px",
    xl: "1280px"
  };
  var sizes = {
    ...spacing,
    ...largeSizes,
    container
  };
  var sizes_default = sizes;

  // node_modules/@chakra-ui/theme/dist/chunk-3WO5B3NB.mjs
  var foundations = {
    breakpoints: breakpoints_default,
    zIndices: z_index_default,
    radii: radius_default,
    blur: blur_default,
    colors: colors_default,
    ...typography_default,
    sizes: sizes_default,
    shadows: shadows_default,
    space: spacing,
    borders: borders_default,
    transition: transition_default
  };

  // node_modules/@chakra-ui/theme/dist/chunk-Q5NOVGYN.mjs
  var { defineMultiStyleConfig, definePartsStyle } = createMultiStyleConfigHelpers([
    "stepper",
    "step",
    "title",
    "description",
    "indicator",
    "separator",
    "icon",
    "number"
  ]);
  var $size = cssVar("stepper-indicator-size");
  var $iconSize = cssVar("stepper-icon-size");
  var $titleFontSize = cssVar("stepper-title-font-size");
  var $descFontSize = cssVar("stepper-description-font-size");
  var $accentColor = cssVar("stepper-accent-color");
  var baseStyle = definePartsStyle(({ colorScheme: c }) => ({
    stepper: {
      display: "flex",
      justifyContent: "space-between",
      gap: "4",
      "&[data-orientation=vertical]": {
        flexDirection: "column",
        alignItems: "flex-start"
      },
      "&[data-orientation=horizontal]": {
        flexDirection: "row",
        alignItems: "center"
      },
      [$accentColor.variable]: `colors.${c}.500`,
      _dark: {
        [$accentColor.variable]: `colors.${c}.200`
      }
    },
    title: {
      fontSize: $titleFontSize.reference,
      fontWeight: "medium"
    },
    description: {
      fontSize: $descFontSize.reference,
      color: "chakra-subtle-text"
    },
    number: {
      fontSize: $titleFontSize.reference
    },
    step: {
      flexShrink: 0,
      position: "relative",
      display: "flex",
      gap: "2",
      "&[data-orientation=horizontal]": {
        alignItems: "center"
      },
      flex: "1",
      "&:last-of-type:not([data-stretch])": {
        flex: "initial"
      }
    },
    icon: {
      flexShrink: 0,
      width: $iconSize.reference,
      height: $iconSize.reference
    },
    indicator: {
      flexShrink: 0,
      borderRadius: "full",
      width: $size.reference,
      height: $size.reference,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      "&[data-status=active]": {
        borderWidth: "2px",
        borderColor: $accentColor.reference
      },
      "&[data-status=complete]": {
        bg: $accentColor.reference,
        color: "chakra-inverse-text"
      },
      "&[data-status=incomplete]": {
        borderWidth: "2px"
      }
    },
    separator: {
      bg: "chakra-border-color",
      flex: "1",
      "&[data-status=complete]": {
        bg: $accentColor.reference
      },
      "&[data-orientation=horizontal]": {
        width: "100%",
        height: "2px",
        marginStart: "2"
      },
      "&[data-orientation=vertical]": {
        width: "2px",
        position: "absolute",
        height: "100%",
        maxHeight: `calc(100% - ${$size.reference} - 8px)`,
        top: `calc(${$size.reference} + 4px)`,
        insetStart: `calc(${$size.reference} / 2 - 1px)`
      }
    }
  }));
  var stepperTheme = defineMultiStyleConfig({
    baseStyle,
    sizes: {
      xs: definePartsStyle({
        stepper: {
          [$size.variable]: "sizes.4",
          [$iconSize.variable]: "sizes.3",
          [$titleFontSize.variable]: "fontSizes.xs",
          [$descFontSize.variable]: "fontSizes.xs"
        }
      }),
      sm: definePartsStyle({
        stepper: {
          [$size.variable]: "sizes.6",
          [$iconSize.variable]: "sizes.4",
          [$titleFontSize.variable]: "fontSizes.sm",
          [$descFontSize.variable]: "fontSizes.xs"
        }
      }),
      md: definePartsStyle({
        stepper: {
          [$size.variable]: "sizes.8",
          [$iconSize.variable]: "sizes.5",
          [$titleFontSize.variable]: "fontSizes.md",
          [$descFontSize.variable]: "fontSizes.sm"
        }
      }),
      lg: definePartsStyle({
        stepper: {
          [$size.variable]: "sizes.10",
          [$iconSize.variable]: "sizes.6",
          [$titleFontSize.variable]: "fontSizes.lg",
          [$descFontSize.variable]: "fontSizes.md"
        }
      })
    },
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  });

  // node_modules/@chakra-ui/anatomy/dist/chunk-OA3DH5LS.mjs
  function anatomy(name, map2 = {}) {
    let called = false;
    function assert() {
      if (!called) {
        called = true;
        return;
      }
      throw new Error(
        "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
      );
    }
    function parts(...values) {
      assert();
      for (const part of values) {
        ;
        map2[part] = toPart(part);
      }
      return anatomy(name, map2);
    }
    function extend2(...parts2) {
      for (const part of parts2) {
        if (part in map2)
          continue;
        map2[part] = toPart(part);
      }
      return anatomy(name, map2);
    }
    function selectors() {
      const value = Object.fromEntries(
        Object.entries(map2).map(([key, part]) => [key, part.selector])
      );
      return value;
    }
    function classnames3() {
      const value = Object.fromEntries(
        Object.entries(map2).map(([key, part]) => [key, part.className])
      );
      return value;
    }
    function toPart(part) {
      const el = ["container", "root"].includes(part != null ? part : "") ? [name] : [name, part];
      const attr = el.filter(Boolean).join("__");
      const className = `chakra-${attr}`;
      const partObj = {
        className,
        selector: `.${className}`,
        toString: () => part
      };
      return partObj;
    }
    const __type = {};
    return {
      parts,
      toPart,
      extend: extend2,
      selectors,
      classnames: classnames3,
      get keys() {
        return Object.keys(map2);
      },
      __type
    };
  }

  // node_modules/@chakra-ui/anatomy/dist/chunk-7OOI6RFH.mjs
  var accordionAnatomy = anatomy("accordion").parts("root", "container", "button", "panel").extend("icon");
  var alertAnatomy = anatomy("alert").parts("title", "description", "container").extend("icon", "spinner");
  var avatarAnatomy = anatomy("avatar").parts("label", "badge", "container").extend("excessLabel", "group");
  var breadcrumbAnatomy = anatomy("breadcrumb").parts("link", "item", "container").extend("separator");
  var buttonAnatomy = anatomy("button").parts();
  var checkboxAnatomy = anatomy("checkbox").parts("control", "icon", "container").extend("label");
  var circularProgressAnatomy = anatomy("progress").parts("track", "filledTrack").extend("label");
  var drawerAnatomy = anatomy("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
  var editableAnatomy = anatomy("editable").parts(
    "preview",
    "input",
    "textarea"
  );
  var formAnatomy = anatomy("form").parts(
    "container",
    "requiredIndicator",
    "helperText"
  );
  var formErrorAnatomy = anatomy("formError").parts("text", "icon");
  var inputAnatomy = anatomy("input").parts(
    "addon",
    "field",
    "element",
    "group"
  );
  var listAnatomy = anatomy("list").parts("container", "item", "icon");
  var menuAnatomy = anatomy("menu").parts("button", "list", "item").extend("groupTitle", "icon", "command", "divider");
  var modalAnatomy = anatomy("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
  var numberInputAnatomy = anatomy("numberinput").parts(
    "root",
    "field",
    "stepperGroup",
    "stepper"
  );
  var pinInputAnatomy = anatomy("pininput").parts("field");
  var popoverAnatomy = anatomy("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton");
  var progressAnatomy = anatomy("progress").parts(
    "label",
    "filledTrack",
    "track"
  );
  var radioAnatomy = anatomy("radio").parts(
    "container",
    "control",
    "label"
  );
  var selectAnatomy = anatomy("select").parts("field", "icon");
  var sliderAnatomy = anatomy("slider").parts(
    "container",
    "track",
    "thumb",
    "filledTrack",
    "mark"
  );
  var statAnatomy = anatomy("stat").parts(
    "container",
    "label",
    "helpText",
    "number",
    "icon"
  );
  var switchAnatomy = anatomy("switch").parts(
    "container",
    "track",
    "thumb",
    "label"
  );
  var tableAnatomy = anatomy("table").parts(
    "table",
    "thead",
    "tbody",
    "tr",
    "th",
    "td",
    "tfoot",
    "caption"
  );
  var tabsAnatomy = anatomy("tabs").parts(
    "root",
    "tab",
    "tablist",
    "tabpanel",
    "tabpanels",
    "indicator"
  );
  var tagAnatomy = anatomy("tag").parts(
    "container",
    "label",
    "closeButton"
  );
  var cardAnatomy = anatomy("card").parts(
    "container",
    "header",
    "body",
    "footer"
  );
  var stepperAnatomy = anatomy("stepper").parts(
    "stepper",
    "step",
    "title",
    "description",
    "indicator",
    "separator",
    "icon",
    "number"
  );

  // node_modules/color2k/dist/index.exports.import.es.mjs
  function guard(low, high, value) {
    return Math.min(Math.max(low, value), high);
  }
  var ColorError = class extends Error {
    constructor(color4) {
      super(`Failed to parse color: "${color4}"`);
    }
  };
  var ColorError$1 = ColorError;
  function parseToRgba(color4) {
    if (typeof color4 !== "string")
      throw new ColorError$1(color4);
    if (color4.trim().toLowerCase() === "transparent")
      return [0, 0, 0, 0];
    let normalizedColor = color4.trim();
    normalizedColor = namedColorRegex.test(color4) ? nameToHex(color4) : color4;
    const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
    if (reducedHexMatch) {
      const arr = Array.from(reducedHexMatch).slice(1);
      return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
    }
    const hexMatch = hexRegex.exec(normalizedColor);
    if (hexMatch) {
      const arr = Array.from(hexMatch).slice(1);
      return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
    }
    const rgbaMatch = rgbaRegex.exec(normalizedColor);
    if (rgbaMatch) {
      const arr = Array.from(rgbaMatch).slice(1);
      return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
    }
    const hslaMatch = hslaRegex.exec(normalizedColor);
    if (hslaMatch) {
      const [h, s2, l2, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
      if (guard(0, 100, s2) !== s2)
        throw new ColorError$1(color4);
      if (guard(0, 100, l2) !== l2)
        throw new ColorError$1(color4);
      return [...hslToRgb(h, s2, l2), Number.isNaN(a) ? 1 : a];
    }
    throw new ColorError$1(color4);
  }
  function hash2(str) {
    let hash5 = 5381;
    let i = str.length;
    while (i) {
      hash5 = hash5 * 33 ^ str.charCodeAt(--i);
    }
    return (hash5 >>> 0) % 2341;
  }
  var colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
  var compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next2) => {
    const key = colorToInt(next2.substring(0, 3));
    const hex3 = colorToInt(next2.substring(3)).toString(16);
    let prefix2 = "";
    for (let i = 0; i < 6 - hex3.length; i++) {
      prefix2 += "0";
    }
    acc[key] = `${prefix2}${hex3}`;
    return acc;
  }, {});
  function nameToHex(color4) {
    const normalizedColorName = color4.toLowerCase().trim();
    const result = compressedColorMap[hash2(normalizedColorName)];
    if (!result)
      throw new ColorError$1(color4);
    return `#${result}`;
  }
  var r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
  var reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
  var hexRegex = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
  var rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
  var hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
  var namedColorRegex = /^[a-z]+$/i;
  var roundColor = (color4) => {
    return Math.round(color4 * 255);
  };
  var hslToRgb = (hue2, saturation, lightness) => {
    let l2 = lightness / 100;
    if (saturation === 0) {
      return [l2, l2, l2].map(roundColor);
    }
    const huePrime = (hue2 % 360 + 360) % 360 / 60;
    const chroma = (1 - Math.abs(2 * l2 - 1)) * (saturation / 100);
    const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
    let red = 0;
    let green = 0;
    let blue = 0;
    if (huePrime >= 0 && huePrime < 1) {
      red = chroma;
      green = secondComponent;
    } else if (huePrime >= 1 && huePrime < 2) {
      red = secondComponent;
      green = chroma;
    } else if (huePrime >= 2 && huePrime < 3) {
      green = chroma;
      blue = secondComponent;
    } else if (huePrime >= 3 && huePrime < 4) {
      green = secondComponent;
      blue = chroma;
    } else if (huePrime >= 4 && huePrime < 5) {
      red = secondComponent;
      blue = chroma;
    } else if (huePrime >= 5 && huePrime < 6) {
      red = chroma;
      blue = secondComponent;
    }
    const lightnessModification = l2 - chroma / 2;
    const finalRed = red + lightnessModification;
    const finalGreen = green + lightnessModification;
    const finalBlue = blue + lightnessModification;
    return [finalRed, finalGreen, finalBlue].map(roundColor);
  };
  function rgba(red, green, blue, alpha2) {
    return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha2).toFixed(3))})`;
  }
  function transparentize(color4, amount) {
    const [r3, g, b, a] = parseToRgba(color4);
    return rgba(r3, g, b, a - amount);
  }
  function toHex(color4) {
    const [r3, g, b, a] = parseToRgba(color4);
    let hex3 = (x) => {
      const h = guard(0, 255, x).toString(16);
      return h.length === 1 ? `0${h}` : h;
    };
    return `#${hex3(r3)}${hex3(g)}${hex3(b)}${a < 1 ? hex3(Math.round(a * 255)) : ""}`;
  }

  // node_modules/@chakra-ui/theme-tools/dist/chunk-6IC2I3BY.mjs
  function dlv_es_default(t4, e3, l2, n2, r3) {
    for (e3 = e3.split ? e3.split(".") : e3, n2 = 0; n2 < e3.length; n2++)
      t4 = t4 ? t4[e3[n2]] : r3;
    return t4 === r3 ? l2 : t4;
  }
  var isEmptyObject = (obj) => Object.keys(obj).length === 0;
  var getColor = (theme3, color4, fallback) => {
    const hex3 = dlv_es_default(theme3, `colors.${color4}`, color4);
    try {
      toHex(hex3);
      return hex3;
    } catch {
      return fallback != null ? fallback : "#000000";
    }
  };
  var getBrightness = (color4) => {
    const [r3, g, b] = parseToRgba(color4);
    return (r3 * 299 + g * 587 + b * 114) / 1e3;
  };
  var tone = (color4) => (theme3) => {
    const hex3 = getColor(theme3, color4);
    const brightness = getBrightness(hex3);
    const isDark2 = brightness < 128;
    return isDark2 ? "dark" : "light";
  };
  var isDark = (color4) => (theme3) => tone(color4)(theme3) === "dark";
  var transparentize2 = (color4, opacity) => (theme3) => {
    const raw = getColor(theme3, color4);
    return transparentize(raw, 1 - opacity);
  };
  function generateStripe(size2 = "1rem", color4 = "rgba(255, 255, 255, 0.15)") {
    return {
      backgroundImage: `linear-gradient(
    45deg,
    ${color4} 25%,
    transparent 25%,
    transparent 50%,
    ${color4} 50%,
    ${color4} 75%,
    transparent 75%,
    transparent
  )`,
      backgroundSize: `${size2} ${size2}`
    };
  }
  var randomHex = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
  function randomColor(opts) {
    const fallback = randomHex();
    if (!opts || isEmptyObject(opts)) {
      return fallback;
    }
    if (opts.string && opts.colors) {
      return randomColorFromList(opts.string, opts.colors);
    }
    if (opts.string && !opts.colors) {
      return randomColorFromString(opts.string);
    }
    if (opts.colors && !opts.string) {
      return randomFromList(opts.colors);
    }
    return fallback;
  }
  function randomColorFromString(str) {
    let hash5 = 0;
    if (str.length === 0)
      return hash5.toString();
    for (let i = 0; i < str.length; i += 1) {
      hash5 = str.charCodeAt(i) + ((hash5 << 5) - hash5);
      hash5 = hash5 & hash5;
    }
    let color4 = "#";
    for (let j = 0; j < 3; j += 1) {
      const value = hash5 >> j * 8 & 255;
      color4 += `00${value.toString(16)}`.substr(-2);
    }
    return color4;
  }
  function randomColorFromList(str, list2) {
    let index = 0;
    if (str.length === 0)
      return list2[0];
    for (let i = 0; i < str.length; i += 1) {
      index = str.charCodeAt(i) + ((index << 5) - index);
      index = index & index;
    }
    index = (index % list2.length + list2.length) % list2.length;
    return list2[index];
  }
  function randomFromList(list2) {
    return list2[Math.floor(Math.random() * list2.length)];
  }

  // node_modules/@chakra-ui/theme-tools/dist/chunk-FNB7ZWWX.mjs
  function mode(light, dark) {
    return (props) => props.colorMode === "dark" ? dark : light;
  }
  function orient(options) {
    const { orientation, vertical, horizontal } = options;
    if (!orientation)
      return {};
    return orientation === "vertical" ? vertical : horizontal;
  }

  // node_modules/@chakra-ui/theme-tools/dist/chunk-XMZHFSTS.mjs
  function toRef(operand) {
    if (isObject(operand) && operand.reference) {
      return operand.reference;
    }
    return String(operand);
  }
  var toExpr = (operator, ...operands) => operands.map(toRef).join(` ${operator} `).replace(/calc/g, "");
  var add2 = (...operands) => `calc(${toExpr("+", ...operands)})`;
  var subtract3 = (...operands) => `calc(${toExpr("-", ...operands)})`;
  var multiply2 = (...operands) => `calc(${toExpr("*", ...operands)})`;
  var divide2 = (...operands) => `calc(${toExpr("/", ...operands)})`;
  var negate2 = (x) => {
    const value = toRef(x);
    if (value != null && !Number.isNaN(parseFloat(value))) {
      return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
    }
    return multiply2(value, -1);
  };
  var calc2 = Object.assign(
    (x) => ({
      add: (...operands) => calc2(add2(x, ...operands)),
      subtract: (...operands) => calc2(subtract3(x, ...operands)),
      multiply: (...operands) => calc2(multiply2(x, ...operands)),
      divide: (...operands) => calc2(divide2(x, ...operands)),
      negate: () => calc2(negate2(x)),
      toString: () => x.toString()
    }),
    {
      add: add2,
      subtract: subtract3,
      multiply: multiply2,
      divide: divide2,
      negate: negate2
    }
  );

  // node_modules/@chakra-ui/theme-tools/dist/chunk-WSAJBJJ4.mjs
  function isDecimal(value) {
    return !Number.isInteger(parseFloat(value.toString()));
  }
  function replaceWhiteSpace2(value, replaceValue = "-") {
    return value.replace(/\s+/g, replaceValue);
  }
  function escape2(value) {
    const valueStr = replaceWhiteSpace2(value.toString());
    if (valueStr.includes("\\."))
      return value;
    return isDecimal(value) ? valueStr.replace(".", `\\.`) : value;
  }
  function addPrefix2(value, prefix2 = "") {
    return [prefix2, escape2(value)].filter(Boolean).join("-");
  }
  function toVarRef(name, fallback) {
    return `var(${escape2(name)}${fallback ? `, ${fallback}` : ""})`;
  }
  function toVar(value, prefix2 = "") {
    return `--${addPrefix2(value, prefix2)}`;
  }
  function cssVar2(name, options) {
    const cssVariable = toVar(name, options == null ? void 0 : options.prefix);
    return {
      variable: cssVariable,
      reference: toVarRef(cssVariable, getFallback(options == null ? void 0 : options.fallback))
    };
  }
  function getFallback(fallback) {
    if (typeof fallback === "string")
      return fallback;
    return fallback == null ? void 0 : fallback.reference;
  }

  // node_modules/@chakra-ui/theme/dist/chunk-SG67NFYS.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig2, definePartsStyle: definePartsStyle2 } = createMultiStyleConfigHelpers(switchAnatomy.keys);
  var $width = cssVar2("switch-track-width");
  var $height = cssVar2("switch-track-height");
  var $diff = cssVar2("switch-track-diff");
  var diffValue = calc2.subtract($width, $height);
  var $translateX = cssVar2("switch-thumb-x");
  var $bg = cssVar2("switch-bg");
  var baseStyleTrack = defineStyle((props) => {
    const { colorScheme: c } = props;
    return {
      borderRadius: "full",
      p: "0.5",
      width: [$width.reference],
      height: [$height.reference],
      transitionProperty: "common",
      transitionDuration: "fast",
      [$bg.variable]: "colors.gray.300",
      _dark: {
        [$bg.variable]: "colors.whiteAlpha.400"
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      },
      _checked: {
        [$bg.variable]: `colors.${c}.500`,
        _dark: {
          [$bg.variable]: `colors.${c}.200`
        }
      },
      bg: $bg.reference
    };
  });
  var baseStyleThumb = defineStyle({
    bg: "white",
    transitionProperty: "transform",
    transitionDuration: "normal",
    borderRadius: "inherit",
    width: [$height.reference],
    height: [$height.reference],
    _checked: {
      transform: `translateX(${$translateX.reference})`
    }
  });
  var baseStyle2 = definePartsStyle2((props) => ({
    container: {
      [$diff.variable]: diffValue,
      [$translateX.variable]: $diff.reference,
      _rtl: {
        [$translateX.variable]: calc2($diff).negate().toString()
      }
    },
    track: baseStyleTrack(props),
    thumb: baseStyleThumb
  }));
  var sizes2 = {
    sm: definePartsStyle2({
      container: {
        [$width.variable]: "1.375rem",
        [$height.variable]: "sizes.3"
      }
    }),
    md: definePartsStyle2({
      container: {
        [$width.variable]: "1.875rem",
        [$height.variable]: "sizes.4"
      }
    }),
    lg: definePartsStyle2({
      container: {
        [$width.variable]: "2.875rem",
        [$height.variable]: "sizes.6"
      }
    })
  };
  var switchTheme = defineMultiStyleConfig2({
    baseStyle: baseStyle2,
    sizes: sizes2,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-QWN3S45W.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig3, definePartsStyle: definePartsStyle3 } = createMultiStyleConfigHelpers(tableAnatomy.keys);
  var baseStyle3 = definePartsStyle3({
    table: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full"
    },
    th: {
      fontFamily: "heading",
      fontWeight: "bold",
      textTransform: "uppercase",
      letterSpacing: "wider",
      textAlign: "start"
    },
    td: {
      textAlign: "start"
    },
    caption: {
      mt: 4,
      fontFamily: "heading",
      textAlign: "center",
      fontWeight: "medium"
    }
  });
  var numericStyles = defineStyle({
    "&[data-is-numeric=true]": {
      textAlign: "end"
    }
  });
  var variantSimple = definePartsStyle3((props) => {
    const { colorScheme: c } = props;
    return {
      th: {
        color: mode("gray.600", "gray.400")(props),
        borderBottom: "1px",
        borderColor: mode(`${c}.100`, `${c}.700`)(props),
        ...numericStyles
      },
      td: {
        borderBottom: "1px",
        borderColor: mode(`${c}.100`, `${c}.700`)(props),
        ...numericStyles
      },
      caption: {
        color: mode("gray.600", "gray.100")(props)
      },
      tfoot: {
        tr: {
          "&:last-of-type": {
            th: { borderBottomWidth: 0 }
          }
        }
      }
    };
  });
  var variantStripe = definePartsStyle3((props) => {
    const { colorScheme: c } = props;
    return {
      th: {
        color: mode("gray.600", "gray.400")(props),
        borderBottom: "1px",
        borderColor: mode(`${c}.100`, `${c}.700`)(props),
        ...numericStyles
      },
      td: {
        borderBottom: "1px",
        borderColor: mode(`${c}.100`, `${c}.700`)(props),
        ...numericStyles
      },
      caption: {
        color: mode("gray.600", "gray.100")(props)
      },
      tbody: {
        tr: {
          "&:nth-of-type(odd)": {
            "th, td": {
              borderBottomWidth: "1px",
              borderColor: mode(`${c}.100`, `${c}.700`)(props)
            },
            td: {
              background: mode(`${c}.100`, `${c}.700`)(props)
            }
          }
        }
      },
      tfoot: {
        tr: {
          "&:last-of-type": {
            th: { borderBottomWidth: 0 }
          }
        }
      }
    };
  });
  var variants = {
    simple: variantSimple,
    striped: variantStripe,
    unstyled: defineStyle({})
  };
  var sizes3 = {
    sm: definePartsStyle3({
      th: {
        px: "4",
        py: "1",
        lineHeight: "4",
        fontSize: "xs"
      },
      td: {
        px: "4",
        py: "2",
        fontSize: "sm",
        lineHeight: "4"
      },
      caption: {
        px: "4",
        py: "2",
        fontSize: "xs"
      }
    }),
    md: definePartsStyle3({
      th: {
        px: "6",
        py: "3",
        lineHeight: "4",
        fontSize: "xs"
      },
      td: {
        px: "6",
        py: "4",
        lineHeight: "5"
      },
      caption: {
        px: "6",
        py: "2",
        fontSize: "sm"
      }
    }),
    lg: definePartsStyle3({
      th: {
        px: "8",
        py: "4",
        lineHeight: "5",
        fontSize: "sm"
      },
      td: {
        px: "8",
        py: "5",
        lineHeight: "6"
      },
      caption: {
        px: "6",
        py: "2",
        fontSize: "md"
      }
    })
  };
  var tableTheme = defineMultiStyleConfig3({
    baseStyle: baseStyle3,
    variants,
    sizes: sizes3,
    defaultProps: {
      variant: "simple",
      size: "md",
      colorScheme: "gray"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-GYISOX2E.mjs
  var $fg = cssVar("tabs-color");
  var $bg2 = cssVar("tabs-bg");
  var $border = cssVar("tabs-border-color");
  var { defineMultiStyleConfig: defineMultiStyleConfig4, definePartsStyle: definePartsStyle4 } = createMultiStyleConfigHelpers(tabsAnatomy.keys);
  var baseStyleRoot = defineStyle((props) => {
    const { orientation } = props;
    return {
      display: orientation === "vertical" ? "flex" : "block"
    };
  });
  var baseStyleTab = defineStyle((props) => {
    const { isFitted } = props;
    return {
      flex: isFitted ? 1 : void 0,
      transitionProperty: "common",
      transitionDuration: "normal",
      _focusVisible: {
        zIndex: 1,
        boxShadow: "outline"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.4
      }
    };
  });
  var baseStyleTablist = defineStyle((props) => {
    const { align = "start", orientation } = props;
    const alignments = {
      end: "flex-end",
      center: "center",
      start: "flex-start"
    };
    return {
      justifyContent: alignments[align],
      flexDirection: orientation === "vertical" ? "column" : "row"
    };
  });
  var baseStyleTabpanel = defineStyle({
    p: 4
  });
  var baseStyle4 = definePartsStyle4((props) => ({
    root: baseStyleRoot(props),
    tab: baseStyleTab(props),
    tablist: baseStyleTablist(props),
    tabpanel: baseStyleTabpanel
  }));
  var sizes4 = {
    sm: definePartsStyle4({
      tab: {
        py: 1,
        px: 4,
        fontSize: "sm"
      }
    }),
    md: definePartsStyle4({
      tab: {
        fontSize: "md",
        py: 2,
        px: 4
      }
    }),
    lg: definePartsStyle4({
      tab: {
        fontSize: "lg",
        py: 3,
        px: 4
      }
    })
  };
  var variantLine = definePartsStyle4((props) => {
    const { colorScheme: c, orientation } = props;
    const isVertical = orientation === "vertical";
    const borderProp = isVertical ? "borderStart" : "borderBottom";
    const marginProp = isVertical ? "marginStart" : "marginBottom";
    return {
      tablist: {
        [borderProp]: "2px solid",
        borderColor: "inherit"
      },
      tab: {
        [borderProp]: "2px solid",
        borderColor: "transparent",
        [marginProp]: "-2px",
        _selected: {
          [$fg.variable]: `colors.${c}.600`,
          _dark: {
            [$fg.variable]: `colors.${c}.300`
          },
          borderColor: "currentColor"
        },
        _active: {
          [$bg2.variable]: "colors.gray.200",
          _dark: {
            [$bg2.variable]: "colors.whiteAlpha.300"
          }
        },
        _disabled: {
          _active: { bg: "none" }
        },
        color: $fg.reference,
        bg: $bg2.reference
      }
    };
  });
  var variantEnclosed = definePartsStyle4((props) => {
    const { colorScheme: c } = props;
    return {
      tab: {
        borderTopRadius: "md",
        border: "1px solid",
        borderColor: "transparent",
        mb: "-1px",
        [$border.variable]: "transparent",
        _selected: {
          [$fg.variable]: `colors.${c}.600`,
          [$border.variable]: `colors.white`,
          _dark: {
            [$fg.variable]: `colors.${c}.300`,
            [$border.variable]: `colors.gray.800`
          },
          borderColor: "inherit",
          borderBottomColor: $border.reference
        },
        color: $fg.reference
      },
      tablist: {
        mb: "-1px",
        borderBottom: "1px solid",
        borderColor: "inherit"
      }
    };
  });
  var variantEnclosedColored = definePartsStyle4((props) => {
    const { colorScheme: c } = props;
    return {
      tab: {
        border: "1px solid",
        borderColor: "inherit",
        [$bg2.variable]: "colors.gray.50",
        _dark: {
          [$bg2.variable]: "colors.whiteAlpha.50"
        },
        mb: "-1px",
        _notLast: {
          marginEnd: "-1px"
        },
        _selected: {
          [$bg2.variable]: "colors.white",
          [$fg.variable]: `colors.${c}.600`,
          _dark: {
            [$bg2.variable]: "colors.gray.800",
            [$fg.variable]: `colors.${c}.300`
          },
          borderColor: "inherit",
          borderTopColor: "currentColor",
          borderBottomColor: "transparent"
        },
        color: $fg.reference,
        bg: $bg2.reference
      },
      tablist: {
        mb: "-1px",
        borderBottom: "1px solid",
        borderColor: "inherit"
      }
    };
  });
  var variantSoftRounded = definePartsStyle4((props) => {
    const { colorScheme: c, theme: theme3 } = props;
    return {
      tab: {
        borderRadius: "full",
        fontWeight: "semibold",
        color: "gray.600",
        _selected: {
          color: getColor(theme3, `${c}.700`),
          bg: getColor(theme3, `${c}.100`)
        }
      }
    };
  });
  var variantSolidRounded = definePartsStyle4((props) => {
    const { colorScheme: c } = props;
    return {
      tab: {
        borderRadius: "full",
        fontWeight: "semibold",
        [$fg.variable]: "colors.gray.600",
        _dark: {
          [$fg.variable]: "inherit"
        },
        _selected: {
          [$fg.variable]: "colors.white",
          [$bg2.variable]: `colors.${c}.600`,
          _dark: {
            [$fg.variable]: "colors.gray.800",
            [$bg2.variable]: `colors.${c}.300`
          }
        },
        color: $fg.reference,
        bg: $bg2.reference
      }
    };
  });
  var variantUnstyled = definePartsStyle4({});
  var variants2 = {
    line: variantLine,
    enclosed: variantEnclosed,
    "enclosed-colored": variantEnclosedColored,
    "soft-rounded": variantSoftRounded,
    "solid-rounded": variantSolidRounded,
    unstyled: variantUnstyled
  };
  var tabsTheme = defineMultiStyleConfig4({
    baseStyle: baseStyle4,
    sizes: sizes4,
    variants: variants2,
    defaultProps: {
      size: "md",
      variant: "line",
      colorScheme: "blue"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-ZQMLTFF3.mjs
  var vars = defineCssVars("badge", ["bg", "color", "shadow"]);
  var baseStyle5 = defineStyle({
    px: 1,
    textTransform: "uppercase",
    fontSize: "xs",
    borderRadius: "sm",
    fontWeight: "bold",
    bg: vars.bg.reference,
    color: vars.color.reference,
    boxShadow: vars.shadow.reference
  });
  var variantSolid = defineStyle((props) => {
    const { colorScheme: c, theme: theme3 } = props;
    const dark = transparentize2(`${c}.500`, 0.6)(theme3);
    return {
      [vars.bg.variable]: `colors.${c}.500`,
      [vars.color.variable]: `colors.white`,
      _dark: {
        [vars.bg.variable]: dark,
        [vars.color.variable]: `colors.whiteAlpha.800`
      }
    };
  });
  var variantSubtle = defineStyle((props) => {
    const { colorScheme: c, theme: theme3 } = props;
    const darkBg = transparentize2(`${c}.200`, 0.16)(theme3);
    return {
      [vars.bg.variable]: `colors.${c}.100`,
      [vars.color.variable]: `colors.${c}.800`,
      _dark: {
        [vars.bg.variable]: darkBg,
        [vars.color.variable]: `colors.${c}.200`
      }
    };
  });
  var variantOutline = defineStyle((props) => {
    const { colorScheme: c, theme: theme3 } = props;
    const darkColor = transparentize2(`${c}.200`, 0.8)(theme3);
    return {
      [vars.color.variable]: `colors.${c}.500`,
      _dark: {
        [vars.color.variable]: darkColor
      },
      [vars.shadow.variable]: `inset 0 0 0px 1px ${vars.color.reference}`
    };
  });
  var variants3 = {
    solid: variantSolid,
    subtle: variantSubtle,
    outline: variantOutline
  };
  var badgeTheme = defineStyleConfig({
    baseStyle: baseStyle5,
    variants: variants3,
    defaultProps: {
      variant: "subtle",
      colorScheme: "gray"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-7RVLYCMR.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig5, definePartsStyle: definePartsStyle5 } = createMultiStyleConfigHelpers(tagAnatomy.keys);
  var $bg3 = cssVar("tag-bg");
  var $color = cssVar("tag-color");
  var $shadow = cssVar("tag-shadow");
  var $minH = cssVar("tag-min-height");
  var $minW = cssVar("tag-min-width");
  var $fontSize = cssVar("tag-font-size");
  var $paddingX = cssVar("tag-padding-inline");
  var baseStyleContainer = defineStyle({
    fontWeight: "medium",
    lineHeight: 1.2,
    outline: 0,
    [$color.variable]: vars.color.reference,
    [$bg3.variable]: vars.bg.reference,
    [$shadow.variable]: vars.shadow.reference,
    color: $color.reference,
    bg: $bg3.reference,
    boxShadow: $shadow.reference,
    borderRadius: "md",
    minH: $minH.reference,
    minW: $minW.reference,
    fontSize: $fontSize.reference,
    px: $paddingX.reference,
    _focusVisible: {
      [$shadow.variable]: "shadows.outline"
    }
  });
  var baseStyleLabel = defineStyle({
    lineHeight: 1.2,
    overflow: "visible"
  });
  var baseStyleCloseButton = defineStyle({
    fontSize: "lg",
    w: "5",
    h: "5",
    transitionProperty: "common",
    transitionDuration: "normal",
    borderRadius: "full",
    marginStart: "1.5",
    marginEnd: "-1",
    opacity: 0.5,
    _disabled: {
      opacity: 0.4
    },
    _focusVisible: {
      boxShadow: "outline",
      bg: "rgba(0, 0, 0, 0.14)"
    },
    _hover: {
      opacity: 0.8
    },
    _active: {
      opacity: 1
    }
  });
  var baseStyle6 = definePartsStyle5({
    container: baseStyleContainer,
    label: baseStyleLabel,
    closeButton: baseStyleCloseButton
  });
  var sizes5 = {
    sm: definePartsStyle5({
      container: {
        [$minH.variable]: "sizes.5",
        [$minW.variable]: "sizes.5",
        [$fontSize.variable]: "fontSizes.xs",
        [$paddingX.variable]: "space.2"
      },
      closeButton: {
        marginEnd: "-2px",
        marginStart: "0.35rem"
      }
    }),
    md: definePartsStyle5({
      container: {
        [$minH.variable]: "sizes.6",
        [$minW.variable]: "sizes.6",
        [$fontSize.variable]: "fontSizes.sm",
        [$paddingX.variable]: "space.2"
      }
    }),
    lg: definePartsStyle5({
      container: {
        [$minH.variable]: "sizes.8",
        [$minW.variable]: "sizes.8",
        [$fontSize.variable]: "fontSizes.md",
        [$paddingX.variable]: "space.3"
      }
    })
  };
  var variants4 = {
    subtle: definePartsStyle5((props) => {
      var _a7;
      return {
        container: (_a7 = badgeTheme.variants) == null ? void 0 : _a7.subtle(props)
      };
    }),
    solid: definePartsStyle5((props) => {
      var _a7;
      return {
        container: (_a7 = badgeTheme.variants) == null ? void 0 : _a7.solid(props)
      };
    }),
    outline: definePartsStyle5((props) => {
      var _a7;
      return {
        container: (_a7 = badgeTheme.variants) == null ? void 0 : _a7.outline(props)
      };
    })
  };
  var tagTheme = defineMultiStyleConfig5({
    variants: variants4,
    baseStyle: baseStyle6,
    sizes: sizes5,
    defaultProps: {
      size: "md",
      variant: "subtle",
      colorScheme: "gray"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-ICL3HPTT.mjs
  var { definePartsStyle: definePartsStyle6, defineMultiStyleConfig: defineMultiStyleConfig6 } = createMultiStyleConfigHelpers(inputAnatomy.keys);
  var $height2 = cssVar("input-height");
  var $fontSize2 = cssVar("input-font-size");
  var $padding = cssVar("input-padding");
  var $borderRadius = cssVar("input-border-radius");
  var baseStyle7 = definePartsStyle6({
    addon: {
      height: $height2.reference,
      fontSize: $fontSize2.reference,
      px: $padding.reference,
      borderRadius: $borderRadius.reference
    },
    field: {
      width: "100%",
      height: $height2.reference,
      fontSize: $fontSize2.reference,
      px: $padding.reference,
      borderRadius: $borderRadius.reference,
      minWidth: 0,
      outline: 0,
      position: "relative",
      appearance: "none",
      transitionProperty: "common",
      transitionDuration: "normal",
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      }
    }
  });
  var size = {
    lg: defineStyle({
      [$fontSize2.variable]: "fontSizes.lg",
      [$padding.variable]: "space.4",
      [$borderRadius.variable]: "radii.md",
      [$height2.variable]: "sizes.12"
    }),
    md: defineStyle({
      [$fontSize2.variable]: "fontSizes.md",
      [$padding.variable]: "space.4",
      [$borderRadius.variable]: "radii.md",
      [$height2.variable]: "sizes.10"
    }),
    sm: defineStyle({
      [$fontSize2.variable]: "fontSizes.sm",
      [$padding.variable]: "space.3",
      [$borderRadius.variable]: "radii.sm",
      [$height2.variable]: "sizes.8"
    }),
    xs: defineStyle({
      [$fontSize2.variable]: "fontSizes.xs",
      [$padding.variable]: "space.2",
      [$borderRadius.variable]: "radii.sm",
      [$height2.variable]: "sizes.6"
    })
  };
  var sizes6 = {
    lg: definePartsStyle6({
      field: size.lg,
      group: size.lg
    }),
    md: definePartsStyle6({
      field: size.md,
      group: size.md
    }),
    sm: definePartsStyle6({
      field: size.sm,
      group: size.sm
    }),
    xs: definePartsStyle6({
      field: size.xs,
      group: size.xs
    })
  };
  function getDefaults(props) {
    const { focusBorderColor: fc, errorBorderColor: ec } = props;
    return {
      focusBorderColor: fc || mode("blue.500", "blue.300")(props),
      errorBorderColor: ec || mode("red.500", "red.300")(props)
    };
  }
  var variantOutline2 = definePartsStyle6((props) => {
    const { theme: theme3 } = props;
    const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
    return {
      field: {
        border: "1px solid",
        borderColor: "inherit",
        bg: "inherit",
        _hover: {
          borderColor: mode("gray.300", "whiteAlpha.400")(props)
        },
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: getColor(theme3, ec),
          boxShadow: `0 0 0 1px ${getColor(theme3, ec)}`
        },
        _focusVisible: {
          zIndex: 1,
          borderColor: getColor(theme3, fc),
          boxShadow: `0 0 0 1px ${getColor(theme3, fc)}`
        }
      },
      addon: {
        border: "1px solid",
        borderColor: mode("inherit", "whiteAlpha.50")(props),
        bg: mode("gray.100", "whiteAlpha.300")(props)
      }
    };
  });
  var variantFilled = definePartsStyle6((props) => {
    const { theme: theme3 } = props;
    const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
    return {
      field: {
        border: "2px solid",
        borderColor: "transparent",
        bg: mode("gray.100", "whiteAlpha.50")(props),
        _hover: {
          bg: mode("gray.200", "whiteAlpha.100")(props)
        },
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: getColor(theme3, ec)
        },
        _focusVisible: {
          bg: "transparent",
          borderColor: getColor(theme3, fc)
        }
      },
      addon: {
        border: "2px solid",
        borderColor: "transparent",
        bg: mode("gray.100", "whiteAlpha.50")(props)
      }
    };
  });
  var variantFlushed = definePartsStyle6((props) => {
    const { theme: theme3 } = props;
    const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
    return {
      field: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent",
        _readOnly: {
          boxShadow: "none !important",
          userSelect: "all"
        },
        _invalid: {
          borderColor: getColor(theme3, ec),
          boxShadow: `0px 1px 0px 0px ${getColor(theme3, ec)}`
        },
        _focusVisible: {
          borderColor: getColor(theme3, fc),
          boxShadow: `0px 1px 0px 0px ${getColor(theme3, fc)}`
        }
      },
      addon: {
        borderBottom: "2px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    };
  });
  var variantUnstyled2 = definePartsStyle6({
    field: {
      bg: "transparent",
      px: "0",
      height: "auto"
    },
    addon: {
      bg: "transparent",
      px: "0",
      height: "auto"
    }
  });
  var variants5 = {
    outline: variantOutline2,
    filled: variantFilled,
    flushed: variantFlushed,
    unstyled: variantUnstyled2
  };
  var inputTheme = defineMultiStyleConfig6({
    baseStyle: baseStyle7,
    sizes: sizes6,
    variants: variants5,
    defaultProps: {
      size: "md",
      variant: "outline"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-KJ26FGJD.mjs
  var _a;
  var baseStyle8 = defineStyle({
    ...(_a = inputTheme.baseStyle) == null ? void 0 : _a.field,
    paddingY: "2",
    minHeight: "20",
    lineHeight: "short",
    verticalAlign: "top"
  });
  var _a2;
  var _b;
  var variants6 = {
    outline: defineStyle(
      (props) => {
        var _a42, _b32;
        return (_b32 = (_a42 = inputTheme.variants) == null ? void 0 : _a42.outline(props).field) != null ? _b32 : {};
      }
    ),
    flushed: defineStyle(
      (props) => {
        var _a42, _b32;
        return (_b32 = (_a42 = inputTheme.variants) == null ? void 0 : _a42.flushed(props).field) != null ? _b32 : {};
      }
    ),
    filled: defineStyle(
      (props) => {
        var _a42, _b32;
        return (_b32 = (_a42 = inputTheme.variants) == null ? void 0 : _a42.filled(props).field) != null ? _b32 : {};
      }
    ),
    unstyled: (_b = (_a2 = inputTheme.variants) == null ? void 0 : _a2.unstyled.field) != null ? _b : {}
  };
  var _a3;
  var _b2;
  var _c;
  var _d;
  var _e;
  var _f;
  var _g;
  var _h;
  var sizes7 = {
    xs: (_b2 = (_a3 = inputTheme.sizes) == null ? void 0 : _a3.xs.field) != null ? _b2 : {},
    sm: (_d = (_c = inputTheme.sizes) == null ? void 0 : _c.sm.field) != null ? _d : {},
    md: (_f = (_e = inputTheme.sizes) == null ? void 0 : _e.md.field) != null ? _f : {},
    lg: (_h = (_g = inputTheme.sizes) == null ? void 0 : _g.lg.field) != null ? _h : {}
  };
  var textareaTheme = defineStyleConfig({
    baseStyle: baseStyle8,
    sizes: sizes7,
    variants: variants6,
    defaultProps: {
      size: "md",
      variant: "outline"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-R7ZISUMV.mjs
  var $bg4 = cssVar2("tooltip-bg");
  var $fg2 = cssVar2("tooltip-fg");
  var $arrowBg = cssVar2("popper-arrow-bg");
  var baseStyle9 = defineStyle({
    bg: $bg4.reference,
    color: $fg2.reference,
    [$bg4.variable]: "colors.gray.700",
    [$fg2.variable]: "colors.whiteAlpha.900",
    _dark: {
      [$bg4.variable]: "colors.gray.300",
      [$fg2.variable]: "colors.gray.900"
    },
    [$arrowBg.variable]: $bg4.reference,
    px: "2",
    py: "0.5",
    borderRadius: "sm",
    fontWeight: "medium",
    fontSize: "sm",
    boxShadow: "md",
    maxW: "xs",
    zIndex: "tooltip"
  });
  var tooltipTheme = defineStyleConfig({
    baseStyle: baseStyle9
  });

  // node_modules/@chakra-ui/theme/dist/chunk-37MNRBP2.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig7, definePartsStyle: definePartsStyle7 } = createMultiStyleConfigHelpers(progressAnatomy.keys);
  var filledStyle = defineStyle((props) => {
    const { colorScheme: c, theme: t4, isIndeterminate, hasStripe } = props;
    const stripeStyle = mode(
      generateStripe(),
      generateStripe("1rem", "rgba(0,0,0,0.1)")
    )(props);
    const bgColor = mode(`${c}.500`, `${c}.200`)(props);
    const gradient = `linear-gradient(
    to right,
    transparent 0%,
    ${getColor(t4, bgColor)} 50%,
    transparent 100%
  )`;
    const addStripe = !isIndeterminate && hasStripe;
    return {
      ...addStripe && stripeStyle,
      ...isIndeterminate ? { bgImage: gradient } : { bgColor }
    };
  });
  var baseStyleLabel2 = defineStyle({
    lineHeight: "1",
    fontSize: "0.25em",
    fontWeight: "bold",
    color: "white"
  });
  var baseStyleTrack2 = defineStyle((props) => {
    return {
      bg: mode("gray.100", "whiteAlpha.300")(props)
    };
  });
  var baseStyleFilledTrack = defineStyle((props) => {
    return {
      transitionProperty: "common",
      transitionDuration: "slow",
      ...filledStyle(props)
    };
  });
  var baseStyle10 = definePartsStyle7((props) => ({
    label: baseStyleLabel2,
    filledTrack: baseStyleFilledTrack(props),
    track: baseStyleTrack2(props)
  }));
  var sizes8 = {
    xs: definePartsStyle7({
      track: { h: "1" }
    }),
    sm: definePartsStyle7({
      track: { h: "2" }
    }),
    md: definePartsStyle7({
      track: { h: "3" }
    }),
    lg: definePartsStyle7({
      track: { h: "4" }
    })
  };
  var progressTheme = defineMultiStyleConfig7({
    sizes: sizes8,
    baseStyle: baseStyle10,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-UV3F75RF.mjs
  var isFunction2 = (value) => typeof value === "function";
  function runIfFn2(valueOrFn, ...args) {
    return isFunction2(valueOrFn) ? valueOrFn(...args) : valueOrFn;
  }

  // node_modules/@chakra-ui/theme/dist/chunk-XHYVH6UO.mjs
  var { definePartsStyle: definePartsStyle8, defineMultiStyleConfig: defineMultiStyleConfig8 } = createMultiStyleConfigHelpers(checkboxAnatomy.keys);
  var $size2 = cssVar("checkbox-size");
  var baseStyleControl = defineStyle((props) => {
    const { colorScheme: c } = props;
    return {
      w: $size2.reference,
      h: $size2.reference,
      transitionProperty: "box-shadow",
      transitionDuration: "normal",
      border: "2px solid",
      borderRadius: "sm",
      borderColor: "inherit",
      color: "white",
      _checked: {
        bg: mode(`${c}.500`, `${c}.200`)(props),
        borderColor: mode(`${c}.500`, `${c}.200`)(props),
        color: mode("white", "gray.900")(props),
        _hover: {
          bg: mode(`${c}.600`, `${c}.300`)(props),
          borderColor: mode(`${c}.600`, `${c}.300`)(props)
        },
        _disabled: {
          borderColor: mode("gray.200", "transparent")(props),
          bg: mode("gray.200", "whiteAlpha.300")(props),
          color: mode("gray.500", "whiteAlpha.500")(props)
        }
      },
      _indeterminate: {
        bg: mode(`${c}.500`, `${c}.200`)(props),
        borderColor: mode(`${c}.500`, `${c}.200`)(props),
        color: mode("white", "gray.900")(props)
      },
      _disabled: {
        bg: mode("gray.100", "whiteAlpha.100")(props),
        borderColor: mode("gray.100", "transparent")(props)
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      _invalid: {
        borderColor: mode("red.500", "red.300")(props)
      }
    };
  });
  var baseStyleContainer2 = defineStyle({
    _disabled: { cursor: "not-allowed" }
  });
  var baseStyleLabel3 = defineStyle({
    userSelect: "none",
    _disabled: { opacity: 0.4 }
  });
  var baseStyleIcon = defineStyle({
    transitionProperty: "transform",
    transitionDuration: "normal"
  });
  var baseStyle11 = definePartsStyle8((props) => ({
    icon: baseStyleIcon,
    container: baseStyleContainer2,
    control: runIfFn2(baseStyleControl, props),
    label: baseStyleLabel3
  }));
  var sizes9 = {
    sm: definePartsStyle8({
      control: { [$size2.variable]: "sizes.3" },
      label: { fontSize: "sm" },
      icon: { fontSize: "3xs" }
    }),
    md: definePartsStyle8({
      control: { [$size2.variable]: "sizes.4" },
      label: { fontSize: "md" },
      icon: { fontSize: "2xs" }
    }),
    lg: definePartsStyle8({
      control: { [$size2.variable]: "sizes.5" },
      label: { fontSize: "lg" },
      icon: { fontSize: "2xs" }
    })
  };
  var checkboxTheme = defineMultiStyleConfig8({
    baseStyle: baseStyle11,
    sizes: sizes9,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-VZUATZ4E.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig9, definePartsStyle: definePartsStyle9 } = createMultiStyleConfigHelpers(radioAnatomy.keys);
  var baseStyleControl2 = defineStyle((props) => {
    var _a7;
    const controlStyle = (_a7 = runIfFn2(checkboxTheme.baseStyle, props)) == null ? void 0 : _a7.control;
    return {
      ...controlStyle,
      borderRadius: "full",
      _checked: {
        ...controlStyle == null ? void 0 : controlStyle["_checked"],
        _before: {
          content: `""`,
          display: "inline-block",
          pos: "relative",
          w: "50%",
          h: "50%",
          borderRadius: "50%",
          bg: "currentColor"
        }
      }
    };
  });
  var baseStyle12 = definePartsStyle9((props) => {
    var _a7, _b5, _c3, _d3;
    return {
      label: (_b5 = (_a7 = checkboxTheme).baseStyle) == null ? void 0 : _b5.call(_a7, props).label,
      container: (_d3 = (_c3 = checkboxTheme).baseStyle) == null ? void 0 : _d3.call(_c3, props).container,
      control: baseStyleControl2(props)
    };
  });
  var sizes10 = {
    md: definePartsStyle9({
      control: { w: "4", h: "4" },
      label: { fontSize: "md" }
    }),
    lg: definePartsStyle9({
      control: { w: "5", h: "5" },
      label: { fontSize: "lg" }
    }),
    sm: definePartsStyle9({
      control: { width: "3", height: "3" },
      label: { fontSize: "sm" }
    })
  };
  var radioTheme = defineMultiStyleConfig9({
    baseStyle: baseStyle12,
    sizes: sizes10,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-NNA4E64A.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig10, definePartsStyle: definePartsStyle10 } = createMultiStyleConfigHelpers(selectAnatomy.keys);
  var $bg5 = cssVar("select-bg");
  var _a4;
  var baseStyleField = defineStyle({
    ...(_a4 = inputTheme.baseStyle) == null ? void 0 : _a4.field,
    appearance: "none",
    paddingBottom: "1px",
    lineHeight: "normal",
    bg: $bg5.reference,
    [$bg5.variable]: "colors.white",
    _dark: {
      [$bg5.variable]: "colors.gray.700"
    },
    "> option, > optgroup": {
      bg: $bg5.reference
    }
  });
  var baseStyleIcon2 = defineStyle({
    width: "6",
    height: "100%",
    insetEnd: "2",
    position: "relative",
    color: "currentColor",
    fontSize: "xl",
    _disabled: {
      opacity: 0.5
    }
  });
  var baseStyle13 = definePartsStyle10({
    field: baseStyleField,
    icon: baseStyleIcon2
  });
  var iconSpacing = defineStyle({
    paddingInlineEnd: "8"
  });
  var _a22;
  var _b3;
  var _c2;
  var _d2;
  var _e2;
  var _f2;
  var _g2;
  var _h2;
  var sizes11 = {
    lg: {
      ...(_a22 = inputTheme.sizes) == null ? void 0 : _a22.lg,
      field: {
        ...(_b3 = inputTheme.sizes) == null ? void 0 : _b3.lg.field,
        ...iconSpacing
      }
    },
    md: {
      ...(_c2 = inputTheme.sizes) == null ? void 0 : _c2.md,
      field: {
        ...(_d2 = inputTheme.sizes) == null ? void 0 : _d2.md.field,
        ...iconSpacing
      }
    },
    sm: {
      ...(_e2 = inputTheme.sizes) == null ? void 0 : _e2.sm,
      field: {
        ...(_f2 = inputTheme.sizes) == null ? void 0 : _f2.sm.field,
        ...iconSpacing
      }
    },
    xs: {
      ...(_g2 = inputTheme.sizes) == null ? void 0 : _g2.xs,
      field: {
        ...(_h2 = inputTheme.sizes) == null ? void 0 : _h2.xs.field,
        ...iconSpacing
      },
      icon: {
        insetEnd: "1"
      }
    }
  };
  var selectTheme = defineMultiStyleConfig10({
    baseStyle: baseStyle13,
    sizes: sizes11,
    variants: inputTheme.variants,
    defaultProps: inputTheme.defaultProps
  });

  // node_modules/@chakra-ui/theme/dist/chunk-X6XFE4TF.mjs
  var $startColor = cssVar("skeleton-start-color");
  var $endColor = cssVar("skeleton-end-color");
  var baseStyle14 = defineStyle({
    [$startColor.variable]: "colors.gray.100",
    [$endColor.variable]: "colors.gray.400",
    _dark: {
      [$startColor.variable]: "colors.gray.800",
      [$endColor.variable]: "colors.gray.600"
    },
    background: $startColor.reference,
    borderColor: $endColor.reference,
    opacity: 0.7,
    borderRadius: "sm"
  });
  var skeletonTheme = defineStyleConfig({
    baseStyle: baseStyle14
  });

  // node_modules/@chakra-ui/theme/dist/chunk-ZREGO6US.mjs
  var $bg6 = cssVar("skip-link-bg");
  var baseStyle15 = defineStyle({
    borderRadius: "md",
    fontWeight: "semibold",
    _focusVisible: {
      boxShadow: "outline",
      padding: "4",
      position: "fixed",
      top: "6",
      insetStart: "6",
      [$bg6.variable]: "colors.white",
      _dark: {
        [$bg6.variable]: "colors.gray.700"
      },
      bg: $bg6.reference
    }
  });
  var skipLinkTheme = defineStyleConfig({
    baseStyle: baseStyle15
  });

  // node_modules/@chakra-ui/theme/dist/chunk-5FA7Y3RP.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig11, definePartsStyle: definePartsStyle11 } = createMultiStyleConfigHelpers(sliderAnatomy.keys);
  var $thumbSize = cssVar("slider-thumb-size");
  var $trackSize = cssVar("slider-track-size");
  var $bg7 = cssVar("slider-bg");
  var baseStyleContainer3 = defineStyle((props) => {
    const { orientation } = props;
    return {
      display: "inline-block",
      position: "relative",
      cursor: "pointer",
      _disabled: {
        opacity: 0.6,
        cursor: "default",
        pointerEvents: "none"
      },
      ...orient({
        orientation,
        vertical: { h: "100%" },
        horizontal: { w: "100%" }
      })
    };
  });
  var baseStyleTrack3 = defineStyle((props) => {
    const orientationStyles = orient({
      orientation: props.orientation,
      horizontal: { h: $trackSize.reference },
      vertical: { w: $trackSize.reference }
    });
    return {
      ...orientationStyles,
      overflow: "hidden",
      borderRadius: "sm",
      [$bg7.variable]: "colors.gray.200",
      _dark: {
        [$bg7.variable]: "colors.whiteAlpha.200"
      },
      _disabled: {
        [$bg7.variable]: "colors.gray.300",
        _dark: {
          [$bg7.variable]: "colors.whiteAlpha.300"
        }
      },
      bg: $bg7.reference
    };
  });
  var baseStyleThumb2 = defineStyle((props) => {
    const { orientation } = props;
    const orientationStyle = orient({
      orientation,
      vertical: {
        left: "50%",
        transform: `translateX(-50%)`,
        _active: {
          transform: `translateX(-50%) scale(1.15)`
        }
      },
      horizontal: {
        top: "50%",
        transform: `translateY(-50%)`,
        _active: {
          transform: `translateY(-50%) scale(1.15)`
        }
      }
    });
    return {
      ...orientationStyle,
      w: $thumbSize.reference,
      h: $thumbSize.reference,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      position: "absolute",
      outline: 0,
      zIndex: 1,
      borderRadius: "full",
      bg: "white",
      boxShadow: "base",
      border: "1px solid",
      borderColor: "transparent",
      transitionProperty: "transform",
      transitionDuration: "normal",
      _focusVisible: {
        boxShadow: "outline"
      },
      _disabled: {
        bg: "gray.300"
      }
    };
  });
  var baseStyleFilledTrack2 = defineStyle((props) => {
    const { colorScheme: c } = props;
    return {
      width: "inherit",
      height: "inherit",
      [$bg7.variable]: `colors.${c}.500`,
      _dark: {
        [$bg7.variable]: `colors.${c}.200`
      },
      bg: $bg7.reference
    };
  });
  var baseStyle16 = definePartsStyle11((props) => ({
    container: baseStyleContainer3(props),
    track: baseStyleTrack3(props),
    thumb: baseStyleThumb2(props),
    filledTrack: baseStyleFilledTrack2(props)
  }));
  var sizeLg = definePartsStyle11({
    container: {
      [$thumbSize.variable]: `sizes.4`,
      [$trackSize.variable]: `sizes.1`
    }
  });
  var sizeMd = definePartsStyle11({
    container: {
      [$thumbSize.variable]: `sizes.3.5`,
      [$trackSize.variable]: `sizes.1`
    }
  });
  var sizeSm = definePartsStyle11({
    container: {
      [$thumbSize.variable]: `sizes.2.5`,
      [$trackSize.variable]: `sizes.0.5`
    }
  });
  var sizes12 = {
    lg: sizeLg,
    md: sizeMd,
    sm: sizeSm
  };
  var sliderTheme = defineMultiStyleConfig11({
    baseStyle: baseStyle16,
    sizes: sizes12,
    defaultProps: {
      size: "md",
      colorScheme: "blue"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-L3YAB6CV.mjs
  var $size3 = cssVar2("spinner-size");
  var baseStyle17 = defineStyle({
    width: [$size3.reference],
    height: [$size3.reference]
  });
  var sizes13 = {
    xs: defineStyle({
      [$size3.variable]: "sizes.3"
    }),
    sm: defineStyle({
      [$size3.variable]: "sizes.4"
    }),
    md: defineStyle({
      [$size3.variable]: "sizes.6"
    }),
    lg: defineStyle({
      [$size3.variable]: "sizes.8"
    }),
    xl: defineStyle({
      [$size3.variable]: "sizes.12"
    })
  };
  var spinnerTheme = defineStyleConfig({
    baseStyle: baseStyle17,
    sizes: sizes13,
    defaultProps: {
      size: "md"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-2KWJXISX.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig12, definePartsStyle: definePartsStyle12 } = createMultiStyleConfigHelpers(statAnatomy.keys);
  var baseStyleLabel4 = defineStyle({
    fontWeight: "medium"
  });
  var baseStyleHelpText = defineStyle({
    opacity: 0.8,
    marginBottom: "2"
  });
  var baseStyleNumber = defineStyle({
    verticalAlign: "baseline",
    fontWeight: "semibold"
  });
  var baseStyleIcon3 = defineStyle({
    marginEnd: 1,
    w: "3.5",
    h: "3.5",
    verticalAlign: "middle"
  });
  var baseStyle18 = definePartsStyle12({
    container: {},
    label: baseStyleLabel4,
    helpText: baseStyleHelpText,
    number: baseStyleNumber,
    icon: baseStyleIcon3
  });
  var sizes14 = {
    md: definePartsStyle12({
      label: { fontSize: "sm" },
      helpText: { fontSize: "sm" },
      number: { fontSize: "2xl" }
    })
  };
  var statTheme = defineMultiStyleConfig12({
    baseStyle: baseStyle18,
    sizes: sizes14,
    defaultProps: {
      size: "md"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-AFCBUAM5.mjs
  var $bg8 = cssVar("kbd-bg");
  var baseStyle19 = defineStyle({
    [$bg8.variable]: "colors.gray.100",
    _dark: {
      [$bg8.variable]: "colors.whiteAlpha.100"
    },
    bg: $bg8.reference,
    borderRadius: "md",
    borderWidth: "1px",
    borderBottomWidth: "3px",
    fontSize: "0.8em",
    fontWeight: "bold",
    lineHeight: "normal",
    px: "0.4em",
    whiteSpace: "nowrap"
  });
  var kbdTheme = defineStyleConfig({
    baseStyle: baseStyle19
  });

  // node_modules/@chakra-ui/theme/dist/chunk-V5KSHSOQ.mjs
  var baseStyle20 = defineStyle({
    transitionProperty: "common",
    transitionDuration: "fast",
    transitionTimingFunction: "ease-out",
    cursor: "pointer",
    textDecoration: "none",
    outline: "none",
    color: "inherit",
    _hover: {
      textDecoration: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  });
  var linkTheme = defineStyleConfig({
    baseStyle: baseStyle20
  });

  // node_modules/@chakra-ui/theme/dist/chunk-MGNM2WZQ.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig13, definePartsStyle: definePartsStyle13 } = createMultiStyleConfigHelpers(listAnatomy.keys);
  var baseStyleIcon4 = defineStyle({
    marginEnd: "2",
    display: "inline",
    verticalAlign: "text-bottom"
  });
  var baseStyle21 = definePartsStyle13({
    icon: baseStyleIcon4
  });
  var listTheme = defineMultiStyleConfig13({
    baseStyle: baseStyle21
  });

  // node_modules/@chakra-ui/theme/dist/chunk-N2GP2AF7.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig14, definePartsStyle: definePartsStyle14 } = createMultiStyleConfigHelpers(menuAnatomy.keys);
  var $bg9 = cssVar("menu-bg");
  var $shadow2 = cssVar("menu-shadow");
  var baseStyleList = defineStyle({
    [$bg9.variable]: "#fff",
    [$shadow2.variable]: "shadows.sm",
    _dark: {
      [$bg9.variable]: "colors.gray.700",
      [$shadow2.variable]: "shadows.dark-lg"
    },
    color: "inherit",
    minW: "3xs",
    py: "2",
    zIndex: 1,
    borderRadius: "md",
    borderWidth: "1px",
    bg: $bg9.reference,
    boxShadow: $shadow2.reference
  });
  var baseStyleItem = defineStyle({
    py: "1.5",
    px: "3",
    transitionProperty: "background",
    transitionDuration: "ultra-fast",
    transitionTimingFunction: "ease-in",
    _focus: {
      [$bg9.variable]: "colors.gray.100",
      _dark: {
        [$bg9.variable]: "colors.whiteAlpha.100"
      }
    },
    _active: {
      [$bg9.variable]: "colors.gray.200",
      _dark: {
        [$bg9.variable]: "colors.whiteAlpha.200"
      }
    },
    _expanded: {
      [$bg9.variable]: "colors.gray.100",
      _dark: {
        [$bg9.variable]: "colors.whiteAlpha.100"
      }
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    bg: $bg9.reference
  });
  var baseStyleGroupTitle = defineStyle({
    mx: 4,
    my: 2,
    fontWeight: "semibold",
    fontSize: "sm"
  });
  var baseStyleIcon5 = defineStyle({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0
  });
  var baseStyleCommand = defineStyle({
    opacity: 0.6
  });
  var baseStyleDivider = defineStyle({
    border: 0,
    borderBottom: "1px solid",
    borderColor: "inherit",
    my: "2",
    opacity: 0.6
  });
  var baseStyleButton = defineStyle({
    transitionProperty: "common",
    transitionDuration: "normal"
  });
  var baseStyle22 = definePartsStyle14({
    button: baseStyleButton,
    list: baseStyleList,
    item: baseStyleItem,
    groupTitle: baseStyleGroupTitle,
    icon: baseStyleIcon5,
    command: baseStyleCommand,
    divider: baseStyleDivider
  });
  var menuTheme = defineMultiStyleConfig14({
    baseStyle: baseStyle22
  });

  // node_modules/@chakra-ui/theme/dist/chunk-JN6QBAR6.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig15, definePartsStyle: definePartsStyle15 } = createMultiStyleConfigHelpers(modalAnatomy.keys);
  var $bg10 = cssVar("modal-bg");
  var $shadow3 = cssVar("modal-shadow");
  var baseStyleOverlay = defineStyle({
    bg: "blackAlpha.600",
    zIndex: "modal"
  });
  var baseStyleDialogContainer = defineStyle((props) => {
    const { isCentered, scrollBehavior } = props;
    return {
      display: "flex",
      zIndex: "modal",
      justifyContent: "center",
      alignItems: isCentered ? "center" : "flex-start",
      overflow: scrollBehavior === "inside" ? "hidden" : "auto",
      overscrollBehaviorY: "none"
    };
  });
  var baseStyleDialog = defineStyle((props) => {
    const { isCentered, scrollBehavior } = props;
    return {
      borderRadius: "md",
      color: "inherit",
      my: isCentered ? "auto" : "16",
      mx: isCentered ? "auto" : void 0,
      zIndex: "modal",
      maxH: scrollBehavior === "inside" ? "calc(100% - 7.5rem)" : void 0,
      [$bg10.variable]: "colors.white",
      [$shadow3.variable]: "shadows.lg",
      _dark: {
        [$bg10.variable]: "colors.gray.700",
        [$shadow3.variable]: "shadows.dark-lg"
      },
      bg: $bg10.reference,
      boxShadow: $shadow3.reference
    };
  });
  var baseStyleHeader = defineStyle({
    px: "6",
    py: "4",
    fontSize: "xl",
    fontWeight: "semibold"
  });
  var baseStyleCloseButton2 = defineStyle({
    position: "absolute",
    top: "2",
    insetEnd: "3"
  });
  var baseStyleBody = defineStyle((props) => {
    const { scrollBehavior } = props;
    return {
      px: "6",
      py: "2",
      flex: "1",
      overflow: scrollBehavior === "inside" ? "auto" : void 0
    };
  });
  var baseStyleFooter = defineStyle({
    px: "6",
    py: "4"
  });
  var baseStyle23 = definePartsStyle15((props) => ({
    overlay: baseStyleOverlay,
    dialogContainer: runIfFn2(baseStyleDialogContainer, props),
    dialog: runIfFn2(baseStyleDialog, props),
    header: baseStyleHeader,
    closeButton: baseStyleCloseButton2,
    body: runIfFn2(baseStyleBody, props),
    footer: baseStyleFooter
  }));
  function getSize(value) {
    if (value === "full") {
      return definePartsStyle15({
        dialog: {
          maxW: "100vw",
          minH: "$100vh",
          my: "0",
          borderRadius: "0"
        }
      });
    }
    return definePartsStyle15({
      dialog: { maxW: value }
    });
  }
  var sizes15 = {
    xs: getSize("xs"),
    sm: getSize("sm"),
    md: getSize("md"),
    lg: getSize("lg"),
    xl: getSize("xl"),
    "2xl": getSize("2xl"),
    "3xl": getSize("3xl"),
    "4xl": getSize("4xl"),
    "5xl": getSize("5xl"),
    "6xl": getSize("6xl"),
    full: getSize("full")
  };
  var modalTheme = defineMultiStyleConfig15({
    baseStyle: baseStyle23,
    sizes: sizes15,
    defaultProps: { size: "md" }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-57T4IAPW.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig16, definePartsStyle: definePartsStyle16 } = createMultiStyleConfigHelpers(numberInputAnatomy.keys);
  var $stepperWidth = cssVar2("number-input-stepper-width");
  var $inputPadding = cssVar2("number-input-input-padding");
  var inputPaddingValue = calc2($stepperWidth).add("0.5rem").toString();
  var $bg11 = cssVar2("number-input-bg");
  var $fg3 = cssVar2("number-input-color");
  var $border2 = cssVar2("number-input-border-color");
  var baseStyleRoot2 = defineStyle({
    [$stepperWidth.variable]: "sizes.6",
    [$inputPadding.variable]: inputPaddingValue
  });
  var baseStyleField2 = defineStyle(
    (props) => {
      var _a7, _b5;
      return (_b5 = (_a7 = runIfFn2(inputTheme.baseStyle, props)) == null ? void 0 : _a7.field) != null ? _b5 : {};
    }
  );
  var baseStyleStepperGroup = defineStyle({
    width: $stepperWidth.reference
  });
  var baseStyleStepper = defineStyle({
    borderStart: "1px solid",
    borderStartColor: $border2.reference,
    color: $fg3.reference,
    bg: $bg11.reference,
    [$fg3.variable]: "colors.chakra-body-text",
    [$border2.variable]: "colors.chakra-border-color",
    _dark: {
      [$fg3.variable]: "colors.whiteAlpha.800",
      [$border2.variable]: "colors.whiteAlpha.300"
    },
    _active: {
      [$bg11.variable]: "colors.gray.200",
      _dark: {
        [$bg11.variable]: "colors.whiteAlpha.300"
      }
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  });
  var baseStyle24 = definePartsStyle16((props) => {
    var _a7;
    return {
      root: baseStyleRoot2,
      field: (_a7 = runIfFn2(baseStyleField2, props)) != null ? _a7 : {},
      stepperGroup: baseStyleStepperGroup,
      stepper: baseStyleStepper
    };
  });
  function getSize2(size2) {
    var _a7, _b5, _c3;
    const sizeStyle = (_a7 = inputTheme.sizes) == null ? void 0 : _a7[size2];
    const radius = {
      lg: "md",
      md: "md",
      sm: "sm",
      xs: "sm"
    };
    const _fontSize = (_c3 = (_b5 = sizeStyle.field) == null ? void 0 : _b5.fontSize) != null ? _c3 : "md";
    const fontSize = typography_default.fontSizes[_fontSize];
    return definePartsStyle16({
      field: {
        ...sizeStyle.field,
        paddingInlineEnd: $inputPadding.reference,
        verticalAlign: "top"
      },
      stepper: {
        fontSize: calc2(fontSize).multiply(0.75).toString(),
        _first: {
          borderTopEndRadius: radius[size2]
        },
        _last: {
          borderBottomEndRadius: radius[size2],
          mt: "-1px",
          borderTopWidth: 1
        }
      }
    });
  }
  var sizes16 = {
    xs: getSize2("xs"),
    sm: getSize2("sm"),
    md: getSize2("md"),
    lg: getSize2("lg")
  };
  var numberInputTheme = defineMultiStyleConfig16({
    baseStyle: baseStyle24,
    sizes: sizes16,
    variants: inputTheme.variants,
    defaultProps: inputTheme.defaultProps
  });

  // node_modules/@chakra-ui/theme/dist/chunk-OEFJDLVS.mjs
  var _a5;
  var baseStyle25 = defineStyle({
    ...(_a5 = inputTheme.baseStyle) == null ? void 0 : _a5.field,
    textAlign: "center"
  });
  var sizes17 = {
    lg: defineStyle({
      fontSize: "lg",
      w: 12,
      h: 12,
      borderRadius: "md"
    }),
    md: defineStyle({
      fontSize: "md",
      w: 10,
      h: 10,
      borderRadius: "md"
    }),
    sm: defineStyle({
      fontSize: "sm",
      w: 8,
      h: 8,
      borderRadius: "sm"
    }),
    xs: defineStyle({
      fontSize: "xs",
      w: 6,
      h: 6,
      borderRadius: "sm"
    })
  };
  var _a23;
  var _b4;
  var variants7 = {
    outline: defineStyle(
      (props) => {
        var _a32, _b22, _c3;
        return (_c3 = (_b22 = runIfFn2((_a32 = inputTheme.variants) == null ? void 0 : _a32.outline, props)) == null ? void 0 : _b22.field) != null ? _c3 : {};
      }
    ),
    flushed: defineStyle(
      (props) => {
        var _a32, _b22, _c3;
        return (_c3 = (_b22 = runIfFn2((_a32 = inputTheme.variants) == null ? void 0 : _a32.flushed, props)) == null ? void 0 : _b22.field) != null ? _c3 : {};
      }
    ),
    filled: defineStyle(
      (props) => {
        var _a32, _b22, _c3;
        return (_c3 = (_b22 = runIfFn2((_a32 = inputTheme.variants) == null ? void 0 : _a32.filled, props)) == null ? void 0 : _b22.field) != null ? _c3 : {};
      }
    ),
    unstyled: (_b4 = (_a23 = inputTheme.variants) == null ? void 0 : _a23.unstyled.field) != null ? _b4 : {}
  };
  var pinInputTheme = defineStyleConfig({
    baseStyle: baseStyle25,
    sizes: sizes17,
    variants: variants7,
    defaultProps: inputTheme.defaultProps
  });

  // node_modules/@chakra-ui/theme/dist/chunk-U3INMHUO.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig17, definePartsStyle: definePartsStyle17 } = createMultiStyleConfigHelpers(popoverAnatomy.keys);
  var $popperBg = cssVar2("popper-bg");
  var $arrowBg2 = cssVar2("popper-arrow-bg");
  var $arrowShadowColor = cssVar2("popper-arrow-shadow-color");
  var baseStylePopper = defineStyle({ zIndex: 10 });
  var baseStyleContent = defineStyle({
    [$popperBg.variable]: `colors.white`,
    bg: $popperBg.reference,
    [$arrowBg2.variable]: $popperBg.reference,
    [$arrowShadowColor.variable]: `colors.gray.200`,
    _dark: {
      [$popperBg.variable]: `colors.gray.700`,
      [$arrowShadowColor.variable]: `colors.whiteAlpha.300`
    },
    width: "xs",
    border: "1px solid",
    borderColor: "inherit",
    borderRadius: "md",
    boxShadow: "sm",
    zIndex: "inherit",
    _focusVisible: {
      outline: 0,
      boxShadow: "outline"
    }
  });
  var baseStyleHeader2 = defineStyle({
    px: 3,
    py: 2,
    borderBottomWidth: "1px"
  });
  var baseStyleBody2 = defineStyle({
    px: 3,
    py: 2
  });
  var baseStyleFooter2 = defineStyle({
    px: 3,
    py: 2,
    borderTopWidth: "1px"
  });
  var baseStyleCloseButton3 = defineStyle({
    position: "absolute",
    borderRadius: "md",
    top: 1,
    insetEnd: 2,
    padding: 2
  });
  var baseStyle26 = definePartsStyle17({
    popper: baseStylePopper,
    content: baseStyleContent,
    header: baseStyleHeader2,
    body: baseStyleBody2,
    footer: baseStyleFooter2,
    closeButton: baseStyleCloseButton3
  });
  var popoverTheme = defineMultiStyleConfig17({
    baseStyle: baseStyle26
  });

  // node_modules/@chakra-ui/theme/dist/chunk-VWP3ZVQT.mjs
  var { definePartsStyle: definePartsStyle18, defineMultiStyleConfig: defineMultiStyleConfig18 } = createMultiStyleConfigHelpers(drawerAnatomy.keys);
  var $bg12 = cssVar("drawer-bg");
  var $bs = cssVar("drawer-box-shadow");
  function getSize3(value) {
    if (value === "full") {
      return definePartsStyle18({
        dialog: { maxW: "100vw", h: "100vh" }
      });
    }
    return definePartsStyle18({
      dialog: { maxW: value }
    });
  }
  var baseStyleOverlay2 = defineStyle({
    bg: "blackAlpha.600",
    zIndex: "modal"
  });
  var baseStyleDialogContainer2 = defineStyle({
    display: "flex",
    zIndex: "modal",
    justifyContent: "center"
  });
  var baseStyleDialog2 = defineStyle((props) => {
    const { isFullHeight } = props;
    return {
      ...isFullHeight && { height: "100vh" },
      zIndex: "modal",
      maxH: "100vh",
      color: "inherit",
      [$bg12.variable]: "colors.white",
      [$bs.variable]: "shadows.lg",
      _dark: {
        [$bg12.variable]: "colors.gray.700",
        [$bs.variable]: "shadows.dark-lg"
      },
      bg: $bg12.reference,
      boxShadow: $bs.reference
    };
  });
  var baseStyleHeader3 = defineStyle({
    px: "6",
    py: "4",
    fontSize: "xl",
    fontWeight: "semibold"
  });
  var baseStyleCloseButton4 = defineStyle({
    position: "absolute",
    top: "2",
    insetEnd: "3"
  });
  var baseStyleBody3 = defineStyle({
    px: "6",
    py: "2",
    flex: "1",
    overflow: "auto"
  });
  var baseStyleFooter3 = defineStyle({
    px: "6",
    py: "4"
  });
  var baseStyle27 = definePartsStyle18((props) => ({
    overlay: baseStyleOverlay2,
    dialogContainer: baseStyleDialogContainer2,
    dialog: runIfFn2(baseStyleDialog2, props),
    header: baseStyleHeader3,
    closeButton: baseStyleCloseButton4,
    body: baseStyleBody3,
    footer: baseStyleFooter3
  }));
  var sizes18 = {
    xs: getSize3("xs"),
    sm: getSize3("md"),
    md: getSize3("lg"),
    lg: getSize3("2xl"),
    xl: getSize3("4xl"),
    full: getSize3("full")
  };
  var drawerTheme = defineMultiStyleConfig18({
    baseStyle: baseStyle27,
    sizes: sizes18,
    defaultProps: {
      size: "xs"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-D6DZ26HA.mjs
  var { definePartsStyle: definePartsStyle19, defineMultiStyleConfig: defineMultiStyleConfig19 } = createMultiStyleConfigHelpers(editableAnatomy.keys);
  var baseStylePreview = defineStyle({
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal"
  });
  var baseStyleInput = defineStyle({
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal",
    width: "full",
    _focusVisible: { boxShadow: "outline" },
    _placeholder: { opacity: 0.6 }
  });
  var baseStyleTextarea = defineStyle({
    borderRadius: "md",
    py: "1",
    transitionProperty: "common",
    transitionDuration: "normal",
    width: "full",
    _focusVisible: { boxShadow: "outline" },
    _placeholder: { opacity: 0.6 }
  });
  var baseStyle28 = definePartsStyle19({
    preview: baseStylePreview,
    input: baseStyleInput,
    textarea: baseStyleTextarea
  });
  var editableTheme = defineMultiStyleConfig19({
    baseStyle: baseStyle28
  });

  // node_modules/@chakra-ui/theme/dist/chunk-O6GGGS4Y.mjs
  var { definePartsStyle: definePartsStyle20, defineMultiStyleConfig: defineMultiStyleConfig20 } = createMultiStyleConfigHelpers(formAnatomy.keys);
  var $fg4 = cssVar("form-control-color");
  var baseStyleRequiredIndicator = defineStyle({
    marginStart: "1",
    [$fg4.variable]: "colors.red.500",
    _dark: {
      [$fg4.variable]: "colors.red.300"
    },
    color: $fg4.reference
  });
  var baseStyleHelperText = defineStyle({
    mt: "2",
    [$fg4.variable]: "colors.gray.600",
    _dark: {
      [$fg4.variable]: "colors.whiteAlpha.600"
    },
    color: $fg4.reference,
    lineHeight: "normal",
    fontSize: "sm"
  });
  var baseStyle29 = definePartsStyle20({
    container: {
      width: "100%",
      position: "relative"
    },
    requiredIndicator: baseStyleRequiredIndicator,
    helperText: baseStyleHelperText
  });
  var formTheme = defineMultiStyleConfig20({
    baseStyle: baseStyle29
  });

  // node_modules/@chakra-ui/theme/dist/chunk-SRBDDT7F.mjs
  var { definePartsStyle: definePartsStyle21, defineMultiStyleConfig: defineMultiStyleConfig21 } = createMultiStyleConfigHelpers(formErrorAnatomy.keys);
  var $fg5 = cssVar("form-error-color");
  var baseStyleText = defineStyle({
    [$fg5.variable]: `colors.red.500`,
    _dark: {
      [$fg5.variable]: `colors.red.300`
    },
    color: $fg5.reference,
    mt: "2",
    fontSize: "sm",
    lineHeight: "normal"
  });
  var baseStyleIcon6 = defineStyle({
    marginEnd: "0.5em",
    [$fg5.variable]: `colors.red.500`,
    _dark: {
      [$fg5.variable]: `colors.red.300`
    },
    color: $fg5.reference
  });
  var baseStyle30 = definePartsStyle21({
    text: baseStyleText,
    icon: baseStyleIcon6
  });
  var formErrorTheme = defineMultiStyleConfig21({
    baseStyle: baseStyle30
  });

  // node_modules/@chakra-ui/theme/dist/chunk-VHM7WLW6.mjs
  var baseStyle31 = defineStyle({
    fontSize: "md",
    marginEnd: "3",
    mb: "2",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "normal",
    opacity: 1,
    _disabled: {
      opacity: 0.4
    }
  });
  var formLabelTheme = defineStyleConfig({
    baseStyle: baseStyle31
  });

  // node_modules/@chakra-ui/theme/dist/chunk-WXARPSDQ.mjs
  var baseStyle32 = defineStyle({
    fontFamily: "heading",
    fontWeight: "bold"
  });
  var sizes19 = {
    "4xl": defineStyle({
      fontSize: ["6xl", null, "7xl"],
      lineHeight: 1
    }),
    "3xl": defineStyle({
      fontSize: ["5xl", null, "6xl"],
      lineHeight: 1
    }),
    "2xl": defineStyle({
      fontSize: ["4xl", null, "5xl"],
      lineHeight: [1.2, null, 1]
    }),
    xl: defineStyle({
      fontSize: ["3xl", null, "4xl"],
      lineHeight: [1.33, null, 1.2]
    }),
    lg: defineStyle({
      fontSize: ["2xl", null, "3xl"],
      lineHeight: [1.33, null, 1.2]
    }),
    md: defineStyle({
      fontSize: "xl",
      lineHeight: 1.2
    }),
    sm: defineStyle({
      fontSize: "md",
      lineHeight: 1.2
    }),
    xs: defineStyle({
      fontSize: "sm",
      lineHeight: 1.2
    })
  };
  var headingTheme = defineStyleConfig({
    baseStyle: baseStyle32,
    sizes: sizes19,
    defaultProps: {
      size: "xl"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-FU5DDBRC.mjs
  var { defineMultiStyleConfig: defineMultiStyleConfig22, definePartsStyle: definePartsStyle22 } = createMultiStyleConfigHelpers(breadcrumbAnatomy.keys);
  var $decor = cssVar("breadcrumb-link-decor");
  var baseStyleLink = defineStyle({
    transitionProperty: "common",
    transitionDuration: "fast",
    transitionTimingFunction: "ease-out",
    outline: "none",
    color: "inherit",
    textDecoration: $decor.reference,
    [$decor.variable]: "none",
    "&:not([aria-current=page])": {
      cursor: "pointer",
      _hover: {
        [$decor.variable]: "underline"
      },
      _focusVisible: {
        boxShadow: "outline"
      }
    }
  });
  var baseStyle33 = definePartsStyle22({
    link: baseStyleLink
  });
  var breadcrumbTheme = defineMultiStyleConfig22({
    baseStyle: baseStyle33
  });

  // node_modules/@chakra-ui/theme/dist/chunk-MBVM6PEK.mjs
  var baseStyle34 = defineStyle({
    lineHeight: "1.2",
    borderRadius: "md",
    fontWeight: "semibold",
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed",
      boxShadow: "none"
    },
    _hover: {
      _disabled: {
        bg: "initial"
      }
    }
  });
  var variantGhost = defineStyle((props) => {
    const { colorScheme: c, theme: theme3 } = props;
    if (c === "gray") {
      return {
        color: mode(`gray.800`, `whiteAlpha.900`)(props),
        _hover: {
          bg: mode(`gray.100`, `whiteAlpha.200`)(props)
        },
        _active: { bg: mode(`gray.200`, `whiteAlpha.300`)(props) }
      };
    }
    const darkHoverBg = transparentize2(`${c}.200`, 0.12)(theme3);
    const darkActiveBg = transparentize2(`${c}.200`, 0.24)(theme3);
    return {
      color: mode(`${c}.600`, `${c}.200`)(props),
      bg: "transparent",
      _hover: {
        bg: mode(`${c}.50`, darkHoverBg)(props)
      },
      _active: {
        bg: mode(`${c}.100`, darkActiveBg)(props)
      }
    };
  });
  var variantOutline3 = defineStyle((props) => {
    const { colorScheme: c } = props;
    const borderColor = mode(`gray.200`, `whiteAlpha.300`)(props);
    return {
      border: "1px solid",
      borderColor: c === "gray" ? borderColor : "currentColor",
      ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": { marginEnd: "-1px" },
      ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": { marginBottom: "-1px" },
      ...runIfFn2(variantGhost, props)
    };
  });
  var accessibleColorMap = {
    yellow: {
      bg: "yellow.400",
      color: "black",
      hoverBg: "yellow.500",
      activeBg: "yellow.600"
    },
    cyan: {
      bg: "cyan.400",
      color: "black",
      hoverBg: "cyan.500",
      activeBg: "cyan.600"
    }
  };
  var variantSolid2 = defineStyle((props) => {
    var _a7;
    const { colorScheme: c } = props;
    if (c === "gray") {
      const bg2 = mode(`gray.100`, `whiteAlpha.200`)(props);
      return {
        bg: bg2,
        color: mode(`gray.800`, `whiteAlpha.900`)(props),
        _hover: {
          bg: mode(`gray.200`, `whiteAlpha.300`)(props),
          _disabled: {
            bg: bg2
          }
        },
        _active: { bg: mode(`gray.300`, `whiteAlpha.400`)(props) }
      };
    }
    const {
      bg = `${c}.500`,
      color: color4 = "white",
      hoverBg = `${c}.600`,
      activeBg = `${c}.700`
    } = (_a7 = accessibleColorMap[c]) != null ? _a7 : {};
    const background2 = mode(bg, `${c}.200`)(props);
    return {
      bg: background2,
      color: mode(color4, `gray.800`)(props),
      _hover: {
        bg: mode(hoverBg, `${c}.300`)(props),
        _disabled: {
          bg: background2
        }
      },
      _active: { bg: mode(activeBg, `${c}.400`)(props) }
    };
  });
  var variantLink = defineStyle((props) => {
    const { colorScheme: c } = props;
    return {
      padding: 0,
      height: "auto",
      lineHeight: "normal",
      verticalAlign: "baseline",
      color: mode(`${c}.500`, `${c}.200`)(props),
      _hover: {
        textDecoration: "underline",
        _disabled: {
          textDecoration: "none"
        }
      },
      _active: {
        color: mode(`${c}.700`, `${c}.500`)(props)
      }
    };
  });
  var variantUnstyled3 = defineStyle({
    bg: "none",
    color: "inherit",
    display: "inline",
    lineHeight: "inherit",
    m: "0",
    p: "0"
  });
  var variants8 = {
    ghost: variantGhost,
    outline: variantOutline3,
    solid: variantSolid2,
    link: variantLink,
    unstyled: variantUnstyled3
  };
  var sizes20 = {
    lg: defineStyle({
      h: "12",
      minW: "12",
      fontSize: "lg",
      px: "6"
    }),
    md: defineStyle({
      h: "10",
      minW: "10",
      fontSize: "md",
      px: "4"
    }),
    sm: defineStyle({
      h: "8",
      minW: "8",
      fontSize: "sm",
      px: "3"
    }),
    xs: defineStyle({
      h: "6",
      minW: "6",
      fontSize: "xs",
      px: "2"
    })
  };
  var buttonTheme = defineStyleConfig({
    baseStyle: baseStyle34,
    variants: variants8,
    sizes: sizes20,
    defaultProps: {
      variant: "solid",
      size: "md",
      colorScheme: "gray"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-F7CKIHPM.mjs
  var { definePartsStyle: definePartsStyle23, defineMultiStyleConfig: defineMultiStyleConfig23 } = createMultiStyleConfigHelpers(cardAnatomy.keys);
  var $bg13 = cssVar("card-bg");
  var $padding2 = cssVar("card-padding");
  var $shadow4 = cssVar("card-shadow");
  var $radius = cssVar("card-radius");
  var $border3 = cssVar("card-border-width", "0");
  var $borderColor = cssVar("card-border-color");
  var baseStyle35 = definePartsStyle23({
    container: {
      [$bg13.variable]: "colors.chakra-body-bg",
      backgroundColor: $bg13.reference,
      boxShadow: $shadow4.reference,
      borderRadius: $radius.reference,
      color: "chakra-body-text",
      borderWidth: $border3.reference,
      borderColor: $borderColor.reference
    },
    body: {
      padding: $padding2.reference,
      flex: "1 1 0%"
    },
    header: {
      padding: $padding2.reference
    },
    footer: {
      padding: $padding2.reference
    }
  });
  var sizes21 = {
    sm: definePartsStyle23({
      container: {
        [$radius.variable]: "radii.base",
        [$padding2.variable]: "space.3"
      }
    }),
    md: definePartsStyle23({
      container: {
        [$radius.variable]: "radii.md",
        [$padding2.variable]: "space.5"
      }
    }),
    lg: definePartsStyle23({
      container: {
        [$radius.variable]: "radii.xl",
        [$padding2.variable]: "space.7"
      }
    })
  };
  var variants9 = {
    elevated: definePartsStyle23({
      container: {
        [$shadow4.variable]: "shadows.base",
        _dark: {
          [$bg13.variable]: "colors.gray.700"
        }
      }
    }),
    outline: definePartsStyle23({
      container: {
        [$border3.variable]: "1px",
        [$borderColor.variable]: "colors.chakra-border-color"
      }
    }),
    filled: definePartsStyle23({
      container: {
        [$bg13.variable]: "colors.chakra-subtle-bg"
      }
    }),
    unstyled: {
      body: {
        [$padding2.variable]: 0
      },
      header: {
        [$padding2.variable]: 0
      },
      footer: {
        [$padding2.variable]: 0
      }
    }
  };
  var cardTheme = defineMultiStyleConfig23({
    baseStyle: baseStyle35,
    variants: variants9,
    sizes: sizes21,
    defaultProps: {
      variant: "elevated",
      size: "md"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-OB7MMEC3.mjs
  var $size4 = cssVar2("close-button-size");
  var $bg14 = cssVar2("close-button-bg");
  var baseStyle36 = defineStyle({
    w: [$size4.reference],
    h: [$size4.reference],
    borderRadius: "md",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed",
      boxShadow: "none"
    },
    _hover: {
      [$bg14.variable]: "colors.blackAlpha.100",
      _dark: {
        [$bg14.variable]: "colors.whiteAlpha.100"
      }
    },
    _active: {
      [$bg14.variable]: "colors.blackAlpha.200",
      _dark: {
        [$bg14.variable]: "colors.whiteAlpha.200"
      }
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    bg: $bg14.reference
  });
  var sizes22 = {
    lg: defineStyle({
      [$size4.variable]: "sizes.10",
      fontSize: "md"
    }),
    md: defineStyle({
      [$size4.variable]: "sizes.8",
      fontSize: "xs"
    }),
    sm: defineStyle({
      [$size4.variable]: "sizes.6",
      fontSize: "2xs"
    })
  };
  var closeButtonTheme = defineStyleConfig({
    baseStyle: baseStyle36,
    sizes: sizes22,
    defaultProps: {
      size: "md"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-K3RH7Y2L.mjs
  var { variants: variants10, defaultProps } = badgeTheme;
  var baseStyle37 = defineStyle({
    fontFamily: "mono",
    fontSize: "sm",
    px: "0.2em",
    borderRadius: "sm",
    bg: vars.bg.reference,
    color: vars.color.reference,
    boxShadow: vars.shadow.reference
  });
  var codeTheme = defineStyleConfig({
    baseStyle: baseStyle37,
    variants: variants10,
    defaultProps
  });

  // node_modules/@chakra-ui/theme/dist/chunk-TECE6HDR.mjs
  var baseStyle38 = defineStyle({
    w: "100%",
    mx: "auto",
    maxW: "prose",
    px: "4"
  });
  var containerTheme = defineStyleConfig({
    baseStyle: baseStyle38
  });

  // node_modules/@chakra-ui/theme/dist/chunk-5S44M2O4.mjs
  var baseStyle39 = defineStyle({
    opacity: 0.6,
    borderColor: "inherit"
  });
  var variantSolid3 = defineStyle({
    borderStyle: "solid"
  });
  var variantDashed = defineStyle({
    borderStyle: "dashed"
  });
  var variants11 = {
    solid: variantSolid3,
    dashed: variantDashed
  };
  var dividerTheme = defineStyleConfig({
    baseStyle: baseStyle39,
    variants: variants11,
    defaultProps: {
      variant: "solid"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-J7AGDWFO.mjs
  var { definePartsStyle: definePartsStyle24, defineMultiStyleConfig: defineMultiStyleConfig24 } = createMultiStyleConfigHelpers(accordionAnatomy.keys);
  var baseStyleContainer4 = defineStyle({
    borderTopWidth: "1px",
    borderColor: "inherit",
    _last: {
      borderBottomWidth: "1px"
    }
  });
  var baseStyleButton2 = defineStyle({
    transitionProperty: "common",
    transitionDuration: "normal",
    fontSize: "md",
    _focusVisible: {
      boxShadow: "outline"
    },
    _hover: {
      bg: "blackAlpha.50"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    px: "4",
    py: "2"
  });
  var baseStylePanel = defineStyle({
    pt: "2",
    px: "4",
    pb: "5"
  });
  var baseStyleIcon7 = defineStyle({
    fontSize: "1.25em"
  });
  var baseStyle40 = definePartsStyle24({
    container: baseStyleContainer4,
    button: baseStyleButton2,
    panel: baseStylePanel,
    icon: baseStyleIcon7
  });
  var accordionTheme = defineMultiStyleConfig24({ baseStyle: baseStyle40 });

  // node_modules/@chakra-ui/theme/dist/chunk-BNQWYFTH.mjs
  var { definePartsStyle: definePartsStyle25, defineMultiStyleConfig: defineMultiStyleConfig25 } = createMultiStyleConfigHelpers(alertAnatomy.keys);
  var $fg6 = cssVar("alert-fg");
  var $bg15 = cssVar("alert-bg");
  var baseStyle41 = definePartsStyle25({
    container: {
      bg: $bg15.reference,
      px: "4",
      py: "3"
    },
    title: {
      fontWeight: "bold",
      lineHeight: "6",
      marginEnd: "2"
    },
    description: {
      lineHeight: "6"
    },
    icon: {
      color: $fg6.reference,
      flexShrink: 0,
      marginEnd: "3",
      w: "5",
      h: "6"
    },
    spinner: {
      color: $fg6.reference,
      flexShrink: 0,
      marginEnd: "3",
      w: "5",
      h: "5"
    }
  });
  function getBg(props) {
    const { theme: theme3, colorScheme: c } = props;
    const darkBg = transparentize2(`${c}.200`, 0.16)(theme3);
    return {
      light: `colors.${c}.100`,
      dark: darkBg
    };
  }
  var variantSubtle2 = definePartsStyle25((props) => {
    const { colorScheme: c } = props;
    const bg = getBg(props);
    return {
      container: {
        [$fg6.variable]: `colors.${c}.600`,
        [$bg15.variable]: bg.light,
        _dark: {
          [$fg6.variable]: `colors.${c}.200`,
          [$bg15.variable]: bg.dark
        }
      }
    };
  });
  var variantLeftAccent = definePartsStyle25((props) => {
    const { colorScheme: c } = props;
    const bg = getBg(props);
    return {
      container: {
        [$fg6.variable]: `colors.${c}.600`,
        [$bg15.variable]: bg.light,
        _dark: {
          [$fg6.variable]: `colors.${c}.200`,
          [$bg15.variable]: bg.dark
        },
        paddingStart: "3",
        borderStartWidth: "4px",
        borderStartColor: $fg6.reference
      }
    };
  });
  var variantTopAccent = definePartsStyle25((props) => {
    const { colorScheme: c } = props;
    const bg = getBg(props);
    return {
      container: {
        [$fg6.variable]: `colors.${c}.600`,
        [$bg15.variable]: bg.light,
        _dark: {
          [$fg6.variable]: `colors.${c}.200`,
          [$bg15.variable]: bg.dark
        },
        pt: "2",
        borderTopWidth: "4px",
        borderTopColor: $fg6.reference
      }
    };
  });
  var variantSolid4 = definePartsStyle25((props) => {
    const { colorScheme: c } = props;
    return {
      container: {
        [$fg6.variable]: `colors.white`,
        [$bg15.variable]: `colors.${c}.600`,
        _dark: {
          [$fg6.variable]: `colors.gray.900`,
          [$bg15.variable]: `colors.${c}.200`
        },
        color: $fg6.reference
      }
    };
  });
  var variants12 = {
    subtle: variantSubtle2,
    "left-accent": variantLeftAccent,
    "top-accent": variantTopAccent,
    solid: variantSolid4
  };
  var alertTheme = defineMultiStyleConfig25({
    baseStyle: baseStyle41,
    variants: variants12,
    defaultProps: {
      variant: "subtle",
      colorScheme: "blue"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-Q5ZQE4MD.mjs
  var { definePartsStyle: definePartsStyle26, defineMultiStyleConfig: defineMultiStyleConfig26 } = createMultiStyleConfigHelpers(avatarAnatomy.keys);
  var $border4 = cssVar("avatar-border-color");
  var $bg16 = cssVar("avatar-bg");
  var $fs = cssVar("avatar-font-size");
  var $size5 = cssVar("avatar-size");
  var baseStyleBadge = defineStyle({
    borderRadius: "full",
    border: "0.2em solid",
    borderColor: $border4.reference,
    [$border4.variable]: "white",
    _dark: {
      [$border4.variable]: "colors.gray.800"
    }
  });
  var baseStyleExcessLabel = defineStyle({
    bg: $bg16.reference,
    fontSize: $fs.reference,
    width: $size5.reference,
    height: $size5.reference,
    lineHeight: "1",
    [$bg16.variable]: "colors.gray.200",
    _dark: {
      [$bg16.variable]: "colors.whiteAlpha.400"
    }
  });
  var baseStyleContainer5 = defineStyle((props) => {
    const { name, theme: theme3 } = props;
    const bg = name ? randomColor({ string: name }) : "colors.gray.400";
    const isBgDark = isDark(bg)(theme3);
    let color4 = "white";
    if (!isBgDark)
      color4 = "gray.800";
    return {
      bg: $bg16.reference,
      fontSize: $fs.reference,
      color: color4,
      borderColor: $border4.reference,
      verticalAlign: "top",
      width: $size5.reference,
      height: $size5.reference,
      "&:not([data-loaded])": {
        [$bg16.variable]: bg
      },
      [$border4.variable]: "colors.white",
      _dark: {
        [$border4.variable]: "colors.gray.800"
      }
    };
  });
  var baseStyleLabel5 = defineStyle({
    fontSize: $fs.reference,
    lineHeight: "1"
  });
  var baseStyle42 = definePartsStyle26((props) => ({
    badge: runIfFn2(baseStyleBadge, props),
    excessLabel: runIfFn2(baseStyleExcessLabel, props),
    container: runIfFn2(baseStyleContainer5, props),
    label: baseStyleLabel5
  }));
  function getSize4(size2) {
    const themeSize = size2 !== "100%" ? sizes_default[size2] : void 0;
    return definePartsStyle26({
      container: {
        [$size5.variable]: themeSize != null ? themeSize : size2,
        [$fs.variable]: `calc(${themeSize != null ? themeSize : size2} / 2.5)`
      },
      excessLabel: {
        [$size5.variable]: themeSize != null ? themeSize : size2,
        [$fs.variable]: `calc(${themeSize != null ? themeSize : size2} / 2.5)`
      }
    });
  }
  var sizes23 = {
    "2xs": getSize4(4),
    xs: getSize4(6),
    sm: getSize4(8),
    md: getSize4(12),
    lg: getSize4(16),
    xl: getSize4(24),
    "2xl": getSize4(32),
    full: getSize4("100%")
  };
  var avatarTheme = defineMultiStyleConfig26({
    baseStyle: baseStyle42,
    sizes: sizes23,
    defaultProps: {
      size: "md"
    }
  });

  // node_modules/@chakra-ui/theme/dist/chunk-P7SDT22G.mjs
  var components = {
    Accordion: accordionTheme,
    Alert: alertTheme,
    Avatar: avatarTheme,
    Badge: badgeTheme,
    Breadcrumb: breadcrumbTheme,
    Button: buttonTheme,
    Checkbox: checkboxTheme,
    CloseButton: closeButtonTheme,
    Code: codeTheme,
    Container: containerTheme,
    Divider: dividerTheme,
    Drawer: drawerTheme,
    Editable: editableTheme,
    Form: formTheme,
    FormError: formErrorTheme,
    FormLabel: formLabelTheme,
    Heading: headingTheme,
    Input: inputTheme,
    Kbd: kbdTheme,
    Link: linkTheme,
    List: listTheme,
    Menu: menuTheme,
    Modal: modalTheme,
    NumberInput: numberInputTheme,
    PinInput: pinInputTheme,
    Popover: popoverTheme,
    Progress: progressTheme,
    Radio: radioTheme,
    Select: selectTheme,
    Skeleton: skeletonTheme,
    SkipLink: skipLinkTheme,
    Slider: sliderTheme,
    Spinner: spinnerTheme,
    Stat: statTheme,
    Switch: switchTheme,
    Table: tableTheme,
    Tabs: tabsTheme,
    Tag: tagTheme,
    Textarea: textareaTheme,
    Tooltip: tooltipTheme,
    Card: cardTheme,
    Stepper: stepperTheme
  };

  // node_modules/@chakra-ui/theme/dist/chunk-5GOSZLB7.mjs
  var semanticTokens = {
    colors: {
      "chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
      "chakra-body-bg": { _light: "white", _dark: "gray.800" },
      "chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
      "chakra-inverse-text": { _light: "white", _dark: "gray.800" },
      "chakra-subtle-bg": { _light: "gray.100", _dark: "gray.700" },
      "chakra-subtle-text": { _light: "gray.600", _dark: "gray.400" },
      "chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" }
    }
  };

  // node_modules/@chakra-ui/theme/dist/chunk-3F7U33P5.mjs
  var styles = {
    global: {
      body: {
        fontFamily: "body",
        color: "chakra-body-text",
        bg: "chakra-body-bg",
        transitionProperty: "background-color",
        transitionDuration: "normal",
        lineHeight: "base"
      },
      "*::placeholder": {
        color: "chakra-placeholder-color"
      },
      "*, *::before, &::after": {
        borderColor: "chakra-border-color"
      }
    }
  };

  // node_modules/@chakra-ui/theme/dist/index.mjs
  var direction = "ltr";
  var config = {
    useSystemColorMode: false,
    initialColorMode: "light",
    cssVarPrefix: "chakra"
  };
  var theme = {
    semanticTokens,
    direction,
    ...foundations,
    components,
    styles,
    config
  };
  var baseTheme = {
    semanticTokens,
    direction,
    components: {},
    ...foundations,
    styles,
    config
  };

  // node_modules/@chakra-ui/theme-utils/dist/chunk-LIR5QAZY.mjs
  var import_lodash5 = __toESM(require_lodash(), 1);
  function isFunction3(value) {
    return typeof value === "function";
  }
  function pipe2(...fns) {
    return (v) => fns.reduce((a, b) => b(a), v);
  }
  var createExtendTheme = (theme22) => {
    return function extendTheme2(...extensions) {
      let overrides = [...extensions];
      let activeTheme = extensions[extensions.length - 1];
      if (isChakraTheme(activeTheme) && // this ensures backward compatibility
      // previously only `extendTheme(override, activeTheme?)` was allowed
      overrides.length > 1) {
        overrides = overrides.slice(0, overrides.length - 1);
      } else {
        activeTheme = theme22;
      }
      return pipe2(
        ...overrides.map(
          (extension) => (prevTheme) => isFunction3(extension) ? extension(prevTheme) : mergeThemeOverride(prevTheme, extension)
        )
      )(activeTheme);
    };
  };
  var extendTheme = createExtendTheme(theme);
  var extendBaseTheme = createExtendTheme(baseTheme);
  function mergeThemeOverride(...overrides) {
    return (0, import_lodash5.default)({}, ...overrides, mergeThemeCustomizer);
  }
  function mergeThemeCustomizer(source, override, key, object) {
    if ((isFunction3(source) || isFunction3(override)) && Object.prototype.hasOwnProperty.call(object, key)) {
      return (...args) => {
        const sourceValue = isFunction3(source) ? source(...args) : source;
        const overrideValue = isFunction3(override) ? override(...args) : override;
        return (0, import_lodash5.default)({}, sourceValue, overrideValue, mergeThemeCustomizer);
      };
    }
    return void 0;
  }

  // node_modules/@chakra-ui/utils/dist/chunk-O3SWHQEE.mjs
  function canUseDOM() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  var isBrowser3 = /* @__PURE__ */ canUseDOM();

  // node_modules/@chakra-ui/utils/dist/chunk-YTQ3XZ3T.mjs
  var import_lodash6 = __toESM(require_lodash(), 1);
  function omit2(object, keys3) {
    const result = {};
    Object.keys(object).forEach((key) => {
      if (keys3.includes(key))
        return;
      result[key] = object[key];
    });
    return result;
  }
  function get2(obj, path, fallback, index) {
    const key = typeof path === "string" ? path.split(".") : [path];
    for (index = 0; index < key.length; index += 1) {
      if (!obj)
        break;
      obj = obj[key[index]];
    }
    return obj === void 0 ? fallback : obj;
  }
  var memoize3 = (fn2) => {
    const cache = /* @__PURE__ */ new WeakMap();
    const memoizedFn = (obj, path, fallback, index) => {
      if (typeof obj === "undefined") {
        return fn2(obj, path, fallback);
      }
      if (!cache.has(obj)) {
        cache.set(obj, /* @__PURE__ */ new Map());
      }
      const map2 = cache.get(obj);
      if (map2.has(path)) {
        return map2.get(path);
      }
      const value = fn2(obj, path, fallback, index);
      map2.set(path, value);
      return value;
    };
    return memoizedFn;
  };
  var memoizedGet2 = memoize3(get2);
  function objectFilter(object, fn2) {
    const result = {};
    Object.keys(object).forEach((key) => {
      const value = object[key];
      const shouldPass = fn2(value, key, object);
      if (shouldPass) {
        result[key] = value;
      }
    });
    return result;
  }
  var filterUndefined = (object) => objectFilter(object, (val) => val !== null && val !== void 0);

  // node_modules/@chakra-ui/utils/dist/chunk-Y5FGD7DM.mjs
  function isFunction4(value) {
    return typeof value === "function";
  }

  // node_modules/@chakra-ui/utils/dist/chunk-M3TFMUOL.mjs
  function runIfFn3(valueOrFn, ...args) {
    return isFunction4(valueOrFn) ? valueOrFn(...args) : valueOrFn;
  }
  function callAllHandlers2(...fns) {
    return function func(event) {
      fns.some((fn2) => {
        fn2 == null ? void 0 : fn2(event);
        return event == null ? void 0 : event.defaultPrevented;
      });
    };
  }

  // node_modules/@chakra-ui/system/dist/chunk-DMO4EI7P.mjs
  var import_react10 = __toESM(require_react(), 1);
  var import_react_fast_compare = __toESM(require_react_fast_compare(), 1);
  function useStyleConfigImpl(themeKey, props = {}) {
    var _a7;
    const { styleConfig: styleConfigProp, ...rest } = props;
    const { theme: theme3, colorMode } = useChakra();
    const themeStyleConfig = themeKey ? memoizedGet2(theme3, `components.${themeKey}`) : void 0;
    const styleConfig = styleConfigProp || themeStyleConfig;
    const mergedProps = (0, import_lodash6.default)(
      { theme: theme3, colorMode },
      (_a7 = styleConfig == null ? void 0 : styleConfig.defaultProps) != null ? _a7 : {},
      filterUndefined(omit2(rest, ["children"]))
    );
    const stylesRef = (0, import_react10.useRef)({});
    if (styleConfig) {
      const getStyles = resolveStyleConfig(styleConfig);
      const styles2 = getStyles(mergedProps);
      const isStyleEqual = (0, import_react_fast_compare.default)(stylesRef.current, styles2);
      if (!isStyleEqual) {
        stylesRef.current = styles2;
      }
    }
    return stylesRef.current;
  }
  function useStyleConfig(themeKey, props = {}) {
    return useStyleConfigImpl(themeKey, props);
  }
  function useMultiStyleConfig(themeKey, props = {}) {
    return useStyleConfigImpl(themeKey, props);
  }

  // node_modules/@chakra-ui/system/dist/chunk-FDQH4LQI.mjs
  var allPropNames = /* @__PURE__ */ new Set([
    ...propNames,
    "textStyle",
    "layerStyle",
    "apply",
    "noOfLines",
    "focusBorderColor",
    "errorBorderColor",
    "as",
    "__css",
    "css",
    "sx"
  ]);
  var validHTMLProps = /* @__PURE__ */ new Set([
    "htmlWidth",
    "htmlHeight",
    "htmlSize",
    "htmlTranslate"
  ]);
  function shouldForwardProp(prop) {
    return validHTMLProps.has(prop) || !allPropNames.has(prop);
  }

  // node_modules/@chakra-ui/object-utils/dist/chunk-OLTBUDV5.mjs
  function assignAfter(target, ...sources) {
    if (target == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    const result = { ...target };
    for (const nextSource of sources) {
      if (nextSource == null)
        continue;
      for (const nextKey in nextSource) {
        if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey))
          continue;
        if (nextKey in result)
          delete result[nextKey];
        result[nextKey] = nextSource[nextKey];
      }
    }
    return result;
  }

  // node_modules/@chakra-ui/object-utils/dist/chunk-R3DH46PF.mjs
  function compact(object) {
    const clone3 = Object.assign({}, object);
    for (let key in clone3) {
      if (clone3[key] === void 0)
        delete clone3[key];
    }
    return clone3;
  }

  // node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
  var React4 = __toESM(require_react());

  // node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var isPropValid = /* @__PURE__ */ memoize(
    function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );

  // node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
  var testOmitPropsOnStringTag = isPropValid;
  var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
    return key !== "theme";
  };
  var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  };
  var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
    var shouldForwardProp2;
    if (options) {
      var optionsShouldForwardProp = options.shouldForwardProp;
      shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
        return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
      } : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp2 !== "function" && isReal) {
      shouldForwardProp2 = tag.__emotion_forwardProp;
    }
    return shouldForwardProp2;
  };
  var ILLEGAL_ESCAPE_SEQUENCE_ERROR2 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
  var Insertion5 = function Insertion6(_ref) {
    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache, serialized, isStringTag);
    });
    return null;
  };
  var createStyled = function createStyled2(tag, options) {
    if (true) {
      if (tag === void 0) {
        throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
      }
    }
    var isReal = tag.__emotion_real === tag;
    var baseTag = isReal && tag.__emotion_base || tag;
    var identifierName;
    var targetClassName;
    if (options !== void 0) {
      identifierName = options.label;
      targetClassName = options.target;
    }
    var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
    var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp("as");
    return function() {
      var args = arguments;
      var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
      if (identifierName !== void 0) {
        styles2.push("label:" + identifierName + ";");
      }
      if (args[0] == null || args[0].raw === void 0) {
        styles2.push.apply(styles2, args);
      } else {
        if (args[0][0] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
        }
        styles2.push(args[0][0]);
        var len = args.length;
        var i = 1;
        for (; i < len; i++) {
          if (args[0][i] === void 0) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
          }
          styles2.push(args[i], args[0][i]);
        }
      }
      var Styled = withEmotionCache(function(props, cache, ref) {
        var FinalTag = shouldUseAs && props.as || baseTag;
        var className = "";
        var classInterpolations = [];
        var mergedProps = props;
        if (props.theme == null) {
          mergedProps = {};
          for (var key in props) {
            mergedProps[key] = props[key];
          }
          mergedProps.theme = React4.useContext(ThemeContext);
        }
        if (typeof props.className === "string") {
          className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
        className += cache.key + "-" + serialized.name;
        if (targetClassName !== void 0) {
          className += " " + targetClassName;
        }
        var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
        var newProps = {};
        for (var _key in props) {
          if (shouldUseAs && _key === "as")
            continue;
          if (
            // $FlowFixMe
            finalShouldForwardProp(_key)
          ) {
            newProps[_key] = props[_key];
          }
        }
        newProps.className = className;
        newProps.ref = ref;
        return /* @__PURE__ */ React4.createElement(React4.Fragment, null, /* @__PURE__ */ React4.createElement(Insertion5, {
          cache,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }), /* @__PURE__ */ React4.createElement(FinalTag, newProps));
      });
      Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
      Styled.defaultProps = tag.defaultProps;
      Styled.__emotion_real = Styled;
      Styled.__emotion_base = baseTag;
      Styled.__emotion_styles = styles2;
      Styled.__emotion_forwardProp = shouldForwardProp2;
      Object.defineProperty(Styled, "toString", {
        value: function value() {
          if (targetClassName === void 0 && true) {
            return "NO_COMPONENT_SELECTOR";
          }
          return "." + targetClassName;
        }
      });
      Styled.withComponent = function(nextTag, nextOptions) {
        return createStyled2(nextTag, _extends({}, options, nextOptions, {
          shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
        })).apply(void 0, styles2);
      };
      return Styled;
    };
  };

  // node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js
  var import_react12 = __toESM(require_react());
  var tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  var newStyled = createStyled.bind();
  tags.forEach(function(tagName) {
    newStyled[tagName] = newStyled(tagName);
  });

  // node_modules/@chakra-ui/system/dist/chunk-5PL47M24.mjs
  var import_react13 = __toESM(require_react(), 1);
  var _a6;
  var emotion_styled = (_a6 = newStyled.default) != null ? _a6 : newStyled;
  var toCSSObject = ({ baseStyle: baseStyle43 }) => (props) => {
    const { theme: theme3, css: cssProp, __css, sx, ...rest } = props;
    const styleProps2 = objectFilter(rest, (_, prop) => isStyleProp(prop));
    const finalBaseStyle = runIfFn3(baseStyle43, props);
    const finalStyles = assignAfter(
      {},
      __css,
      finalBaseStyle,
      filterUndefined(styleProps2),
      sx
    );
    const computedCSS = css3(finalStyles)(props.theme);
    return cssProp ? [computedCSS, cssProp] : computedCSS;
  };
  function styled(component, options) {
    const { baseStyle: baseStyle43, ...styledOptions } = options != null ? options : {};
    if (!styledOptions.shouldForwardProp) {
      styledOptions.shouldForwardProp = shouldForwardProp;
    }
    const styleObject = toCSSObject({ baseStyle: baseStyle43 });
    const Component2 = emotion_styled(
      component,
      styledOptions
    )(styleObject);
    const chakraComponent = import_react13.default.forwardRef(function ChakraComponent(props, ref) {
      const { colorMode, forced } = useColorMode();
      return import_react13.default.createElement(Component2, {
        ref,
        "data-theme": forced ? colorMode : void 0,
        ...props
      });
    });
    return chakraComponent;
  }

  // node_modules/@chakra-ui/system/dist/chunk-ZHQNHOQS.mjs
  function factory() {
    const cache = /* @__PURE__ */ new Map();
    return new Proxy(styled, {
      /**
       * @example
       * const Div = chakra("div")
       * const WithChakra = chakra(AnotherComponent)
       */
      apply(target, thisArg, argArray) {
        return styled(...argArray);
      },
      /**
       * @example
       * <chakra.div />
       */
      get(_, element) {
        if (!cache.has(element)) {
          cache.set(element, styled(element));
        }
        return cache.get(element);
      }
    });
  }
  var chakra = factory();

  // node_modules/@chakra-ui/system/dist/chunk-ZJJGQIVY.mjs
  var import_react14 = __toESM(require_react(), 1);
  function forwardRef3(component) {
    return (0, import_react14.forwardRef)(component);
  }

  // node_modules/@chakra-ui/react-utils/dist/chunk-ITIKTQWJ.mjs
  var import_react15 = __toESM(require_react(), 1);
  function createContext4(options = {}) {
    const {
      strict = true,
      errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
      name
    } = options;
    const Context = (0, import_react15.createContext)(void 0);
    Context.displayName = name;
    function useContext17() {
      var _a7;
      const context = (0, import_react15.useContext)(Context);
      if (!context && strict) {
        const error2 = new Error(errorMessage);
        error2.name = "ContextError";
        (_a7 = Error.captureStackTrace) == null ? void 0 : _a7.call(Error, error2, useContext17);
        throw error2;
      }
      return context;
    }
    return [
      Context.Provider,
      useContext17,
      Context
    ];
  }

  // node_modules/@chakra-ui/system/dist/chunk-MFVQSVQB.mjs
  var import_react17 = __toESM(require_react(), 1);
  var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
  function ThemeProvider3(props) {
    const { cssVarsRoot, theme: theme3, children } = props;
    const computedTheme = (0, import_react17.useMemo)(() => toCSSVar(theme3), [theme3]);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(ThemeProvider, { theme: computedTheme, children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(CSSVars, { root: cssVarsRoot }),
      children
    ] });
  }
  function CSSVars({ root = ":host, :root" }) {
    const selector = [root, `[data-theme]`].join(",");
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Global, { styles: (theme3) => ({ [selector]: theme3.__cssVars }) });
  }
  var [StylesProvider, useStyles] = createContext4({
    name: "StylesContext",
    errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
  });
  function GlobalStyle() {
    const { colorMode } = useColorMode();
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      Global,
      {
        styles: (theme3) => {
          const styleObjectOrFn = memoizedGet2(theme3, "styles.global");
          const globalStyles = runIfFn3(styleObjectOrFn, { theme: theme3, colorMode });
          if (!globalStyles)
            return void 0;
          const styles2 = css3(globalStyles)(theme3);
          return styles2;
        }
      }
    );
  }

  // node_modules/@chakra-ui/react-env/dist/chunk-VMD3UMGK.mjs
  var import_react19 = __toESM(require_react(), 1);
  var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
  var EnvironmentContext = (0, import_react19.createContext)({
    getDocument() {
      return document;
    },
    getWindow() {
      return window;
    }
  });
  EnvironmentContext.displayName = "EnvironmentContext";
  function useEnvironment({ defer } = {}) {
    const [, forceUpdate] = (0, import_react19.useReducer)((c) => c + 1, 0);
    useSafeLayoutEffect(() => {
      if (!defer)
        return;
      forceUpdate();
    }, [defer]);
    return (0, import_react19.useContext)(EnvironmentContext);
  }
  function EnvironmentProvider(props) {
    const { children, environment: environmentProp, disabled } = props;
    const ref = (0, import_react19.useRef)(null);
    const context = (0, import_react19.useMemo)(() => {
      if (environmentProp)
        return environmentProp;
      return {
        getDocument: () => {
          var _a7, _b5;
          return (_b5 = (_a7 = ref.current) == null ? void 0 : _a7.ownerDocument) != null ? _b5 : document;
        },
        getWindow: () => {
          var _a7, _b5;
          return (_b5 = (_a7 = ref.current) == null ? void 0 : _a7.ownerDocument.defaultView) != null ? _b5 : window;
        }
      };
    }, [environmentProp]);
    const showSpan = !disabled || !environmentProp;
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(EnvironmentContext.Provider, { value: context, children: [
      children,
      showSpan && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { id: "__chakra_env", hidden: true, ref })
    ] });
  }
  EnvironmentProvider.displayName = "EnvironmentProvider";

  // node_modules/@chakra-ui/provider/dist/chunk-3DDHO3UN.mjs
  var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
  var ChakraProvider = (props) => {
    const {
      children,
      colorModeManager,
      portalZIndex,
      resetScope,
      resetCSS = true,
      theme: theme3 = {},
      environment,
      cssVarsRoot,
      disableEnvironment,
      disableGlobalStyle
    } = props;
    const _children = /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      EnvironmentProvider,
      {
        environment,
        disabled: disableEnvironment,
        children
      }
    );
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ThemeProvider3, { theme: theme3, cssVarsRoot, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
      ColorModeProvider,
      {
        colorModeManager,
        options: theme3.config,
        children: [
          resetCSS ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CSSReset, { scope: resetScope }) : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CSSPolyfill, {}),
          !disableGlobalStyle && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(GlobalStyle, {}),
          portalZIndex ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(PortalManager, { zIndex: portalZIndex, children: _children }) : _children
        ]
      }
    ) });
  };

  // node_modules/@chakra-ui/toast/dist/chunk-LDADOVIM.mjs
  var findById = (arr, id3) => arr.find((toast) => toast.id === id3);
  function findToast(toasts, id3) {
    const position3 = getToastPosition(toasts, id3);
    const index = position3 ? toasts[position3].findIndex((toast) => toast.id === id3) : -1;
    return {
      position: position3,
      index
    };
  }
  function getToastPosition(toasts, id3) {
    for (const [position3, values] of Object.entries(toasts)) {
      if (findById(values, id3)) {
        return position3;
      }
    }
  }
  function getToastStyle(position3) {
    const isRighty = position3.includes("right");
    const isLefty = position3.includes("left");
    let alignItems = "center";
    if (isRighty)
      alignItems = "flex-end";
    if (isLefty)
      alignItems = "flex-start";
    return {
      display: "flex",
      flexDirection: "column",
      alignItems
    };
  }
  function getToastListStyle(position3) {
    const isTopOrBottom = position3 === "top" || position3 === "bottom";
    const margin = isTopOrBottom ? "0 auto" : void 0;
    const top2 = position3.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
    const bottom2 = position3.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
    const right2 = !position3.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
    const left2 = !position3.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
    return {
      position: "fixed",
      zIndex: "var(--toast-z-index, 5500)",
      pointerEvents: "none",
      display: "flex",
      flexDirection: "column",
      margin,
      top: top2,
      bottom: bottom2,
      right: right2,
      left: left2
    };
  }

  // node_modules/@chakra-ui/react-use-timeout/dist/index.mjs
  var import_react21 = __toESM(require_react(), 1);

  // node_modules/@chakra-ui/react-use-callback-ref/dist/index.mjs
  var import_react20 = __toESM(require_react(), 1);
  function useCallbackRef(callback, deps = []) {
    const callbackRef = (0, import_react20.useRef)(callback);
    (0, import_react20.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react20.useCallback)((...args) => {
      var _a7;
      return (_a7 = callbackRef.current) == null ? void 0 : _a7.call(callbackRef, ...args);
    }, deps);
  }

  // node_modules/@chakra-ui/react-use-timeout/dist/index.mjs
  function useTimeout(callback, delay2) {
    const fn2 = useCallbackRef(callback);
    (0, import_react21.useEffect)(() => {
      if (delay2 == null)
        return void 0;
      let timeoutId = null;
      timeoutId = window.setTimeout(() => {
        fn2();
      }, delay2);
      return () => {
        if (timeoutId) {
          window.clearTimeout(timeoutId);
        }
      };
    }, [delay2, fn2]);
  }

  // node_modules/@chakra-ui/react-use-update-effect/dist/index.mjs
  var import_react22 = __toESM(require_react(), 1);
  function useUpdateEffect(callback, deps) {
    const renderCycleRef = (0, import_react22.useRef)(false);
    const effectCycleRef = (0, import_react22.useRef)(false);
    (0, import_react22.useEffect)(() => {
      const mounted = renderCycleRef.current;
      const run = mounted && effectCycleRef.current;
      if (run) {
        return callback();
      }
      effectCycleRef.current = true;
    }, deps);
    (0, import_react22.useEffect)(() => {
      renderCycleRef.current = true;
      return () => {
        renderCycleRef.current = false;
      };
    }, []);
  }

  // node_modules/framer-motion/dist/es/motion/index.mjs
  var React6 = __toESM(require_react(), 1);
  var import_react33 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
  var import_react23 = __toESM(require_react(), 1);
  var MotionConfigContext = (0, import_react23.createContext)({
    transformPagePoint: (p) => p,
    isStatic: false,
    reducedMotion: "never"
  });

  // node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
  var import_react24 = __toESM(require_react(), 1);
  var MotionContext = (0, import_react24.createContext)({});

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  var import_react28 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/PresenceContext.mjs
  var import_react25 = __toESM(require_react(), 1);
  var PresenceContext = (0, import_react25.createContext)(null);

  // node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var import_react26 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/is-browser.mjs
  var isBrowser4 = typeof document !== "undefined";

  // node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var useIsomorphicLayoutEffect = isBrowser4 ? import_react26.useLayoutEffect : import_react26.useEffect;

  // node_modules/framer-motion/dist/es/context/LazyContext.mjs
  var import_react27 = __toESM(require_react(), 1);
  var LazyContext = (0, import_react27.createContext)({ strict: false });

  // node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
  var camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

  // node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
  var optimizedAppearDataId = "framerAppearId";
  var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

  // node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs
  var MotionGlobalConfig = {
    skipAnimations: false,
    useManualTiming: false
  };

  // node_modules/framer-motion/dist/es/frameloop/render-step.mjs
  var Queue = class {
    constructor() {
      this.order = [];
      this.scheduled = /* @__PURE__ */ new Set();
    }
    add(process2) {
      if (!this.scheduled.has(process2)) {
        this.scheduled.add(process2);
        this.order.push(process2);
        return true;
      }
    }
    remove(process2) {
      const index = this.order.indexOf(process2);
      if (index !== -1) {
        this.order.splice(index, 1);
        this.scheduled.delete(process2);
      }
    }
    clear() {
      this.order.length = 0;
      this.scheduled.clear();
    }
  };
  function createRenderStep(runNextFrame) {
    let thisFrame = new Queue();
    let nextFrame = new Queue();
    let numToRun = 0;
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = /* @__PURE__ */ new WeakSet();
    const step = {
      /**
       * Schedule a process to run on the next frame.
       */
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (queue.add(callback) && addToCurrentFrame && isProcessing) {
          numToRun = thisFrame.order.length;
        }
        return callback;
      },
      /**
       * Cancel the provided callback from running on the next frame.
       */
      cancel: (callback) => {
        nextFrame.remove(callback);
        toKeepAlive.delete(callback);
      },
      /**
       * Execute all schedule callbacks.
       */
      process: (frameData2) => {
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        nextFrame.clear();
        numToRun = thisFrame.order.length;
        if (numToRun) {
          for (let i = 0; i < numToRun; i++) {
            const callback = thisFrame.order[i];
            if (toKeepAlive.has(callback)) {
              step.schedule(callback);
              runNextFrame();
            }
            callback(frameData2);
          }
        }
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }

  // node_modules/framer-motion/dist/es/frameloop/batcher.mjs
  var stepsOrder = [
    "prepare",
    "read",
    "update",
    "preRender",
    "render",
    "postRender"
  ];
  var maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state2 = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const steps2 = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(() => runNextFrame = true);
      return acc;
    }, {});
    const processStep = (stepId) => {
      steps2[stepId].process(state2);
    };
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state2.timestamp : performance.now();
      runNextFrame = false;
      state2.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state2.timestamp, maxElapsed), 1);
      state2.timestamp = timestamp;
      state2.isProcessing = true;
      stepsOrder.forEach(processStep);
      state2.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state2.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps2[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => stepsOrder.forEach((key) => steps2[key].cancel(process2));
    return { schedule, cancel, state: state2, steps: steps2 };
  }

  // node_modules/framer-motion/dist/es/frameloop/microtask.mjs
  var { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  function useVisualElement(Component2, visualState, props, createVisualElement) {
    const { visualElement: parent } = (0, import_react28.useContext)(MotionContext);
    const lazyContext = (0, import_react28.useContext)(LazyContext);
    const presenceContext = (0, import_react28.useContext)(PresenceContext);
    const reducedMotionConfig = (0, import_react28.useContext)(MotionConfigContext).reducedMotion;
    const visualElementRef = (0, import_react28.useRef)();
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component2, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig
      });
    }
    const visualElement = visualElementRef.current;
    (0, import_react28.useInsertionEffect)(() => {
      visualElement && visualElement.update(props, presenceContext);
    });
    const wantsHandoff = (0, import_react28.useRef)(Boolean(props[optimizedAppearDataAttribute] && !window.HandoffComplete));
    useIsomorphicLayoutEffect(() => {
      if (!visualElement)
        return;
      microtask.postRender(visualElement.render);
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    (0, import_react28.useEffect)(() => {
      if (!visualElement)
        return;
      visualElement.updateFeatures();
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        wantsHandoff.current = false;
        window.HandoffComplete = true;
      }
    });
    return visualElement;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  var import_react29 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
  function isRefObject(ref) {
    return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  function useMotionRef(visualState, visualElement, externalRef) {
    return (0, import_react29.useCallback)(
      (instance) => {
        instance && visualState.mount && visualState.mount(instance);
        if (visualElement) {
          instance ? visualElement.mount(instance) : visualElement.unmount();
        }
        if (externalRef) {
          if (typeof externalRef === "function") {
            externalRef(instance);
          } else if (isRefObject(externalRef)) {
            externalRef.current = instance;
          }
        }
      },
      /**
       * Only pass a new ref callback to React if we've received a visual element
       * factory. Otherwise we'll be mounting/remounting every time externalRef
       * or other dependencies change.
       */
      [visualElement]
    );
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  var import_react30 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
  function isVariantLabel(v) {
    return typeof v === "string" || Array.isArray(v);
  }

  // node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
  function isAnimationControls(v) {
    return v !== null && typeof v === "object" && typeof v.start === "function";
  }

  // node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
  var variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  var variantProps = ["initial", ...variantPriorityOrder];

  // node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context : {};
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, (0, import_react30.useContext)(MotionContext));
    return (0, import_react30.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }

  // node_modules/framer-motion/dist/es/motion/features/definitions.mjs
  var featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  };
  var featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name])
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/load-features.mjs
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key]
      };
    }
  }

  // node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
  var import_react31 = __toESM(require_react(), 1);
  var LayoutGroupContext = (0, import_react31.createContext)({});

  // node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
  var import_react32 = __toESM(require_react(), 1);
  var SwitchLayoutGroupContext = (0, import_react32.createContext)({});

  // node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
  var motionComponentSymbol = Symbol.for("motionComponentSymbol");

  // node_modules/framer-motion/dist/es/motion/index.mjs
  function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component: Component2 }) {
    preloadedFeatures2 && loadFeatures(preloadedFeatures2);
    function MotionComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...(0, import_react33.useContext)(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser4) {
        context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement);
        const initialLayoutGroupConfig = (0, import_react33.useContext)(SwitchLayoutGroupContext);
        const isStrict = (0, import_react33.useContext)(LazyContext).strict;
        if (context.visualElement) {
          MeasureLayout2 = context.visualElement.loadFeatures(
            // Note: Pass the full new combined props to correctly re-render dynamic feature components.
            configAndProps,
            isStrict,
            preloadedFeatures2,
            initialLayoutGroupConfig
          );
        }
      }
      return React6.createElement(
        MotionContext.Provider,
        { value: context },
        MeasureLayout2 && context.visualElement ? React6.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
        useRender(Component2, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
      );
    }
    const ForwardRefComponent = (0, import_react33.forwardRef)(MotionComponent);
    ForwardRefComponent[motionComponentSymbol] = Component2;
    return ForwardRefComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = (0, import_react33.useContext)(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }

  // node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
  function createMotionProxy(createConfig) {
    function custom(Component2, customMotionComponentConfig = {}) {
      return createMotionComponent(createConfig(Component2, customMotionComponentConfig));
    }
    if (typeof Proxy === "undefined") {
      return custom;
    }
    const componentCache = /* @__PURE__ */ new Map();
    return new Proxy(custom, {
      /**
       * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
       * The prop name is passed through as `key` and we can use that to generate a `motion`
       * DOM component with that name.
       */
      get: (_target, key) => {
        if (!componentCache.has(key)) {
          componentCache.set(key, custom(key));
        }
        return componentCache.get(key);
      }
    });
  }

  // node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
  var lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];

  // node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
  function isSVGComponent(Component2) {
    if (
      /**
       * If it's not a string, it's a custom React component. Currently we only support
       * HTML custom React components.
       */
      typeof Component2 !== "string" || /**
       * If it contains a dash, the element is a custom HTML webcomponent.
       */
      Component2.includes("-")
    ) {
      return false;
    } else if (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      lowercaseSVGElements.indexOf(Component2) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(Component2)
    ) {
      return true;
    }
    return false;
  }

  // node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  var import_react36 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/html/use-props.mjs
  var import_react34 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
  var scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    Object.assign(scaleCorrectors, correctors);
  }

  // node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
  var transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  var transformProps = new Set(transformPropOrder);

  // node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
  function isForcedMotionValue(key, { layout: layout3, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout3 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }

  // node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
  var isMotionValue = (value) => Boolean(value && value.getVelocity);

  // node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
  var translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  var numTransforms = transformPropOrder.length;
  function buildTransform(transform2, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate2) {
    let transformString = "";
    for (let i = 0; i < numTransforms; i++) {
      const key = transformPropOrder[i];
      if (transform2[key] !== void 0) {
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${transform2[key]}) `;
      }
    }
    if (enableHardwareAcceleration && !transform2.z) {
      transformString += "translateZ(0)";
    }
    transformString = transformString.trim();
    if (transformTemplate2) {
      transformString = transformTemplate2(transform2, transformIsDefault ? "" : transformString);
    } else if (allowTransformNone && transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
  var checkStringStartsWith = (token2) => (key) => typeof key === "string" && key.startsWith(token2);
  var isCSSVariableName = checkStringStartsWith("--");
  var startsAsVariableToken = checkStringStartsWith("var(--");
  var isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
      return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  var singleCssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)$/i;

  // node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
  var getValueAsType = (value, type) => {
    return type && typeof value === "number" ? type.transform(value) : value;
  };

  // node_modules/framer-motion/dist/es/utils/clamp.mjs
  var clamp = (min2, max2, v) => {
    if (v > max2)
      return max2;
    if (v < min2)
      return min2;
    return v;
  };

  // node_modules/framer-motion/dist/es/value/types/numbers/index.mjs
  var number = {
    test: (v) => typeof v === "number",
    parse: parseFloat,
    transform: (v) => v
  };
  var alpha = {
    ...number,
    transform: (v) => clamp(0, 1, v)
  };
  var scale = {
    ...number,
    default: 1
  };

  // node_modules/framer-motion/dist/es/value/types/utils.mjs
  var sanitize = (v) => Math.round(v * 1e5) / 1e5;
  var floatRegex = /(-)?([\d]*\.?[\d])+/g;
  var colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
  var singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
  function isString(v) {
    return typeof v === "string";
  }

  // node_modules/framer-motion/dist/es/value/types/numbers/units.mjs
  var createUnitType = (unit2) => ({
    test: (v) => isString(v) && v.endsWith(unit2) && v.split(" ").length === 1,
    parse: parseFloat,
    transform: (v) => `${v}${unit2}`
  });
  var degrees = createUnitType("deg");
  var percent = createUnitType("%");
  var px2 = createUnitType("px");
  var vh = createUnitType("vh");
  var vw = createUnitType("vw");
  var progressPercentage = {
    ...percent,
    parse: (v) => percent.parse(v) / 100,
    transform: (v) => percent.transform(v * 100)
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
  var int = {
    ...number,
    transform: Math.round
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
  var numberValueTypes = {
    // Border props
    borderWidth: px2,
    borderTopWidth: px2,
    borderRightWidth: px2,
    borderBottomWidth: px2,
    borderLeftWidth: px2,
    borderRadius: px2,
    radius: px2,
    borderTopLeftRadius: px2,
    borderTopRightRadius: px2,
    borderBottomRightRadius: px2,
    borderBottomLeftRadius: px2,
    // Positioning props
    width: px2,
    maxWidth: px2,
    height: px2,
    maxHeight: px2,
    size: px2,
    top: px2,
    right: px2,
    bottom: px2,
    left: px2,
    // Spacing props
    padding: px2,
    paddingTop: px2,
    paddingRight: px2,
    paddingBottom: px2,
    paddingLeft: px2,
    margin: px2,
    marginTop: px2,
    marginRight: px2,
    marginBottom: px2,
    marginLeft: px2,
    // Transform props
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px2,
    translateX: px2,
    translateY: px2,
    translateZ: px2,
    x: px2,
    y: px2,
    z: px2,
    perspective: px2,
    transformPerspective: px2,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px2,
    // Misc
    zIndex: int,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };

  // node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
  function buildHTMLStyles(state2, latestValues, options, transformTemplate2) {
    const { style, vars: vars2, transform: transform2, transformOrigin: transformOrigin2 } = state2;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    let transformIsNone = true;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (isCSSVariableName(key)) {
        vars2[key] = value;
        continue;
      }
      const valueType = numberValueTypes[key];
      const valueAsType = getValueAsType(value, valueType);
      if (transformProps.has(key)) {
        hasTransform2 = true;
        transform2[key] = valueAsType;
        if (!transformIsNone)
          continue;
        if (value !== (valueType.default || 0))
          transformIsNone = false;
      } else if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin2[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate2) {
        style.transform = buildTransform(state2.transform, options, transformIsNone, transformTemplate2);
      } else if (style.transform) {
        style.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }

  // node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
  var createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });

  // node_modules/framer-motion/dist/es/render/html/use-props.mjs
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate: transformTemplate2 }, visualState, isStatic) {
    return (0, import_react34.useMemo)(() => {
      const state2 = createHtmlRenderState();
      buildHTMLStyles(state2, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate2);
      return Object.assign({}, state2.vars, state2.style);
    }, [visualState]);
  }
  function useStyle(props, visualState, isStatic) {
    const styleProp = props.style || {};
    const style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
    return style;
  }
  function useHTMLProps(props, visualState, isStatic) {
    const htmlProps = {};
    const style = useStyle(props, visualState, isStatic);
    if (props.drag && props.dragListener !== false) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
  }

  // node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
  var validMotionProps = /* @__PURE__ */ new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
  var shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (!isValidProp)
      return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp(require_is_prop_valid_browser_cjs().default);
  } catch (_a7) {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object")
        continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
      props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  var import_react35 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
  function calcOrigin(origin, offset3, size2) {
    return typeof origin === "string" ? origin : px2.transform(offset3 + size2 * origin);
  }
  function calcSVGTransformOrigin(dimensions, originX, originY) {
    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
    return `${pxOriginX} ${pxOriginY}`;
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
  var dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  var camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length2, spacing2 = 1, offset3 = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys3 = useDashCase ? dashKeys : camelKeys;
    attrs[keys3.offset] = px2.transform(-offset3);
    const pathLength = px2.transform(length2);
    const pathSpacing = px2.transform(spacing2);
    attrs[keys3.array] = `${pathLength} ${pathSpacing}`;
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
  function buildSVGAttrs(state2, {
    attrX,
    attrY,
    attrScale,
    originX,
    originY,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
    // This is object creation, which we try to avoid per-frame.
    ...latest
  }, options, isSVGTag2, transformTemplate2) {
    buildHTMLStyles(state2, latest, options, transformTemplate2);
    if (isSVGTag2) {
      if (state2.style.viewBox) {
        state2.attrs.viewBox = state2.style.viewBox;
      }
      return;
    }
    state2.attrs = state2.style;
    state2.style = {};
    const { attrs, style, dimensions } = state2;
    if (attrs.transform) {
      if (dimensions)
        style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
      style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
    }
    if (attrX !== void 0)
      attrs.x = attrX;
    if (attrY !== void 0)
      attrs.y = attrY;
    if (attrScale !== void 0)
      attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
  var createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });

  // node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
  var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

  // node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  function useSVGProps(props, visualState, _isStatic, Component2) {
    const visualProps = (0, import_react35.useMemo)(() => {
      const state2 = createSvgRenderState();
      buildSVGAttrs(state2, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component2), props.transformTemplate);
      return {
        ...state2.attrs,
        style: { ...state2.style }
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  }

  // node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  function createUseRender(forwardMotionProps = false) {
    const useRender = (Component2, props, ref, { latestValues }, isStatic) => {
      const useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
      const visualProps = useVisualProps(props, latestValues, isStatic, Component2);
      const filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
      const elementProps = Component2 !== import_react36.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
      const { children } = props;
      const renderedChildren = (0, import_react36.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
      return (0, import_react36.createElement)(Component2, {
        ...elementProps,
        children: renderedChildren
      });
    };
    return useRender;
  }

  // node_modules/framer-motion/dist/es/render/html/utils/render.mjs
  function renderHTML(element, { style, vars: vars2 }, styleProp, projection) {
    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
    for (const key in vars2) {
      element.style.setProperty(key, vars2[key]);
    }
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
  var camelCaseAttributes = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);

  // node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }

  // node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps(props, prevProps) {
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps2(props, prevProps) {
    const newValues = scrapeMotionValuesFromProps(props, prevProps);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  var import_react38 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
  function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
    if (typeof definition === "function") {
      definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
    }
    if (typeof definition === "string") {
      definition = props.variants && props.variants[definition];
    }
    if (typeof definition === "function") {
      definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
    }
    return definition;
  }

  // node_modules/framer-motion/dist/es/utils/use-constant.mjs
  var import_react37 = __toESM(require_react(), 1);
  function useConstant(init3) {
    const ref = (0, import_react37.useRef)(null);
    if (ref.current === null) {
      ref.current = init3();
    }
    return ref.current;
  }

  // node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
  var isKeyframesTarget = (v) => {
    return Array.isArray(v);
  };

  // node_modules/framer-motion/dist/es/utils/resolve-value.mjs
  var isCustomValue = (v) => {
    return Boolean(v && typeof v === "object" && v.mix && v.toValue);
  };
  var resolveFinalValueInKeyframes = (v) => {
    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
  };

  // node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
  function resolveMotionValue(value) {
    const unwrappedValue = isMotionValue(value) ? value.get() : value;
    return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {
    const state2 = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
      renderState: createRenderState()
    };
    if (onMount) {
      state2.mount = (instance) => onMount(props, instance, state2);
    }
    return state2;
  }
  var makeUseVisualState = (config2) => (props, isStatic) => {
    const context = (0, import_react38.useContext)(MotionContext);
    const presenceContext = (0, import_react38.useContext)(PresenceContext);
    const make = () => makeState(config2, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0)
        initial = context.initial;
      if (animate === void 0)
        animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      list2.forEach((definition) => {
        const resolved = resolveVariantFromProps(props, definition);
        if (!resolved)
          return;
        const { transitionEnd, transition: transition3, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd)
          values[key] = transitionEnd[key];
      });
    }
    return values;
  }

  // node_modules/framer-motion/dist/es/utils/noop.mjs
  var noop3 = (any) => any;

  // node_modules/framer-motion/dist/es/frameloop/frame.mjs
  var { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop3, true);

  // node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
  var svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
      createRenderState: createSvgRenderState,
      onMount: (props, instance, { renderState, latestValues }) => {
        frame.read(() => {
          try {
            renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
          } catch (e3) {
            renderState.dimensions = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
          }
        });
        frame.render(() => {
          buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
          renderSVG(instance, renderState);
        });
      }
    })
  };

  // node_modules/framer-motion/dist/es/render/html/config-motion.mjs
  var htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps,
      createRenderState: createHtmlRenderState
    })
  };

  // node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
  function createDomMotionConfig(Component2, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
    const baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;
    return {
      ...baseConfig,
      preloadedFeatures: preloadedFeatures2,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component: Component2
    };
  }

  // node_modules/framer-motion/dist/es/events/add-dom-event.mjs
  function addDomEvent2(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }

  // node_modules/framer-motion/dist/es/events/utils/is-primary-pointer.mjs
  var isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };

  // node_modules/framer-motion/dist/es/events/event-info.mjs
  function extractEventInfo(event, pointType = "page") {
    return {
      point: {
        x: event[pointType + "X"],
        y: event[pointType + "Y"]
      }
    };
  }
  var addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };

  // node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent2(target, eventName, addPointerInfo(handler), options);
  }

  // node_modules/framer-motion/dist/es/utils/pipe.mjs
  var combineFunctions = (a, b) => (v) => b(a(v));
  var pipe4 = (...transformers) => transformers.reduce(combineFunctions);

  // node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
  function createLock(name) {
    let lock = null;
    return () => {
      const openLock = () => {
        lock = null;
      };
      if (lock === null) {
        lock = name;
        return openLock;
      }
      return false;
    };
  }
  var globalHorizontalLock = createLock("dragHorizontal");
  var globalVerticalLock = createLock("dragVertical");
  function getGlobalLock(drag2) {
    let lock = false;
    if (drag2 === "y") {
      lock = globalVerticalLock();
    } else if (drag2 === "x") {
      lock = globalHorizontalLock();
    } else {
      const openHorizontal = globalHorizontalLock();
      const openVertical = globalVerticalLock();
      if (openHorizontal && openVertical) {
        lock = () => {
          openHorizontal();
          openVertical();
        };
      } else {
        if (openHorizontal)
          openHorizontal();
        if (openVertical)
          openVertical();
      }
    }
    return lock;
  }
  function isDragActive() {
    const openGestureLock = getGlobalLock(true);
    if (!openGestureLock)
      return true;
    openGestureLock();
    return false;
  }

  // node_modules/framer-motion/dist/es/motion/features/Feature.mjs
  var Feature = class {
    constructor(node2) {
      this.isMounted = false;
      this.node = node2;
    }
    update() {
    }
  };

  // node_modules/framer-motion/dist/es/gestures/hover.mjs
  function addHoverEvent(node2, isActive) {
    const eventName = "pointer" + (isActive ? "enter" : "leave");
    const callbackName = "onHover" + (isActive ? "Start" : "End");
    const handleEvent = (event, info) => {
      if (event.pointerType === "touch" || isDragActive())
        return;
      const props = node2.getProps();
      if (node2.animationState && props.whileHover) {
        node2.animationState.setActive("whileHover", isActive);
      }
      if (props[callbackName]) {
        frame.update(() => props[callbackName](event, info));
      }
    };
    return addPointerEvent(node2.current, eventName, handleEvent, {
      passive: !node2.getProps()[callbackName]
    });
  }
  var HoverGesture = class extends Feature {
    mount() {
      this.unmount = pipe4(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/gestures/focus.mjs
  var FocusGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e3) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe4(addDomEvent2(this.node.current, "focus", () => this.onFocus()), addDomEvent2(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
  var isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };

  // node_modules/framer-motion/dist/es/gestures/press.mjs
  function fireSyntheticPointerEvent(name, handler) {
    if (!handler)
      return;
    const syntheticPointerEvent = new PointerEvent("pointer" + name);
    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
  }
  var PressGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.removeStartListeners = noop3;
      this.removeEndListeners = noop3;
      this.removeAccessibleListeners = noop3;
      this.startPointerPress = (startEvent, startInfo) => {
        if (this.isPressing)
          return;
        this.removeEndListeners();
        const props = this.node.getProps();
        const endPointerPress = (endEvent, endInfo) => {
          if (!this.checkPressEnd())
            return;
          const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
          frame.update(() => {
            !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
          });
        };
        const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, { passive: !(props.onTap || props["onPointerUp"]) });
        const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props["onPointerCancel"]) });
        this.removeEndListeners = pipe4(removePointerUpListener, removePointerCancelListener);
        this.startPress(startEvent, startInfo);
      };
      this.startAccessiblePress = () => {
        const handleKeydown = (keydownEvent) => {
          if (keydownEvent.key !== "Enter" || this.isPressing)
            return;
          const handleKeyup = (keyupEvent) => {
            if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
              return;
            fireSyntheticPointerEvent("up", (event, info) => {
              const { onTap } = this.node.getProps();
              if (onTap) {
                frame.update(() => onTap(event, info));
              }
            });
          };
          this.removeEndListeners();
          this.removeEndListeners = addDomEvent2(this.node.current, "keyup", handleKeyup);
          fireSyntheticPointerEvent("down", (event, info) => {
            this.startPress(event, info);
          });
        };
        const removeKeydownListener = addDomEvent2(this.node.current, "keydown", handleKeydown);
        const handleBlur = () => {
          if (!this.isPressing)
            return;
          fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
        };
        const removeBlurListener = addDomEvent2(this.node.current, "blur", handleBlur);
        this.removeAccessibleListeners = pipe4(removeKeydownListener, removeBlurListener);
      };
    }
    startPress(event, info) {
      this.isPressing = true;
      const { onTapStart, whileTap } = this.node.getProps();
      if (whileTap && this.node.animationState) {
        this.node.animationState.setActive("whileTap", true);
      }
      if (onTapStart) {
        frame.update(() => onTapStart(event, info));
      }
    }
    checkPressEnd() {
      this.removeEndListeners();
      this.isPressing = false;
      const props = this.node.getProps();
      if (props.whileTap && this.node.animationState) {
        this.node.animationState.setActive("whileTap", false);
      }
      return !isDragActive();
    }
    cancelPress(event, info) {
      if (!this.checkPressEnd())
        return;
      const { onTapCancel } = this.node.getProps();
      if (onTapCancel) {
        frame.update(() => onTapCancel(event, info));
      }
    }
    mount() {
      const props = this.node.getProps();
      const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props["onPointerStart"]) });
      const removeFocusListener = addDomEvent2(this.node.current, "focus", this.startAccessiblePress);
      this.removeStartListeners = pipe4(removePointerListener, removeFocusListener);
    }
    unmount() {
      this.removeStartListeners();
      this.removeEndListeners();
      this.removeAccessibleListeners();
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
  var observerCallbacks = /* @__PURE__ */ new WeakMap();
  var observers = /* @__PURE__ */ new WeakMap();
  var fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  var fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root, ...options }) {
    const lookupRoot = root || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
  var thresholdNames = {
    some: 0,
    all: 1
  };
  var InViewFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport: viewport2 = {} } = this.node.getProps();
      const { root, margin: rootMargin, amount = "some", once: once2 } = viewport2;
      const options = {
        root: root ? root.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting)
          return;
        this.isInView = isIntersecting;
        if (once2 && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined")
        return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  };
  function hasViewportOptionChanged({ viewport: viewport2 = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport2[name] !== prevViewport[name];
  }

  // node_modules/framer-motion/dist/es/motion/features/gestures.mjs
  var gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };

  // node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
  function shallowCompare(next2, prev2) {
    if (!Array.isArray(prev2))
      return false;
    const prevLength = prev2.length;
    if (prevLength !== next2.length)
      return false;
    for (let i = 0; i < prevLength; i++) {
      if (prev2[i] !== next2[i])
        return false;
    }
    return true;
  }

  // node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
  function getCurrent(visualElement) {
    const current = {};
    visualElement.values.forEach((value, key) => current[key] = value.get());
    return current;
  }
  function getVelocity(visualElement) {
    const velocity = {};
    visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());
    return velocity;
  }
  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));
  }

  // node_modules/framer-motion/dist/es/utils/errors.mjs
  var warning = noop3;
  var invariant = noop3;
  if (true) {
    warning = (check, message) => {
      if (!check && typeof console !== "undefined") {
        console.warn(message);
      }
    };
    invariant = (check, message) => {
      if (!check) {
        throw new Error(message);
      }
    };
  }

  // node_modules/framer-motion/dist/es/utils/time-conversion.mjs
  var secondsToMilliseconds = (seconds2) => seconds2 * 1e3;
  var millisecondsToSeconds = (milliseconds2) => milliseconds2 / 1e3;

  // node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
  var instantAnimationState = {
    current: false
  };

  // node_modules/framer-motion/dist/es/easing/utils/is-bezier-definition.mjs
  var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

  // node_modules/framer-motion/dist/es/animation/animators/waapi/easing.mjs
  function isWaapiSupportedEasing(easing) {
    return Boolean(!easing || typeof easing === "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
  }
  var cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
  var supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
  };
  function mapEasingToNativeEasing(easing) {
    if (!easing)
      return void 0;
    return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
  }

  // node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs
  function animateStyle(element, valueName, keyframes5, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
    const keyframeOptions = { [valueName]: keyframes5 };
    if (times)
      keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease2);
    if (Array.isArray(easing))
      keyframeOptions.easing = easing;
    return element.animate(keyframeOptions, {
      delay: delay2,
      duration,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    });
  }

  // node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
  function getFinalKeyframe(keyframes5, { repeat, repeatType = "loop" }) {
    const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes5.length - 1;
    return keyframes5[index];
  }

  // node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs
  var calcBezier = (t4, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t4 + (3 * a2 - 6 * a1)) * t4 + 3 * a1) * t4;
  var subdivisionPrecision = 1e-7;
  var subdivisionMaxIterations = 12;
  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noop3;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t4) => t4 === 0 || t4 === 1 ? t4 : calcBezier(getTForX(t4), mY1, mY2);
  }

  // node_modules/framer-motion/dist/es/easing/ease.mjs
  var easeIn = cubicBezier(0.42, 0, 1, 1);
  var easeOut = cubicBezier(0, 0, 0.58, 1);
  var easeInOut = cubicBezier(0.42, 0, 0.58, 1);

  // node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs
  var isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };

  // node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs
  var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

  // node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs
  var reverseEasing = (easing) => (p) => 1 - easing(1 - p);

  // node_modules/framer-motion/dist/es/easing/circ.mjs
  var circIn = (p) => 1 - Math.sin(Math.acos(p));
  var circOut = reverseEasing(circIn);
  var circInOut = mirrorEasing(circIn);

  // node_modules/framer-motion/dist/es/easing/back.mjs
  var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
  var backIn = reverseEasing(backOut);
  var backInOut = mirrorEasing(backIn);

  // node_modules/framer-motion/dist/es/easing/anticipate.mjs
  var anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

  // node_modules/framer-motion/dist/es/easing/utils/map.mjs
  var easingLookup = {
    linear: noop3,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  var easingDefinitionToFunction = (definition) => {
    if (Array.isArray(definition)) {
      invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (typeof definition === "string") {
      invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
      return easingLookup[definition];
    }
    return definition;
  };

  // node_modules/framer-motion/dist/es/utils/progress.mjs
  var progress = (from2, to, value) => {
    const toFromDifference = to - from2;
    return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
  };

  // node_modules/framer-motion/dist/es/utils/mix/number.mjs
  var mixNumber = (from2, to, progress2) => {
    return from2 + (to - from2) * progress2;
  };

  // node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs
  function hueToRgb(p, q, t4) {
    if (t4 < 0)
      t4 += 1;
    if (t4 > 1)
      t4 -= 1;
    if (t4 < 1 / 6)
      return p + (q - p) * 6 * t4;
    if (t4 < 1 / 2)
      return q;
    if (t4 < 2 / 3)
      return p + (q - p) * (2 / 3 - t4) * 6;
    return p;
  }
  function hslaToRgba({ hue: hue2, saturation, lightness, alpha: alpha2 }) {
    hue2 /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p = 2 * lightness - q;
      red = hueToRgb(p, q, hue2 + 1 / 3);
      green = hueToRgb(p, q, hue2);
      blue = hueToRgb(p, q, hue2 - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }

  // node_modules/framer-motion/dist/es/value/types/color/utils.mjs
  var isColorString = (type, testProp) => (v) => {
    return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));
  };
  var splitColor = (aName, bName, cName) => (v) => {
    if (!isString(v))
      return v;
    const [a, b, c, alpha2] = v.match(floatRegex);
    return {
      [aName]: parseFloat(a),
      [bName]: parseFloat(b),
      [cName]: parseFloat(c),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };

  // node_modules/framer-motion/dist/es/value/types/color/rgba.mjs
  var clampRgbUnit = (v) => clamp(0, 255, v);
  var rgbUnit = {
    ...number,
    transform: (v) => Math.round(clampRgbUnit(v))
  };
  var rgba2 = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };

  // node_modules/framer-motion/dist/es/value/types/color/hex.mjs
  function parseHex(v) {
    let r3 = "";
    let g = "";
    let b = "";
    let a = "";
    if (v.length > 5) {
      r3 = v.substring(1, 3);
      g = v.substring(3, 5);
      b = v.substring(5, 7);
      a = v.substring(7, 9);
    } else {
      r3 = v.substring(1, 2);
      g = v.substring(2, 3);
      b = v.substring(3, 4);
      a = v.substring(4, 5);
      r3 += r3;
      g += g;
      b += b;
      a += a;
    }
    return {
      red: parseInt(r3, 16),
      green: parseInt(g, 16),
      blue: parseInt(b, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1
    };
  }
  var hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba2.transform
  };

  // node_modules/framer-motion/dist/es/value/types/color/hsla.mjs
  var hsla2 = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({ hue: hue2, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue2) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };

  // node_modules/framer-motion/dist/es/utils/mix/color.mjs
  var mixLinearColor = (from2, to, v) => {
    const fromExpo = from2 * from2;
    const expo = v * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  var colorTypes = [hex, rgba2, hsla2];
  var getColorType = (v) => colorTypes.find((type) => type.test(v));
  function asRGBA(color4) {
    const type = getColorType(color4);
    invariant(Boolean(type), `'${color4}' is not an animatable color. Use the equivalent color code instead.`);
    let model = type.parse(color4);
    if (type === hsla2) {
      model = hslaToRgba(model);
    }
    return model;
  }
  var mixColor = (from2, to) => {
    const fromRGBA = asRGBA(from2);
    const toRGBA = asRGBA(to);
    const blended = { ...fromRGBA };
    return (v) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
      blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);
      return rgba2.transform(blended);
    };
  };

  // node_modules/framer-motion/dist/es/value/types/color/index.mjs
  var color2 = {
    test: (v) => rgba2.test(v) || hex.test(v) || hsla2.test(v),
    parse: (v) => {
      if (rgba2.test(v)) {
        return rgba2.parse(v);
      } else if (hsla2.test(v)) {
        return hsla2.parse(v);
      } else {
        return hex.parse(v);
      }
    },
    transform: (v) => {
      return isString(v) ? v : v.hasOwnProperty("red") ? rgba2.transform(v) : hsla2.transform(v);
    }
  };

  // node_modules/framer-motion/dist/es/value/types/complex/index.mjs
  function test(v) {
    var _a7, _b5;
    return isNaN(v) && isString(v) && (((_a7 = v.match(floatRegex)) === null || _a7 === void 0 ? void 0 : _a7.length) || 0) + (((_b5 = v.match(colorRegex)) === null || _b5 === void 0 ? void 0 : _b5.length) || 0) > 0;
  }
  var NUMBER_TOKEN = "number";
  var COLOR_TOKEN = "color";
  var VAR_TOKEN = "var";
  var VAR_FUNCTION_TOKEN = "var(";
  var SPLIT_TOKEN = "${}";
  var complexRegex = /(var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\))|(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))|((-)?([\d]*\.?[\d])+)/gi;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const matchedValues = originalValue.match(complexRegex) || [];
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types2 = [];
    for (let i = 0; i < matchedValues.length; i++) {
      const parsedValue = matchedValues[i];
      if (color2.test(parsedValue)) {
        indexes.color.push(i);
        types2.push(COLOR_TOKEN);
        values.push(color2.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i);
        types2.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i);
        types2.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
    }
    const tokenised = originalValue.replace(complexRegex, SPLIT_TOKEN);
    const split3 = tokenised.split(SPLIT_TOKEN);
    return { values, split: split3, indexes, types: types2 };
  }
  function parseComplexValue(v) {
    return analyseComplexValue(v).values;
  }
  function createTransformer(source) {
    const { split: split3, types: types2 } = analyseComplexValue(source);
    const numSections = split3.length;
    return (v) => {
      let output = "";
      for (let i = 0; i < numSections; i++) {
        output += split3[i];
        if (v[i] !== void 0) {
          const type = types2[i];
          if (type === NUMBER_TOKEN) {
            output += sanitize(v[i]);
          } else if (type === COLOR_TOKEN) {
            output += color2.transform(v[i]);
          } else {
            output += v[i];
          }
        }
      }
      return output;
    };
  }
  var convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
  function getAnimatableNone(v) {
    const parsed = parseComplexValue(v);
    const transformer2 = createTransformer(v);
    return transformer2(parsed.map(convertNumbersToZero));
  }
  var complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone
  };

  // node_modules/framer-motion/dist/es/utils/mix/complex.mjs
  function mixImmediate(a, b) {
    return (p) => p > 0 ? b : a;
  }
  function mixNumber2(a, b) {
    return (p) => mixNumber(a, b, p);
  }
  function getMixer(a) {
    if (typeof a === "number") {
      return mixNumber2;
    } else if (typeof a === "string") {
      return isCSSVariableToken(a) ? mixImmediate : color2.test(a) ? mixColor : mixComplex;
    } else if (Array.isArray(a)) {
      return mixArray;
    } else if (typeof a === "object") {
      return color2.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a, b) {
    const output = [...a];
    const numValues = output.length;
    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
    return (p) => {
      for (let i = 0; i < numValues; i++) {
        output[i] = blendValue[i](p);
      }
      return output;
    };
  }
  function mixObject(a, b) {
    const output = { ...a, ...b };
    const blendValue = {};
    for (const key in output) {
      if (a[key] !== void 0 && b[key] !== void 0) {
        blendValue[key] = getMixer(a[key])(a[key], b[key]);
      }
    }
    return (v) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v);
      }
      return output;
    };
  }
  function matchOrder(origin, target) {
    var _a7;
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i = 0; i < target.values.length; i++) {
      const type = target.types[i];
      const originIndex = origin.indexes[type][pointers[type]];
      const originValue = (_a7 = origin.values[originIndex]) !== null && _a7 !== void 0 ? _a7 : 0;
      orderedOrigin[i] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  var mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      return pipe4(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
      return mixImmediate(origin, target);
    }
  };

  // node_modules/framer-motion/dist/es/utils/mix/index.mjs
  function mix2(from2, to, p) {
    if (typeof from2 === "number" && typeof to === "number" && typeof p === "number") {
      return mixNumber(from2, to, p);
    }
    const mixer = getMixer(from2);
    return mixer(from2, to);
  }

  // node_modules/framer-motion/dist/es/utils/interpolate.mjs
  function createMixers(output, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || mix2;
    const numMixers = output.length - 1;
    for (let i = 0; i < numMixers; i++) {
      let mixer = mixerFactory(output[i], output[i + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i] || noop3 : ease2;
        mixer = pipe4(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output.length, "Both input and output ranges must be the same length");
    if (inputLength === 1)
      return () => output[0];
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output = [...output].reverse();
    }
    const mixers = createMixers(output, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v) => {
      let i = 0;
      if (numMixers > 1) {
        for (; i < input.length - 2; i++) {
          if (v < input[i + 1])
            break;
        }
      }
      const progressInRange = progress(input[i], input[i + 1], v);
      return mixers[i](progressInRange);
    };
    return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
  }

  // node_modules/framer-motion/dist/es/utils/offsets/fill.mjs
  function fillOffset(offset3, remaining) {
    const min2 = offset3[offset3.length - 1];
    for (let i = 1; i <= remaining; i++) {
      const offsetProgress = progress(0, remaining, i);
      offset3.push(mixNumber(min2, 1, offsetProgress));
    }
  }

  // node_modules/framer-motion/dist/es/utils/offsets/default.mjs
  function defaultOffset(arr) {
    const offset3 = [0];
    fillOffset(offset3, arr.length - 1);
    return offset3;
  }

  // node_modules/framer-motion/dist/es/utils/offsets/time.mjs
  function convertOffsetToTimes(offset3, duration) {
    return offset3.map((o) => o * duration);
  }

  // node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes3({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state2 = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(
      // Only use the provided offsets if they're the correct length
      // TODO Maybe we should warn here if there's a length mismatch
      times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
      duration
    );
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration,
      next: (t4) => {
        state2.value = mapTimeToKeyframe(t4);
        state2.done = t4 >= duration;
        return state2;
      }
    };
  }

  // node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }

  // node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs
  var velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t4, current) {
    const prevT = Math.max(t4 - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t4 - prevT);
  }

  // node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs
  var safeMin = 1e-3;
  var minDuration = 0.01;
  var maxDuration = 10;
  var minDamping = 0.05;
  var maxDamping = 1;
  function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
    let envelope;
    let derivative;
    warning(duration <= secondsToMilliseconds(maxDuration), "Spring duration must be 10 seconds or less");
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
    duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b = calcAngularFreq(undampedFreq2, dampingRatio);
        const c = Math.exp(-delta);
        return safeMin - a / b * c;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d = delta * velocity + velocity;
        const e3 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f = Math.exp(-delta);
        const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d - e3) * f) / g;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a * b;
      };
      derivative = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (velocity - undampedFreq2) * (duration * duration);
        return a * b;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: 100,
        damping: 10,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  var rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i = 1; i < rootIterations; i++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }

  // node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs
  var durationKeys = ["duration", "bounce"];
  var physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options, keys3) {
    return keys3.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: 0,
      stiffness: 100,
      damping: 10,
      mass: 1,
      isResolvedFromDuration: false,
      ...options
    };
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: 1
      };
      springOptions.isResolvedFromDuration = true;
    }
    return springOptions;
  }
  function spring({ keyframes: keyframes5, restDelta, restSpeed, ...options }) {
    const origin = keyframes5[0];
    const target = keyframes5[keyframes5.length - 1];
    const state2 = { done: false, value: origin };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options,
      velocity: -millisecondsToSeconds(options.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
    restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t4) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t4);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t4) + initialDelta * Math.cos(angularFreq * t4));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t4) => target - Math.exp(-undampedAngularFreq * t4) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t4);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t4) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t4);
        const freqForT = Math.min(dampedAngularFreq * t4, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    return {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t4) => {
        const current = resolveSpring(t4);
        if (!isResolvedFromDuration) {
          let currentVelocity = initialVelocity;
          if (t4 !== 0) {
            if (dampingRatio < 1) {
              currentVelocity = calcGeneratorVelocity(resolveSpring, t4, current);
            } else {
              currentVelocity = 0;
            }
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state2.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state2.done = t4 >= duration;
        }
        state2.value = state2.done ? target : current;
        return state2;
      }
    };
  }

  // node_modules/framer-motion/dist/es/animation/generators/inertia.mjs
  function inertia({ keyframes: keyframes5, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
    const origin = keyframes5[0];
    const state2 = {
      done: false,
      value: origin
    };
    const isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2;
    const nearestBoundary = (v) => {
      if (min2 === void 0)
        return max2;
      if (max2 === void 0)
        return min2;
      return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - origin;
    const calcDelta = (t4) => -amplitude * Math.exp(-t4 / timeConstant);
    const calcLatest = (t4) => target + calcDelta(t4);
    const applyFriction = (t4) => {
      const delta = calcDelta(t4);
      const latest = calcLatest(t4);
      state2.done = Math.abs(delta) <= restDelta;
      state2.value = state2.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t4) => {
      if (!isOutOfBounds(state2.value))
        return;
      timeReachedBoundary = t4;
      spring$1 = spring({
        keyframes: [state2.value, nearestBoundary(state2.value)],
        velocity: calcGeneratorVelocity(calcLatest, t4, state2.value),
        damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t4) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t4);
          checkCatchBoundary(t4);
        }
        if (timeReachedBoundary !== void 0 && t4 > timeReachedBoundary) {
          return spring$1.next(t4 - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t4);
          return state2;
        }
      }
    };
  }

  // node_modules/framer-motion/dist/es/frameloop/sync-time.mjs
  var now;
  function clearTime() {
    now = void 0;
  }
  var time = {
    now: () => {
      if (now === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    }
  };

  // node_modules/framer-motion/dist/es/animation/animators/js/driver-frameloop.mjs
  var frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
      start: () => frame.update(passTimestamp, true),
      stop: () => cancelFrame(passTimestamp),
      /**
       * If we're processing this frame we can use the
       * framelocked timestamp to keep things in sync.
       */
      now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };

  // node_modules/framer-motion/dist/es/animation/generators/utils/calc-duration.mjs
  var maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state2 = generator.next(duration);
    while (!state2.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state2 = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  }

  // node_modules/framer-motion/dist/es/animation/animators/js/index.mjs
  var types = {
    decay: inertia,
    inertia,
    tween: keyframes3,
    keyframes: keyframes3,
    spring
  };
  var percentToProgress = (percent2) => percent2 / 100;
  function animateValue({ autoplay = true, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$1, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options }) {
    let speed = 1;
    let hasStopped = false;
    let resolveFinishedPromise;
    let currentFinishedPromise;
    const updateFinishedPromise = () => {
      currentFinishedPromise = new Promise((resolve) => {
        resolveFinishedPromise = resolve;
      });
    };
    updateFinishedPromise();
    let animationDriver;
    const generatorFactory = types[type] || keyframes3;
    let mapNumbersToKeyframes;
    if (generatorFactory !== keyframes3 && typeof keyframes$1[0] !== "number") {
      if (true) {
        invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
      }
      mapNumbersToKeyframes = pipe4(percentToProgress, mix2(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    let mirroredGenerator;
    if (repeatType === "mirror") {
      mirroredGenerator = generatorFactory({
        ...options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -(options.velocity || 0)
      });
    }
    let playState = "idle";
    let holdTime = null;
    let startTime = null;
    let cancelTime = null;
    if (generator.calculatedDuration === null && repeat) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    let resolvedDuration = Infinity;
    let totalDuration = Infinity;
    if (calculatedDuration !== null) {
      resolvedDuration = calculatedDuration + repeatDelay;
      totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    }
    let currentTime = 0;
    const tick = (timestamp) => {
      if (startTime === null)
        return;
      if (speed > 0)
        startTime = Math.min(startTime, timestamp);
      if (speed < 0)
        startTime = Math.min(timestamp - totalDuration / speed, startTime);
      if (holdTime !== null) {
        currentTime = holdTime;
      } else {
        currentTime = Math.round(timestamp - startTime) * speed;
      }
      const timeWithoutDelay = currentTime - delay2 * (speed >= 0 ? 1 : -1);
      const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      currentTime = Math.max(timeWithoutDelay, 0);
      if (playState === "finished" && holdTime === null) {
        currentTime = totalDuration;
      }
      let elapsed = currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      const state2 = isInDelayPhase ? { done: false, value: keyframes$1[0] } : frameGenerator.next(elapsed);
      if (mapNumbersToKeyframes) {
        state2.value = mapNumbersToKeyframes(state2.value);
      }
      let { done } = state2;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
      }
      const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done);
      if (onUpdate) {
        onUpdate(state2.value);
      }
      if (isAnimationFinished) {
        finish();
      }
      return state2;
    };
    const stopAnimationDriver = () => {
      animationDriver && animationDriver.stop();
      animationDriver = void 0;
    };
    const cancel = () => {
      playState = "idle";
      stopAnimationDriver();
      resolveFinishedPromise();
      updateFinishedPromise();
      startTime = cancelTime = null;
    };
    const finish = () => {
      playState = "finished";
      onComplete && onComplete();
      stopAnimationDriver();
      resolveFinishedPromise();
    };
    const play = () => {
      if (hasStopped)
        return;
      if (!animationDriver)
        animationDriver = driver(tick);
      const now3 = animationDriver.now();
      onPlay && onPlay();
      if (holdTime !== null) {
        startTime = now3 - holdTime;
      } else if (!startTime || playState === "finished") {
        startTime = now3;
      }
      if (playState === "finished") {
        updateFinishedPromise();
      }
      cancelTime = startTime;
      holdTime = null;
      playState = "running";
      animationDriver.start();
    };
    if (autoplay) {
      play();
    }
    const controls = {
      then(resolve, reject) {
        return currentFinishedPromise.then(resolve, reject);
      },
      get time() {
        return millisecondsToSeconds(currentTime);
      },
      set time(newTime) {
        newTime = secondsToMilliseconds(newTime);
        currentTime = newTime;
        if (holdTime !== null || !animationDriver || speed === 0) {
          holdTime = newTime;
        } else {
          startTime = animationDriver.now() - newTime / speed;
        }
      },
      get duration() {
        const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
        return millisecondsToSeconds(duration);
      },
      get speed() {
        return speed;
      },
      set speed(newSpeed) {
        if (newSpeed === speed || !animationDriver)
          return;
        speed = newSpeed;
        controls.time = millisecondsToSeconds(currentTime);
      },
      get state() {
        return playState;
      },
      play,
      pause: () => {
        playState = "paused";
        holdTime = currentTime;
      },
      stop: () => {
        hasStopped = true;
        if (playState === "idle")
          return;
        playState = "idle";
        onStop && onStop();
        cancel();
      },
      cancel: () => {
        if (cancelTime !== null)
          tick(cancelTime);
        cancel();
      },
      complete: () => {
        playState = "finished";
      },
      sample: (elapsed) => {
        startTime = 0;
        return tick(elapsed);
      }
    };
    return controls;
  }

  // node_modules/framer-motion/dist/es/utils/memo.mjs
  function memo(callback) {
    let result;
    return () => {
      if (result === void 0)
        result = callback();
      return result;
    };
  }

  // node_modules/framer-motion/dist/es/animation/animators/waapi/create-accelerated-animation.mjs
  var supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  var acceleratedValues = /* @__PURE__ */ new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"
  ]);
  var sampleDelta = 10;
  var maxDuration2 = 2e4;
  var requiresPregeneratedKeyframes = (valueName, options) => options.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
  function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
    const canAccelerateAnimation = supportsWaapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0 && options.type !== "inertia";
    if (!canAccelerateAnimation)
      return false;
    let hasStopped = false;
    let resolveFinishedPromise;
    let currentFinishedPromise;
    let pendingCancel = false;
    const updateFinishedPromise = () => {
      currentFinishedPromise = new Promise((resolve) => {
        resolveFinishedPromise = resolve;
      });
    };
    updateFinishedPromise();
    let { keyframes: keyframes5, duration = 300, ease: ease2, times } = options;
    if (requiresPregeneratedKeyframes(valueName, options)) {
      const sampleAnimation = animateValue({
        ...options,
        repeat: 0,
        delay: 0
      });
      let state2 = { done: false, value: keyframes5[0] };
      const pregeneratedKeyframes = [];
      let t4 = 0;
      while (!state2.done && t4 < maxDuration2) {
        state2 = sampleAnimation.sample(t4);
        pregeneratedKeyframes.push(state2.value);
        t4 += sampleDelta;
      }
      times = void 0;
      keyframes5 = pregeneratedKeyframes;
      duration = t4 - sampleDelta;
      ease2 = "linear";
    }
    const animation = animateStyle(value.owner.current, valueName, keyframes5, {
      ...options,
      duration,
      /**
       * This function is currently not called if ease is provided
       * as a function so the cast is safe.
       *
       * However it would be possible for a future refinement to port
       * in easing pregeneration from Motion One for browsers that
       * support the upcoming `linear()` easing function.
       */
      ease: ease2,
      times
    });
    const cancelAnimation = () => {
      pendingCancel = false;
      animation.cancel();
    };
    const safeCancel = () => {
      pendingCancel = true;
      frame.update(cancelAnimation);
      resolveFinishedPromise();
      updateFinishedPromise();
    };
    animation.onfinish = () => {
      if (pendingCancel)
        return;
      value.set(getFinalKeyframe(keyframes5, options));
      onComplete && onComplete();
      safeCancel();
    };
    const controls = {
      then(resolve, reject) {
        return currentFinishedPromise.then(resolve, reject);
      },
      attachTimeline(timeline) {
        animation.timeline = timeline;
        animation.onfinish = null;
        return noop3;
      },
      get time() {
        return millisecondsToSeconds(animation.currentTime || 0);
      },
      set time(newTime) {
        animation.currentTime = secondsToMilliseconds(newTime);
      },
      get speed() {
        return animation.playbackRate;
      },
      set speed(newSpeed) {
        animation.playbackRate = newSpeed;
      },
      get duration() {
        return millisecondsToSeconds(duration);
      },
      play: () => {
        if (hasStopped)
          return;
        animation.play();
        cancelFrame(cancelAnimation);
      },
      pause: () => animation.pause(),
      stop: () => {
        hasStopped = true;
        if (animation.playState === "idle")
          return;
        const { currentTime } = animation;
        if (currentTime) {
          const sampleAnimation = animateValue({
            ...options,
            autoplay: false
          });
          value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
        }
        safeCancel();
      },
      complete: () => {
        if (pendingCancel)
          return;
        animation.finish();
      },
      cancel: safeCancel
    };
    return controls;
  }

  // node_modules/framer-motion/dist/es/animation/animators/instant.mjs
  function createInstantAnimation({ keyframes: keyframes5, delay: delay2, onUpdate, onComplete }) {
    const setValue = () => {
      onUpdate && onUpdate(keyframes5[keyframes5.length - 1]);
      onComplete && onComplete();
      return {
        time: 0,
        speed: 1,
        duration: 0,
        play: noop3,
        pause: noop3,
        stop: noop3,
        then: (resolve) => {
          resolve();
          return Promise.resolve();
        },
        cancel: noop3,
        complete: noop3
      };
    };
    return delay2 ? animateValue({
      keyframes: [0, 1],
      duration: 0,
      delay: delay2,
      onComplete: setValue
    }) : setValue();
  }

  // node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
  var underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  var criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  var keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  var ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3
  };
  var getDefaultTransition = (valueKey, { keyframes: keyframes5 }) => {
    if (keyframes5.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes5[1]) : underDampedSpring;
    }
    return ease;
  };

  // node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
  var isAnimatable = (key, value) => {
    if (key === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" && // It's animatable if we have a string
    (complex.test(value) || value === "0") && // And it contains numbers and/or colors
    !value.startsWith("url(")) {
      return true;
    }
    return false;
  };

  // node_modules/framer-motion/dist/es/value/types/complex/filter.mjs
  var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v) {
    const [name, value] = v.slice(0, -1).split("(");
    if (name === "drop-shadow")
      return v;
    const [number5] = value.match(floatRegex) || [];
    if (!number5)
      return v;
    const unit2 = value.replace(number5, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number5 !== value)
      defaultValue *= 100;
    return name + "(" + defaultValue + unit2 + ")";
  }
  var functionRegex = /([a-z-]*)\(.*?\)/g;
  var filter2 = {
    ...complex,
    getAnimatableNone: (v) => {
      const functions = v.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v;
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
  var defaultValueTypes = {
    ...numberValueTypes,
    // Color props
    color: color2,
    backgroundColor: color2,
    outlineColor: color2,
    fill: color2,
    stroke: color2,
    // Border props
    borderColor: color2,
    borderTopColor: color2,
    borderRightColor: color2,
    borderBottomColor: color2,
    borderLeftColor: color2,
    filter: filter2,
    WebkitFilter: filter2
  };
  var getDefaultValueType = (key) => defaultValueTypes[key];

  // node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
  function getAnimatableNone2(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter2)
      defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }

  // node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
  var isZeroValueString = (v) => /^0[^.\s]+$/.test(v);

  // node_modules/framer-motion/dist/es/animation/utils/is-none.mjs
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    }
  }

  // node_modules/framer-motion/dist/es/animation/utils/keyframes.mjs
  function getKeyframes(value, valueName, target, transition3) {
    const isTargetAnimatable = isAnimatable(valueName, target);
    let keyframes5;
    if (Array.isArray(target)) {
      keyframes5 = [...target];
    } else {
      keyframes5 = [null, target];
    }
    const defaultOrigin = transition3.from !== void 0 ? transition3.from : value.get();
    let animatableTemplateValue = void 0;
    const noneKeyframeIndexes = [];
    for (let i = 0; i < keyframes5.length; i++) {
      if (keyframes5[i] === null) {
        keyframes5[i] = i === 0 ? defaultOrigin : keyframes5[i - 1];
      }
      if (isNone(keyframes5[i])) {
        noneKeyframeIndexes.push(i);
      }
      if (typeof keyframes5[i] === "string" && keyframes5[i] !== "none" && keyframes5[i] !== "0") {
        animatableTemplateValue = keyframes5[i];
      }
    }
    if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
      for (let i = 0; i < noneKeyframeIndexes.length; i++) {
        const index = noneKeyframeIndexes[i];
        keyframes5[index] = getAnimatableNone2(valueName, animatableTemplateValue);
      }
    }
    return keyframes5;
  }

  // node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition3 }) {
    return !!Object.keys(transition3).length;
  }
  function getValueTransition(transition3, key) {
    return transition3[key] || transition3["default"] || transition3;
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
  var animateMotionValue = (valueName, value, target, transition3 = {}) => {
    return (onComplete) => {
      const valueTransition = getValueTransition(transition3, valueName) || {};
      const delay2 = valueTransition.delay || transition3.delay || 0;
      let { elapsed = 0 } = transition3;
      elapsed = elapsed - secondsToMilliseconds(delay2);
      const keyframes5 = getKeyframes(value, valueName, target, valueTransition);
      const originKeyframe = keyframes5[0];
      const targetKeyframe = keyframes5[keyframes5.length - 1];
      const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
      const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
      warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
      let options = {
        keyframes: keyframes5,
        velocity: value.getVelocity(),
        ease: "easeOut",
        ...valueTransition,
        delay: -elapsed,
        onUpdate: (v) => {
          value.set(v);
          valueTransition.onUpdate && valueTransition.onUpdate(v);
        },
        onComplete: () => {
          onComplete();
          valueTransition.onComplete && valueTransition.onComplete();
        }
      };
      if (!isTransitionDefined(valueTransition)) {
        options = {
          ...options,
          ...getDefaultTransition(valueName, options)
        };
      }
      if (options.duration) {
        options.duration = secondsToMilliseconds(options.duration);
      }
      if (options.repeatDelay) {
        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
      }
      if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false || MotionGlobalConfig.skipAnimations) {
        return createInstantAnimation(instantAnimationState.current ? { ...options, delay: 0 } : options);
      }
      if (
        /**
         * If this is a handoff animation, the optimised animation will be running via
         * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
         * optimised animation.
         */
        !transition3.isHandoff && value.owner && value.owner.current instanceof HTMLElement && /**
         * If we're outputting values to onUpdate then we can't use WAAPI as there's
         * no way to read the value from WAAPI every frame.
         */
        !value.owner.getProps().onUpdate
      ) {
        const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
        if (acceleratedAnimation)
          return acceleratedAnimation;
      }
      return animateValue(options);
    };
  };

  // node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }

  // node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
  var isNumericalString = (v) => /^\-?\d*\.?\d+$/.test(v);

  // node_modules/framer-motion/dist/es/utils/array.mjs
  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
      arr.push(item);
  }
  function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1)
      arr.splice(index, 1);
  }

  // node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
  var SubscriptionManager = class {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b, c) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b, c);
      } else {
        for (let i = 0; i < numSubscriptions; i++) {
          const handler = this.subscriptions[i];
          handler && handler(a, b, c);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  };

  // node_modules/framer-motion/dist/es/utils/warn-once.mjs
  var warned = /* @__PURE__ */ new Set();
  function warnOnce(condition, message, element) {
    if (condition || warned.has(message))
      return;
    console.warn(message);
    if (element)
      console.warn(element);
    warned.add(message);
  }

  // node_modules/framer-motion/dist/es/value/index.mjs
  var MAX_VELOCITY_DELTA = 30;
  var isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  var collectMotionValues = {
    current: void 0
  };
  var MotionValue = class {
    /**
     * @param init - The initiating value
     * @param config - Optional configuration options
     *
     * -  `transformer`: A function to transform incoming values with.
     *
     * @internal
     */
    constructor(init3, options = {}) {
      this.version = "11.0.8";
      this.canTrackVelocity = false;
      this.events = {};
      this.updateAndNotify = (v, render = true) => {
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v);
        if (this.current !== this.prev && this.events.change) {
          this.events.change.notify(this.current);
        }
        if (render && this.events.renderRequest) {
          this.events.renderRequest.notify(this.current);
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init3);
      this.canTrackVelocity = isFloat(this.current);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    /**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     *
     * When calling `onChange` inside a React component, it should be wrapped with the
     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
     * from the `useEffect` function to ensure you don't add duplicate subscribers..
     *
     * ```jsx
     * export const MyComponent = () => {
     *   const x = useMotionValue(0)
     *   const y = useMotionValue(0)
     *   const opacity = useMotionValue(1)
     *
     *   useEffect(() => {
     *     function updateOpacity() {
     *       const maxXY = Math.max(x.get(), y.get())
     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
     *       opacity.set(newOpacity)
     *     }
     *
     *     const unsubscribeX = x.on("change", updateOpacity)
     *     const unsubscribeY = y.on("change", updateOpacity)
     *
     *     return () => {
     *       unsubscribeX()
     *       unsubscribeY()
     *     }
     *   }, [])
     *
     *   return <motion.div style={{ x }} />
     * }
     * ```
     *
     * @param subscriber - A function that receives the latest value.
     * @returns A function that, when called, will cancel this subscription.
     *
     * @deprecated
     */
    onChange(subscription) {
      if (true) {
        warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
      }
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    /**
     * Attaches a passive effect to the `MotionValue`.
     *
     * @internal
     */
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    /**
     * Sets the state of the `MotionValue`.
     *
     * @remarks
     *
     * ```jsx
     * const x = useMotionValue(0)
     * x.set(10)
     * ```
     *
     * @param latest - Latest value to set.
     * @param render - Whether to notify render subscribers. Defaults to `true`
     *
     * @public
     */
    set(v, render = true) {
      if (!render || !this.passiveEffect) {
        this.updateAndNotify(v, render);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    }
    setWithVelocity(prev2, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev2;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    /**
     * Set the state of the `MotionValue`, stopping any active animations,
     * effects, and resets velocity to `0`.
     */
    jump(v) {
      this.updateAndNotify(v);
      this.prev = v;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      this.stop();
      if (this.stopPassiveEffect)
        this.stopPassiveEffect();
    }
    /**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     *
     * @public
     */
    get() {
      if (collectMotionValues.current) {
        collectMotionValues.current.push(this);
      }
      return this.current;
    }
    /**
     * @public
     */
    getPrevious() {
      return this.prev;
    }
    /**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     *
     * @public
     */
    getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
    /**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     *
     * ```jsx
     * value.start()
     * ```
     *
     * @param animation - A function that starts the provided animation
     *
     * @internal
     */
    start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
    /**
     * Stop the currently active animation.
     *
     * @public
     */
    stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
    /**
     * Returns `true` if this value is currently animating.
     *
     * @public
     */
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    /**
     * Destroy and clean up subscribers to this `MotionValue`.
     *
     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
     * created a `MotionValue` via the `motionValue` function.
     *
     * @public
     */
    destroy() {
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  };
  function motionValue(init3, options) {
    return new MotionValue(init3, options);
  }

  // node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
  var testValueType = (v) => (type) => type.test(v);

  // node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
  var auto = {
    test: (v) => v === "auto",
    parse: (v) => v
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
  var dimensionValueTypes = [number, px2, percent, degrees, vw, vh, auto];
  var findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));

  // node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
  var valueTypes = [...dimensionValueTypes, color2, complex];
  var findValueType = (v) => valueTypes.find(testValueType(v));

  // node_modules/framer-motion/dist/es/render/utils/setters.mjs
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition: transition3 = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }
  function checkTargetForNewValues(visualElement, target, origin) {
    var _a7, _b5;
    const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));
    const numNewValues = newValueKeys.length;
    if (!numNewValues)
      return;
    for (let i = 0; i < numNewValues; i++) {
      const key = newValueKeys[i];
      const targetValue = target[key];
      let value = null;
      if (Array.isArray(targetValue)) {
        value = targetValue[0];
      }
      if (value === null) {
        value = (_b5 = (_a7 = origin[key]) !== null && _a7 !== void 0 ? _a7 : visualElement.readValue(key)) !== null && _b5 !== void 0 ? _b5 : target[key];
      }
      if (value === void 0 || value === null)
        continue;
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(targetValue)) {
        value = getAnimatableNone2(key, targetValue);
      }
      visualElement.addValue(key, motionValue(value, { owner: visualElement }));
      if (origin[key] === void 0) {
        origin[key] = value;
      }
      if (value !== null)
        visualElement.setBaseTarget(key, value);
    }
  }
  function getOriginFromTransition(key, transition3) {
    if (!transition3)
      return;
    const valueTransition = transition3[key] || transition3["default"] || transition3;
    return valueTransition.from;
  }
  function getOrigin(target, transition3, visualElement) {
    const origin = {};
    for (const key in target) {
      const transitionOrigin = getOriginFromTransition(key, transition3);
      if (transitionOrigin !== void 0) {
        origin[key] = transitionOrigin;
      } else {
        const value = visualElement.getValue(key);
        if (value) {
          origin[key] = value.get();
        }
      }
    }
    return origin;
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function hasKeyframesChanged(value, target) {
    const current = value.get();
    if (Array.isArray(target)) {
      for (let i = 0; i < target.length; i++) {
        if (target[i] !== current)
          return true;
      }
    } else {
      return current !== target;
    }
  }
  function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
    let { transition: transition3 = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
    const willChange = visualElement.getValue("willChange");
    if (transitionOverride)
      transition3 = transitionOverride;
    const animations2 = [];
    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key);
      const valueTarget = target[key];
      if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        elapsed: 0,
        ...getValueTransition(transition3 || {}, key)
      };
      if (window.HandoffAppearAnimations) {
        const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
        if (appearId) {
          const elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);
          if (elapsed !== null) {
            valueTransition.elapsed = elapsed;
            valueTransition.isHandoff = true;
          }
        }
      }
      let canSkip = !valueTransition.isHandoff && !hasKeyframesChanged(value, valueTarget);
      if (valueTransition.type === "spring" && (value.getVelocity() || valueTransition.velocity)) {
        canSkip = false;
      }
      if (value.animation) {
        canSkip = false;
      }
      if (canSkip)
        continue;
      value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition));
      const animation = value.animation;
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
        animation.then(() => willChange.remove(key));
      }
      animations2.push(animation);
    }
    if (transitionEnd) {
      Promise.all(animations2).then(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    }
    return animations2;
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
  function animateVariant(visualElement, variant, options = {}) {
    const resolved = resolveVariant(visualElement, variant, options.custom);
    let { transition: transition3 = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition3 = options.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition3;
      return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve();
    const { when } = transition3;
    if (when) {
      const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
      return first().then(() => last());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
  }
  function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations2 = [];
    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
    const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
    Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options,
        delay: delayChildren + generateStaggerDuration(i)
      }).then(() => child.notify("AnimationComplete", variant)));
    });
    return Promise.all(animations2);
  }
  function sortByTreeOrder(a, b) {
    return a.sortNodePosition(b);
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => visualElement.notify("AnimationComplete", definition));
  }

  // node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
  var reversePriorityOrder = [...variantPriorityOrder].reverse();
  var numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    const state2 = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (acc, definition) => {
      const resolved = resolveVariant(visualElement, definition);
      if (resolved) {
        const { transition: transition3, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(options, changedActiveType) {
      const props = visualElement.getProps();
      const context = visualElement.getVariantContext(true) || {};
      const animations2 = [];
      const removedKeys = /* @__PURE__ */ new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i = 0; i < numAnimationTypes; i++) {
        const type = reversePriorityOrder[i];
        const typeState = state2[type];
        const prop = props[type] !== void 0 ? props[type] : context[type];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i;
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = { ...encounteredKeys };
        if (
          // If it isn't active and hasn't *just* been set as inactive
          !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
          !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
          isAnimationControls(prop) || typeof prop === "boolean"
        ) {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
        i > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
        if (activeDelta === false)
          resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
        };
        for (const key in allKeys) {
          const next2 = resolvedValues[key];
          const prev2 = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
            valueHasChanged = !shallowCompare(next2, prev2);
          } else {
            valueHasChanged = next2 !== prev2;
          }
          if (valueHasChanged) {
            if (next2 !== void 0) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next2 !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        if (shouldAnimateType && (!isInherited || handledRemovedValues)) {
          animations2.push(...definitionList.map((animation) => ({
            animation,
            options: { type, ...options }
          })));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          if (fallbackTarget !== void 0) {
            fallbackAnimation[key] = fallbackTarget;
          }
        });
        animations2.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type, isActive, options) {
      var _a7;
      if (state2[type].isActive === isActive)
        return Promise.resolve();
      (_a7 = visualElement.variantChildren) === null || _a7 === void 0 ? void 0 : _a7.forEach((child) => {
        var _a8;
        return (_a8 = child.animationState) === null || _a8 === void 0 ? void 0 : _a8.setActive(type, isActive);
      });
      state2[type].isActive = isActive;
      const animations2 = animateChanges(options, type);
      for (const key in state2) {
        state2[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state2
    };
  }
  function checkVariantsDidChange(prev2, next2) {
    if (typeof next2 === "string") {
      return next2 !== prev2;
    } else if (Array.isArray(next2)) {
      return !shallowCompare(next2, prev2);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
  var AnimationFeature = class extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node2) {
      super(node2);
      node2.animationState || (node2.animationState = createAnimationState(node2));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      this.unmount();
      if (isAnimationControls(animate)) {
        this.unmount = animate.subscribe(this.node);
      }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
  var id = 0;
  var ExitAnimationFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.id = id++;
    }
    update() {
      if (!this.node.presenceContext)
        return;
      const { isPresent: isPresent2, onExitComplete, custom } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent2 === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent2, { custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom });
      if (onExitComplete && !isPresent2) {
        exitAnimation.then(() => onExitComplete(this.id));
      }
    }
    mount() {
      const { register } = this.node.presenceContext || {};
      if (register) {
        this.unmount = register(this.id);
      }
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/animations.mjs
  var animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };

  // node_modules/framer-motion/dist/es/utils/distance.mjs
  var distance2 = (a, b) => Math.abs(a - b);
  function distance2D(a, b) {
    const xDelta = distance2(a.x, b.x);
    const yDelta = distance2(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }

  // node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
  var PanSession = class {
    constructor(event, handlers4, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        const { point: point3 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({ ...point3, timestamp: timestamp2 });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin)
          resumeAnimation && resumeAnimation();
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event))
        return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers4;
      this.transformPagePoint = transformPagePoint;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point: point2 } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point2, timestamp }];
      const { onSessionStart } = handlers4;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe4(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers4) {
      this.handlers = handlers4;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  };
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
  }
  function getPanInfo({ point: point2 }, history) {
    return {
      point: point2,
      delta: subtractPoint(point2, lastDevicePoint(history)),
      offset: subtractPoint(point2, startDevicePoint(history)),
      velocity: getVelocity2(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity2(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    let i = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i >= 0) {
      timestampedPoint = history[i];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target = 0, maxDistance = 0.01) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
      delta.scale = 1;
    delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
    if (isNear(delta.translate) || isNaN(delta.translate))
      delta.translate = 0;
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout3, parent) {
    target.min = layout3.min - parent.min;
    target.max = target.min + calcLength(layout3);
  }
  function calcRelativePosition(target, layout3, parent) {
    calcRelativeAxisPosition(target.x, layout3.x, parent.x);
    calcRelativeAxisPosition(target.y, layout3.y, parent.y);
  }

  // node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
  function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
    if (min2 !== void 0 && point2 < min2) {
      point2 = elastic ? mixNumber(min2, point2, elastic.min) : Math.max(point2, min2);
    } else if (max2 !== void 0 && point2 > max2) {
      point2 = elastic ? mixNumber(max2, point2, elastic.max) : Math.min(point2, max2);
    }
    return point2;
  }
  function calcRelativeAxisConstraints(axis, min2, max2) {
    return {
      min: min2 !== void 0 ? axis.min + min2 : void 0,
      max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top: top2, left: left2, bottom: bottom2, right: right2 }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left2, right2),
      y: calcRelativeAxisConstraints(layoutBox.y, top2, bottom2)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min2 = constraintsAxis.min - layoutAxis.min;
    let max2 = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min2, max2] = [max2, min2];
    }
    return { min: min2, max: max2 };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin2(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin);
  }
  function rebaseAxisConstraints(layout3, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout3.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout3.min;
    }
    return relativeConstraints;
  }
  var defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }

  // node_modules/framer-motion/dist/es/projection/geometry/models.mjs
  var createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  var createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  var createAxis = () => ({ min: 0, max: 0 });
  var createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });

  // node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }

  // node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
  function convertBoundingBoxToBox({ top: top2, left: left2, right: right2, bottom: bottom2 }) {
    return {
      x: { min: left2, max: right2 },
      y: { min: top2, max: bottom2 }
    };
  }
  function convertBoxToBoundingBox({ x, y }) {
    return { top: y.min, right: x.max, bottom: y.max, left: x.min };
  }
  function transformBoxPoints(point2, transformPoint2) {
    if (!transformPoint2)
      return point2;
    const topLeft = transformPoint2({ x: point2.left, y: point2.top });
    const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }

  // node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
  function isIdentityScale(scale3) {
    return scale3 === void 0 || scale3 === 1;
  }
  function hasScale({ scale: scale3, scaleX, scaleY }) {
    return !isIdentityScale(scale3) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
  function scalePoint(point2, scale3, originPoint) {
    const distanceFromOrigin = point2 - originPoint;
    const scaled = scale3 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point2, translate, scale3, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point2 = scalePoint(point2, boxScale, originPoint);
    }
    return scalePoint(point2, scale3, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale3 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale3, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale3, originPoint, boxScale);
  }
  function applyBoxDelta(box, { x, y }) {
    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
  }
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    let node2;
    let delta;
    for (let i = 0; i < treeLength; i++) {
      node2 = treePath[i];
      delta = node2.projectionDelta;
      const instance = node2.instance;
      if (instance && instance.style && instance.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
        transformBox(box, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node2.latestValues)) {
        transformBox(box, node2.latestValues);
      }
    }
    treeScale.x = snapToDefault(treeScale.x);
    treeScale.y = snapToDefault(treeScale.y);
  }
  function snapToDefault(scale3) {
    if (Number.isInteger(scale3))
      return scale3;
    return scale3 > 1.0000000000001 || scale3 < 0.999999999999 ? scale3 : 1;
  }
  function translateAxis(axis, distance3) {
    axis.min = axis.min + distance3;
    axis.max = axis.max + distance3;
  }
  function transformAxis(axis, transforms2, [key, scaleKey, originKey]) {
    const axisOrigin = transforms2[originKey] !== void 0 ? transforms2[originKey] : 0.5;
    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, transforms2[key], transforms2[scaleKey], originPoint, transforms2.scale);
  }
  var xKeys = ["x", "scaleX", "originX"];
  var yKeys = ["y", "scaleY", "originY"];
  function transformBox(box, transform2) {
    transformAxis(box.x, transform2, xKeys);
    transformAxis(box.y, transform2, yKeys);
  }

  // node_modules/framer-motion/dist/es/projection/utils/measure.mjs
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll: scroll2 } = rootProjectionNode2;
    if (scroll2) {
      translateAxis(viewportBox.x, scroll2.offset.x);
      translateAxis(viewportBox.y, scroll2.offset.y);
    }
    return viewportBox;
  }

  // node_modules/framer-motion/dist/es/utils/get-context-window.mjs
  var getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };

  // node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
  var elementDragControls = /* @__PURE__ */ new WeakMap();
  var VisualElementDragControls = class {
    constructor(visualElement) {
      this.openGlobalLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false)
        return;
      const onSessionStart = (event) => {
        const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
        dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event, "page").point);
        }
      };
      const onStart = (event, info) => {
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openGlobalLock)
            this.openGlobalLock();
          this.openGlobalLock = getGlobalLock(drag2);
          if (!this.openGlobalLock)
            return;
        }
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length2 = calcLength(measuredAxis);
                current = length2 * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.update(() => onDragStart(event, info), false, true);
        }
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openGlobalLock)
          return;
        const { offset: offset3 } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset3);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset3);
        this.updateAxis("y", info.point, offset3);
        this.visualElement.render();
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => this.stop(event, info);
      const resumeAnimation = () => eachAxis((axis) => {
        var _a7;
        return this.getAnimationState(axis) === "paused" && ((_a7 = this.getAxisMotionValue(axis).animation) === null || _a7 === void 0 ? void 0 : _a7.play());
      });
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        contextWindow: getContextWindow(this.visualElement)
      });
    }
    stop(event, info) {
      const isDragging = this.isDragging;
      this.cancel();
      if (!isDragging)
        return;
      const { velocity } = info;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.update(() => onDragEnd(event, info));
      }
    }
    cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openGlobalLock) {
        this.openGlobalLock();
        this.openGlobalLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset3) {
      const { drag: drag2 } = this.getProps();
      if (!offset3 || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      let next2 = this.originPoint[axis] + offset3[axis];
      if (this.constraints && this.constraints[axis]) {
        next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next2);
    }
    resolveConstraints() {
      var _a7;
      const { dragConstraints, dragElastic } = this.getProps();
      const layout3 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a7 = this.visualElement.projection) === null || _a7 === void 0 ? void 0 : _a7.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout3) {
          this.constraints = calcRelativeConstraints(layout3.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout3 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout3.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints))
        return false;
      const constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
      const { projection } = this.visualElement;
      if (!projection || !projection.layout)
        return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition3 = constraints && constraints[axis] || {};
        if (dragSnapToOrigin)
          transition3 = { min: 0, max: 0 };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition3
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition3) {
      const axisValue = this.getAxisMotionValue(axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition3));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => {
        var _a7;
        return (_a7 = this.getAxisMotionValue(axis).animation) === null || _a7 === void 0 ? void 0 : _a7.pause();
      });
    }
    getAnimationState(axis) {
      var _a7;
      return (_a7 = this.getAxisMotionValue(axis).animation) === null || _a7 === void 0 ? void 0 : _a7.state;
    }
    /**
     * Drag works differently depending on which props are provided.
     *
     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
     * - Otherwise, we apply the delta to the x/y motion values.
     */
    getAxisMotionValue(axis) {
      const dragKey = "_drag" + axis.toUpperCase();
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point2) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection))
          return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
          axisValue.set(point2[axis] - mixNumber(min2, max2, 0.5));
        }
      });
    }
    /**
     * When the viewport resizes we want to check if the measured constraints
     * have changed and, if so, reposition the element within those new constraints
     * relative to where it was before the resize.
     */
    scalePositionWithinConstraints() {
      if (!this.visualElement.current)
        return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      const { transformTemplate: transformTemplate2 } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min: min2, max: max2 } = this.constraints[axis];
        axisValue.set(mixNumber(min2, max2, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current)
        return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        drag2 && dragListener && this.start(event);
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints)) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      measureDragConstraints();
      const stopResizeListener = addDomEvent2(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      });
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  };
  function shouldDrag(direction2, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction2) && (currentDirection === null || currentDirection === direction2);
  }
  function getCurrentDirection(offset3, lockThreshold = 10) {
    let direction2 = null;
    if (Math.abs(offset3.y) > lockThreshold) {
      direction2 = "y";
    } else if (Math.abs(offset3.x) > lockThreshold) {
      direction2 = "x";
    }
    return direction2;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/index.mjs
  var DragGesture = class extends Feature {
    constructor(node2) {
      super(node2);
      this.removeGroupControls = noop3;
      this.removeListeners = noop3;
      this.controls = new VisualElementDragControls(node2);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop3;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  };

  // node_modules/framer-motion/dist/es/gestures/pan/index.mjs
  var asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.update(() => handler(event, info));
    }
  };
  var PanGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop3;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.update(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var import_react40 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
  var import_react39 = __toESM(require_react(), 1);
  function usePresence() {
    const context = (0, import_react39.useContext)(PresenceContext);
    if (context === null)
      return [true, null];
    const { isPresent: isPresent2, onExitComplete, register } = context;
    const id3 = (0, import_react39.useId)();
    (0, import_react39.useEffect)(() => register(id3), []);
    const safeToRemove = () => onExitComplete && onExitComplete(id3);
    return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
  }
  function useIsPresent() {
    return isPresent((0, import_react39.useContext)(PresenceContext));
  }
  function isPresent(context) {
    return context === null ? true : context.isPresent;
  }

  // node_modules/framer-motion/dist/es/projection/node/state.mjs
  var globalProjectionState = {
    /**
     * Global flag as to whether the tree has animated since the last time
     * we resized the window
     */
    hasAnimatedSinceResize: true,
    /**
     * We set this to true once, on the first update. Any nodes added to the tree beyond that
     * update will be given a `data-projection-id` attribute.
     */
    hasEverUpdated: false
  };

  // node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  var correctBorderRadius = {
    correct: (latest, node2) => {
      if (!node2.target)
        return latest;
      if (typeof latest === "string") {
        if (px2.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x = pixelsToPercent(latest, node2.target.x);
      const y = pixelsToPercent(latest, node2.target.y);
      return `${x}% ${y}%`;
    }
  };

  // node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
  var correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5)
        return original;
      const template = complex.createTransformer(latest);
      const offset3 = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset3] /= xScale;
      shadow[1 + offset3] /= yScale;
      const averageScale = mixNumber(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset3] === "number")
        shadow[2 + offset3] /= averageScale;
      if (typeof shadow[3 + offset3] === "number")
        shadow[3 + offset3] /= averageScale;
      return template(shadow);
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var MeasureLayoutWithContext = class extends import_react40.default.Component {
    /**
     * This only mounts projection nodes for components that
     * need measuring, we might want to do it for all components
     * in order to incorporate transforms
     */
    componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup.group)
          layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        projection.root.didUpdate();
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2 } = this.props;
      const projection = visualElement.projection;
      if (!projection)
        return null;
      projection.isPresent = isPresent2;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent2) {
        if (isPresent2) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  };
  function MeasureLayout(props) {
    const [isPresent2, safeToRemove] = usePresence();
    const layoutGroup = (0, import_react40.useContext)(LayoutGroupContext);
    return import_react40.default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react40.useContext)(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });
  }
  var defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };

  // node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
  var borders2 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  var numBorders = borders2.length;
  var asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
  var isPx = (value) => typeof value === "number" || px2.test(value);
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber(
        0,
        // TODO Reinstate this if only child
        lead.opacity !== void 0 ? lead.opacity : 1,
        easeCrossfadeIn(progress2)
      );
      target.opacityExit = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
    }
    for (let i = 0; i < numBorders; i++) {
      const borderLabel = `border${borders2[i]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  var easeCrossfadeIn = compress(0, 0.5, circOut);
  var easeCrossfadeOut = compress(0.5, 0.95, noop3);
  function compress(min2, max2, easing) {
    return (p) => {
      if (p < min2)
        return 0;
      if (p > max2)
        return 1;
      return easing(progress(min2, max2, p));
    };
  }

  // node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
  function removePointDelta(point2, translate, scale3, originPoint, boxScale) {
    point2 -= translate;
    point2 = scalePoint(point2, 1 / scale3, originPoint);
    if (boxScale !== void 0) {
      point2 = scalePoint(point2, 1 / boxScale, originPoint);
    }
    return point2;
  }
  function removeAxisDelta(axis, translate = 0, scale3 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale3, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale3, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms2, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms2[key], transforms2[scaleKey], transforms2[originKey], transforms2.scale, origin, sourceAxis);
  }
  var xKeys2 = ["x", "scaleX", "originX"];
  var yKeys2 = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box, transforms2, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms2, xKeys2, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms2, yKeys2, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }

  // node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function boxEquals(a, b) {
    return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;
  }
  function boxEqualsRounded(a, b) {
    return Math.round(a.x.min) === Math.round(b.x.min) && Math.round(a.x.max) === Math.round(b.x.max) && Math.round(a.y.min) === Math.round(b.y.min) && Math.round(a.y.max) === Math.round(b.y.max);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }

  // node_modules/framer-motion/dist/es/projection/shared/stack.mjs
  var NodeStack = class {
    constructor() {
      this.members = [];
    }
    add(node2) {
      addUniqueItem(this.members, node2);
      node2.scheduleRender();
    }
    remove(node2) {
      removeItem(this.members, node2);
      if (node2 === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node2 === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node2) {
      const indexOfNode = this.members.findIndex((member) => node2 === member);
      if (indexOfNode === 0)
        return false;
      let prevLead;
      for (let i = indexOfNode; i >= 0; i--) {
        const member = this.members[i];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node2, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node2 === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node2;
      node2.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node2.scheduleRender();
        node2.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node2.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node2.snapshot = prevLead.snapshot;
          node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node2.root && node2.root.isUpdating) {
          node2.isLayoutDirty = true;
        }
        const { crossfade } = node2.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node2) => {
        const { options, resumingFrom } = node2;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node2) => {
        node2.instance && node2.scheduleRender(false);
      });
    }
    /**
     * Clear any leads that have been removed this render to prevent them from being
     * used in future animations and to prevent memory leaks
     */
    removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  };

  // node_modules/framer-motion/dist/es/projection/styles/transform.mjs
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform2 = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    if (xTranslate || yTranslate) {
      transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { rotate, rotateX, rotateY } = latestTransform;
      if (rotate)
        transform2 += `rotate(${rotate}deg) `;
      if (rotateX)
        transform2 += `rotateX(${rotateX}deg) `;
      if (rotateY)
        transform2 += `rotateY(${rotateY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform2 || "none";
  }

  // node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
  var compareByDepth = (a, b) => a.depth - b.depth;

  // node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
  var FlatTree = class {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  };

  // node_modules/framer-motion/dist/es/utils/delay.mjs
  function delay(callback, timeout) {
    const start2 = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start2;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame.read(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }

  // node_modules/framer-motion/dist/es/debug/record.mjs
  function record(data) {
    if (window.MotionDebug) {
      window.MotionDebug.record(data);
    }
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs
  function isSVGElement(element) {
    return element instanceof SVGElement && element.tagName !== "svg";
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/single-value.mjs
  function animateSingleValue(value, keyframes5, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes5, options));
    return motionValue$1.animation;
  }

  // node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
  var transformAxes = ["", "X", "Y", "Z"];
  var hiddenVisibility = { visibility: "hidden" };
  var animationTarget = 1e3;
  var id2 = 0;
  var projectionFrameData = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
  };
  function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
        this.id = id2++;
        this.animationId = 0;
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.hasTreeAnimated = false;
        this.updateScheduled = false;
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
          record(projectionFrameData);
        };
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i = 0; i < this.path.length; i++) {
          this.path[i].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
      /**
       * Lifecycles
       */
      mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
        if (this.instance)
          return;
        this.isSVG = isSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout: layout3, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (isLayoutDirty && (layout3 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          attachResizeListener(instance, () => {
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout3)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
            if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        cancelFrame(this.updateProjection);
      }
      // only on the root
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
      // Note: currently only running on root node
      startUpdate() {
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          node2.shouldResetTransform = true;
          node2.updateScroll("snapshot");
          if (node2.options.layoutRoot) {
            node2.willUpdate(false);
          }
        }
        const { layoutId, layout: layout3 } = this.options;
        if (layoutId === void 0 && !layout3)
          return;
        const transformTemplate2 = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        }
        this.isUpdating = false;
        if (window.HandoffCancelAllAnimations) {
          window.HandoffCancelAllAnimations();
        }
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        const now3 = time.now();
        frameData.delta = clamp(0, 1e3 / 60, now3 - frameData.timestamp);
        frameData.timestamp = now3;
        frameData.isProcessing = true;
        steps.update.process(frameData);
        steps.preRender.process(frameData);
        steps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(() => this.update());
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
      /**
       * Update measurements
       */
      updateSnapshot() {
        if (this.snapshot || !this.instance)
          return;
        this.snapshot = this.measure();
      }
      updateLayout() {
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i = 0; i < this.path.length; i++) {
            const node2 = this.path[i];
            node2.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement) {
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot: checkIsScrollRoot(this.instance),
            offset: measureScroll(this.instance)
          };
        }
      }
      resetTransform() {
        if (!resetTransform)
          return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate2 = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        const { visualElement } = this.options;
        if (!visualElement)
          return createBox();
        const box = visualElement.measureViewportBox();
        const { scroll: scroll2 } = this.root;
        if (scroll2) {
          translateAxis(box.x, scroll2.offset.x);
          translateAxis(box.y, scroll2.offset.y);
        }
        return box;
      }
      removeElementScroll(box) {
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          const { scroll: scroll2, options } = node2;
          if (node2 !== this.root && scroll2 && options.layoutScroll) {
            if (scroll2.isRoot) {
              copyBoxInto(boxWithoutScroll, box);
              const { scroll: rootScroll } = this.root;
              if (rootScroll) {
                translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
                translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
              }
            }
            translateAxis(boxWithoutScroll.x, scroll2.offset.x);
            translateAxis(boxWithoutScroll.y, scroll2.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
            transformBox(withTransforms, {
              x: -node2.scroll.offset.x,
              y: -node2.scroll.offset.y
            });
          }
          if (!hasTransform(node2.latestValues))
            continue;
          transformBox(withTransforms, node2.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          if (!node2.instance)
            continue;
          if (!hasTransform(node2.latestValues))
            continue;
          hasScale(node2.latestValues) && node2.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node2.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== void 0 ? options.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent)
          return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        var _a7;
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a7 = this.parent) === null || _a7 === void 0 ? void 0 : _a7.isProjectionDirty) || this.attemptToResolveRelativeTarget);
        if (canSkip)
          return;
        const { layout: layout3, layoutId } = this.options;
        if (!this.layout || !(layout3 || layoutId))
          return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        if (!this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        projectionFrameData.resolvedTargetDeltas++;
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      calcProjection() {
        var _a7;
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || ((_a7 = this.parent) === null || _a7 === void 0 ? void 0 : _a7.isProjectionDirty)) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip)
          return;
        const { layout: layout3, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout3 || layoutId))
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.projectionTransform) {
            this.projectionDelta = createDelta();
            this.projectionTransform = "none";
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta) {
          this.projectionDelta = createDelta();
          this.projectionDeltaWithTransform = createDelta();
        }
        const prevProjectionTransform = this.projectionTransform;
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
        if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
        projectionFrameData.recalculatedProjection++;
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll = true) {
        this.options.scheduleRender && this.options.scheduleRender();
        if (notifyAll) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot2 = this.snapshot;
        const snapshotLatestValues = snapshot2 ? snapshot2.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot2 ? snapshot2.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget)
              prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation && this.currentAnimation.stop();
        if (this.resumingFrom && this.resumingFrom.currentAnimation) {
          this.resumingFrom.currentAnimation.stop();
        }
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          this.currentAnimation = animateSingleValue(0, animationTarget, {
            ...options,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onComplete: () => {
              options.onComplete && options.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout3, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout3)
          return;
        if (this !== lead && this.layout && layout3 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout3.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node2) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node2);
        const config2 = node2.options.initialPromotionConfig;
        node2.promote({
          transition: config2 ? config2.transition : void 0,
          preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node2) : void 0
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        var _a7;
        const { layoutId } = this.options;
        return layoutId ? ((_a7 = this.getStack()) === null || _a7 === void 0 ? void 0 : _a7.lead) || this : this;
      }
      getPrevLead() {
        var _a7;
        const { layoutId } = this.options;
        return layoutId ? (_a7 = this.getStack()) === null || _a7 === void 0 ? void 0 : _a7.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition: transition3, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition3)
          this.setOptions({ transition: transition3 });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetRotation() {
        const { visualElement } = this.options;
        if (!visualElement)
          return;
        let hasRotate = false;
        const { latestValues } = visualElement;
        if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
          hasRotate = true;
        }
        if (!hasRotate)
          return;
        const resetValues = {};
        for (let i = 0; i < transformAxes.length; i++) {
          const key = "rotate" + transformAxes[i];
          if (latestValues[key]) {
            resetValues[key] = latestValues[key];
            visualElement.setStaticValue(key, 0);
          }
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
        }
        visualElement.scheduleRender();
      }
      getProjectionStyles(styleProp) {
        var _a7, _b5;
        if (!this.instance || this.isSVG)
          return void 0;
        if (!this.isVisible) {
          return hiddenVisibility;
        }
        const styles2 = {
          visibility: ""
        };
        const transformTemplate2 = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          styles2.opacity = "";
          styles2.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
          styles2.transform = transformTemplate2 ? transformTemplate2(this.latestValues, "") : "none";
          return styles2;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          const emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            emptyStyles.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate2) {
          styles2.transform = transformTemplate2(valuesToRender, styles2.transform);
        }
        const { x, y } = this.projectionDelta;
        styles2.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
        if (lead.animationValues) {
          styles2.opacity = lead === this ? (_b5 = (_a7 = valuesToRender.opacity) !== null && _a7 !== void 0 ? _a7 : this.latestValues.opacity) !== null && _b5 !== void 0 ? _b5 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          const { correct, applyTo } = scaleCorrectors[key];
          const corrected = styles2.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i = 0; i < num; i++) {
              styles2[applyTo[i]] = corrected;
            }
          } else {
            styles2[key] = corrected;
          }
        }
        if (this.options.layoutId) {
          styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
        }
        return styles2;
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      // Only run on root
      resetTree() {
        this.root.nodes.forEach((node2) => {
          var _a7;
          return (_a7 = node2.currentAnimation) === null || _a7 === void 0 ? void 0 : _a7.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node2) {
    node2.updateLayout();
  }
  function notifyLayoutUpdate(node2) {
    var _a7;
    const snapshot2 = ((_a7 = node2.resumeFrom) === null || _a7 === void 0 ? void 0 : _a7.snapshot) || node2.snapshot;
    if (node2.isLead() && node2.layout && snapshot2 && node2.hasListeners("didUpdate")) {
      const { layoutBox: layout3, measuredBox: measuredLayout } = node2.layout;
      const { animationType } = node2.options;
      const isShared = snapshot2.source !== node2.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot2.measuredBox[axis] : snapshot2.layoutBox[axis];
          const length2 = calcLength(axisSnapshot);
          axisSnapshot.min = layout3[axis].min;
          axisSnapshot.max = axisSnapshot.min + length2;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot2.layoutBox, layout3)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot2.measuredBox[axis] : snapshot2.layoutBox[axis];
          const length2 = calcLength(layout3[axis]);
          axisSnapshot.max = axisSnapshot.min + length2;
          if (node2.relativeTarget && !node2.currentAnimation) {
            node2.isProjectionDirty = true;
            node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout3, snapshot2.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot2.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout3, snapshot2.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeTargetChanged = false;
      if (!node2.resumeFrom) {
        const relativeParent = node2.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot2.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout3, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeTargetChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node2.relativeTarget = relativeLayout;
              node2.relativeTargetOrigin = relativeSnapshot;
              node2.relativeParent = relativeParent;
            }
          }
        }
      }
      node2.notifyListeners("didUpdate", {
        layout: layout3,
        snapshot: snapshot2,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeTargetChanged
      });
    } else if (node2.isLead()) {
      const { onExitComplete } = node2.options;
      onExitComplete && onExitComplete();
    }
    node2.options.transition = void 0;
  }
  function propagateDirtyNodes(node2) {
    projectionFrameData.totalNodes++;
    if (!node2.parent)
      return;
    if (!node2.isProjecting()) {
      node2.isProjectionDirty = node2.parent.isProjectionDirty;
    }
    node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
    node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node2) {
    node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
  }
  function clearSnapshot(node2) {
    node2.clearSnapshot();
  }
  function clearMeasurements(node2) {
    node2.clearMeasurements();
  }
  function clearIsLayoutDirty(node2) {
    node2.isLayoutDirty = false;
  }
  function resetTransformStyle(node2) {
    const { visualElement } = node2.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node2.resetTransform();
  }
  function finishAnimation(node2) {
    node2.finishAnimation();
    node2.targetDelta = node2.relativeTarget = node2.target = void 0;
    node2.isProjectionDirty = true;
  }
  function resolveTargetDelta(node2) {
    node2.resolveTargetDelta();
  }
  function calcProjection(node2) {
    node2.calcProjection();
  }
  function resetRotation(node2) {
    node2.resetRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p) {
    output.translate = mixNumber(delta.translate, 0, p);
    output.scale = mixNumber(delta.scale, 1, p);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from2, to, p) {
    output.min = mixNumber(from2.min, to.min, p);
    output.max = mixNumber(from2.max, to.max, p);
  }
  function mixBox(output, from2, to, p) {
    mixAxis(output.x, from2.x, to.x, p);
    mixAxis(output.y, from2.y, to.y, p);
  }
  function hasOpacityCrossfade(node2) {
    return node2.animationValues && node2.animationValues.opacityExit !== void 0;
  }
  var defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  var userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
  var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop3;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot2, layout3) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot2), aspectRatio(layout3), 0.2);
  }

  // node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
  var DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (ref, notify) => addDomEvent2(ref, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  });

  // node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
  var rootProjectionNode = {
    current: void 0
  };
  var HTMLProjectionNode = createProjectionNode({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
  });

  // node_modules/framer-motion/dist/es/motion/features/drag.mjs
  var drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
  var splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  function parseCSSVariable(current) {
    const match3 = splitCSSVariableRegex.exec(current);
    if (!match3)
      return [,];
    const [, token2, fallback] = match3;
    return [token2, fallback];
  }
  var maxDepth = 4;
  function getVariableValue(current, element, depth = 1) {
    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
    const [token2, fallback] = parseCSSVariable(current);
    if (!token2)
      return;
    const resolved = window.getComputedStyle(element).getPropertyValue(token2);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    } else if (isCSSVariableToken(fallback)) {
      return getVariableValue(fallback, element, depth + 1);
    } else {
      return fallback;
    }
  }
  function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
    const element = visualElement.current;
    if (!(element instanceof Element))
      return { target, transitionEnd };
    if (transitionEnd) {
      transitionEnd = { ...transitionEnd };
    }
    visualElement.values.forEach((value) => {
      const current = value.get();
      if (!isCSSVariableToken(current))
        return;
      const resolved = getVariableValue(current, element);
      if (resolved)
        value.set(resolved);
    });
    for (const key in target) {
      const current = target[key];
      if (!isCSSVariableToken(current))
        continue;
      const resolved = getVariableValue(current, element);
      if (!resolved)
        continue;
      target[key] = resolved;
      if (!transitionEnd)
        transitionEnd = {};
      if (transitionEnd[key] === void 0) {
        transitionEnd[key] = current;
      }
    }
    return { target, transitionEnd };
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
  var positionalKeys = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY"
  ]);
  var isPositionalKey = (key) => positionalKeys.has(key);
  var hasPositionalKey = (target) => {
    return Object.keys(target).some(isPositionalKey);
  };
  var isNumOrPxType = (v) => v === number || v === px2;
  var getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
  var getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {
    if (transform2 === "none" || !transform2)
      return 0;
    const matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      const matrix = transform2.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
  var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
  var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    if (removedTransforms.length)
      visualElement.render();
    return removedTransforms;
  }
  var positionalValues = {
    // Dimensions
    width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top: top2 }) => parseFloat(top2),
    left: (_bbox, { left: left2 }) => parseFloat(left2),
    bottom: ({ y }, { top: top2 }) => parseFloat(top2) + (y.max - y.min),
    right: ({ x }, { left: left2 }) => parseFloat(left2) + (x.max - x.min),
    // Transform
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;
  var convertChangedValueTypes = (target, visualElement, changedKeys) => {
    const originBbox = visualElement.measureViewportBox();
    const element = visualElement.current;
    const elementComputedStyle = getComputedStyle(element);
    const { display } = elementComputedStyle;
    const origin = {};
    if (display === "none") {
      visualElement.setStaticValue("display", target.display || "block");
    }
    changedKeys.forEach((key) => {
      origin[key] = positionalValues[key](originBbox, elementComputedStyle);
    });
    visualElement.render();
    const targetBbox = visualElement.measureViewportBox();
    changedKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      value && value.jump(origin[key]);
      target[key] = positionalValues[key](targetBbox, elementComputedStyle);
    });
    return target;
  };
  var checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
    target = { ...target };
    transitionEnd = { ...transitionEnd };
    const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
    let removedTransformValues = [];
    let hasAttemptedToRemoveTransformValues = false;
    const changedValueTypeKeys = [];
    targetPositionalKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (!visualElement.hasValue(key))
        return;
      let from2 = origin[key];
      let fromType = findDimensionValueType(from2);
      const to = target[key];
      let toType;
      if (isKeyframesTarget(to)) {
        const numKeyframes = to.length;
        const fromIndex = to[0] === null ? 1 : 0;
        from2 = to[fromIndex];
        fromType = findDimensionValueType(from2);
        for (let i = fromIndex; i < numKeyframes; i++) {
          if (to[i] === null)
            break;
          if (!toType) {
            toType = findDimensionValueType(to[i]);
            invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
          } else {
            invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
          }
        }
      } else {
        toType = findDimensionValueType(to);
      }
      if (fromType !== toType) {
        if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
          const current = value.get();
          if (typeof current === "string") {
            value.set(parseFloat(current));
          }
          if (typeof to === "string") {
            target[key] = parseFloat(to);
          } else if (Array.isArray(to) && toType === px2) {
            target[key] = to.map(parseFloat);
          }
        } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
          if (from2 === 0) {
            value.set(toType.transform(from2));
          } else {
            target[key] = fromType.transform(to);
          }
        } else {
          if (!hasAttemptedToRemoveTransformValues) {
            removedTransformValues = removeNonTranslationalTransform(visualElement);
            hasAttemptedToRemoveTransformValues = true;
          }
          changedValueTypeKeys.push(key);
          transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
          value.jump(to);
        }
      }
    });
    if (changedValueTypeKeys.length) {
      const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
      const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
      if (removedTransformValues.length) {
        removedTransformValues.forEach(([key, value]) => {
          visualElement.getValue(key).set(value);
        });
      }
      visualElement.render();
      if (isBrowser4 && scrollY !== null) {
        window.scrollTo({ top: scrollY });
      }
      return { target: convertedTarget, transitionEnd };
    } else {
      return { target, transitionEnd };
    }
  };
  function unitConversion(visualElement, target, origin, transitionEnd) {
    return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs
  var parseDomVariant = (visualElement, target, origin, transitionEnd) => {
    const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
    target = resolved.target;
    transitionEnd = resolved.transitionEnd;
    return unitConversion(visualElement, target, origin, transitionEnd);
  };

  // node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
  var prefersReducedMotion = { current: null };
  var hasReducedMotionListener = { current: false };

  // node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser4)
      return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addListener(setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }

  // node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
  function updateMotionValuesFromProps(element, next2, prev2) {
    const { willChange } = next2;
    for (const key in next2) {
      const nextValue = next2[key];
      const prevValue = prev2[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
        }
        if (true) {
          warnOnce(nextValue.version === "11.0.8", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.0.8 may not work as expected.`);
        }
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue, { owner: element }));
        if (isWillChangeMotionValue(willChange)) {
          willChange.remove(key);
        }
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          !existingValue.hasAnimated && existingValue.set(nextValue);
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
        }
      }
    }
    for (const key in prev2) {
      if (next2[key] === void 0)
        element.removeValue(key);
    }
    return next2;
  }

  // node_modules/framer-motion/dist/es/render/store.mjs
  var visualElementStore = /* @__PURE__ */ new WeakMap();

  // node_modules/framer-motion/dist/es/render/VisualElement.mjs
  var featureNames = Object.keys(featureDefinitions);
  var numFeatures = featureNames.length;
  var propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  var numVariantProps = variantProps.length;
  var VisualElement = class {
    constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options = {}) {
      this.current = null;
      this.children = /* @__PURE__ */ new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.values = /* @__PURE__ */ new Map();
      this.features = {};
      this.valueSubscriptions = /* @__PURE__ */ new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current)
          return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.scheduleRender = () => frame.render(this.render, false, true);
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = /* @__PURE__ */ new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key], false);
          if (isWillChangeMotionValue(willChange)) {
            willChange.add(key);
          }
        }
      }
    }
    /**
     * This method takes React props and returns found MotionValues. For example, HTML
     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
     *
     * This isn't an abstract method as it needs calling in the constructor, but it is
     * intended to be one.
     */
    scrapeMotionValuesFromProps(_props, _prevProps) {
      return {};
    }
    mount(instance) {
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      if (true) {
        warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
      }
      if (this.parent)
        this.parent.children.add(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      visualElementStore.delete(this.current);
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove) => remove());
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent && this.parent.children.delete(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        this.features[key].unmount();
      }
      this.current = null;
    }
    bindToMotionValue(key, value) {
      const valueIsTransform = transformProps.has(key);
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.update(this.notifyUpdate, false, true);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
      });
      const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
      let ProjectionNodeConstructor;
      let MeasureLayout2;
      if (preloadedFeatures2 && isStrict) {
        const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
        renderedProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);
      }
      for (let i = 0; i < numFeatures; i++) {
        const name = featureNames[i];
        const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];
        if (ProjectionNode)
          ProjectionNodeConstructor = ProjectionNode;
        if (isEnabled(renderedProps)) {
          if (!this.features[name] && FeatureConstructor) {
            this.features[name] = new FeatureConstructor(this);
          }
          if (MeasureLayoutComponent) {
            MeasureLayout2 = MeasureLayoutComponent;
          }
        }
      }
      if ((this.type === "html" || this.type === "svg") && !this.projection && ProjectionNodeConstructor) {
        this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
        const { layoutId, layout: layout3, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
        this.projection.setOptions({
          layoutId,
          layout: layout3,
          alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
          visualElement: this,
          scheduleRender: () => this.scheduleRender(),
          /**
           * TODO: Update options in an effect. This could be tricky as it'll be too late
           * to update by the time layout animations run.
           * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
           * ensuring it gets called if there's no potential layout animations.
           *
           */
          animationType: typeof layout3 === "string" ? layout3 : "both",
          initialPromotionConfig: initialLayoutGroupConfig,
          layoutScroll,
          layoutRoot
        });
      }
      return MeasureLayout2;
    }
    updateFeatures() {
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.options, this.props);
    }
    /**
     * Measure the current viewport box with or without transforms.
     * Only measures axis-aligned boxes, rotate and skew must be manually
     * removed with a re-render to work.
     */
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    /**
     * Make a target animatable by Popmotion. For instance, if we're
     * trying to animate width from 100px to 100vw we need to measure 100vw
     * in pixels to determine what we really need to animate to. This is also
     * pluggable to support Framer's custom value types like Color,
     * and CSS variables.
     */
    makeTargetAnimatable(target, canMutate = true) {
      return this.makeTargetAnimatableFromInstance(target, canMutate);
    }
    /**
     * Update the provided props. Ensure any newly-added motion values are
     * added to our map, old ones removed, and listeners updated.
     */
    update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i = 0; i < propEventHandlers.length; i++) {
        const key = propEventHandlers[i];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listener = props["on" + key];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
    /**
     * Returns the variant definition with a given name.
     */
    getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
    /**
     * Returns the defined default transition on this component.
     */
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    getVariantContext(startAtParent = false) {
      if (startAtParent) {
        return this.parent ? this.parent.getVariantContext() : void 0;
      }
      if (!this.isControllingVariants) {
        const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
        if (this.props.initial !== void 0) {
          context2.initial = this.props.initial;
        }
        return context2;
      }
      const context = {};
      for (let i = 0; i < numVariantProps; i++) {
        const name = variantProps[i];
        const prop = this.props[name];
        if (isVariantLabel(prop) || prop === false) {
          context[name] = prop;
        }
      }
      return context;
    }
    /**
     * Add a child visual element to our set of children.
     */
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
    /**
     * Add a motion value and bind it to this visual element.
     */
    addValue(key, value) {
      if (value !== this.values.get(key)) {
        this.removeValue(key);
        this.bindToMotionValue(key, value);
      }
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
    /**
     * Remove a motion value and unbind any active subscriptions.
     */
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    /**
     * Check whether we have a motion value for this key
     */
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
    /**
     * If we're trying to animate to a previously unencountered value,
     * we need to check for it in our state and as a last resort read it
     * directly from the instance (which might have performance implications).
     */
    readValue(key) {
      var _a7;
      return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a7 = this.getBaseTargetFromProps(this.props, key)) !== null && _a7 !== void 0 ? _a7 : this.readValueFromInstance(this.current, key, this.options);
    }
    /**
     * Set the base target to later animate back to. This is currently
     * only hydrated on creation and when we first read a value.
     */
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    /**
     * Find the base target for a value thats been removed from all animation
     * props.
     */
    getBaseTarget(key) {
      var _a7;
      const { initial } = this.props;
      const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a7 = resolveVariantFromProps(this.props, initial)) === null || _a7 === void 0 ? void 0 : _a7[key] : void 0;
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target))
        return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
  var DOMVisualElement = class extends VisualElement {
    sortInstanceNodePosition(a, b) {
      return a.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, { vars: vars2, style }) {
      delete vars2[key];
      delete style[key];
    }
    makeTargetAnimatableFromInstance({ transition: transition3, transitionEnd, ...target }, isMounted) {
      const origin = getOrigin(target, transition3 || {}, this);
      if (isMounted) {
        checkTargetForNewValues(this, target, origin);
        const parsed = parseDomVariant(this, target, origin, transitionEnd);
        transitionEnd = parsed.transitionEnd;
        target = parsed.target;
      }
      return {
        transition: transition3,
        transitionEnd,
        ...target
      };
    }
  };

  // node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
  function getComputedStyle2(element) {
    return window.getComputedStyle(element);
  }
  var HTMLVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      } else {
        const computedStyle = getComputedStyle2(instance);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, options, props) {
      buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps) {
      return scrapeMotionValuesFromProps(props, prevProps);
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current)
            this.current.textContent = `${latest}`;
        });
      }
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderHTML(instance, renderState, styleProp, projection);
    }
  };

  // node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
  var SVGVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    measureInstanceViewportBox() {
      return createBox();
    }
    scrapeMotionValuesFromProps(props, prevProps) {
      return scrapeMotionValuesFromProps2(props, prevProps);
    }
    build(renderState, latestValues, options, props) {
      buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var createDomVisualElement = (Component2, options) => {
    return isSVGComponent(Component2) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });
  };

  // node_modules/framer-motion/dist/es/motion/features/layout.mjs
  var layout2 = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/motion.mjs
  var preloadedFeatures = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout2
  };
  var motion = /* @__PURE__ */ createMotionProxy((Component2, config2) => createDomMotionConfig(Component2, config2, preloadedFeatures, createDomVisualElement));

  // node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
  var React9 = __toESM(require_react(), 1);
  var import_react46 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/use-force-update.mjs
  var import_react42 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs
  var import_react41 = __toESM(require_react(), 1);
  function useIsMounted() {
    const isMounted = (0, import_react41.useRef)(false);
    useIsomorphicLayoutEffect(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  }

  // node_modules/framer-motion/dist/es/utils/use-force-update.mjs
  function useForceUpdate() {
    const isMounted = useIsMounted();
    const [forcedRenderCount, setForcedRenderCount] = (0, import_react42.useState)(0);
    const forceRender = (0, import_react42.useCallback)(() => {
      isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
    }, [forcedRenderCount]);
    const deferredForceRender = (0, import_react42.useCallback)(() => frame.postRender(forceRender), [forceRender]);
    return [deferredForceRender, forcedRenderCount];
  }

  // node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
  var React8 = __toESM(require_react(), 1);
  var import_react44 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
  var React7 = __toESM(require_react(), 1);
  var import_react43 = __toESM(require_react(), 1);
  var PopChildMeasure = class extends React7.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element = this.props.childRef.current;
      if (element && prevProps.isPresent && !this.props.isPresent) {
        const size2 = this.props.sizeRef.current;
        size2.height = element.offsetHeight || 0;
        size2.width = element.offsetWidth || 0;
        size2.top = element.offsetTop;
        size2.left = element.offsetLeft;
      }
      return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */
    componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  };
  function PopChild({ children, isPresent: isPresent2 }) {
    const id3 = (0, import_react43.useId)();
    const ref = (0, import_react43.useRef)(null);
    const size2 = (0, import_react43.useRef)({
      width: 0,
      height: 0,
      top: 0,
      left: 0
    });
    (0, import_react43.useInsertionEffect)(() => {
      const { width, height, top: top2, left: left2 } = size2.current;
      if (isPresent2 || !ref.current || !width || !height)
        return;
      ref.current.dataset.motionPopId = id3;
      const style = document.createElement("style");
      document.head.appendChild(style);
      if (style.sheet) {
        style.sheet.insertRule(`
          [data-motion-pop-id="${id3}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top2}px !important;
            left: ${left2}px !important;
          }
        `);
      }
      return () => {
        document.head.removeChild(style);
      };
    }, [isPresent2]);
    return React7.createElement(PopChildMeasure, { isPresent: isPresent2, childRef: ref, sizeRef: size2 }, React7.cloneElement(children, { ref }));
  }

  // node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
  var PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode: mode2 }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id3 = (0, import_react44.useId)();
    const context = (0, import_react44.useMemo)(
      () => ({
        id: id3,
        initial,
        isPresent: isPresent2,
        custom,
        onExitComplete: (childId) => {
          presenceChildren.set(childId, true);
          for (const isComplete of presenceChildren.values()) {
            if (!isComplete)
              return;
          }
          onExitComplete && onExitComplete();
        },
        register: (childId) => {
          presenceChildren.set(childId, false);
          return () => presenceChildren.delete(childId);
        }
      }),
      /**
       * If the presence of a child affects the layout of the components around it,
       * we want to make a new context value to ensure they get re-rendered
       * so they can detect that layout change.
       */
      presenceAffectsLayout ? void 0 : [isPresent2]
    );
    (0, import_react44.useMemo)(() => {
      presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
    }, [isPresent2]);
    React8.useEffect(() => {
      !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent2]);
    if (mode2 === "popLayout") {
      children = React8.createElement(PopChild, { isPresent: isPresent2 }, children);
    }
    return React8.createElement(PresenceContext.Provider, { value: context }, children);
  };
  function newChildrenMap() {
    return /* @__PURE__ */ new Map();
  }

  // node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
  var import_react45 = __toESM(require_react(), 1);
  function useUnmountEffect(callback) {
    return (0, import_react45.useEffect)(() => () => callback(), []);
  }

  // node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
  var getChildKey = (child) => child.key || "";
  function updateChildLookup(children, allChildren) {
    children.forEach((child) => {
      const key = getChildKey(child);
      allChildren.set(key, child);
    });
  }
  function onlyElements(children) {
    const filtered = [];
    import_react46.Children.forEach(children, (child) => {
      if ((0, import_react46.isValidElement)(child))
        filtered.push(child);
    });
    return filtered;
  }
  var AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode: mode2 = "sync" }) => {
    invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
    const forceRender = (0, import_react46.useContext)(LayoutGroupContext).forceRender || useForceUpdate()[0];
    const isMounted = useIsMounted();
    const filteredChildren = onlyElements(children);
    let childrenToRender = filteredChildren;
    const exitingChildren = (0, import_react46.useRef)(/* @__PURE__ */ new Map()).current;
    const presentChildren = (0, import_react46.useRef)(childrenToRender);
    const allChildren = (0, import_react46.useRef)(/* @__PURE__ */ new Map()).current;
    const isInitialRender = (0, import_react46.useRef)(true);
    useIsomorphicLayoutEffect(() => {
      isInitialRender.current = false;
      updateChildLookup(filteredChildren, allChildren);
      presentChildren.current = childrenToRender;
    });
    useUnmountEffect(() => {
      isInitialRender.current = true;
      allChildren.clear();
      exitingChildren.clear();
    });
    if (isInitialRender.current) {
      return React9.createElement(React9.Fragment, null, childrenToRender.map((child) => React9.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode: mode2 }, child)));
    }
    childrenToRender = [...childrenToRender];
    const presentKeys = presentChildren.current.map(getChildKey);
    const targetKeys = filteredChildren.map(getChildKey);
    const numPresent = presentKeys.length;
    for (let i = 0; i < numPresent; i++) {
      const key = presentKeys[i];
      if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {
        exitingChildren.set(key, void 0);
      }
    }
    if (mode2 === "wait" && exitingChildren.size) {
      childrenToRender = [];
    }
    exitingChildren.forEach((component, key) => {
      if (targetKeys.indexOf(key) !== -1)
        return;
      const child = allChildren.get(key);
      if (!child)
        return;
      const insertionIndex = presentKeys.indexOf(key);
      let exitingComponent = component;
      if (!exitingComponent) {
        const onExit = () => {
          exitingChildren.delete(key);
          const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));
          leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));
          presentChildren.current = filteredChildren.filter((presentChild) => {
            const presentChildKey = getChildKey(presentChild);
            return (
              // filter out the node exiting
              presentChildKey === key || // filter out the leftover children
              leftOverKeys.includes(presentChildKey)
            );
          });
          if (!exitingChildren.size) {
            if (isMounted.current === false)
              return;
            forceRender();
            onExitComplete && onExitComplete();
          }
        };
        exitingComponent = React9.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode: mode2 }, child);
        exitingChildren.set(key, exitingComponent);
      }
      childrenToRender.splice(insertionIndex, 0, exitingComponent);
    });
    childrenToRender = childrenToRender.map((child) => {
      const key = child.key;
      return exitingChildren.has(key) ? child : React9.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode: mode2 }, child);
    });
    if (mode2 === "wait" && childrenToRender.length > 1) {
      console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
    }
    return React9.createElement(React9.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map((child) => (0, import_react46.cloneElement)(child)));
  };

  // node_modules/@chakra-ui/toast/dist/chunk-VXESY33O.mjs
  var import_react47 = __toESM(require_react(), 1);
  var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
  var toastMotionVariants = {
    initial: (props) => {
      const { position: position3 } = props;
      const dir = ["top", "bottom"].includes(position3) ? "y" : "x";
      let factor = ["top-right", "bottom-right"].includes(position3) ? 1 : -1;
      if (position3 === "bottom")
        factor = 1;
      return {
        opacity: 0,
        [dir]: factor * 24
      };
    },
    animate: {
      opacity: 1,
      y: 0,
      x: 0,
      scale: 1,
      transition: {
        duration: 0.4,
        ease: [0.4, 0, 0.2, 1]
      }
    },
    exit: {
      opacity: 0,
      scale: 0.85,
      transition: {
        duration: 0.2,
        ease: [0.4, 0, 1, 1]
      }
    }
  };
  var ToastComponent = (0, import_react47.memo)((props) => {
    const {
      id: id3,
      message,
      onCloseComplete,
      onRequestRemove,
      requestClose = false,
      position: position3 = "bottom",
      duration = 5e3,
      containerStyle,
      motionVariants = toastMotionVariants,
      toastSpacing = "0.5rem"
    } = props;
    const [delay2, setDelay] = (0, import_react47.useState)(duration);
    const isPresent2 = useIsPresent();
    useUpdateEffect(() => {
      if (!isPresent2) {
        onCloseComplete == null ? void 0 : onCloseComplete();
      }
    }, [isPresent2]);
    useUpdateEffect(() => {
      setDelay(duration);
    }, [duration]);
    const onMouseEnter = () => setDelay(null);
    const onMouseLeave = () => setDelay(duration);
    const close2 = () => {
      if (isPresent2)
        onRequestRemove();
    };
    (0, import_react47.useEffect)(() => {
      if (isPresent2 && requestClose) {
        onRequestRemove();
      }
    }, [isPresent2, requestClose, onRequestRemove]);
    useTimeout(close2, delay2);
    const containerStyles = (0, import_react47.useMemo)(
      () => ({
        pointerEvents: "auto",
        maxWidth: 560,
        minWidth: 300,
        margin: toastSpacing,
        ...containerStyle
      }),
      [containerStyle, toastSpacing]
    );
    const toastStyle = (0, import_react47.useMemo)(() => getToastStyle(position3), [position3]);
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      motion.div,
      {
        layout: true,
        className: "chakra-toast",
        variants: motionVariants,
        initial: "initial",
        animate: "animate",
        exit: "exit",
        onHoverStart: onMouseEnter,
        onHoverEnd: onMouseLeave,
        custom: { position: position3 },
        style: toastStyle,
        children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          chakra.div,
          {
            role: "status",
            "aria-atomic": "true",
            className: "chakra-toast__inner",
            __css: containerStyles,
            children: runIfFn(message, { id: id3, onClose: close2 })
          }
        )
      }
    );
  });
  ToastComponent.displayName = "ToastComponent";

  // node_modules/@chakra-ui/icon/dist/chunk-2GBDXOMA.mjs
  var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
  var fallbackIcon = {
    path: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "path",
        {
          strokeLinecap: "round",
          fill: "none",
          d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "path",
        {
          fill: "currentColor",
          strokeLinecap: "round",
          d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
    ] }),
    viewBox: "0 0 24 24"
  };
  var Icon = forwardRef3((props, ref) => {
    const {
      as: element,
      viewBox,
      color: color4 = "currentColor",
      focusable = false,
      children,
      className,
      __css,
      ...rest
    } = props;
    const _className = cx("chakra-icon", className);
    const customStyles = useStyleConfig("Icon", props);
    const styles2 = {
      w: "1em",
      h: "1em",
      display: "inline-block",
      lineHeight: "1em",
      flexShrink: 0,
      color: color4,
      ...__css,
      ...customStyles
    };
    const shared = {
      ref,
      focusable,
      className: _className,
      __css: styles2
    };
    const _viewBox = viewBox != null ? viewBox : fallbackIcon.viewBox;
    if (element && typeof element !== "string") {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(chakra.svg, { as: element, ...shared, ...rest });
    }
    const _path = children != null ? children : fallbackIcon.path;
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(chakra.svg, { verticalAlign: "middle", viewBox: _viewBox, ...shared, ...rest, children: _path });
  });
  Icon.displayName = "Icon";

  // node_modules/@chakra-ui/icon/dist/chunk-DEQZ7DVA.mjs
  var import_react48 = __toESM(require_react(), 1);
  var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
  function createIcon(options) {
    const {
      viewBox = "0 0 24 24",
      d: pathDefinition,
      displayName,
      defaultProps: defaultProps2 = {}
    } = options;
    const path = import_react48.Children.toArray(options.path);
    const Comp = forwardRef3((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Icon, { ref, viewBox, ...defaultProps2, ...props, children: path.length ? path : /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("path", { fill: "currentColor", d: pathDefinition }) }));
    Comp.displayName = displayName;
    return Comp;
  }

  // node_modules/@chakra-ui/alert/dist/chunk-NEDBTDT2.mjs
  var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
  function CheckIcon(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
      }
    ) });
  }
  function InfoIcon(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
      }
    ) });
  }
  function WarningIcon(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
      }
    ) });
  }

  // node_modules/@chakra-ui/spinner/dist/chunk-5PH6ULNP.mjs
  var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
  var spin = keyframes({
    "0%": {
      transform: "rotate(0deg)"
    },
    "100%": {
      transform: "rotate(360deg)"
    }
  });
  var Spinner = forwardRef3((props, ref) => {
    const styles2 = useStyleConfig("Spinner", props);
    const {
      label = "Loading...",
      thickness = "2px",
      speed = "0.45s",
      emptyColor = "transparent",
      className,
      ...rest
    } = omitThemingProps(props);
    const _className = cx("chakra-spinner", className);
    const spinnerStyles = {
      display: "inline-block",
      borderColor: "currentColor",
      borderStyle: "solid",
      borderRadius: "99999px",
      borderWidth: thickness,
      borderBottomColor: emptyColor,
      borderLeftColor: emptyColor,
      animation: `${spin} ${speed} linear infinite`,
      ...styles2
    };
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      chakra.div,
      {
        ref,
        __css: spinnerStyles,
        className: _className,
        ...rest,
        children: label && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(chakra.span, { srOnly: true, children: label })
      }
    );
  });
  Spinner.displayName = "Spinner";

  // node_modules/@chakra-ui/alert/dist/chunk-XCES3W5V.mjs
  var [AlertProvider, useAlertContext] = createContext2({
    name: "AlertContext",
    hookName: "useAlertContext",
    providerName: "<Alert />"
  });
  var [AlertStylesProvider, useAlertStyles] = createContext2({
    name: `AlertStylesContext`,
    hookName: `useAlertStyles`,
    providerName: "<Alert />"
  });
  var STATUSES = {
    info: { icon: InfoIcon, colorScheme: "blue" },
    warning: { icon: WarningIcon, colorScheme: "orange" },
    success: { icon: CheckIcon, colorScheme: "green" },
    error: { icon: WarningIcon, colorScheme: "red" },
    loading: { icon: Spinner, colorScheme: "blue" }
  };
  function getStatusColorScheme(status) {
    return STATUSES[status].colorScheme;
  }
  function getStatusIcon(status) {
    return STATUSES[status].icon;
  }

  // node_modules/@chakra-ui/alert/dist/chunk-CUKBNH6U.mjs
  var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
  var AlertDescription = forwardRef3(
    function AlertDescription2(props, ref) {
      const styles2 = useAlertStyles();
      const { status } = useAlertContext();
      const descriptionStyles = {
        display: "inline",
        ...styles2.description
      };
      return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
        chakra.div,
        {
          ref,
          "data-status": status,
          ...props,
          className: cx("chakra-alert__desc", props.className),
          __css: descriptionStyles
        }
      );
    }
  );
  AlertDescription.displayName = "AlertDescription";

  // node_modules/@chakra-ui/alert/dist/chunk-ALC6QPCI.mjs
  var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
  function AlertIcon(props) {
    const { status } = useAlertContext();
    const BaseIcon = getStatusIcon(status);
    const styles2 = useAlertStyles();
    const css4 = status === "loading" ? styles2.spinner : styles2.icon;
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
      chakra.span,
      {
        display: "inherit",
        "data-status": status,
        ...props,
        className: cx("chakra-alert__icon", props.className),
        __css: css4,
        children: props.children || /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(BaseIcon, { h: "100%", w: "100%" })
      }
    );
  }
  AlertIcon.displayName = "AlertIcon";

  // node_modules/@chakra-ui/alert/dist/chunk-QURMB2UJ.mjs
  var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
  var AlertTitle = forwardRef3(
    function AlertTitle2(props, ref) {
      const styles2 = useAlertStyles();
      const { status } = useAlertContext();
      return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        chakra.div,
        {
          ref,
          "data-status": status,
          ...props,
          className: cx("chakra-alert__title", props.className),
          __css: styles2.title
        }
      );
    }
  );
  AlertTitle.displayName = "AlertTitle";

  // node_modules/@chakra-ui/alert/dist/chunk-3KCBMPN5.mjs
  var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
  var Alert = forwardRef3(function Alert2(props, ref) {
    var _a7;
    const { status = "info", addRole = true, ...rest } = omitThemingProps(props);
    const colorScheme = (_a7 = props.colorScheme) != null ? _a7 : getStatusColorScheme(status);
    const styles2 = useMultiStyleConfig("Alert", { ...props, colorScheme });
    const alertStyles = {
      width: "100%",
      display: "flex",
      alignItems: "center",
      position: "relative",
      overflow: "hidden",
      ...styles2.container
    };
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlertProvider, { value: { status }, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AlertStylesProvider, { value: styles2, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      chakra.div,
      {
        "data-status": status,
        role: addRole ? "alert" : void 0,
        ref,
        ...rest,
        className: cx("chakra-alert", props.className),
        __css: alertStyles
      }
    ) }) });
  });
  Alert.displayName = "Alert";

  // node_modules/@chakra-ui/close-button/dist/chunk-37N6GCLA.mjs
  var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
  function CloseIcon(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Icon, { focusable: "false", "aria-hidden": true, ...props, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
      }
    ) });
  }
  var CloseButton = forwardRef3(
    function CloseButton2(props, ref) {
      const styles2 = useStyleConfig("CloseButton", props);
      const { children, isDisabled, __css, ...rest } = omitThemingProps(props);
      const baseStyle43 = {
        outline: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0
      };
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
        chakra.button,
        {
          type: "button",
          "aria-label": "Close",
          ref,
          disabled: isDisabled,
          __css: {
            ...baseStyle43,
            ...styles2,
            ...__css
          },
          ...rest,
          children: children || /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(CloseIcon, { width: "1em", height: "1em" })
        }
      );
    }
  );
  CloseButton.displayName = "CloseButton";

  // node_modules/@chakra-ui/toast/dist/chunk-HYCJNCPE.mjs
  var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
  var initialState = {
    top: [],
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    bottom: [],
    "bottom-right": []
  };
  var toastStore = createStore(initialState);
  function createStore(initialState2) {
    let state2 = initialState2;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (setStateFn) => {
      state2 = setStateFn(state2);
      listeners.forEach((l2) => l2());
    };
    return {
      getState: () => state2,
      subscribe: (listener) => {
        listeners.add(listener);
        return () => {
          setState(() => initialState2);
          listeners.delete(listener);
        };
      },
      /**
       * Delete a toast record at its position
       */
      removeToast: (id3, position3) => {
        setState((prevState) => ({
          ...prevState,
          // id may be string or number
          // eslint-disable-next-line eqeqeq
          [position3]: prevState[position3].filter((toast) => toast.id != id3)
        }));
      },
      notify: (message, options) => {
        const toast = createToast(message, options);
        const { position: position3, id: id3 } = toast;
        setState((prevToasts) => {
          var _a7, _b5;
          const isTop = position3.includes("top");
          const toasts = isTop ? [toast, ...(_a7 = prevToasts[position3]) != null ? _a7 : []] : [...(_b5 = prevToasts[position3]) != null ? _b5 : [], toast];
          return {
            ...prevToasts,
            [position3]: toasts
          };
        });
        return id3;
      },
      update: (id3, options) => {
        if (!id3)
          return;
        setState((prevState) => {
          const nextState = { ...prevState };
          const { position: position3, index } = findToast(nextState, id3);
          if (position3 && index !== -1) {
            nextState[position3][index] = {
              ...nextState[position3][index],
              ...options,
              message: createRenderToast(options)
            };
          }
          return nextState;
        });
      },
      closeAll: ({ positions } = {}) => {
        setState((prev2) => {
          const allPositions = [
            "bottom",
            "bottom-right",
            "bottom-left",
            "top",
            "top-left",
            "top-right"
          ];
          const positionsToClose = positions != null ? positions : allPositions;
          return positionsToClose.reduce(
            (acc, position3) => {
              acc[position3] = prev2[position3].map((toast) => ({
                ...toast,
                requestClose: true
              }));
              return acc;
            },
            { ...prev2 }
          );
        });
      },
      close: (id3) => {
        setState((prevState) => {
          const position3 = getToastPosition(prevState, id3);
          if (!position3)
            return prevState;
          return {
            ...prevState,
            [position3]: prevState[position3].map((toast) => {
              if (toast.id == id3) {
                return {
                  ...toast,
                  requestClose: true
                };
              }
              return toast;
            })
          };
        });
      },
      isActive: (id3) => Boolean(findToast(toastStore.getState(), id3).position)
    };
  }
  var counter = 0;
  function createToast(message, options = {}) {
    var _a7, _b5;
    counter += 1;
    const id3 = (_a7 = options.id) != null ? _a7 : counter;
    const position3 = (_b5 = options.position) != null ? _b5 : "bottom";
    return {
      id: id3,
      message,
      position: position3,
      duration: options.duration,
      onCloseComplete: options.onCloseComplete,
      onRequestRemove: () => toastStore.removeToast(String(id3), position3),
      status: options.status,
      requestClose: false,
      containerStyle: options.containerStyle
    };
  }
  var Toast = (props) => {
    const {
      status,
      variant = "solid",
      id: id3,
      title,
      isClosable,
      onClose,
      description,
      colorScheme,
      icon
    } = props;
    const ids = id3 ? {
      root: `toast-${id3}`,
      title: `toast-${id3}-title`,
      description: `toast-${id3}-description`
    } : void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(
      Alert,
      {
        addRole: false,
        status,
        variant,
        id: ids == null ? void 0 : ids.root,
        alignItems: "start",
        borderRadius: "md",
        boxShadow: "lg",
        paddingEnd: 8,
        textAlign: "start",
        width: "auto",
        colorScheme,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(AlertIcon, { children: icon }),
          /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(chakra.div, { flex: "1", maxWidth: "100%", children: [
            title && /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(AlertTitle, { id: ids == null ? void 0 : ids.title, children: title }),
            description && /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(AlertDescription, { id: ids == null ? void 0 : ids.description, display: "block", children: description })
          ] }),
          isClosable && /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
            CloseButton,
            {
              size: "sm",
              onClick: onClose,
              position: "absolute",
              insetEnd: 1,
              top: 1
            }
          )
        ]
      }
    );
  };
  function createRenderToast(options = {}) {
    const { render, toastComponent: ToastComponent2 = Toast } = options;
    const renderToast = (props) => {
      if (typeof render === "function") {
        return render({ ...props, ...options });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ToastComponent2, { ...props, ...options });
    };
    return renderToast;
  }

  // node_modules/@chakra-ui/toast/dist/chunk-3Y4YXCR2.mjs
  var import_react49 = __toESM(require_react(), 1);
  var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
  var [ToastOptionProvider, useToastOptionContext] = createContext2({
    name: `ToastOptionsContext`,
    strict: false
  });
  var ToastProvider = (props) => {
    const state2 = (0, import_react49.useSyncExternalStore)(
      toastStore.subscribe,
      toastStore.getState,
      toastStore.getState
    );
    const {
      motionVariants,
      component: Component2 = ToastComponent,
      portalProps
    } = props;
    const stateKeys = Object.keys(state2);
    const toastList = stateKeys.map((position3) => {
      const toasts = state2[position3];
      return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "div",
        {
          role: "region",
          "aria-live": "polite",
          "aria-label": `Notifications-${position3}`,
          id: `chakra-toast-manager-${position3}`,
          style: getToastListStyle(position3),
          children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(AnimatePresence, { initial: false, children: toasts.map((toast) => /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
            Component2,
            {
              motionVariants,
              ...toast
            },
            toast.id
          )) })
        },
        position3
      );
    });
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Portal, { ...portalProps, children: toastList });
  };

  // node_modules/@chakra-ui/react/dist/chunk-QAITB7GG.mjs
  var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
  var createChakraProvider = (providerTheme) => {
    return function ChakraProvider22({
      children,
      theme: theme3 = providerTheme,
      toastOptions,
      ...restProps
    }) {
      return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(ChakraProvider, { theme: theme3, ...restProps, children: [
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(ToastOptionProvider, { value: toastOptions == null ? void 0 : toastOptions.defaultOptions, children }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(ToastProvider, { ...toastOptions })
      ] });
    };
  };
  var ChakraProvider2 = createChakraProvider(theme);
  var ChakraBaseProvider = createChakraProvider(baseTheme);

  // node_modules/@chakra-ui/react-use-merge-refs/dist/index.mjs
  var import_react50 = __toESM(require_react(), 1);
  function assignRef(ref, value) {
    if (ref == null)
      return;
    if (typeof ref === "function") {
      ref(value);
      return;
    }
    try {
      ref.current = value;
    } catch (error2) {
      throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
    }
  }
  function mergeRefs(...refs) {
    return (node2) => {
      refs.forEach((ref) => {
        assignRef(ref, node2);
      });
    };
  }
  function useMergeRefs(...refs) {
    return (0, import_react50.useMemo)(() => mergeRefs(...refs), refs);
  }

  // node_modules/@chakra-ui/react-children-utils/dist/index.mjs
  var import_react51 = __toESM(require_react(), 1);
  function getValidChildren(children) {
    return import_react51.Children.toArray(children).filter(
      (child) => (0, import_react51.isValidElement)(child)
    );
  }

  // node_modules/@chakra-ui/button/dist/chunk-T6ZDZOLO.mjs
  var [ButtonGroupProvider, useButtonGroup] = createContext2({
    strict: false,
    name: "ButtonGroupContext"
  });

  // node_modules/@chakra-ui/button/dist/chunk-J37R6SZE.mjs
  var import_react52 = __toESM(require_react(), 1);
  function useButtonType(value) {
    const [isButton, setIsButton] = (0, import_react52.useState)(!value);
    const refCallback = (0, import_react52.useCallback)((node2) => {
      if (!node2)
        return;
      setIsButton(node2.tagName === "BUTTON");
    }, []);
    const type = isButton ? "button" : void 0;
    return { ref: refCallback, type };
  }

  // node_modules/@chakra-ui/button/dist/chunk-3RENZ2UO.mjs
  var import_react53 = __toESM(require_react(), 1);
  var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
  function ButtonIcon(props) {
    const { children, className, ...rest } = props;
    const _children = (0, import_react53.isValidElement)(children) ? (0, import_react53.cloneElement)(children, {
      "aria-hidden": true,
      focusable: false
    }) : children;
    const _className = cx("chakra-button__icon", className);
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
      chakra.span,
      {
        display: "inline-flex",
        alignSelf: "center",
        flexShrink: 0,
        ...rest,
        className: _className,
        children: _children
      }
    );
  }
  ButtonIcon.displayName = "ButtonIcon";

  // node_modules/@chakra-ui/button/dist/chunk-QB2Y5VKH.mjs
  var import_react54 = __toESM(require_react(), 1);
  var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
  function ButtonSpinner(props) {
    const {
      label,
      placement,
      spacing: spacing2 = "0.5rem",
      children = /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(Spinner, { color: "currentColor", width: "1em", height: "1em" }),
      className,
      __css,
      ...rest
    } = props;
    const _className = cx("chakra-button__spinner", className);
    const marginProp = placement === "start" ? "marginEnd" : "marginStart";
    const spinnerStyles = (0, import_react54.useMemo)(
      () => ({
        display: "flex",
        alignItems: "center",
        position: label ? "relative" : "absolute",
        [marginProp]: label ? spacing2 : 0,
        fontSize: "1em",
        lineHeight: "normal",
        ...__css
      }),
      [__css, label, marginProp, spacing2]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(chakra.div, { className: _className, ...rest, __css: spinnerStyles, children });
  }
  ButtonSpinner.displayName = "ButtonSpinner";

  // node_modules/@chakra-ui/button/dist/chunk-UVUR7MCU.mjs
  var import_react55 = __toESM(require_react(), 1);
  var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
  var Button = forwardRef3((props, ref) => {
    const group = useButtonGroup();
    const styles2 = useStyleConfig("Button", { ...group, ...props });
    const {
      isDisabled = group == null ? void 0 : group.isDisabled,
      isLoading,
      isActive,
      children,
      leftIcon,
      rightIcon,
      loadingText,
      iconSpacing: iconSpacing2 = "0.5rem",
      type,
      spinner,
      spinnerPlacement = "start",
      className,
      as,
      ...rest
    } = omitThemingProps(props);
    const buttonStyles = (0, import_react55.useMemo)(() => {
      const _focus = { ...styles2 == null ? void 0 : styles2["_focus"], zIndex: 1 };
      return {
        display: "inline-flex",
        appearance: "none",
        alignItems: "center",
        justifyContent: "center",
        userSelect: "none",
        position: "relative",
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        outline: "none",
        ...styles2,
        ...!!group && { _focus }
      };
    }, [styles2, group]);
    const { ref: _ref, type: defaultType } = useButtonType(as);
    const contentProps = { rightIcon, leftIcon, iconSpacing: iconSpacing2, children };
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(
      chakra.button,
      {
        ref: useMergeRefs(ref, _ref),
        as,
        type: type != null ? type : defaultType,
        "data-active": dataAttr(isActive),
        "data-loading": dataAttr(isLoading),
        __css: buttonStyles,
        className: cx("chakra-button", className),
        ...rest,
        disabled: isDisabled || isLoading,
        children: [
          isLoading && spinnerPlacement === "start" && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
            ButtonSpinner,
            {
              className: "chakra-button__spinner--start",
              label: loadingText,
              placement: "start",
              spacing: iconSpacing2,
              children: spinner
            }
          ),
          isLoading ? loadingText || /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(chakra.span, { opacity: 0, children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ButtonContent, { ...contentProps }) }) : /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ButtonContent, { ...contentProps }),
          isLoading && spinnerPlacement === "end" && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
            ButtonSpinner,
            {
              className: "chakra-button__spinner--end",
              label: loadingText,
              placement: "end",
              spacing: iconSpacing2,
              children: spinner
            }
          )
        ]
      }
    );
  });
  Button.displayName = "Button";
  function ButtonContent(props) {
    const { leftIcon, rightIcon, children, iconSpacing: iconSpacing2 } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(import_jsx_runtime23.Fragment, { children: [
      leftIcon && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ButtonIcon, { marginEnd: iconSpacing2, children: leftIcon }),
      children,
      rightIcon && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ButtonIcon, { marginStart: iconSpacing2, children: rightIcon })
    ] });
  }

  // node_modules/@chakra-ui/form-control/dist/chunk-DFWC5MHP.mjs
  var import_react56 = __toESM(require_react(), 1);
  var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
  var [FormControlStylesProvider, useFormControlStyles] = createContext2({
    name: `FormControlStylesContext`,
    errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
  });
  var [FormControlProvider, useFormControlContext] = createContext2({
    strict: false,
    name: "FormControlContext"
  });
  function useFormControlProvider(props) {
    const {
      id: idProp,
      isRequired,
      isInvalid,
      isDisabled,
      isReadOnly,
      ...htmlProps
    } = props;
    const uuid = (0, import_react56.useId)();
    const id3 = idProp || `field-${uuid}`;
    const labelId = `${id3}-label`;
    const feedbackId = `${id3}-feedback`;
    const helpTextId = `${id3}-helptext`;
    const [hasFeedbackText, setHasFeedbackText] = (0, import_react56.useState)(false);
    const [hasHelpText, setHasHelpText] = (0, import_react56.useState)(false);
    const [isFocused, setFocus] = (0, import_react56.useState)(false);
    const getHelpTextProps = (0, import_react56.useCallback)(
      (props2 = {}, forwardedRef = null) => ({
        id: helpTextId,
        ...props2,
        /**
         * Notify the field context when the help text is rendered on screen,
         * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
         */
        ref: mergeRefs(forwardedRef, (node2) => {
          if (!node2)
            return;
          setHasHelpText(true);
        })
      }),
      [helpTextId]
    );
    const getLabelProps = (0, import_react56.useCallback)(
      (props2 = {}, forwardedRef = null) => ({
        ...props2,
        ref: forwardedRef,
        "data-focus": dataAttr(isFocused),
        "data-disabled": dataAttr(isDisabled),
        "data-invalid": dataAttr(isInvalid),
        "data-readonly": dataAttr(isReadOnly),
        id: props2.id !== void 0 ? props2.id : labelId,
        htmlFor: props2.htmlFor !== void 0 ? props2.htmlFor : id3
      }),
      [id3, isDisabled, isFocused, isInvalid, isReadOnly, labelId]
    );
    const getErrorMessageProps = (0, import_react56.useCallback)(
      (props2 = {}, forwardedRef = null) => ({
        id: feedbackId,
        ...props2,
        /**
         * Notify the field context when the error message is rendered on screen,
         * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
         */
        ref: mergeRefs(forwardedRef, (node2) => {
          if (!node2)
            return;
          setHasFeedbackText(true);
        }),
        "aria-live": "polite"
      }),
      [feedbackId]
    );
    const getRootProps = (0, import_react56.useCallback)(
      (props2 = {}, forwardedRef = null) => ({
        ...props2,
        ...htmlProps,
        ref: forwardedRef,
        role: "group",
        "data-focus": dataAttr(isFocused),
        "data-disabled": dataAttr(isDisabled),
        "data-invalid": dataAttr(isInvalid),
        "data-readonly": dataAttr(isReadOnly)
      }),
      [htmlProps, isDisabled, isFocused, isInvalid, isReadOnly]
    );
    const getRequiredIndicatorProps = (0, import_react56.useCallback)(
      (props2 = {}, forwardedRef = null) => ({
        ...props2,
        ref: forwardedRef,
        role: "presentation",
        "aria-hidden": true,
        children: props2.children || "*"
      }),
      []
    );
    return {
      isRequired: !!isRequired,
      isInvalid: !!isInvalid,
      isReadOnly: !!isReadOnly,
      isDisabled: !!isDisabled,
      isFocused: !!isFocused,
      onFocus: () => setFocus(true),
      onBlur: () => setFocus(false),
      hasFeedbackText,
      setHasFeedbackText,
      hasHelpText,
      setHasHelpText,
      id: id3,
      labelId,
      feedbackId,
      helpTextId,
      htmlProps,
      getHelpTextProps,
      getErrorMessageProps,
      getRootProps,
      getLabelProps,
      getRequiredIndicatorProps
    };
  }
  var FormControl = forwardRef3(
    function FormControl2(props, ref) {
      const styles2 = useMultiStyleConfig("Form", props);
      const ownProps = omitThemingProps(props);
      const {
        getRootProps,
        htmlProps: _,
        ...context
      } = useFormControlProvider(ownProps);
      const className = cx("chakra-form-control", props.className);
      return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(FormControlProvider, { value: context, children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(FormControlStylesProvider, { value: styles2, children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        chakra.div,
        {
          ...getRootProps({}, ref),
          className,
          __css: styles2["container"]
        }
      ) }) });
    }
  );
  FormControl.displayName = "FormControl";
  var FormHelperText = forwardRef3(
    function FormHelperText2(props, ref) {
      const field = useFormControlContext();
      const styles2 = useFormControlStyles();
      const className = cx("chakra-form__helper-text", props.className);
      return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        chakra.div,
        {
          ...field == null ? void 0 : field.getHelpTextProps(props, ref),
          __css: styles2.helperText,
          className
        }
      );
    }
  );
  FormHelperText.displayName = "FormHelperText";

  // node_modules/@chakra-ui/form-control/dist/chunk-H46NUPBZ.mjs
  var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
  var FormLabel = forwardRef3(function FormLabel2(passedProps, ref) {
    var _a7;
    const styles2 = useStyleConfig("FormLabel", passedProps);
    const props = omitThemingProps(passedProps);
    const {
      className,
      children,
      requiredIndicator = /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(RequiredIndicator, {}),
      optionalIndicator = null,
      ...rest
    } = props;
    const field = useFormControlContext();
    const ownProps = (_a7 = field == null ? void 0 : field.getLabelProps(rest, ref)) != null ? _a7 : { ref, ...rest };
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(
      chakra.label,
      {
        ...ownProps,
        className: cx("chakra-form__label", props.className),
        __css: {
          display: "block",
          textAlign: "start",
          ...styles2
        },
        children: [
          children,
          (field == null ? void 0 : field.isRequired) ? requiredIndicator : optionalIndicator
        ]
      }
    );
  });
  FormLabel.displayName = "FormLabel";
  var RequiredIndicator = forwardRef3(
    function RequiredIndicator2(props, ref) {
      const field = useFormControlContext();
      const styles2 = useFormControlStyles();
      if (!(field == null ? void 0 : field.isRequired))
        return null;
      const className = cx("chakra-form__required-indicator", props.className);
      return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
        chakra.span,
        {
          ...field == null ? void 0 : field.getRequiredIndicatorProps(props, ref),
          __css: styles2.requiredIndicator,
          className
        }
      );
    }
  );
  RequiredIndicator.displayName = "RequiredIndicator";

  // node_modules/@chakra-ui/form-control/dist/chunk-56K2BSAJ.mjs
  function useFormControl(props) {
    const { isDisabled, isInvalid, isReadOnly, isRequired, ...rest } = useFormControlProps(props);
    return {
      ...rest,
      disabled: isDisabled,
      readOnly: isReadOnly,
      required: isRequired,
      "aria-invalid": ariaAttr(isInvalid),
      "aria-required": ariaAttr(isRequired),
      "aria-readonly": ariaAttr(isReadOnly)
    };
  }
  function useFormControlProps(props) {
    var _a7, _b5, _c3;
    const field = useFormControlContext();
    const {
      id: id3,
      disabled,
      readOnly,
      required,
      isRequired,
      isInvalid,
      isReadOnly,
      isDisabled,
      onFocus,
      onBlur,
      ...rest
    } = props;
    const labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : [];
    if ((field == null ? void 0 : field.hasFeedbackText) && (field == null ? void 0 : field.isInvalid)) {
      labelIds.push(field.feedbackId);
    }
    if (field == null ? void 0 : field.hasHelpText) {
      labelIds.push(field.helpTextId);
    }
    return {
      ...rest,
      "aria-describedby": labelIds.join(" ") || void 0,
      id: id3 != null ? id3 : field == null ? void 0 : field.id,
      isDisabled: (_a7 = disabled != null ? disabled : isDisabled) != null ? _a7 : field == null ? void 0 : field.isDisabled,
      isReadOnly: (_b5 = readOnly != null ? readOnly : isReadOnly) != null ? _b5 : field == null ? void 0 : field.isReadOnly,
      isRequired: (_c3 = required != null ? required : isRequired) != null ? _c3 : field == null ? void 0 : field.isRequired,
      isInvalid: isInvalid != null ? isInvalid : field == null ? void 0 : field.isInvalid,
      onFocus: callAllHandlers(field == null ? void 0 : field.onFocus, onFocus),
      onBlur: callAllHandlers(field == null ? void 0 : field.onBlur, onBlur)
    };
  }

  // node_modules/@chakra-ui/react-use-event-listener/dist/index.mjs
  var import_react57 = __toESM(require_react(), 1);
  function useEventListener(target, event, handler, options) {
    const listener = useCallbackRef(handler);
    (0, import_react57.useEffect)(() => {
      const node2 = typeof target === "function" ? target() : target != null ? target : document;
      if (!handler || !node2)
        return;
      node2.addEventListener(event, listener, options);
      return () => {
        node2.removeEventListener(event, listener, options);
      };
    }, [event, target, options, listener, handler]);
    return () => {
      const node2 = typeof target === "function" ? target() : target != null ? target : document;
      node2 == null ? void 0 : node2.removeEventListener(event, listener, options);
    };
  }

  // node_modules/@chakra-ui/dom-utils/dist/chunk-3XANSPY5.mjs
  function isElement2(el) {
    return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
  }
  function isHTMLElement2(el) {
    var _a7;
    if (!isElement2(el))
      return false;
    const win = (_a7 = el.ownerDocument.defaultView) != null ? _a7 : window;
    return el instanceof win.HTMLElement;
  }

  // node_modules/@chakra-ui/dom-utils/dist/chunk-4WEUWBTD.mjs
  function isScrollParent(el) {
    const win = el.ownerDocument.defaultView || window;
    const { overflow, overflowX, overflowY } = win.getComputedStyle(el);
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function getParent(el) {
    if (el.localName === "html")
      return el;
    return el.assignedSlot || el.parentElement || el.ownerDocument.documentElement;
  }
  function getScrollParent(el) {
    if (["html", "body", "#document"].includes(el.localName)) {
      return el.ownerDocument.body;
    }
    if (isHTMLElement2(el) && isScrollParent(el)) {
      return el;
    }
    return getScrollParent(getParent(el));
  }

  // node_modules/@chakra-ui/dom-utils/dist/index.mjs
  var focusableElList = [
    "input:not(:disabled):not([disabled])",
    "select:not(:disabled):not([disabled])",
    "textarea:not(:disabled):not([disabled])",
    "embed",
    "iframe",
    "object",
    "a[href]",
    "area[href]",
    "button:not(:disabled):not([disabled])",
    "[tabindex]",
    "audio[controls]",
    "video[controls]",
    "*[tabindex]:not([aria-disabled])",
    "*[contenteditable]"
  ];
  var focusableElSelector = focusableElList.join();

  // node_modules/@chakra-ui/hooks/dist/chunk-724WJZW4.mjs
  var import_react58 = __toESM(require_react(), 1);
  var useSafeLayoutEffect2 = isBrowser3 ? import_react58.useLayoutEffect : import_react58.useEffect;

  // node_modules/@chakra-ui/hooks/dist/chunk-KA2477BY.mjs
  var import_react59 = __toESM(require_react(), 1);
  function useCallbackRef2(fn2, deps = []) {
    const ref = (0, import_react59.useRef)(fn2);
    useSafeLayoutEffect2(() => {
      ref.current = fn2;
    });
    return (0, import_react59.useCallback)((...args) => {
      var _a7;
      return (_a7 = ref.current) == null ? void 0 : _a7.call(ref, ...args);
    }, deps);
  }

  // node_modules/@chakra-ui/hooks/dist/chunk-6B2YUEGK.mjs
  var import_react60 = __toESM(require_react(), 1);
  function useId5(idProp, prefix2) {
    const id3 = (0, import_react60.useId)();
    return (0, import_react60.useMemo)(
      () => idProp || [prefix2, id3].filter(Boolean).join("-"),
      [idProp, prefix2, id3]
    );
  }

  // node_modules/@chakra-ui/hooks/dist/chunk-7JSBRQFI.mjs
  var import_react61 = __toESM(require_react(), 1);
  function useControllableProp(prop, state2) {
    const isControlled = prop !== void 0;
    const value = isControlled && typeof prop !== "undefined" ? prop : state2;
    return [isControlled, value];
  }

  // node_modules/@chakra-ui/hooks/dist/chunk-7JBTTEVG.mjs
  var import_react62 = __toESM(require_react(), 1);
  function useDisclosure(props = {}) {
    const {
      onClose: onCloseProp,
      onOpen: onOpenProp,
      isOpen: isOpenProp,
      id: idProp
    } = props;
    const onOpenPropCallbackRef = useCallbackRef2(onOpenProp);
    const onClosePropCallbackRef = useCallbackRef2(onCloseProp);
    const [isOpenState, setIsOpen] = (0, import_react62.useState)(props.defaultIsOpen || false);
    const [isControlled, isOpen] = useControllableProp(isOpenProp, isOpenState);
    const id3 = useId5(idProp, "disclosure");
    const onClose = (0, import_react62.useCallback)(() => {
      if (!isControlled) {
        setIsOpen(false);
      }
      onClosePropCallbackRef == null ? void 0 : onClosePropCallbackRef();
    }, [isControlled, onClosePropCallbackRef]);
    const onOpen = (0, import_react62.useCallback)(() => {
      if (!isControlled) {
        setIsOpen(true);
      }
      onOpenPropCallbackRef == null ? void 0 : onOpenPropCallbackRef();
    }, [isControlled, onOpenPropCallbackRef]);
    const onToggle = (0, import_react62.useCallback)(() => {
      const action = isOpen ? onClose : onOpen;
      action();
    }, [isOpen, onOpen, onClose]);
    return {
      isOpen: !!isOpen,
      onOpen,
      onClose,
      onToggle,
      isControlled,
      getButtonProps: (props2 = {}) => ({
        ...props2,
        "aria-expanded": isOpen,
        "aria-controls": id3,
        onClick: callAllHandlers2(props2.onClick, onToggle)
      }),
      getDisclosureProps: (props2 = {}) => ({
        ...props2,
        hidden: !isOpen,
        id: id3
      })
    };
  }

  // node_modules/@chakra-ui/input/dist/chunk-FKYN3ZGE.mjs
  var import_react63 = __toESM(require_react(), 1);
  var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
  var [InputGroupStylesProvider, useInputGroupStyles] = createContext2({
    name: `InputGroupStylesContext`,
    errorMessage: `useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `
  });
  var InputGroup = forwardRef3(
    function InputGroup2(props, ref) {
      const styles2 = useMultiStyleConfig("Input", props);
      const { children, className, ...rest } = omitThemingProps(props);
      const _className = cx("chakra-input__group", className);
      const groupStyles = {};
      const validChildren = getValidChildren(children);
      const input = styles2.field;
      validChildren.forEach((child) => {
        var _a7, _b5;
        if (!styles2)
          return;
        if (input && child.type.id === "InputLeftElement") {
          groupStyles.paddingStart = (_a7 = input.height) != null ? _a7 : input.h;
        }
        if (input && child.type.id === "InputRightElement") {
          groupStyles.paddingEnd = (_b5 = input.height) != null ? _b5 : input.h;
        }
        if (child.type.id === "InputRightAddon") {
          groupStyles.borderEndRadius = 0;
        }
        if (child.type.id === "InputLeftAddon") {
          groupStyles.borderStartRadius = 0;
        }
      });
      const clones = validChildren.map((child) => {
        var _a7, _b5;
        const theming = compact({
          size: ((_a7 = child.props) == null ? void 0 : _a7.size) || props.size,
          variant: ((_b5 = child.props) == null ? void 0 : _b5.variant) || props.variant
        });
        return child.type.id !== "Input" ? (0, import_react63.cloneElement)(child, theming) : (0, import_react63.cloneElement)(child, Object.assign(theming, groupStyles, child.props));
      });
      return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
        chakra.div,
        {
          className: _className,
          ref,
          __css: {
            width: "100%",
            display: "flex",
            position: "relative",
            // Parts of inputs override z-index to ensure that they stack correctly on each other
            // Create a new stacking context so that these overrides don't leak out and conflict with other z-indexes
            isolation: "isolate",
            ...styles2.group
          },
          "data-group": true,
          ...rest,
          children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(InputGroupStylesProvider, { value: styles2, children: clones })
        }
      );
    }
  );
  InputGroup.displayName = "InputGroup";

  // node_modules/@chakra-ui/input/dist/chunk-ADBZ7YHX.mjs
  var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
  var placements = {
    left: {
      marginEnd: "-1px",
      borderEndRadius: 0,
      borderEndColor: "transparent"
    },
    right: {
      marginStart: "-1px",
      borderStartRadius: 0,
      borderStartColor: "transparent"
    }
  };
  var StyledAddon = chakra("div", {
    baseStyle: {
      flex: "0 0 auto",
      width: "auto",
      display: "flex",
      alignItems: "center",
      whiteSpace: "nowrap"
    }
  });
  var InputAddon = forwardRef3(
    function InputAddon2(props, ref) {
      var _a7;
      const { placement = "left", ...rest } = props;
      const placementStyles = (_a7 = placements[placement]) != null ? _a7 : {};
      const styles2 = useInputGroupStyles();
      return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        StyledAddon,
        {
          ref,
          ...rest,
          __css: {
            ...styles2.addon,
            ...placementStyles
          }
        }
      );
    }
  );
  InputAddon.displayName = "InputAddon";
  var InputLeftAddon = forwardRef3(
    function InputLeftAddon2(props, ref) {
      return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        InputAddon,
        {
          ref,
          placement: "left",
          ...props,
          className: cx("chakra-input__left-addon", props.className)
        }
      );
    }
  );
  InputLeftAddon.displayName = "InputLeftAddon";
  InputLeftAddon.id = "InputLeftAddon";
  var InputRightAddon = forwardRef3(
    function InputRightAddon2(props, ref) {
      return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        InputAddon,
        {
          ref,
          placement: "right",
          ...props,
          className: cx("chakra-input__right-addon", props.className)
        }
      );
    }
  );
  InputRightAddon.displayName = "InputRightAddon";
  InputRightAddon.id = "InputRightAddon";

  // node_modules/@chakra-ui/input/dist/chunk-6CVSDS6C.mjs
  var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
  var Input = forwardRef3(function Input2(props, ref) {
    const { htmlSize, ...rest } = props;
    const styles2 = useMultiStyleConfig("Input", rest);
    const ownProps = omitThemingProps(rest);
    const input = useFormControl(ownProps);
    const _className = cx("chakra-input", props.className);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
      chakra.input,
      {
        size: htmlSize,
        ...input,
        __css: styles2.field,
        ref,
        className: _className
      }
    );
  });
  Input.displayName = "Input";
  Input.id = "Input";

  // node_modules/@chakra-ui/layout/dist/chunk-K7XRJ7NL.mjs
  var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
  var Link = forwardRef3(function Link2(props, ref) {
    const styles2 = useStyleConfig("Link", props);
    const { className, isExternal, ...rest } = omitThemingProps(props);
    return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      chakra.a,
      {
        target: isExternal ? "_blank" : void 0,
        rel: isExternal ? "noopener" : void 0,
        ref,
        className: cx("chakra-link", className),
        ...rest,
        __css: styles2
      }
    );
  });
  Link.displayName = "Link";

  // node_modules/@chakra-ui/breakpoint-utils/dist/chunk-G72KV6MB.mjs
  var breakpoints2 = Object.freeze([
    "base",
    "sm",
    "md",
    "lg",
    "xl",
    "2xl"
  ]);
  function mapResponsive(prop, mapper) {
    if (Array.isArray(prop)) {
      return prop.map((item) => item === null ? null : mapper(item));
    }
    if (isObject(prop)) {
      return Object.keys(prop).reduce((result, key) => {
        result[key] = mapper(prop[key]);
        return result;
      }, {});
    }
    if (prop != null) {
      return mapper(prop);
    }
    return null;
  }
  function arrayToObjectNotation(values, bps = breakpoints2) {
    const result = {};
    values.forEach((value, index) => {
      const key = bps[index];
      if (value == null)
        return;
      result[key] = value;
    });
    return result;
  }

  // node_modules/@chakra-ui/layout/dist/chunk-2OOHT3W5.mjs
  var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
  var Text = forwardRef3(function Text2(props, ref) {
    const styles2 = useStyleConfig("Text", props);
    const { className, align, decoration, casing, ...rest } = omitThemingProps(props);
    const aliasedProps = compact({
      textAlign: props.align,
      textDecoration: props.decoration,
      textTransform: props.casing
    });
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
      chakra.p,
      {
        ref,
        className: cx("chakra-text", props.className),
        ...aliasedProps,
        ...rest,
        __css: styles2
      }
    );
  });
  Text.displayName = "Text";

  // node_modules/@chakra-ui/layout/dist/chunk-ZFQCCYWD.mjs
  var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
  var StackItem = (props) => /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    chakra.div,
    {
      className: "chakra-stack__item",
      ...props,
      __css: {
        display: "inline-block",
        flex: "0 0 auto",
        minWidth: 0,
        ...props["__css"]
      }
    }
  );
  StackItem.displayName = "StackItem";

  // node_modules/@chakra-ui/layout/dist/chunk-5VJV6UNA.mjs
  function getDividerStyles(options) {
    const { spacing: spacing2, direction: direction2 } = options;
    const dividerStyles = {
      column: {
        my: spacing2,
        mx: 0,
        borderLeftWidth: 0,
        borderBottomWidth: "1px"
      },
      "column-reverse": {
        my: spacing2,
        mx: 0,
        borderLeftWidth: 0,
        borderBottomWidth: "1px"
      },
      row: {
        mx: spacing2,
        my: 0,
        borderLeftWidth: "1px",
        borderBottomWidth: 0
      },
      "row-reverse": {
        mx: spacing2,
        my: 0,
        borderLeftWidth: "1px",
        borderBottomWidth: 0
      }
    };
    return {
      "&": mapResponsive(
        direction2,
        (value) => dividerStyles[value]
      )
    };
  }

  // node_modules/@chakra-ui/layout/dist/chunk-ZHMYA64R.mjs
  var import_react64 = __toESM(require_react(), 1);
  var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
  var Stack = forwardRef3((props, ref) => {
    const {
      isInline,
      direction: directionProp,
      align,
      justify,
      spacing: spacing2 = "0.5rem",
      wrap: wrap4,
      children,
      divider,
      className,
      shouldWrapChildren,
      ...rest
    } = props;
    const direction2 = isInline ? "row" : directionProp != null ? directionProp : "column";
    const dividerStyle = (0, import_react64.useMemo)(
      () => getDividerStyles({ spacing: spacing2, direction: direction2 }),
      [spacing2, direction2]
    );
    const hasDivider = !!divider;
    const shouldUseChildren = !shouldWrapChildren && !hasDivider;
    const clones = (0, import_react64.useMemo)(() => {
      const validChildren = getValidChildren(children);
      return shouldUseChildren ? validChildren : validChildren.map((child, index) => {
        const key = typeof child.key !== "undefined" ? child.key : index;
        const isLast = index + 1 === validChildren.length;
        const wrappedChild = /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(StackItem, { children: child }, key);
        const _child = shouldWrapChildren ? wrappedChild : child;
        if (!hasDivider)
          return _child;
        const clonedDivider = (0, import_react64.cloneElement)(
          divider,
          {
            __css: dividerStyle
          }
        );
        const _divider = isLast ? null : clonedDivider;
        return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(import_react64.Fragment, { children: [
          _child,
          _divider
        ] }, key);
      });
    }, [
      divider,
      dividerStyle,
      hasDivider,
      shouldUseChildren,
      shouldWrapChildren,
      children
    ]);
    const _className = cx("chakra-stack", className);
    return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
      chakra.div,
      {
        ref,
        display: "flex",
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction2,
        flexWrap: wrap4,
        gap: hasDivider ? void 0 : spacing2,
        className: _className,
        ...rest,
        children: clones
      }
    );
  });
  Stack.displayName = "Stack";

  // node_modules/@chakra-ui/layout/dist/chunk-NTCQBYKE.mjs
  var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
  var VStack = forwardRef3((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Stack, { align: "center", ...props, direction: "column", ref }));
  VStack.displayName = "VStack";

  // node_modules/@chakra-ui/layout/dist/chunk-3ASUQ6PA.mjs
  var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
  var HStack = forwardRef3((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Stack, { align: "center", ...props, direction: "row", ref }));
  HStack.displayName = "HStack";

  // node_modules/@chakra-ui/layout/dist/chunk-7OLJDQMT.mjs
  var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
  var Heading = forwardRef3(function Heading2(props, ref) {
    const styles2 = useStyleConfig("Heading", props);
    const { className, ...rest } = omitThemingProps(props);
    return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      chakra.h2,
      {
        ref,
        className: cx("chakra-heading", props.className),
        ...rest,
        __css: styles2
      }
    );
  });
  Heading.displayName = "Heading";

  // node_modules/@chakra-ui/layout/dist/chunk-PULVB27S.mjs
  var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
  var Box = chakra("div");
  Box.displayName = "Box";
  var Square = forwardRef3(function Square2(props, ref) {
    const { size: size2, centerContent = true, ...rest } = props;
    const styles2 = centerContent ? { display: "flex", alignItems: "center", justifyContent: "center" } : {};
    return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
      Box,
      {
        ref,
        boxSize: size2,
        __css: {
          ...styles2,
          flexShrink: 0,
          flexGrow: 0
        },
        ...rest
      }
    );
  });
  Square.displayName = "Square";
  var Circle = forwardRef3(function Circle2(props, ref) {
    const { size: size2, ...rest } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(Square, { size: size2, ref, borderRadius: "9999px", ...rest });
  });
  Circle.displayName = "Circle";

  // node_modules/@chakra-ui/layout/dist/chunk-FAWTVNS3.mjs
  var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
  var Center = chakra("div", {
    baseStyle: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }
  });
  Center.displayName = "Center";
  var centerStyles = {
    horizontal: {
      insetStart: "50%",
      transform: "translateX(-50%)"
    },
    vertical: {
      top: "50%",
      transform: "translateY(-50%)"
    },
    both: {
      insetStart: "50%",
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  };
  var AbsoluteCenter = forwardRef3(
    function AbsoluteCenter2(props, ref) {
      const { axis = "both", ...rest } = props;
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        chakra.div,
        {
          ref,
          __css: centerStyles[axis],
          ...rest,
          position: "absolute"
        }
      );
    }
  );

  // node_modules/@chakra-ui/layout/dist/chunk-5MKCW436.mjs
  var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
  var Container2 = forwardRef3(function Container22(props, ref) {
    const { className, centerContent, ...rest } = omitThemingProps(props);
    const styles2 = useStyleConfig("Container", props);
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
      chakra.div,
      {
        ref,
        className: cx("chakra-container", className),
        ...rest,
        __css: {
          ...styles2,
          ...centerContent && {
            display: "flex",
            flexDirection: "column",
            alignItems: "center"
          }
        }
      }
    );
  });
  Container2.displayName = "Container";

  // node_modules/@chakra-ui/layout/dist/chunk-KRPLQIP4.mjs
  var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
  var Flex = forwardRef3(function Flex2(props, ref) {
    const { direction: direction2, align, justify, wrap: wrap4, basis: basis2, grow, shrink, ...rest } = props;
    const styles2 = {
      display: "flex",
      flexDirection: direction2,
      alignItems: align,
      justifyContent: justify,
      flexWrap: wrap4,
      flexBasis: basis2,
      flexGrow: grow,
      flexShrink: shrink
    };
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(chakra.div, { ref, __css: styles2, ...rest });
  });
  Flex.displayName = "Flex";

  // node_modules/@chakra-ui/media-query/dist/chunk-57I6FYPZ.mjs
  var import_react65 = __toESM(require_react(), 1);
  function useMediaQuery(query, options = {}) {
    const { ssr = true, fallback } = options;
    const { getWindow: getWindow2 } = useEnvironment();
    const queries = Array.isArray(query) ? query : [query];
    let fallbackValues = Array.isArray(fallback) ? fallback : [fallback];
    fallbackValues = fallbackValues.filter((v) => v != null);
    const [value, setValue] = (0, import_react65.useState)(() => {
      return queries.map((query2, index) => ({
        media: query2,
        matches: ssr ? !!fallbackValues[index] : getWindow2().matchMedia(query2).matches
      }));
    });
    (0, import_react65.useEffect)(() => {
      const win = getWindow2();
      setValue(
        queries.map((query2) => ({
          media: query2,
          matches: win.matchMedia(query2).matches
        }))
      );
      const mql = queries.map((query2) => win.matchMedia(query2));
      const handler = (evt) => {
        setValue((prev2) => {
          return prev2.slice().map((item) => {
            if (item.media === evt.media)
              return { ...item, matches: evt.matches };
            return item;
          });
        });
      };
      mql.forEach((mql2) => {
        if (typeof mql2.addListener === "function") {
          mql2.addListener(handler);
        } else {
          mql2.addEventListener("change", handler);
        }
      });
      return () => {
        mql.forEach((mql2) => {
          if (typeof mql2.removeListener === "function") {
            mql2.removeListener(handler);
          } else {
            mql2.removeEventListener("change", handler);
          }
        });
      };
    }, [getWindow2]);
    return value.map((item) => item.matches);
  }

  // node_modules/@chakra-ui/media-query/dist/chunk-C53CKZDP.mjs
  function getClosestValue(values, breakpoint, breakpoints3 = breakpoints2) {
    let index = Object.keys(values).indexOf(breakpoint);
    if (index !== -1) {
      return values[breakpoint];
    }
    let stopIndex = breakpoints3.indexOf(breakpoint);
    while (stopIndex >= 0) {
      const key = breakpoints3[stopIndex];
      if (values.hasOwnProperty(key)) {
        index = stopIndex;
        break;
      }
      stopIndex -= 1;
    }
    if (index !== -1) {
      const key = breakpoints3[index];
      return values[key];
    }
    return void 0;
  }

  // node_modules/@chakra-ui/media-query/dist/chunk-6KW5I77S.mjs
  function useBreakpoint(arg) {
    var _a7, _b5;
    const opts = isObject(arg) ? arg : { fallback: arg != null ? arg : "base" };
    const theme3 = useTheme2();
    const breakpoints3 = theme3.__breakpoints.details.map(
      ({ minMaxQuery, breakpoint }) => ({
        breakpoint,
        query: minMaxQuery.replace("@media screen and ", "")
      })
    );
    const fallback = breakpoints3.map((bp) => bp.breakpoint === opts.fallback);
    const values = useMediaQuery(
      breakpoints3.map((bp) => bp.query),
      { fallback, ssr: opts.ssr }
    );
    const index = values.findIndex((value) => value == true);
    return (_b5 = (_a7 = breakpoints3[index]) == null ? void 0 : _a7.breakpoint) != null ? _b5 : opts.fallback;
  }

  // node_modules/@chakra-ui/media-query/dist/chunk-KC77MHL3.mjs
  function useBreakpointValue(values, arg) {
    var _a7;
    const opts = isObject(arg) ? arg : { fallback: arg != null ? arg : "base" };
    const breakpoint = useBreakpoint(opts);
    const theme3 = useTheme2();
    if (!breakpoint)
      return;
    const breakpoints3 = Array.from(((_a7 = theme3.__breakpoints) == null ? void 0 : _a7.keys) || []);
    const obj = Array.isArray(values) ? Object.fromEntries(
      Object.entries(arrayToObjectNotation(values, breakpoints3)).map(
        ([key, value]) => [key, value]
      )
    ) : values;
    return getClosestValue(obj, breakpoint, breakpoints3);
  }

  // node_modules/@chakra-ui/popper/dist/chunk-6WT2JRWX.mjs
  var toVar2 = (value, fallback) => ({
    var: value,
    varRef: fallback ? `var(${value}, ${fallback})` : `var(${value})`
  });
  var cssVars = {
    arrowShadowColor: toVar2("--popper-arrow-shadow-color"),
    arrowSize: toVar2("--popper-arrow-size", "8px"),
    arrowSizeHalf: toVar2("--popper-arrow-size-half"),
    arrowBg: toVar2("--popper-arrow-bg"),
    transformOrigin: toVar2("--popper-transform-origin"),
    arrowOffset: toVar2("--popper-arrow-offset")
  };
  function getBoxShadow(placement) {
    if (placement.includes("top"))
      return `1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
    if (placement.includes("bottom"))
      return `-1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
    if (placement.includes("right"))
      return `-1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
    if (placement.includes("left"))
      return `1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
  }
  var transforms = {
    top: "bottom center",
    "top-start": "bottom left",
    "top-end": "bottom right",
    bottom: "top center",
    "bottom-start": "top left",
    "bottom-end": "top right",
    left: "right center",
    "left-start": "right top",
    "left-end": "right bottom",
    right: "left center",
    "right-start": "left top",
    "right-end": "left bottom"
  };
  var toTransformOrigin = (placement) => transforms[placement];
  var defaultEventListeners = {
    scroll: true,
    resize: true
  };
  function getEventListenerOptions(value) {
    let eventListeners;
    if (typeof value === "object") {
      eventListeners = {
        enabled: true,
        options: { ...defaultEventListeners, ...value }
      };
    } else {
      eventListeners = {
        enabled: value,
        options: defaultEventListeners
      };
    }
    return eventListeners;
  }

  // node_modules/@chakra-ui/popper/dist/chunk-P4KPSAOW.mjs
  var matchWidth = {
    name: "matchWidth",
    enabled: true,
    phase: "beforeWrite",
    requires: ["computeStyles"],
    fn: ({ state: state2 }) => {
      state2.styles.popper.width = `${state2.rects.reference.width}px`;
    },
    effect: ({ state: state2 }) => () => {
      const reference2 = state2.elements.reference;
      state2.elements.popper.style.width = `${reference2.offsetWidth}px`;
    }
  };
  var transformOrigin = {
    name: "transformOrigin",
    enabled: true,
    phase: "write",
    fn: ({ state: state2 }) => {
      setTransformOrigin(state2);
    },
    effect: ({ state: state2 }) => () => {
      setTransformOrigin(state2);
    }
  };
  var setTransformOrigin = (state2) => {
    state2.elements.popper.style.setProperty(
      cssVars.transformOrigin.var,
      toTransformOrigin(state2.placement)
    );
  };
  var positionArrow = {
    name: "positionArrow",
    enabled: true,
    phase: "afterWrite",
    fn: ({ state: state2 }) => {
      setArrowStyles(state2);
    }
  };
  var setArrowStyles = (state2) => {
    var _a7;
    if (!state2.placement)
      return;
    const overrides = getArrowStyle(state2.placement);
    if (((_a7 = state2.elements) == null ? void 0 : _a7.arrow) && overrides) {
      Object.assign(state2.elements.arrow.style, {
        [overrides.property]: overrides.value,
        width: cssVars.arrowSize.varRef,
        height: cssVars.arrowSize.varRef,
        zIndex: -1
      });
      const vars2 = {
        [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2 - 1px)`,
        [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`
      };
      for (const property in vars2) {
        state2.elements.arrow.style.setProperty(property, vars2[property]);
      }
    }
  };
  var getArrowStyle = (placement) => {
    if (placement.startsWith("top")) {
      return { property: "bottom", value: cssVars.arrowOffset.varRef };
    }
    if (placement.startsWith("bottom")) {
      return { property: "top", value: cssVars.arrowOffset.varRef };
    }
    if (placement.startsWith("left")) {
      return { property: "right", value: cssVars.arrowOffset.varRef };
    }
    if (placement.startsWith("right")) {
      return { property: "left", value: cssVars.arrowOffset.varRef };
    }
  };
  var innerArrow = {
    name: "innerArrow",
    enabled: true,
    phase: "main",
    requires: ["arrow"],
    fn: ({ state: state2 }) => {
      setInnerArrowStyles(state2);
    },
    effect: ({ state: state2 }) => () => {
      setInnerArrowStyles(state2);
    }
  };
  var setInnerArrowStyles = (state2) => {
    if (!state2.elements.arrow)
      return;
    const inner = state2.elements.arrow.querySelector(
      "[data-popper-arrow-inner]"
    );
    if (!inner)
      return;
    const boxShadow = getBoxShadow(state2.placement);
    if (boxShadow) {
      inner.style.setProperty("--popper-arrow-default-shadow", boxShadow);
    }
    Object.assign(inner.style, {
      transform: "rotate(45deg)",
      background: cssVars.arrowBg.varRef,
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit",
      boxShadow: `var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))`
    });
  };

  // node_modules/@chakra-ui/popper/dist/chunk-AUJXXV3B.mjs
  var logicals = {
    "start-start": { ltr: "left-start", rtl: "right-start" },
    "start-end": { ltr: "left-end", rtl: "right-end" },
    "end-start": { ltr: "right-start", rtl: "left-start" },
    "end-end": { ltr: "right-end", rtl: "left-end" },
    start: { ltr: "left", rtl: "right" },
    end: { ltr: "right", rtl: "left" }
  };
  var opposites = {
    "auto-start": "auto-end",
    "auto-end": "auto-start",
    "top-start": "top-end",
    "top-end": "top-start",
    "bottom-start": "bottom-end",
    "bottom-end": "bottom-start"
  };
  function getPopperPlacement(placement, dir = "ltr") {
    var _a7, _b5;
    const value = ((_a7 = logicals[placement]) == null ? void 0 : _a7[dir]) || placement;
    if (dir === "ltr")
      return value;
    return (_b5 = opposites[placement]) != null ? _b5 : value;
  }

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto2 = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements2 = /* @__PURE__ */ [].concat(basePlacements, [auto2]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node2) {
    if (node2 == null) {
      return window;
    }
    if (node2.toString() !== "[object Window]") {
      var ownerDocument = node2.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node2;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement3(node2) {
    var OwnElement = getWindow(node2).Element;
    return node2 instanceof OwnElement || node2 instanceof Element;
  }
  function isHTMLElement3(node2) {
    var OwnElement = getWindow(node2).HTMLElement;
    return node2 instanceof OwnElement || node2 instanceof HTMLElement;
  }
  function isShadowRoot(node2) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node2).ShadowRoot;
    return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state2 = _ref.state;
    Object.keys(state2.elements).forEach(function(name) {
      var style = state2.styles[name] || {};
      var attributes = state2.attributes[name] || {};
      var element = state2.elements[name];
      if (!isHTMLElement3(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect2(_ref2) {
    var state2 = _ref2.state;
    var initialStyles = {
      popper: {
        position: state2.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state2.elements.popper.style, initialStyles.popper);
    state2.styles = initialStyles;
    if (state2.elements.arrow) {
      Object.assign(state2.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state2.elements).forEach(function(name) {
        var element = state2.elements[name];
        var attributes = state2.attributes[name] || {};
        var styleProperties = Object.keys(state2.styles.hasOwnProperty(name) ? state2.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement3(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect2,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement3(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement3(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains2(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next2 = child;
      do {
        if (next2 && parent.isSameNode(next2)) {
          return true;
        }
        next2 = next2.parentNode || next2.host;
      } while (next2);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle3(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement3(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement3(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle3(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement3(element)) {
      var elementCss = getComputedStyle3(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement3(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css4 = getComputedStyle3(currentNode);
      if (css4.transform !== "none" || css4.perspective !== "none" || css4.contain === "paint" || ["transform", "perspective"].indexOf(css4.willChange) !== -1 || isFirefox && css4.willChange === "filter" || isFirefox && css4.filter && css4.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle3(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle3(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys3) {
    return keys3.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state2) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
      placement: state2.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state2 = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state2.elements.arrow;
    var popperOffsets2 = state2.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state2.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state2);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset3 = within(min2, center, max2);
    var axisProp = axis;
    state2.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
  }
  function effect3(_ref2) {
    var state2 = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state2.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains2(state2.elements.popper, arrowElement)) {
      return;
    }
    state2.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect3,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position3 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle3(offsetParent).position !== "static" && position3 === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position: position3
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state2 = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state2.placement),
      variation: getVariation(state2.placement),
      popper: state2.elements.popper,
      popperRect: state2.rects.popper,
      gpuAcceleration,
      isFixed: state2.options.strategy === "fixed"
    };
    if (state2.modifiersData.popperOffsets != null) {
      state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state2.modifiersData.popperOffsets,
        position: state2.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state2.modifiersData.arrow != null) {
      state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state2.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
      "data-popper-placement": state2.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect4(_ref) {
    var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state2.elements.popper);
    var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
    if (scroll2) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll2) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect4,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash3 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash3[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash4 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash4[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node2) {
    var win = getWindow(node2);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle3(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent2(element) {
    var _getComputedStyle = getComputedStyle3(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent2(node2) {
    if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
      return node2.ownerDocument.body;
    }
    if (isHTMLElement3(node2) && isScrollParent2(node2)) {
      return node2;
    }
    return getScrollParent2(getParentNode(node2));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list2) {
    var _element$ownerDocumen;
    if (list2 === void 0) {
      list2 = [];
    }
    var scrollParent = getScrollParent2(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent2(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list2.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement3(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle3(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement3(element) ? getOffsetParent(element) : element;
    if (!isElement3(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement3(clippingParent) && contains2(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state2, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state2.rects.popper;
    var element = state2.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement3(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state2.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state2.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset3 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply3 = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset3[axis] * multiply3;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state2, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements2 : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements3 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements3.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements3;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state2, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto2) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state2 = _ref.state, options = _ref.options, name = _ref.name;
    if (state2.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state2.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements3 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto2 ? computeAutoPlacement(state2, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state2.rects.reference;
    var popperRect = state2.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements3[0];
    for (var i = 0; i < placements3.length; i++) {
      var placement = placements3[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state2, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements3.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state2.placement !== firstFittingPlacement) {
      state2.modifiersData[name]._skip = true;
      state2.placement = firstFittingPlacement;
      state2.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state2 = _ref.state, name = _ref.name;
    var referenceRect = state2.rects.reference;
    var popperRect = state2.rects.popper;
    var preventedOffsets = state2.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state2, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state2, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state2.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset3) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
      placement
    })) : offset3, skidding = _ref[0], distance3 = _ref[1];
    skidding = skidding || 0;
    distance3 = (distance3 || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance3,
      y: skidding
    } : {
      x: skidding,
      y: distance3
    };
  }
  function offset(_ref2) {
    var state2 = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements2.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset3);
      return acc;
    }, {});
    var _data$state$placement = data[state2.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state2.modifiersData.popperOffsets != null) {
      state2.modifiersData.popperOffsets.x += x;
      state2.modifiersData.popperOffsets.y += y;
    }
    state2.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state2 = _ref.state, name = _ref.name;
    state2.modifiersData[name] = computeOffsets({
      reference: state2.rects.reference,
      element: state2.rects.popper,
      strategy: "absolute",
      placement: state2.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state2 = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state2, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state2.placement);
    var variation = getVariation(state2.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state2.modifiersData.popperOffsets;
    var referenceRect = state2.rects.reference;
    var popperRect = state2.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
      placement: state2.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset3 = popperOffsets2[mainAxis];
      var min2 = offset3 + overflow[mainSide];
      var max2 = offset3 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state2.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset3 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset3, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset3;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state2.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node2) {
    if (node2 === getWindow(node2) || !isHTMLElement3(node2)) {
      return getWindowScroll(node2);
    } else {
      return getHTMLElementScroll(node2);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement3(offsetParent);
    var offsetParentIsScaled = isHTMLElement3(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll2 = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent2(documentElement)) {
        scroll2 = getNodeScroll(offsetParent);
      }
      if (isHTMLElement3(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll2.scrollLeft - offsets.x,
      y: rect.top + scroll2.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map2 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map2.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map2.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state2 = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state2,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
          cleanupModifierEffects();
          state2.options = Object.assign({}, defaultOptions, state2.options, options2);
          state2.scrollParents = {
            reference: isElement3(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
          state2.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state2.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state2.reset = false;
          state2.placement = state2.options.placement;
          state2.orderedModifiers.forEach(function(modifier) {
            return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state2.orderedModifiers.length; index++) {
            if (state2.reset === true) {
              state2.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state2.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state2 = fn2({
                state: state2,
                options: _options,
                name,
                instance
              }) || state2;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state2);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function(state3) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state3);
        }
      });
      function runModifierEffects() {
        state2.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
          if (typeof effect5 === "function") {
            var cleanupFn = effect5({
              state: state2,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/@chakra-ui/popper/dist/chunk-LUYFNC5G.mjs
  var import_react66 = __toESM(require_react(), 1);
  function usePopper(props = {}) {
    const {
      enabled = true,
      modifiers,
      placement: placementProp = "bottom",
      strategy = "absolute",
      arrowPadding = 8,
      eventListeners = true,
      offset: offset3,
      gutter = 8,
      flip: flip2 = true,
      boundary = "clippingParents",
      preventOverflow: preventOverflow2 = true,
      matchWidth: matchWidth2,
      direction: direction2 = "ltr"
    } = props;
    const reference2 = (0, import_react66.useRef)(null);
    const popper2 = (0, import_react66.useRef)(null);
    const instance = (0, import_react66.useRef)(null);
    const placement = getPopperPlacement(placementProp, direction2);
    const cleanup = (0, import_react66.useRef)(() => {
    });
    const setupPopper = (0, import_react66.useCallback)(() => {
      var _a7;
      if (!enabled || !reference2.current || !popper2.current)
        return;
      (_a7 = cleanup.current) == null ? void 0 : _a7.call(cleanup);
      instance.current = createPopper(reference2.current, popper2.current, {
        placement,
        modifiers: [
          innerArrow,
          positionArrow,
          transformOrigin,
          {
            ...matchWidth,
            enabled: !!matchWidth2
          },
          {
            name: "eventListeners",
            ...getEventListenerOptions(eventListeners)
          },
          {
            name: "arrow",
            options: { padding: arrowPadding }
          },
          {
            name: "offset",
            options: {
              offset: offset3 != null ? offset3 : [0, gutter]
            }
          },
          {
            name: "flip",
            enabled: !!flip2,
            options: { padding: 8 }
          },
          {
            name: "preventOverflow",
            enabled: !!preventOverflow2,
            options: { boundary }
          },
          // allow users override internal modifiers
          ...modifiers != null ? modifiers : []
        ],
        strategy
      });
      instance.current.forceUpdate();
      cleanup.current = instance.current.destroy;
    }, [
      placement,
      enabled,
      modifiers,
      matchWidth2,
      eventListeners,
      arrowPadding,
      offset3,
      gutter,
      flip2,
      preventOverflow2,
      boundary,
      strategy
    ]);
    (0, import_react66.useEffect)(() => {
      return () => {
        var _a7;
        if (!reference2.current && !popper2.current) {
          (_a7 = instance.current) == null ? void 0 : _a7.destroy();
          instance.current = null;
        }
      };
    }, []);
    const referenceRef = (0, import_react66.useCallback)(
      (node2) => {
        reference2.current = node2;
        setupPopper();
      },
      [setupPopper]
    );
    const getReferenceProps = (0, import_react66.useCallback)(
      (props2 = {}, ref = null) => ({
        ...props2,
        ref: mergeRefs(referenceRef, ref)
      }),
      [referenceRef]
    );
    const popperRef = (0, import_react66.useCallback)(
      (node2) => {
        popper2.current = node2;
        setupPopper();
      },
      [setupPopper]
    );
    const getPopperProps = (0, import_react66.useCallback)(
      (props2 = {}, ref = null) => ({
        ...props2,
        ref: mergeRefs(popperRef, ref),
        style: {
          ...props2.style,
          position: strategy,
          minWidth: matchWidth2 ? void 0 : "max-content",
          inset: "0 auto auto 0"
        }
      }),
      [strategy, popperRef, matchWidth2]
    );
    const getArrowProps = (0, import_react66.useCallback)((props2 = {}, ref = null) => {
      const { size: size2, shadowColor, bg, style, ...rest } = props2;
      return {
        ...rest,
        ref,
        "data-popper-arrow": "",
        style: getArrowStyle2(props2)
      };
    }, []);
    const getArrowInnerProps = (0, import_react66.useCallback)(
      (props2 = {}, ref = null) => ({
        ...props2,
        ref,
        "data-popper-arrow-inner": ""
      }),
      []
    );
    return {
      update() {
        var _a7;
        (_a7 = instance.current) == null ? void 0 : _a7.update();
      },
      forceUpdate() {
        var _a7;
        (_a7 = instance.current) == null ? void 0 : _a7.forceUpdate();
      },
      transformOrigin: cssVars.transformOrigin.varRef,
      referenceRef,
      popperRef,
      getPopperProps,
      getArrowProps,
      getArrowInnerProps,
      getReferenceProps
    };
  }
  function getArrowStyle2(props) {
    const { size: size2, shadowColor, bg, style } = props;
    const computedStyle = { ...style, position: "absolute" };
    if (size2) {
      computedStyle["--popper-arrow-size"] = size2;
    }
    if (shadowColor) {
      computedStyle["--popper-arrow-shadow-color"] = shadowColor;
    }
    if (bg) {
      computedStyle["--popper-arrow-bg"] = bg;
    }
    return computedStyle;
  }

  // node_modules/@chakra-ui/react-use-disclosure/dist/index.mjs
  var import_react67 = __toESM(require_react(), 1);
  function useDisclosure2(props = {}) {
    const {
      onClose: onCloseProp,
      onOpen: onOpenProp,
      isOpen: isOpenProp,
      id: idProp
    } = props;
    const handleOpen = useCallbackRef(onOpenProp);
    const handleClose = useCallbackRef(onCloseProp);
    const [isOpenState, setIsOpen] = (0, import_react67.useState)(props.defaultIsOpen || false);
    const isOpen = isOpenProp !== void 0 ? isOpenProp : isOpenState;
    const isControlled = isOpenProp !== void 0;
    const uid = (0, import_react67.useId)();
    const id3 = idProp != null ? idProp : `disclosure-${uid}`;
    const onClose = (0, import_react67.useCallback)(() => {
      if (!isControlled) {
        setIsOpen(false);
      }
      handleClose == null ? void 0 : handleClose();
    }, [isControlled, handleClose]);
    const onOpen = (0, import_react67.useCallback)(() => {
      if (!isControlled) {
        setIsOpen(true);
      }
      handleOpen == null ? void 0 : handleOpen();
    }, [isControlled, handleOpen]);
    const onToggle = (0, import_react67.useCallback)(() => {
      if (isOpen) {
        onClose();
      } else {
        onOpen();
      }
    }, [isOpen, onOpen, onClose]);
    function getButtonProps(props2 = {}) {
      return {
        ...props2,
        "aria-expanded": isOpen,
        "aria-controls": id3,
        onClick(event) {
          var _a7;
          (_a7 = props2.onClick) == null ? void 0 : _a7.call(props2, event);
          onToggle();
        }
      };
    }
    function getDisclosureProps(props2 = {}) {
      return {
        ...props2,
        hidden: !isOpen,
        id: id3
      };
    }
    return {
      isOpen,
      onOpen,
      onClose,
      onToggle,
      isControlled,
      getButtonProps,
      getDisclosureProps
    };
  }

  // node_modules/@chakra-ui/select/dist/chunk-C6OUXMED.mjs
  var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
  var SelectField = forwardRef3(
    function SelectField2(props, ref) {
      const { children, placeholder, className, ...rest } = props;
      return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(
        chakra.select,
        {
          ...rest,
          ref,
          className: cx("chakra-select", className),
          children: [
            placeholder && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("option", { value: "", children: placeholder }),
            children
          ]
        }
      );
    }
  );
  SelectField.displayName = "SelectField";

  // node_modules/@chakra-ui/select/dist/chunk-3RSXBRAN.mjs
  var import_react68 = __toESM(require_react(), 1);
  var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
  function split2(object, keys3) {
    const picked = {};
    const omitted = {};
    for (const [key, value] of Object.entries(object)) {
      if (keys3.includes(key))
        picked[key] = value;
      else
        omitted[key] = value;
    }
    return [picked, omitted];
  }
  var Select = forwardRef3((props, ref) => {
    var _a7;
    const styles2 = useMultiStyleConfig("Select", props);
    const {
      rootProps,
      placeholder,
      icon,
      color: color4,
      height,
      h,
      minH,
      minHeight,
      iconColor,
      iconSize,
      ...rest
    } = omitThemingProps(props);
    const [layoutProps, otherProps] = split2(rest, layoutPropNames);
    const ownProps = useFormControl(otherProps);
    const rootStyles = {
      width: "100%",
      height: "fit-content",
      position: "relative",
      color: color4
    };
    const fieldStyles = {
      paddingEnd: "2rem",
      ...styles2.field,
      _focus: {
        zIndex: "unset",
        ...(_a7 = styles2.field) == null ? void 0 : _a7["_focus"]
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(
      chakra.div,
      {
        className: "chakra-select__wrapper",
        __css: rootStyles,
        ...layoutProps,
        ...rootProps,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
            SelectField,
            {
              ref,
              height: h != null ? h : height,
              minH: minH != null ? minH : minHeight,
              placeholder,
              ...ownProps,
              __css: fieldStyles,
              children: props.children
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
            SelectIcon,
            {
              "data-disabled": dataAttr(ownProps.disabled),
              ...(iconColor || color4) && { color: iconColor || color4 },
              __css: styles2.icon,
              ...iconSize && { fontSize: iconSize },
              children: icon
            }
          )
        ]
      }
    );
  });
  Select.displayName = "Select";
  var DefaultIcon = (props) => /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("svg", { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
    }
  ) });
  var IconWrapper = chakra("div", {
    baseStyle: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)"
    }
  });
  var SelectIcon = (props) => {
    const { children = /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(DefaultIcon, {}), ...rest } = props;
    const clone3 = (0, import_react68.cloneElement)(children, {
      role: "presentation",
      className: "chakra-select__icon",
      focusable: false,
      "aria-hidden": true,
      // force icon to adhere to `IconWrapper` styles
      style: {
        width: "1em",
        height: "1em",
        color: "currentColor"
      }
    });
    return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(IconWrapper, { ...rest, className: "chakra-select__icon-wrapper", children: (0, import_react68.isValidElement)(children) ? clone3 : null });
  };
  SelectIcon.displayName = "SelectIcon";

  // node_modules/@chakra-ui/tooltip/dist/chunk-XRZH7COS.mjs
  var scale2 = {
    exit: {
      scale: 0.85,
      opacity: 0,
      transition: {
        opacity: { duration: 0.15, easings: "easeInOut" },
        scale: { duration: 0.2, easings: "easeInOut" }
      }
    },
    enter: {
      scale: 1,
      opacity: 1,
      transition: {
        opacity: { easings: "easeOut", duration: 0.2 },
        scale: { duration: 0.2, ease: [0.175, 0.885, 0.4, 1.1] }
      }
    }
  };

  // node_modules/@chakra-ui/tooltip/dist/chunk-P7BNLW77.mjs
  var import_react69 = __toESM(require_react(), 1);
  var getDoc = (ref) => {
    var _a7;
    return ((_a7 = ref.current) == null ? void 0 : _a7.ownerDocument) || document;
  };
  var getWin = (ref) => {
    var _a7, _b5;
    return ((_b5 = (_a7 = ref.current) == null ? void 0 : _a7.ownerDocument) == null ? void 0 : _b5.defaultView) || window;
  };
  function useTooltip(props = {}) {
    const {
      openDelay = 0,
      closeDelay = 0,
      closeOnClick = true,
      closeOnMouseDown,
      closeOnScroll,
      closeOnPointerDown = closeOnMouseDown,
      closeOnEsc = true,
      onOpen: onOpenProp,
      onClose: onCloseProp,
      placement,
      id: id3,
      isOpen: isOpenProp,
      defaultIsOpen,
      arrowSize = 10,
      arrowShadowColor,
      arrowPadding,
      modifiers,
      isDisabled,
      gutter,
      offset: offset3,
      direction: direction2,
      ...htmlProps
    } = props;
    const { isOpen, onOpen, onClose } = useDisclosure2({
      isOpen: isOpenProp,
      defaultIsOpen,
      onOpen: onOpenProp,
      onClose: onCloseProp
    });
    const { referenceRef, getPopperProps, getArrowInnerProps, getArrowProps } = usePopper({
      enabled: isOpen,
      placement,
      arrowPadding,
      modifiers,
      gutter,
      offset: offset3,
      direction: direction2
    });
    const uuid = (0, import_react69.useId)();
    const uid = id3 != null ? id3 : uuid;
    const tooltipId = `tooltip-${uid}`;
    const ref = (0, import_react69.useRef)(null);
    const enterTimeout = (0, import_react69.useRef)();
    const clearEnterTimeout = (0, import_react69.useCallback)(() => {
      if (enterTimeout.current) {
        clearTimeout(enterTimeout.current);
        enterTimeout.current = void 0;
      }
    }, []);
    const exitTimeout = (0, import_react69.useRef)();
    const clearExitTimeout = (0, import_react69.useCallback)(() => {
      if (exitTimeout.current) {
        clearTimeout(exitTimeout.current);
        exitTimeout.current = void 0;
      }
    }, []);
    const closeNow = (0, import_react69.useCallback)(() => {
      clearExitTimeout();
      onClose();
    }, [onClose, clearExitTimeout]);
    const dispatchCloseEvent = useCloseEvent(ref, closeNow);
    const openWithDelay = (0, import_react69.useCallback)(() => {
      if (!isDisabled && !enterTimeout.current) {
        if (isOpen)
          dispatchCloseEvent();
        const win = getWin(ref);
        enterTimeout.current = win.setTimeout(onOpen, openDelay);
      }
    }, [dispatchCloseEvent, isDisabled, isOpen, onOpen, openDelay]);
    const closeWithDelay = (0, import_react69.useCallback)(() => {
      clearEnterTimeout();
      const win = getWin(ref);
      exitTimeout.current = win.setTimeout(closeNow, closeDelay);
    }, [closeDelay, closeNow, clearEnterTimeout]);
    const onClick = (0, import_react69.useCallback)(() => {
      if (isOpen && closeOnClick) {
        closeWithDelay();
      }
    }, [closeOnClick, closeWithDelay, isOpen]);
    const onPointerDown = (0, import_react69.useCallback)(() => {
      if (isOpen && closeOnPointerDown) {
        closeWithDelay();
      }
    }, [closeOnPointerDown, closeWithDelay, isOpen]);
    const onKeyDown = (0, import_react69.useCallback)(
      (event) => {
        if (isOpen && event.key === "Escape") {
          closeWithDelay();
        }
      },
      [isOpen, closeWithDelay]
    );
    useEventListener(
      () => getDoc(ref),
      "keydown",
      closeOnEsc ? onKeyDown : void 0
    );
    useEventListener(
      () => {
        if (!closeOnScroll)
          return null;
        const node2 = ref.current;
        if (!node2)
          return null;
        const scrollParent = getScrollParent(node2);
        return scrollParent.localName === "body" ? getWin(ref) : scrollParent;
      },
      "scroll",
      () => {
        if (isOpen && closeOnScroll) {
          closeNow();
        }
      },
      { passive: true, capture: true }
    );
    (0, import_react69.useEffect)(() => {
      if (!isDisabled)
        return;
      clearEnterTimeout();
      if (isOpen)
        onClose();
    }, [isDisabled, isOpen, onClose, clearEnterTimeout]);
    (0, import_react69.useEffect)(() => {
      return () => {
        clearEnterTimeout();
        clearExitTimeout();
      };
    }, [clearEnterTimeout, clearExitTimeout]);
    useEventListener(() => ref.current, "pointerleave", closeWithDelay);
    const getTriggerProps = (0, import_react69.useCallback)(
      (props2 = {}, _ref = null) => {
        const triggerProps = {
          ...props2,
          ref: mergeRefs(ref, _ref, referenceRef),
          onPointerEnter: callAllHandlers(props2.onPointerEnter, (e3) => {
            if (e3.pointerType === "touch")
              return;
            openWithDelay();
          }),
          onClick: callAllHandlers(props2.onClick, onClick),
          onPointerDown: callAllHandlers(props2.onPointerDown, onPointerDown),
          onFocus: callAllHandlers(props2.onFocus, openWithDelay),
          onBlur: callAllHandlers(props2.onBlur, closeWithDelay),
          "aria-describedby": isOpen ? tooltipId : void 0
        };
        return triggerProps;
      },
      [
        openWithDelay,
        closeWithDelay,
        onPointerDown,
        isOpen,
        tooltipId,
        onClick,
        referenceRef
      ]
    );
    const getTooltipPositionerProps = (0, import_react69.useCallback)(
      (props2 = {}, forwardedRef = null) => getPopperProps(
        {
          ...props2,
          style: {
            ...props2.style,
            [cssVars.arrowSize.var]: arrowSize ? `${arrowSize}px` : void 0,
            [cssVars.arrowShadowColor.var]: arrowShadowColor
          }
        },
        forwardedRef
      ),
      [getPopperProps, arrowSize, arrowShadowColor]
    );
    const getTooltipProps = (0, import_react69.useCallback)(
      (props2 = {}, ref2 = null) => {
        const styles2 = {
          ...props2.style,
          position: "relative",
          transformOrigin: cssVars.transformOrigin.varRef
        };
        return {
          ref: ref2,
          ...htmlProps,
          ...props2,
          id: tooltipId,
          role: "tooltip",
          style: styles2
        };
      },
      [htmlProps, tooltipId]
    );
    return {
      isOpen,
      show: openWithDelay,
      hide: closeWithDelay,
      getTriggerProps,
      getTooltipProps,
      getTooltipPositionerProps,
      getArrowProps,
      getArrowInnerProps
    };
  }
  var closeEventName = "chakra-ui:close-tooltip";
  function useCloseEvent(ref, close2) {
    (0, import_react69.useEffect)(() => {
      const doc = getDoc(ref);
      doc.addEventListener(closeEventName, close2);
      return () => doc.removeEventListener(closeEventName, close2);
    }, [close2, ref]);
    return () => {
      const doc = getDoc(ref);
      const win = getWin(ref);
      doc.dispatchEvent(new win.CustomEvent(closeEventName));
    };
  }

  // node_modules/@chakra-ui/tooltip/dist/chunk-TK6VMDNP.mjs
  var import_react70 = __toESM(require_react(), 1);
  var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
  function omit3(object, keysToOmit = []) {
    const clone3 = Object.assign({}, object);
    for (const key of keysToOmit) {
      if (key in clone3) {
        delete clone3[key];
      }
    }
    return clone3;
  }
  function pick3(object, keysToPick) {
    const result = {};
    for (const key of keysToPick) {
      if (key in object) {
        result[key] = object[key];
      }
    }
    return result;
  }
  var MotionDiv = chakra(motion.div);
  var Tooltip = forwardRef3((props, ref) => {
    var _a7, _b5;
    const styles2 = useStyleConfig("Tooltip", props);
    const ownProps = omitThemingProps(props);
    const theme3 = useTheme2();
    const {
      children,
      label,
      shouldWrapChildren,
      "aria-label": ariaLabel,
      hasArrow,
      bg,
      portalProps,
      background: background2,
      backgroundColor,
      bgColor,
      motionProps,
      ...rest
    } = ownProps;
    const userDefinedBg = (_b5 = (_a7 = background2 != null ? background2 : backgroundColor) != null ? _a7 : bg) != null ? _b5 : bgColor;
    if (userDefinedBg) {
      styles2.bg = userDefinedBg;
      const bgVar = getCSSVar(theme3, "colors", userDefinedBg);
      styles2[cssVars.arrowBg.var] = bgVar;
    }
    const tooltip = useTooltip({ ...rest, direction: theme3.direction });
    const shouldWrap = typeof children === "string" || shouldWrapChildren;
    let trigger;
    if (shouldWrap) {
      trigger = /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
        chakra.span,
        {
          display: "inline-block",
          tabIndex: 0,
          ...tooltip.getTriggerProps(),
          children
        }
      );
    } else {
      const child = import_react70.Children.only(children);
      trigger = (0, import_react70.cloneElement)(
        child,
        tooltip.getTriggerProps(child.props, child.ref)
      );
    }
    const hasAriaLabel = !!ariaLabel;
    const _tooltipProps = tooltip.getTooltipProps({}, ref);
    const tooltipProps = hasAriaLabel ? omit3(_tooltipProps, ["role", "id"]) : _tooltipProps;
    const srOnlyProps = pick3(_tooltipProps, ["role", "id"]);
    if (!label) {
      return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(import_jsx_runtime42.Fragment, { children });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(import_jsx_runtime42.Fragment, { children: [
      trigger,
      /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(AnimatePresence, { children: tooltip.isOpen && /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(Portal, { ...portalProps, children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
        chakra.div,
        {
          ...tooltip.getTooltipPositionerProps(),
          __css: {
            zIndex: styles2.zIndex,
            pointerEvents: "none"
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(
            MotionDiv,
            {
              variants: scale2,
              initial: "exit",
              animate: "enter",
              exit: "exit",
              ...motionProps,
              ...tooltipProps,
              __css: styles2,
              children: [
                label,
                hasAriaLabel && /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(chakra.span, { srOnly: true, ...srOnlyProps, children: ariaLabel }),
                hasArrow && /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
                  chakra.div,
                  {
                    "data-popper-arrow": true,
                    className: "chakra-tooltip__arrow-wrapper",
                    children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
                      chakra.div,
                      {
                        "data-popper-arrow-inner": true,
                        className: "chakra-tooltip__arrow",
                        __css: { bg: styles2.bg }
                      }
                    )
                  }
                )
              ]
            }
          )
        }
      ) }) })
    ] });
  });
  Tooltip.displayName = "Tooltip";

  // src/app/views/calculator-app-view.tsx
  var import_react129 = __toESM(require_react());

  // node_modules/jotai/esm/vanilla.mjs
  var import_meta = {};
  var keyCount = 0;
  function atom(read2, write2) {
    const key = `atom${++keyCount}`;
    const config2 = {
      toString: () => key
    };
    if (typeof read2 === "function") {
      config2.read = read2;
    } else {
      config2.init = read2;
      config2.read = defaultRead;
      config2.write = defaultWrite;
    }
    if (write2) {
      config2.write = write2;
    }
    return config2;
  }
  function defaultRead(get3) {
    return get3(this);
  }
  function defaultWrite(get3, set, arg) {
    return set(
      this,
      typeof arg === "function" ? arg(get3(this)) : arg
    );
  }
  var isSelfAtom = (atom2, a) => atom2.unstable_is ? atom2.unstable_is(a) : a === atom2;
  var hasInitialValue = (atom2) => "init" in atom2;
  var isActuallyWritableAtom = (atom2) => !!atom2.write;
  var cancelPromiseMap = /* @__PURE__ */ new WeakMap();
  var registerCancelPromise = (promise, cancel) => {
    cancelPromiseMap.set(promise, cancel);
    promise.catch(() => {
    }).finally(() => cancelPromiseMap.delete(promise));
  };
  var cancelPromise = (promise, next2) => {
    const cancel = cancelPromiseMap.get(promise);
    if (cancel) {
      cancelPromiseMap.delete(promise);
      cancel(next2);
    }
  };
  var resolvePromise = (promise, value) => {
    promise.status = "fulfilled";
    promise.value = value;
  };
  var rejectPromise = (promise, e3) => {
    promise.status = "rejected";
    promise.reason = e3;
  };
  var isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === "function";
  var isEqualAtomValue = (a, b) => !!a && "v" in a && "v" in b && Object.is(a.v, b.v);
  var isEqualAtomError = (a, b) => !!a && "e" in a && "e" in b && Object.is(a.e, b.e);
  var hasPromiseAtomValue = (a) => !!a && "v" in a && a.v instanceof Promise;
  var isEqualPromiseAtomValue = (a, b) => "v" in a && "v" in b && a.v.orig && a.v.orig === b.v.orig;
  var returnAtomValue = (atomState) => {
    if ("e" in atomState) {
      throw atomState.e;
    }
    return atomState.v;
  };
  var createStore2 = () => {
    const atomStateMap = /* @__PURE__ */ new WeakMap();
    const mountedMap = /* @__PURE__ */ new WeakMap();
    const pendingStack = [];
    const pendingMap = /* @__PURE__ */ new WeakMap();
    let storeListenersRev2;
    let mountedAtoms;
    if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
      storeListenersRev2 = /* @__PURE__ */ new Set();
      mountedAtoms = /* @__PURE__ */ new Set();
    }
    const getAtomState = (atom2) => atomStateMap.get(atom2);
    const addPendingDependent = (atom2, atomState) => {
      atomState.d.forEach((_, a) => {
        var _a7;
        if (!pendingMap.has(a)) {
          const aState = getAtomState(a);
          (_a7 = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a7.add(a);
          pendingMap.set(a, [aState, /* @__PURE__ */ new Set()]);
          if (aState) {
            addPendingDependent(a, aState);
          }
        }
        pendingMap.get(a)[1].add(atom2);
      });
    };
    const setAtomState = (atom2, atomState) => {
      var _a7;
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        Object.freeze(atomState);
      }
      const prevAtomState = getAtomState(atom2);
      atomStateMap.set(atom2, atomState);
      if (!pendingMap.has(atom2)) {
        (_a7 = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a7.add(atom2);
        pendingMap.set(atom2, [prevAtomState, /* @__PURE__ */ new Set()]);
        addPendingDependent(atom2, atomState);
      }
      if (hasPromiseAtomValue(prevAtomState)) {
        const next2 = "v" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);
        if (prevAtomState.v !== next2) {
          cancelPromise(prevAtomState.v, next2);
        }
      }
    };
    const updateDependencies = (atom2, nextAtomState, nextDependencies, keepPreviousDependencies) => {
      const dependencies = new Map(
        keepPreviousDependencies ? nextAtomState.d : null
      );
      let changed = false;
      nextDependencies.forEach((aState, a) => {
        if (!aState && isSelfAtom(atom2, a)) {
          aState = nextAtomState;
        }
        if (aState) {
          dependencies.set(a, aState);
          if (nextAtomState.d.get(a) !== aState) {
            changed = true;
          }
        } else if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
          console.warn("[Bug] atom state not found");
        }
      });
      if (changed || nextAtomState.d.size !== dependencies.size) {
        nextAtomState.d = dependencies;
      }
    };
    const setAtomValue = (atom2, value, nextDependencies, keepPreviousDependencies) => {
      const prevAtomState = getAtomState(atom2);
      const nextAtomState = {
        d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
        v: value
      };
      if (nextDependencies) {
        updateDependencies(
          atom2,
          nextAtomState,
          nextDependencies,
          keepPreviousDependencies
        );
      }
      if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
        return prevAtomState;
      }
      if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {
        if (prevAtomState.d === nextAtomState.d) {
          return prevAtomState;
        } else {
          nextAtomState.v = prevAtomState.v;
        }
      }
      setAtomState(atom2, nextAtomState);
      return nextAtomState;
    };
    const setAtomValueOrPromise = (atom2, valueOrPromise, nextDependencies, abortPromise) => {
      if (isPromiseLike(valueOrPromise)) {
        let continuePromise;
        const updatePromiseDependencies = () => {
          const prevAtomState = getAtomState(atom2);
          if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {
            return;
          }
          const nextAtomState = setAtomValue(
            atom2,
            promise,
            nextDependencies
          );
          if (mountedMap.has(atom2) && prevAtomState.d !== nextAtomState.d) {
            mountDependencies(atom2, nextAtomState, prevAtomState.d);
          }
        };
        const promise = new Promise((resolve, reject) => {
          let settled = false;
          valueOrPromise.then(
            (v) => {
              if (!settled) {
                settled = true;
                resolvePromise(promise, v);
                resolve(v);
                updatePromiseDependencies();
              }
            },
            (e3) => {
              if (!settled) {
                settled = true;
                rejectPromise(promise, e3);
                reject(e3);
                updatePromiseDependencies();
              }
            }
          );
          continuePromise = (next2) => {
            if (!settled) {
              settled = true;
              next2.then(
                (v) => resolvePromise(promise, v),
                (e3) => rejectPromise(promise, e3)
              );
              resolve(next2);
            }
          };
        });
        promise.orig = valueOrPromise;
        promise.status = "pending";
        registerCancelPromise(promise, (next2) => {
          if (next2) {
            continuePromise(next2);
          }
          abortPromise == null ? void 0 : abortPromise();
        });
        return setAtomValue(atom2, promise, nextDependencies, true);
      }
      return setAtomValue(atom2, valueOrPromise, nextDependencies);
    };
    const setAtomError = (atom2, error2, nextDependencies) => {
      const prevAtomState = getAtomState(atom2);
      const nextAtomState = {
        d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
        e: error2
      };
      if (nextDependencies) {
        updateDependencies(atom2, nextAtomState, nextDependencies);
      }
      if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
        return prevAtomState;
      }
      setAtomState(atom2, nextAtomState);
      return nextAtomState;
    };
    const readAtomState = (atom2, force) => {
      const atomState = getAtomState(atom2);
      if (!force && atomState) {
        if (mountedMap.has(atom2)) {
          return atomState;
        }
        if (Array.from(atomState.d).every(([a, s2]) => {
          if (a === atom2) {
            return true;
          }
          const aState = readAtomState(a);
          return aState === s2 || isEqualAtomValue(aState, s2);
        })) {
          return atomState;
        }
      }
      const nextDependencies = /* @__PURE__ */ new Map();
      let isSync = true;
      const getter = (a) => {
        if (isSelfAtom(atom2, a)) {
          const aState2 = getAtomState(a);
          if (aState2) {
            nextDependencies.set(a, aState2);
            return returnAtomValue(aState2);
          }
          if (hasInitialValue(a)) {
            nextDependencies.set(a, void 0);
            return a.init;
          }
          throw new Error("no atom init");
        }
        const aState = readAtomState(a);
        nextDependencies.set(a, aState);
        return returnAtomValue(aState);
      };
      let controller;
      let setSelf;
      const options = {
        get signal() {
          if (!controller) {
            controller = new AbortController();
          }
          return controller.signal;
        },
        get setSelf() {
          if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
            console.warn("setSelf function cannot be used with read-only atom");
          }
          if (!setSelf && isActuallyWritableAtom(atom2)) {
            setSelf = (...args) => {
              if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production" && isSync) {
                console.warn("setSelf function cannot be called in sync");
              }
              if (!isSync) {
                return writeAtom(atom2, ...args);
              }
            };
          }
          return setSelf;
        }
      };
      try {
        const valueOrPromise = atom2.read(getter, options);
        return setAtomValueOrPromise(
          atom2,
          valueOrPromise,
          nextDependencies,
          () => controller == null ? void 0 : controller.abort()
        );
      } catch (error2) {
        return setAtomError(atom2, error2, nextDependencies);
      } finally {
        isSync = false;
      }
    };
    const readAtom = (atom2) => returnAtomValue(readAtomState(atom2));
    const addAtom = (atom2) => {
      let mounted = mountedMap.get(atom2);
      if (!mounted) {
        mounted = mountAtom(atom2);
      }
      return mounted;
    };
    const canUnmountAtom = (atom2, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom2));
    const delAtom = (atom2) => {
      const mounted = mountedMap.get(atom2);
      if (mounted && canUnmountAtom(atom2, mounted)) {
        unmountAtom(atom2);
      }
    };
    const recomputeDependents = (atom2) => {
      const getDependents = (a) => {
        var _a7, _b5;
        const dependents = new Set((_a7 = mountedMap.get(a)) == null ? void 0 : _a7.t);
        (_b5 = pendingMap.get(a)) == null ? void 0 : _b5[1].forEach((dependent) => {
          dependents.add(dependent);
        });
        return dependents;
      };
      const topsortedAtoms = new Array();
      const markedAtoms = /* @__PURE__ */ new Set();
      const visit2 = (n2) => {
        if (markedAtoms.has(n2)) {
          return;
        }
        markedAtoms.add(n2);
        for (const m of getDependents(n2)) {
          if (n2 !== m) {
            visit2(m);
          }
        }
        topsortedAtoms.push(n2);
      };
      visit2(atom2);
      const changedAtoms = /* @__PURE__ */ new Set([atom2]);
      for (let i = topsortedAtoms.length - 1; i >= 0; --i) {
        const a = topsortedAtoms[i];
        const prevAtomState = getAtomState(a);
        if (!prevAtomState) {
          continue;
        }
        let hasChangedDeps = false;
        for (const dep of prevAtomState.d.keys()) {
          if (dep !== a && changedAtoms.has(dep)) {
            hasChangedDeps = true;
            break;
          }
        }
        if (hasChangedDeps) {
          const nextAtomState = readAtomState(a, true);
          if (!isEqualAtomValue(prevAtomState, nextAtomState)) {
            changedAtoms.add(a);
          }
        }
      }
    };
    const writeAtomState = (atom2, ...args) => {
      let isSync = true;
      const getter = (a) => returnAtomValue(readAtomState(a));
      const setter = (a, ...args2) => {
        let r3;
        if (isSelfAtom(atom2, a)) {
          if (!hasInitialValue(a)) {
            throw new Error("atom not writable");
          }
          const prevAtomState = getAtomState(a);
          const nextAtomState = setAtomValueOrPromise(a, args2[0]);
          if (!isEqualAtomValue(prevAtomState, nextAtomState)) {
            recomputeDependents(a);
          }
        } else {
          r3 = writeAtomState(a, ...args2);
        }
        if (!isSync) {
          const flushed = flushPending([a]);
          if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
            storeListenersRev2.forEach(
              (l2) => l2({ type: "async-write", flushed })
            );
          }
        }
        return r3;
      };
      const result = atom2.write(getter, setter, ...args);
      isSync = false;
      return result;
    };
    const writeAtom = (atom2, ...args) => {
      pendingStack.push(/* @__PURE__ */ new Set([atom2]));
      const result = writeAtomState(atom2, ...args);
      const flushed = flushPending(pendingStack.pop());
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        storeListenersRev2.forEach((l2) => l2({ type: "write", flushed }));
      }
      return result;
    };
    const mountAtom = (atom2, initialDependent, onMountQueue) => {
      var _a7;
      const queue = onMountQueue || [];
      (_a7 = getAtomState(atom2)) == null ? void 0 : _a7.d.forEach((_, a) => {
        const aMounted = mountedMap.get(a);
        if (aMounted) {
          aMounted.t.add(atom2);
        } else {
          if (a !== atom2) {
            mountAtom(a, atom2, queue);
          }
        }
      });
      readAtomState(atom2);
      const mounted = {
        t: new Set(initialDependent && [initialDependent]),
        l: /* @__PURE__ */ new Set()
      };
      mountedMap.set(atom2, mounted);
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        mountedAtoms.add(atom2);
      }
      if (isActuallyWritableAtom(atom2) && atom2.onMount) {
        const { onMount } = atom2;
        queue.push(() => {
          const onUnmount = onMount((...args) => writeAtom(atom2, ...args));
          if (onUnmount) {
            mounted.u = onUnmount;
          }
        });
      }
      if (!onMountQueue) {
        queue.forEach((f) => f());
      }
      return mounted;
    };
    const unmountAtom = (atom2) => {
      var _a7;
      const onUnmount = (_a7 = mountedMap.get(atom2)) == null ? void 0 : _a7.u;
      if (onUnmount) {
        onUnmount();
      }
      mountedMap.delete(atom2);
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        mountedAtoms.delete(atom2);
      }
      const atomState = getAtomState(atom2);
      if (atomState) {
        if (hasPromiseAtomValue(atomState)) {
          cancelPromise(atomState.v);
        }
        atomState.d.forEach((_, a) => {
          if (a !== atom2) {
            const mounted = mountedMap.get(a);
            if (mounted) {
              mounted.t.delete(atom2);
              if (canUnmountAtom(a, mounted)) {
                unmountAtom(a);
              }
            }
          }
        });
      } else if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn("[Bug] could not find atom state to unmount", atom2);
      }
    };
    const mountDependencies = (atom2, atomState, prevDependencies) => {
      const depSet = new Set(atomState.d.keys());
      const maybeUnmountAtomSet = /* @__PURE__ */ new Set();
      prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {
        if (depSet.has(a)) {
          depSet.delete(a);
          return;
        }
        maybeUnmountAtomSet.add(a);
        const mounted = mountedMap.get(a);
        if (mounted) {
          mounted.t.delete(atom2);
        }
      });
      depSet.forEach((a) => {
        const mounted = mountedMap.get(a);
        if (mounted) {
          mounted.t.add(atom2);
        } else if (mountedMap.has(atom2)) {
          mountAtom(a, atom2);
        }
      });
      maybeUnmountAtomSet.forEach((a) => {
        const mounted = mountedMap.get(a);
        if (mounted && canUnmountAtom(a, mounted)) {
          unmountAtom(a);
        }
      });
    };
    const flushPending = (pendingAtoms) => {
      let flushed;
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        flushed = /* @__PURE__ */ new Set();
      }
      const pending = [];
      const collectPending = (pendingAtom) => {
        var _a7;
        if (!pendingMap.has(pendingAtom)) {
          return;
        }
        const [prevAtomState, dependents] = pendingMap.get(pendingAtom);
        pendingMap.delete(pendingAtom);
        pending.push([pendingAtom, prevAtomState]);
        dependents.forEach(collectPending);
        (_a7 = getAtomState(pendingAtom)) == null ? void 0 : _a7.d.forEach((_, a) => collectPending(a));
      };
      pendingAtoms.forEach(collectPending);
      pending.forEach(([atom2, prevAtomState]) => {
        const atomState = getAtomState(atom2);
        if (!atomState) {
          if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
            console.warn("[Bug] no atom state to flush");
          }
          return;
        }
        if (atomState !== prevAtomState) {
          const mounted = mountedMap.get(atom2);
          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
            mountDependencies(atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
          }
          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.
          // Maybe we could `mountDependencies` in `setAtomState`?
          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {
            mounted.l.forEach((listener) => listener());
            if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
              flushed.add(atom2);
            }
          }
        }
      });
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        return flushed;
      }
    };
    const subscribeAtom = (atom2, listener) => {
      const mounted = addAtom(atom2);
      const flushed = flushPending([atom2]);
      const listeners = mounted.l;
      listeners.add(listener);
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        storeListenersRev2.forEach(
          (l2) => l2({ type: "sub", flushed })
        );
      }
      return () => {
        listeners.delete(listener);
        delAtom(atom2);
        if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
          storeListenersRev2.forEach((l2) => l2({ type: "unsub" }));
        }
      };
    };
    if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
      return {
        get: readAtom,
        set: writeAtom,
        sub: subscribeAtom,
        // store dev methods (these are tentative and subject to change without notice)
        dev_subscribe_store: (l2, rev) => {
          if (rev !== 2) {
            throw new Error("The current StoreListener revision is 2.");
          }
          storeListenersRev2.add(l2);
          return () => {
            storeListenersRev2.delete(l2);
          };
        },
        dev_get_mounted_atoms: () => mountedAtoms.values(),
        dev_get_atom_state: (a) => atomStateMap.get(a),
        dev_get_mounted: (a) => mountedMap.get(a),
        dev_restore_atoms: (values) => {
          pendingStack.push(/* @__PURE__ */ new Set());
          for (const [atom2, valueOrPromise] of values) {
            if (hasInitialValue(atom2)) {
              setAtomValueOrPromise(atom2, valueOrPromise);
              recomputeDependents(atom2);
            }
          }
          const flushed = flushPending(pendingStack.pop());
          storeListenersRev2.forEach(
            (l2) => l2({ type: "restore", flushed })
          );
        }
      };
    }
    return {
      get: readAtom,
      set: writeAtom,
      sub: subscribeAtom
    };
  };
  var defaultStore;
  if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
    if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === "number") {
      ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;
    } else {
      globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;
    }
  }
  var getDefaultStore = () => {
    if (!defaultStore) {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {
        console.warn(
          "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
        );
      }
      defaultStore = createStore2();
    }
    return defaultStore;
  };

  // node_modules/jotai/esm/react.mjs
  var import_react71 = __toESM(require_react(), 1);
  var import_meta2 = {};
  var StoreContext = (0, import_react71.createContext)(void 0);
  var useStore = (options) => {
    const store = (0, import_react71.useContext)(StoreContext);
    return (options == null ? void 0 : options.store) || store || getDefaultStore();
  };
  var isPromiseLike2 = (x) => typeof (x == null ? void 0 : x.then) === "function";
  var use = import_react71.default.use || ((promise) => {
    if (promise.status === "pending") {
      throw promise;
    } else if (promise.status === "fulfilled") {
      return promise.value;
    } else if (promise.status === "rejected") {
      throw promise.reason;
    } else {
      promise.status = "pending";
      promise.then(
        (v) => {
          promise.status = "fulfilled";
          promise.value = v;
        },
        (e3) => {
          promise.status = "rejected";
          promise.reason = e3;
        }
      );
      throw promise;
    }
  });
  function useAtomValue(atom2, options) {
    const store = useStore(options);
    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, import_react71.useReducer)(
      (prev2) => {
        const nextValue = store.get(atom2);
        if (Object.is(prev2[0], nextValue) && prev2[1] === store && prev2[2] === atom2) {
          return prev2;
        }
        return [nextValue, store, atom2];
      },
      void 0,
      () => [store.get(atom2), store, atom2]
    );
    let value = valueFromReducer;
    if (storeFromReducer !== store || atomFromReducer !== atom2) {
      rerender();
      value = store.get(atom2);
    }
    const delay2 = options == null ? void 0 : options.delay;
    (0, import_react71.useEffect)(() => {
      const unsub = store.sub(atom2, () => {
        if (typeof delay2 === "number") {
          setTimeout(rerender, delay2);
          return;
        }
        rerender();
      });
      rerender();
      return unsub;
    }, [store, atom2, delay2]);
    (0, import_react71.useDebugValue)(value);
    return isPromiseLike2(value) ? use(value) : value;
  }
  function useSetAtom(atom2, options) {
    const store = useStore(options);
    const setAtom = (0, import_react71.useCallback)(
      (...args) => {
        if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && !("write" in atom2)) {
          throw new Error("not writable atom");
        }
        return store.set(atom2, ...args);
      },
      [store, atom2]
    );
    return setAtom;
  }
  function useAtom(atom2, options) {
    return [
      useAtomValue(atom2, options),
      // We do wrong type assertion here, which results in throwing an error.
      useSetAtom(atom2, options)
    ];
  }

  // src/lib/units.ts
  var WATT_HOUR_PER_BTU = 0.293071;
  var KWH_PER_BTU = WATT_HOUR_PER_BTU / 1e3;
  var CUBIC_METER_PER_CCF = 2.83;
  var BTU_PER_CCF_NATURAL_GAS = 103700;
  function btusToKwh(btu) {
    return btu * KWH_PER_BTU;
  }
  function kWToBtusPerHour(kW) {
    return kW / KWH_PER_BTU;
  }
  function fahrenheitToCelcius(fahrenheit) {
    return (fahrenheit - 32) / 1.8;
  }
  function celciusToFahrenheit(celcius) {
    return celcius * 1.8 + 32;
  }
  function metersToFeet(meters) {
    return meters * 3.28084;
  }

  // src/app/app-state/config-state.ts
  var heatingSetPointCAtom = atom(20);
  var coolingSetPointCAtom = atom(26);
  var auxSwitchoverTempCAtom = atom(-16);
  var heatingSetPointFAtom = atom(
    (get3) => celciusToFahrenheit(get3(heatingSetPointCAtom))
  );
  var coolingSetPointFAtom = atom(
    (get3) => celciusToFahrenheit(get3(coolingSetPointCAtom))
  );
  var auxSwitchoverTempFAtom = atom(
    (get3) => celciusToFahrenheit(get3(auxSwitchoverTempCAtom))
  );
  var floorSpaceSqFtAtom = atom(null);
  var postalCodeAtom = atom(null);
  var statusQuoFurnaceFuelAtom = atom("gas");
  var heatpumpBackupFuelAtom = atom("electric");
  var heatpumpInstallCostAtom = atom(17e3);
  var gasFurnaceInstallCostAtom = atom(6500);
  var airConditionerInstallCostAtom = atom(6e3);
  var electricFurnaceInstallCostAtom = atom(6e3);
  var hasOtherGasAppliancesAtom = atom(true);
  var welcomeFormHasBeenSubmitAtom = atom(false);

  // src/app/views/welcome-screen-view.tsx
  var import_react78 = __toESM(require_react());

  // node_modules/luxon/src/errors.js
  var LuxonError = class extends Error {
  };
  var InvalidDateTimeError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  };
  var InvalidIntervalError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  };
  var InvalidDurationError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  };
  var ConflictingSpecificationError = class extends LuxonError {
  };
  var InvalidUnitError = class extends LuxonError {
    constructor(unit2) {
      super(`Invalid unit ${unit2}`);
    }
  };
  var InvalidArgumentError = class extends LuxonError {
  };
  var ZoneIsAbstractError = class extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  };

  // node_modules/luxon/src/impl/formats.js
  var n = "numeric";
  var s = "short";
  var l = "long";
  var DATE_SHORT = {
    year: n,
    month: n,
    day: n
  };
  var DATE_MED = {
    year: n,
    month: s,
    day: n
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s
  };
  var DATE_FULL = {
    year: n,
    month: l,
    day: n
  };
  var DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l
  };
  var TIME_SIMPLE = {
    hour: n,
    minute: n
  };
  var TIME_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };
  var TIME_24_SIMPLE = {
    hour: n,
    minute: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: s
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: l
  };
  var DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s,
    hour: n,
    minute: n
  };
  var DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    timeZoneName: s
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    timeZoneName: l
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };

  // node_modules/luxon/src/zone.js
  var Zone = class {
    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get type() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */
    get name() {
      throw new ZoneIsAbstractError();
    }
    get ianaName() {
      return this.name;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */
    get isUniversal() {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns the offset's value as a string
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format2) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(ts) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return whether this Zone is equal to another zone
     * @abstract
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return whether this Zone is valid.
     * @abstract
     * @type {boolean}
     */
    get isValid() {
      throw new ZoneIsAbstractError();
    }
  };

  // node_modules/luxon/src/zones/systemZone.js
  var singleton = null;
  var SystemZone = class _SystemZone extends Zone {
    /**
     * Get a singleton instance of the local zone
     * @return {SystemZone}
     */
    static get instance() {
      if (singleton === null) {
        singleton = new _SystemZone();
      }
      return singleton;
    }
    /** @override **/
    get type() {
      return "system";
    }
    /** @override **/
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName(ts, { format: format2, locale: locale3 }) {
      return parseZoneInfo(ts, format2, locale3);
    }
    /** @override **/
    formatOffset(ts, format2) {
      return formatOffset(this.offset(ts), format2);
    }
    /** @override **/
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    /** @override **/
    equals(otherZone) {
      return otherZone.type === "system";
    }
    /** @override **/
    get isValid() {
      return true;
    }
  };

  // node_modules/luxon/src/zones/IANAZone.js
  var dtfCache = {};
  function makeDTF(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
    }
    return dtfCache[zone];
  }
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  function hackyOffset(dtf, date2) {
    const formatted = dtf.format(date2).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  }
  function partsOffset(dtf, date2) {
    const formatted = dtf.formatToParts(date2);
    const filled = [];
    for (let i = 0; i < formatted.length; i++) {
      const { type, value } = formatted[i];
      const pos = typeToPos[type];
      if (type === "era") {
        filled[pos] = value;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value, 10);
      }
    }
    return filled;
  }
  var ianaZoneCache = {};
  var IANAZone = class _IANAZone extends Zone {
    /**
     * @param {string} name - Zone name
     * @return {IANAZone}
     */
    static create(name) {
      if (!ianaZoneCache[name]) {
        ianaZoneCache[name] = new _IANAZone(name);
      }
      return ianaZoneCache[name];
    }
    /**
     * Reset local caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCache() {
      ianaZoneCache = {};
      dtfCache = {};
    }
    /**
     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
     * @param {string} s - The string to check validity on
     * @example IANAZone.isValidSpecifier("America/New_York") //=> true
     * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
     * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
     * @return {boolean}
     */
    static isValidSpecifier(s2) {
      return this.isValidZone(s2);
    }
    /**
     * Returns whether the provided string identifies a real zone
     * @param {string} zone - The string to check
     * @example IANAZone.isValidZone("America/New_York") //=> true
     * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
     * @example IANAZone.isValidZone("Sport~~blorp") //=> false
     * @return {boolean}
     */
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
        return true;
      } catch (e3) {
        return false;
      }
    }
    constructor(name) {
      super();
      this.zoneName = name;
      this.valid = _IANAZone.isValidZone(name);
    }
    /** @override **/
    get type() {
      return "iana";
    }
    /** @override **/
    get name() {
      return this.zoneName;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName(ts, { format: format2, locale: locale3 }) {
      return parseZoneInfo(ts, format2, locale3, this.name);
    }
    /** @override **/
    formatOffset(ts, format2) {
      return formatOffset(this.offset(ts), format2);
    }
    /** @override **/
    offset(ts) {
      const date2 = new Date(ts);
      if (isNaN(date2))
        return NaN;
      const dtf = makeDTF(this.name);
      let [year, month, day, adOrBc, hour, minute, second2] = dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
      if (adOrBc === "BC") {
        year = -Math.abs(year) + 1;
      }
      const adjustedHour = hour === 24 ? 0 : hour;
      const asUTC = objToLocalTS({
        year,
        month,
        day,
        hour: adjustedHour,
        minute,
        second: second2,
        millisecond: 0
      });
      let asTS = +date2;
      const over = asTS % 1e3;
      asTS -= over >= 0 ? over : 1e3 + over;
      return (asUTC - asTS) / (60 * 1e3);
    }
    /** @override **/
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    /** @override **/
    get isValid() {
      return this.valid;
    }
  };

  // node_modules/luxon/src/impl/locale.js
  var intlLFCache = {};
  function getCachedLF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  }
  var intlDTCache = {};
  function getCachedDTF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  }
  var intlNumCache = {};
  function getCachedINF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  }
  var intlRelCache = {};
  function getCachedRTF(locString, opts = {}) {
    const { base, ...cacheKeyOpts } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  }
  var sysLocaleCache = null;
  function systemLocale() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  }
  var weekInfoCache = {};
  function getCachedWeekInfo(locString) {
    let data = weekInfoCache[locString];
    if (!data) {
      const locale3 = new Intl.Locale(locString);
      data = "getWeekInfo" in locale3 ? locale3.getWeekInfo() : locale3.weekInfo;
      weekInfoCache[locString] = data;
    }
    return data;
  }
  function parseLocaleString(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e3) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const { numberingSystem, calendar: calendar2 } = options;
      return [selectedStr, numberingSystem, calendar2];
    }
  }
  function intlConfigString(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  }
  function mapMonths(f) {
    const ms = [];
    for (let i = 1; i <= 12; i++) {
      const dt = DateTime.utc(2009, i, 1);
      ms.push(f(dt));
    }
    return ms;
  }
  function mapWeekdays(f) {
    const ms = [];
    for (let i = 1; i <= 7; i++) {
      const dt = DateTime.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  }
  function listStuff(loc, length2, englishFn, intlFn) {
    const mode2 = loc.listingMode();
    if (mode2 === "error") {
      return null;
    } else if (mode2 === "en") {
      return englishFn(length2);
    } else {
      return intlFn(length2);
    }
  }
  function supportsFastNumbers(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
    }
  }
  var PolyNumberFormatter = class {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const { padTo, floor, ...otherOpts } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = { useGrouping: false, ...opts };
        if (opts.padTo > 0)
          intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart(fixed, this.padTo);
      }
    }
  };
  var PolyDateFormatter = class {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = void 0;
      let z = void 0;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z = offsetZ;
          this.dt = dt;
        } else {
          z = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z = dt.zone.name;
      } else {
        z = "UTC";
        this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
      const intlOpts = { ...this.opts };
      intlOpts.timeZone = intlOpts.timeZone || z;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({ value }) => value).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  };
  var PolyRelFormatter = class {
    constructor(intl, isEnglish, opts) {
      this.opts = { style: "long", ...opts };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count, unit2) {
      if (this.rtf) {
        return this.rtf.format(count, unit2);
      } else {
        return formatRelativeTime(unit2, count, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count, unit2) {
      if (this.rtf) {
        return this.rtf.formatToParts(count, unit2);
      } else {
        return [];
      }
    }
  };
  var fallbackWeekSettings = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
  };
  var Locale = class _Locale {
    static fromOpts(opts) {
      return _Locale.create(
        opts.locale,
        opts.numberingSystem,
        opts.outputCalendar,
        opts.weekSettings,
        opts.defaultToEN
      );
    }
    static create(locale3, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
      const specifiedLocale = locale3 || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
      return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache = {};
      intlNumCache = {};
      intlRelCache = {};
    }
    static fromObject({ locale: locale3, numberingSystem, outputCalendar, weekSettings } = {}) {
      return _Locale.create(locale3, numberingSystem, outputCalendar, weekSettings);
    }
    constructor(locale3, numbering, outputCalendar, weekSettings, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale3);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.weekSettings = weekSettings;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = { format: {}, standalone: {} };
      this.monthsCache = { format: {}, standalone: {} };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return _Locale.create(
          alts.locale || this.specifiedLocale,
          alts.numberingSystem || this.numberingSystem,
          alts.outputCalendar || this.outputCalendar,
          validateWeekSettings(alts.weekSettings) || this.weekSettings,
          alts.defaultToEN || false
        );
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({ ...alts, defaultToEN: true });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({ ...alts, defaultToEN: false });
    }
    months(length2, format2 = false) {
      return listStuff(this, length2, months, () => {
        const intl = format2 ? { month: length2, day: "numeric" } : { month: length2 }, formatStr = format2 ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length2]) {
          this.monthsCache[formatStr][length2] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length2];
      });
    }
    weekdays(length2, format2 = false) {
      return listStuff(this, length2, weekdays, () => {
        const intl = format2 ? { weekday: length2, year: "numeric", month: "long", day: "numeric" } : { weekday: length2 }, formatStr = format2 ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length2]) {
          this.weekdaysCache[formatStr][length2] = mapWeekdays(
            (dt) => this.extract(dt, intl, "weekday")
          );
        }
        return this.weekdaysCache[formatStr][length2];
      });
    }
    meridiems() {
      return listStuff(
        this,
        void 0,
        () => meridiems,
        () => {
          if (!this.meridiemCache) {
            const intl = { hour: "numeric", hourCycle: "h12" };
            this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
              (dt) => this.extract(dt, intl, "dayperiod")
            );
          }
          return this.meridiemCache;
        }
      );
    }
    eras(length2) {
      return listStuff(this, length2, eras, () => {
        const intl = { era: length2 };
        if (!this.eraCache[length2]) {
          this.eraCache[length2] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
            (dt) => this.extract(dt, intl, "era")
          );
        }
        return this.eraCache[length2];
      });
    }
    extract(dt, intlOpts, field) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
    }
    getWeekSettings() {
      if (this.weekSettings) {
        return this.weekSettings;
      } else if (!hasLocaleWeekInfo()) {
        return fallbackWeekSettings;
      } else {
        return getCachedWeekInfo(this.locale);
      }
    }
    getStartOfWeek() {
      return this.getWeekSettings().firstDay;
    }
    getMinDaysInFirstWeek() {
      return this.getWeekSettings().minimalDays;
    }
    getWeekendDays() {
      return this.getWeekSettings().weekend;
    }
    equals(other) {
      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
    }
  };

  // node_modules/luxon/src/zones/fixedOffsetZone.js
  var singleton2 = null;
  var FixedOffsetZone = class _FixedOffsetZone extends Zone {
    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    static get utcInstance() {
      if (singleton2 === null) {
        singleton2 = new _FixedOffsetZone(0);
      }
      return singleton2;
    }
    /**
     * Get an instance with a specified offset
     * @param {number} offset - The offset in minutes
     * @return {FixedOffsetZone}
     */
    static instance(offset3) {
      return offset3 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset3);
    }
    /**
     * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
     * @param {string} s - The offset string to parse
     * @example FixedOffsetZone.parseSpecifier("UTC+6")
     * @example FixedOffsetZone.parseSpecifier("UTC+06")
     * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
     * @return {FixedOffsetZone}
     */
    static parseSpecifier(s2) {
      if (s2) {
        const r3 = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r3) {
          return new _FixedOffsetZone(signedOffset(r3[1], r3[2]));
        }
      }
      return null;
    }
    constructor(offset3) {
      super();
      this.fixed = offset3;
    }
    /** @override **/
    get type() {
      return "fixed";
    }
    /** @override **/
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    /** @override **/
    offsetName() {
      return this.name;
    }
    /** @override **/
    formatOffset(ts, format2) {
      return formatOffset(this.fixed, format2);
    }
    /** @override **/
    get isUniversal() {
      return true;
    }
    /** @override **/
    offset() {
      return this.fixed;
    }
    /** @override **/
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    /** @override **/
    get isValid() {
      return true;
    }
  };

  // node_modules/luxon/src/zones/invalidZone.js
  var InvalidZone = class extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    /** @override **/
    get type() {
      return "invalid";
    }
    /** @override **/
    get name() {
      return this.zoneName;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName() {
      return null;
    }
    /** @override **/
    formatOffset() {
      return "";
    }
    /** @override **/
    offset() {
      return NaN;
    }
    /** @override **/
    equals() {
      return false;
    }
    /** @override **/
    get isValid() {
      return false;
    }
  };

  // node_modules/luxon/src/impl/zoneUtil.js
  function normalizeZone(input, defaultZone2) {
    let offset3;
    if (isUndefined(input) || input === null) {
      return defaultZone2;
    } else if (input instanceof Zone) {
      return input;
    } else if (isString2(input)) {
      const lowered = input.toLowerCase();
      if (lowered === "default")
        return defaultZone2;
      else if (lowered === "local" || lowered === "system")
        return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt")
        return FixedOffsetZone.utcInstance;
      else
        return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
    } else if (isNumber2(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
      return input;
    } else {
      return new InvalidZone(input);
    }
  }

  // node_modules/luxon/src/settings.js
  var now2 = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;
  var defaultWeekSettings = null;
  var Settings = class {
    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    static get now() {
      return now2;
    }
    /**
     * Set the callback for returning the current timestamp.
     * The function should return a number, which will be interpreted as an Epoch millisecond count
     * @type {function}
     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
     */
    static set now(n2) {
      now2 = n2;
    }
    /**
     * Set the default time zone to create DateTimes in. Does not affect existing instances.
     * Use the value "system" to reset this value to the system's time zone.
     * @type {string}
     */
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    /**
     * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
     * The default value is the system's time zone (the one set on the machine that runs this code).
     * @type {Zone}
     */
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultLocale() {
      return defaultLocale;
    }
    /**
     * Set the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultLocale(locale3) {
      defaultLocale = locale3;
    }
    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    /**
     * Set the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    /**
     * Set the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    /**
     * @typedef {Object} WeekSettings
     * @property {number} firstDay
     * @property {number} minimalDays
     * @property {number[]} weekend
     */
    /**
     * @return {WeekSettings|null}
     */
    static get defaultWeekSettings() {
      return defaultWeekSettings;
    }
    /**
     * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
     * how many days are required in the first week of a year.
     * Does not affect existing instances.
     *
     * @param {WeekSettings|null} weekSettings
     */
    static set defaultWeekSettings(weekSettings) {
      defaultWeekSettings = validateWeekSettings(weekSettings);
    }
    /**
     * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
     * @type {number}
     */
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    /**
     * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
     * @type {number}
     * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
     * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
     * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
     * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
     */
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    /**
     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static set throwOnInvalid(t4) {
      throwOnInvalid = t4;
    }
    /**
     * Reset Luxon's global caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
    }
  };

  // node_modules/luxon/src/impl/invalid.js
  var Invalid = class {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  };

  // node_modules/luxon/src/impl/conversions.js
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  function unitOutOfRange(unit2, value) {
    return new Invalid(
      "unit out of range",
      `you specified ${value} (of type ${typeof value}) as a ${unit2}, which is invalid`
    );
  }
  function dayOfWeek(year, month, day) {
    const d = new Date(Date.UTC(year, month - 1, day));
    if (year < 100 && year >= 0) {
      d.setUTCFullYear(d.getUTCFullYear() - 1900);
    }
    const js = d.getUTCDay();
    return js === 0 ? 7 : js;
  }
  function computeOrdinal(year, month, day) {
    return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  }
  function uncomputeOrdinal(year, ordinal2) {
    const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal2), day = ordinal2 - table[month0];
    return { month: month0 + 1, day };
  }
  function isoWeekdayToLocal(isoWeekday, startOfWeek) {
    return (isoWeekday - startOfWeek + 7) % 7 + 1;
  }
  function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const { year, month, day } = gregObj, ordinal2 = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
    let weekNumber = Math.floor((ordinal2 - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
    } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }
    return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
  }
  function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
    let ordinal2 = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
    if (ordinal2 < 1) {
      year = weekYear - 1;
      ordinal2 += daysInYear(year);
    } else if (ordinal2 > yearInDays) {
      year = weekYear + 1;
      ordinal2 -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }
    const { month, day } = uncomputeOrdinal(year, ordinal2);
    return { year, month, day, ...timeObject(weekData) };
  }
  function gregorianToOrdinal(gregData) {
    const { year, month, day } = gregData;
    const ordinal2 = computeOrdinal(year, month, day);
    return { year, ordinal: ordinal2, ...timeObject(gregData) };
  }
  function ordinalToGregorian(ordinalData) {
    const { year, ordinal: ordinal2 } = ordinalData;
    const { month, day } = uncomputeOrdinal(year, ordinal2);
    return { year, month, day, ...timeObject(ordinalData) };
  }
  function usesLocalWeekValues(obj, loc) {
    const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
    if (hasLocaleWeekData) {
      const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
      if (hasIsoWeekData) {
        throw new ConflictingSpecificationError(
          "Cannot mix locale-based week fields with ISO-based week fields"
        );
      }
      if (!isUndefined(obj.localWeekday))
        obj.weekday = obj.localWeekday;
      if (!isUndefined(obj.localWeekNumber))
        obj.weekNumber = obj.localWeekNumber;
      if (!isUndefined(obj.localWeekYear))
        obj.weekYear = obj.localWeekYear;
      delete obj.localWeekday;
      delete obj.localWeekNumber;
      delete obj.localWeekYear;
      return {
        minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
        startOfWeek: loc.getStartOfWeek()
      };
    } else {
      return { minDaysInFirstWeek: 4, startOfWeek: 1 };
    }
  }
  function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
      obj.weekNumber,
      1,
      weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
    ), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.weekNumber);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else
      return false;
  }
  function hasInvalidOrdinalData(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else
      return false;
  }
  function hasInvalidGregorianData(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else
      return false;
  }
  function hasInvalidTimeData(obj) {
    const { hour, minute, second: second2, millisecond: millisecond2 } = obj;
    const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second2 === 0 && millisecond2 === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second2, 0, 59), validMillisecond = integerBetween(millisecond2, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second2);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond2);
    } else
      return false;
  }

  // node_modules/luxon/src/impl/util.js
  function isUndefined(o) {
    return typeof o === "undefined";
  }
  function isNumber2(o) {
    return typeof o === "number";
  }
  function isInteger(o) {
    return typeof o === "number" && o % 1 === 0;
  }
  function isString2(o) {
    return typeof o === "string";
  }
  function isDate(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  }
  function hasRelative() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e3) {
      return false;
    }
  }
  function hasLocaleWeekInfo() {
    try {
      return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
    } catch (e3) {
      return false;
    }
  }
  function maybeArray(thing) {
    return Array.isArray(thing) ? thing : [thing];
  }
  function bestBy(arr, by, compare) {
    if (arr.length === 0) {
      return void 0;
    }
    return arr.reduce((best, next2) => {
      const pair = [by(next2), next2];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  }
  function pick4(obj, keys3) {
    return keys3.reduce((a, k) => {
      a[k] = obj[k];
      return a;
    }, {});
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function validateWeekSettings(settings) {
    if (settings == null) {
      return null;
    } else if (typeof settings !== "object") {
      throw new InvalidArgumentError("Week settings must be an object");
    } else {
      if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
        throw new InvalidArgumentError("Invalid week settings");
      }
      return {
        firstDay: settings.firstDay,
        minimalDays: settings.minimalDays,
        weekend: Array.from(settings.weekend)
      };
    }
  }
  function integerBetween(thing, bottom2, top2) {
    return isInteger(thing) && thing >= bottom2 && thing <= top2;
  }
  function floorMod(x, n2) {
    return x - n2 * Math.floor(x / n2);
  }
  function padStart(input, n2 = 2) {
    const isNeg = input < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input).padStart(n2, "0");
    } else {
      padded = ("" + input).padStart(n2, "0");
    }
    return padded;
  }
  function parseInteger(string) {
    if (isUndefined(string) || string === null || string === "") {
      return void 0;
    } else {
      return parseInt(string, 10);
    }
  }
  function parseFloating(string) {
    if (isUndefined(string) || string === null || string === "") {
      return void 0;
    } else {
      return parseFloat(string);
    }
  }
  function parseMillis(fraction) {
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return void 0;
    } else {
      const f = parseFloat("0." + fraction) * 1e3;
      return Math.floor(f);
    }
  }
  function roundTo(number5, digits, towardZero = false) {
    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number5 * factor) / factor;
  }
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function daysInMonth(year, month) {
    const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  }
  function objToLocalTS(obj) {
    let d = Date.UTC(
      obj.year,
      obj.month - 1,
      obj.day,
      obj.hour,
      obj.minute,
      obj.second,
      obj.millisecond
    );
    if (obj.year < 100 && obj.year >= 0) {
      d = new Date(d);
      d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d;
  }
  function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
    const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
    return -fwdlw + minDaysInFirstWeek - 1;
  }
  function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
    const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
    return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
  }
  function untruncateYear(year) {
    if (year > 99) {
      return year;
    } else
      return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
  }
  function parseZoneInfo(ts, offsetFormat, locale3, timeZone = null) {
    const date2 = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = { timeZoneName: offsetFormat, ...intlOpts };
    const parsed = new Intl.DateTimeFormat(locale3, modified).formatToParts(date2).find((m) => m.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  }
  function signedOffset(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  }
  function asNumber2(value) {
    const numericValue = Number(value);
    if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value}`);
    return numericValue;
  }
  function normalizeObject(obj, normalizer) {
    const normalized = {};
    for (const u in obj) {
      if (hasOwnProperty(obj, u)) {
        const v = obj[u];
        if (v === void 0 || v === null)
          continue;
        normalized[normalizer(u)] = asNumber2(v);
      }
    }
    return normalized;
  }
  function formatOffset(offset3, format2) {
    const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign = offset3 >= 0 ? "+" : "-";
    switch (format2) {
      case "short":
        return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format2} is out of range for property format`);
    }
  }
  function timeObject(obj) {
    return pick4(obj, ["hour", "minute", "second", "millisecond"]);
  }

  // node_modules/luxon/src/impl/english.js
  var monthsLong = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var monthsShort = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  function months(length2) {
    switch (length2) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  }
  var weekdaysLong = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday"
  ];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  function weekdays(length2) {
    switch (length2) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  }
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  function eras(length2) {
    switch (length2) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  }
  function meridiemForDateTime(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  }
  function weekdayForDateTime(dt, length2) {
    return weekdays(length2)[dt.weekday - 1];
  }
  function monthForDateTime(dt, length2) {
    return months(length2)[dt.month - 1];
  }
  function eraForDateTime(dt, length2) {
    return eras(length2)[dt.year < 0 ? 0 : 1];
  }
  function formatRelativeTime(unit2, count, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit2) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit2 === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit2][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit2][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit2][0]}`;
        default:
      }
    }
    const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit2], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit2][0] : unit2;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  }

  // node_modules/luxon/src/impl/formatter.js
  function stringifyTokens(splits, tokenToString) {
    let s2 = "";
    for (const token2 of splits) {
      if (token2.literal) {
        s2 += token2.val;
      } else {
        s2 += tokenToString(token2.val);
      }
    }
    return s2;
  }
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };
  var Formatter = class _Formatter {
    static create(locale3, opts = {}) {
      return new _Formatter(locale3, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i = 0; i < fmt.length; i++) {
        const c = fmt.charAt(i);
        if (c === "'") {
          if (currentFull.length > 0) {
            splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c;
        } else if (c === current) {
          currentFull += c;
        } else {
          if (currentFull.length > 0) {
            splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
          }
          currentFull = c;
          current = c;
        }
      }
      if (currentFull.length > 0) {
        splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token2) {
      return macroTokenToFormatOpts[token2];
    }
    constructor(locale3, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale3;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval, opts) {
      const df = this.dtFormatter(interval.start, opts);
      return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n2, p = 0) {
      if (this.opts.forceSimple) {
        return padStart(n2, p);
      }
      const opts = { ...this.opts };
      if (p > 0) {
        opts.padTo = p;
      }
      return this.loc.numberFormatter(opts).format(n2);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length2, standalone) => knownEnglish ? monthForDateTime(dt, length2) : string(standalone ? { month: length2 } : { month: length2, day: "numeric" }, "month"), weekday = (length2, standalone) => knownEnglish ? weekdayForDateTime(dt, length2) : string(
        standalone ? { weekday: length2 } : { weekday: length2, month: "long", day: "numeric" },
        "weekday"
      ), maybeMacro = (token2) => {
        const formatOpts = _Formatter.macroTokenToFormatOpts(token2);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token2;
        }
      }, era = (length2) => knownEnglish ? eraForDateTime(dt, length2) : string({ era: length2 }, "era"), tokenToString = (token2) => {
        switch (token2) {
          case "S":
            return this.num(dt.millisecond);
          case "u":
          case "SSS":
            return this.num(dt.millisecond, 3);
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          case "Z":
            return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
          case "z":
            return dt.zoneName;
          case "a":
            return meridiem();
          case "d":
            return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          case "M":
            return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          case "y":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "n":
            return this.num(dt.localWeekNumber);
          case "nn":
            return this.num(dt.localWeekNumber, 2);
          case "ii":
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(dt.localWeekYear, 4);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1e3));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token2);
        }
      };
      return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const tokenToField = (token2) => {
        switch (token2[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      }, tokenToString = (lildur) => (token2) => {
        const mapped = tokenToField(token2);
        if (mapped) {
          return this.num(lildur.get(mapped), token2.length);
        } else {
          return token2;
        }
      }, tokens2 = _Formatter.parseFormat(fmt), realTokens = tokens2.reduce(
        (found, { literal, val }) => literal ? found : found.concat(val),
        []
      ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t4) => t4));
      return stringifyTokens(tokens2, tokenToString(collapsed));
    }
  };

  // node_modules/luxon/src/impl/regexParser.js
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  function combineRegexes(...regexes) {
    const full = regexes.reduce((f, r3) => f + r3.source, "");
    return RegExp(`^${full}$`);
  }
  function combineExtractors(...extractors) {
    return (m) => extractors.reduce(
      ([mergedVals, mergedZone, cursor2], ex) => {
        const [val, zone, next2] = ex(m, cursor2);
        return [{ ...mergedVals, ...val }, zone || mergedZone, next2];
      },
      [{}, null, 1]
    ).slice(0, 2);
  }
  function parse2(s2, ...patterns) {
    if (s2 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns) {
      const m = regex.exec(s2);
      if (m) {
        return extractor(m);
      }
    }
    return [null, null];
  }
  function simpleParse(...keys3) {
    return (match3, cursor2) => {
      const ret = {};
      let i;
      for (i = 0; i < keys3.length; i++) {
        ret[keys3[i]] = parseInteger(match3[cursor2 + i]);
      }
      return [ret, null, cursor2 + i];
    };
  }
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(
    `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
  );
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  function int2(match3, pos, fallback) {
    const m = match3[pos];
    return isUndefined(m) ? fallback : parseInteger(m);
  }
  function extractISOYmd(match3, cursor2) {
    const item = {
      year: int2(match3, cursor2),
      month: int2(match3, cursor2 + 1, 1),
      day: int2(match3, cursor2 + 2, 1)
    };
    return [item, null, cursor2 + 3];
  }
  function extractISOTime(match3, cursor2) {
    const item = {
      hours: int2(match3, cursor2, 0),
      minutes: int2(match3, cursor2 + 1, 0),
      seconds: int2(match3, cursor2 + 2, 0),
      milliseconds: parseMillis(match3[cursor2 + 3])
    };
    return [item, null, cursor2 + 4];
  }
  function extractISOOffset(match3, cursor2) {
    const local = !match3[cursor2] && !match3[cursor2 + 1], fullOffset = signedOffset(match3[cursor2 + 1], match3[cursor2 + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor2 + 3];
  }
  function extractIANAZone(match3, cursor2) {
    const zone = match3[cursor2] ? IANAZone.create(match3[cursor2]) : null;
    return [{}, zone, cursor2 + 1];
  }
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  function extractISODuration(match3) {
    const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match3;
    const hasNegativePrefix = s2[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
    return [
      {
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }
    ];
  }
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr)
      result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result;
  }
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  function extractRFC2822(match3) {
    const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
      obsOffset,
      milOffset,
      offHourStr,
      offMinuteStr
    ] = match3, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset3;
    if (obsOffset) {
      offset3 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset3 = 0;
    } else {
      offset3 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result, new FixedOffsetZone(offset3)];
  }
  function preprocessRFC2822(s2) {
    return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  }
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  function extractRFC1123Or850(match3) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match3, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  function extractASCII(match3) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match3, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(
    extractISOYmd,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOWeekTimeAndOffset = combineExtractors(
    extractISOWeekData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOOrdinalDateAndTime = combineExtractors(
    extractISOOrdinalData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOTimeAndOffset = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  function parseISODate(s2) {
    return parse2(
      s2,
      [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
      [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
      [isoTimeCombinedRegex, extractISOTimeAndOffset]
    );
  }
  function parseRFC2822Date(s2) {
    return parse2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
  }
  function parseHTTPDate(s2) {
    return parse2(
      s2,
      [rfc1123, extractRFC1123Or850],
      [rfc850, extractRFC1123Or850],
      [ascii, extractASCII]
    );
  }
  function parseISODuration(s2) {
    return parse2(s2, [isoDuration, extractISODuration]);
  }
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  function parseISOTimeOnly(s2) {
    return parse2(s2, [isoTimeOnly, extractISOTimeOnly]);
  }
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  function parseSQL(s2) {
    return parse2(
      s2,
      [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
    );
  }

  // node_modules/luxon/src/duration.js
  var INVALID = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1e3
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1e3
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
    minutes: { seconds: 60, milliseconds: 60 * 1e3 },
    seconds: { milliseconds: 1e3 }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1e3
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
  };
  var orderedUnits = [
    "years",
    "quarters",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds"
  ];
  var reverseUnits = orderedUnits.slice(0).reverse();
  function clone(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  }
  function durationToMillis(matrix, vals) {
    let sum = vals.milliseconds ?? 0;
    for (const unit2 of reverseUnits.slice(1)) {
      if (vals[unit2]) {
        sum += vals[unit2] * matrix[unit2]["milliseconds"];
      }
    }
    return sum;
  }
  function normalizeValues(matrix, vals) {
    const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
    orderedUnits.reduceRight((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  }
  function removeZeroes(vals) {
    const newVals = {};
    for (const [key, value] of Object.entries(vals)) {
      if (value !== 0) {
        newVals[key] = value;
      }
    }
    return newVals;
  }
  var Duration = class _Duration {
    /**
     * @private
     */
    constructor(config2) {
      const accurate = config2.conversionAccuracy === "longterm" || false;
      let matrix = accurate ? accurateMatrix : casualMatrix;
      if (config2.matrix) {
        matrix = config2.matrix;
      }
      this.values = config2.values;
      this.loc = config2.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config2.invalid || null;
      this.matrix = matrix;
      this.isLuxonDuration = true;
    }
    /**
     * Create Duration from a number of milliseconds.
     * @param {number} count of milliseconds
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    static fromMillis(count, opts) {
      return _Duration.fromObject({ milliseconds: count }, opts);
    }
    /**
     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
     * If this object is empty then a zero milliseconds duration is returned.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.years
     * @param {number} obj.quarters
     * @param {number} obj.months
     * @param {number} obj.weeks
     * @param {number} obj.days
     * @param {number} obj.hours
     * @param {number} obj.minutes
     * @param {number} obj.seconds
     * @param {number} obj.milliseconds
     * @param {Object} [opts=[]] - options for creating this Duration
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the custom conversion system to use
     * @return {Duration}
     */
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(
          `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
        );
      }
      return new _Duration({
        values: normalizeObject(obj, _Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    /**
     * Create a Duration from DurationLike.
     *
     * @param {Object | number | Duration} durationLike
     * One of:
     * - object with keys like 'years' and 'hours'.
     * - number representing milliseconds
     * - Duration instance
     * @return {Duration}
     */
    static fromDurationLike(durationLike) {
      if (isNumber2(durationLike)) {
        return _Duration.fromMillis(durationLike);
      } else if (_Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return _Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(
          `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
        );
      }
    }
    /**
     * Create a Duration from an ISO 8601 duration string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the preset conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
     * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
     * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
     * @return {Duration}
     */
    static fromISO(text, opts) {
      const [parsed] = parseISODuration(text);
      if (parsed) {
        return _Duration.fromObject(parsed, opts);
      } else {
        return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    /**
     * Create a Duration from an ISO 8601 time string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
     * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @return {Duration}
     */
    static fromISOTime(text, opts) {
      const [parsed] = parseISOTimeOnly(text);
      if (parsed) {
        return _Duration.fromObject(parsed, opts);
      } else {
        return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    /**
     * Create an invalid Duration.
     * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Duration}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new _Duration({ invalid });
      }
    }
    /**
     * @private
     */
    static normalizeUnit(unit2) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit2 ? unit2.toLowerCase() : unit2];
      if (!normalized)
        throw new InvalidUnitError(unit2);
      return normalized;
    }
    /**
     * Check if an object is a Duration. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDuration(o) {
      return o && o.isLuxonDuration || false;
    }
    /**
     * Get  the locale of a Duration, such 'en-GB'
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
     * * `S` for milliseconds
     * * `s` for seconds
     * * `m` for minutes
     * * `h` for hours
     * * `d` for days
     * * `w` for weeks
     * * `M` for months
     * * `y` for years
     * Notes:
     * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
     * * Tokens can be escaped by wrapping with single quotes.
     * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
     * @param {string} fmt - the format string
     * @param {Object} opts - options
     * @param {boolean} [opts.floor=true] - floor numerical values
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
    }
    /**
     * Returns a string representation of a Duration with all units included.
     * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
     * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
     * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
     * @example
     * ```js
     * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
     * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
     * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
     * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
     * ```
     */
    toHuman(opts = {}) {
      if (!this.isValid)
        return INVALID;
      const l2 = orderedUnits.map((unit2) => {
        const val = this.values[unit2];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit2.slice(0, -1) }).format(val);
      }).filter((n2) => n2);
      return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
    }
    /**
     * Returns a JavaScript object with this Duration's values.
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
     * @return {Object}
     */
    toObject() {
      if (!this.isValid)
        return {};
      return { ...this.values };
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
     * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
     * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
     * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
     * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
     * @return {string}
     */
    toISO() {
      if (!this.isValid)
        return null;
      let s2 = "P";
      if (this.years !== 0)
        s2 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0)
        s2 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0)
        s2 += this.weeks + "W";
      if (this.days !== 0)
        s2 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s2 += "T";
      if (this.hours !== 0)
        s2 += this.hours + "H";
      if (this.minutes !== 0)
        s2 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
      if (s2 === "P")
        s2 += "T0S";
      return s2;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
     * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
     * @return {string}
     */
    toISOTime(opts = {}) {
      if (!this.isValid)
        return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 864e5)
        return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
      return dateTime.toISOTime(opts);
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
     * @return {string}
     */
    toString() {
      return this.toISO();
    }
    /**
     * Returns a string representation of this Duration appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Duration { values: ${JSON.stringify(this.values)} }`;
      } else {
        return `Duration { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns an milliseconds value of this Duration.
     * @return {number}
     */
    toMillis() {
      if (!this.isValid)
        return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    /**
     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = _Duration.fromDurationLike(duration), result = {};
      for (const k of orderedUnits) {
        if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
          result[k] = dur.get(k) + this.get(k);
        }
      }
      return clone(this, { values: result }, true);
    }
    /**
     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = _Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }
    /**
     * Scale this Duration by the specified amount. Return a newly-constructed Duration.
     * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
     * @return {Duration}
     */
    mapUnits(fn2) {
      if (!this.isValid)
        return this;
      const result = {};
      for (const k of Object.keys(this.values)) {
        result[k] = asNumber2(fn2(this.values[k], k));
      }
      return clone(this, { values: result }, true);
    }
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
     * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
     * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
     * @return {number}
     */
    get(unit2) {
      return this[_Duration.normalizeUnit(unit2)];
    }
    /**
     * "Set" the values of specified units. Return a newly-constructed Duration.
     * @param {Object} values - a mapping of units to numbers
     * @example dur.set({ years: 2017 })
     * @example dur.set({ hours: 8, minutes: 30 })
     * @return {Duration}
     */
    set(values) {
      if (!this.isValid)
        return this;
      const mixed = { ...this.values, ...normalizeObject(values, _Duration.normalizeUnit) };
      return clone(this, { values: mixed });
    }
    /**
     * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
     * @example dur.reconfigure({ locale: 'en-GB' })
     * @return {Duration}
     */
    reconfigure({ locale: locale3, numberingSystem, conversionAccuracy, matrix } = {}) {
      const loc = this.loc.clone({ locale: locale3, numberingSystem });
      const opts = { loc, matrix, conversionAccuracy };
      return clone(this, opts);
    }
    /**
     * Return the length of the duration in the specified unit.
     * @param {string} unit - a unit such as 'minutes' or 'days'
     * @example Duration.fromObject({years: 1}).as('days') //=> 365
     * @example Duration.fromObject({years: 1}).as('months') //=> 12
     * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
     * @return {number}
     */
    as(unit2) {
      return this.isValid ? this.shiftTo(unit2).get(unit2) : NaN;
    }
    /**
     * Reduce this Duration to its canonical representation in its current units.
     * Assuming the overall value of the Duration is positive, this means:
     * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
     * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
     *   the overall value would be negative, see third example)
     * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
     *
     * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
     * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
     * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
     * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
     * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
     * @return {Duration}
     */
    normalize() {
      if (!this.isValid)
        return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone(this, { values: vals }, true);
    }
    /**
     * Rescale units to its largest representation
     * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
     * @return {Duration}
     */
    rescale() {
      if (!this.isValid)
        return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone(this, { values: vals }, true);
    }
    /**
     * Convert this Duration into its representation in a different set of units.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
     * @return {Duration}
     */
    shiftTo(...units) {
      if (!this.isValid)
        return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u) => _Duration.normalizeUnit(u));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k of orderedUnits) {
        if (units.indexOf(k) >= 0) {
          lastUnit = k;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber2(vals[k])) {
            own += vals[k];
          }
          const i = Math.trunc(own);
          built[k] = i;
          accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
        } else if (isNumber2(vals[k])) {
          accumulated[k] = vals[k];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone(this, { values: built }, true);
    }
    /**
     * Shift this Duration to all available units.
     * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
     * @return {Duration}
     */
    shiftToAll() {
      if (!this.isValid)
        return this;
      return this.shiftTo(
        "years",
        "months",
        "weeks",
        "days",
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
      );
    }
    /**
     * Return the negative of this Duration.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
     * @return {Duration}
     */
    negate() {
      if (!this.isValid)
        return this;
      const negated = {};
      for (const k of Object.keys(this.values)) {
        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
      }
      return clone(this, { values: negated }, true);
    }
    /**
     * Get the years.
     * @type {number}
     */
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    /**
     * Get the quarters.
     * @type {number}
     */
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    /**
     * Get the months.
     * @type {number}
     */
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    /**
     * Get the weeks
     * @type {number}
     */
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    /**
     * Get the days.
     * @type {number}
     */
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    /**
     * Get the hours.
     * @type {number}
     */
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    /**
     * Get the minutes.
     * @type {number}
     */
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    /**
     * Get the seconds.
     * @return {number}
     */
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    /**
     * Get the milliseconds.
     * @return {number}
     */
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Equality check
     * Two Durations are equal iff they have the same units and the same values for each unit.
     * @param {Duration} other
     * @return {boolean}
     */
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      if (!this.loc.equals(other.loc)) {
        return false;
      }
      function eq(v1, v2) {
        if (v1 === void 0 || v1 === 0)
          return v2 === void 0 || v2 === 0;
        return v1 === v2;
      }
      for (const u of orderedUnits) {
        if (!eq(this.values[u], other.values[u])) {
          return false;
        }
      }
      return true;
    }
  };

  // node_modules/luxon/src/interval.js
  var INVALID2 = "Invalid Interval";
  function validateStartEnd(start2, end2) {
    if (!start2 || !start2.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end2 || !end2.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end2 < start2) {
      return Interval.invalid(
        "end before start",
        `The end of an interval must be after its start, but you had start=${start2.toISO()} and end=${end2.toISO()}`
      );
    } else {
      return null;
    }
  }
  var Interval = class _Interval {
    /**
     * @private
     */
    constructor(config2) {
      this.s = config2.start;
      this.e = config2.end;
      this.invalid = config2.invalid || null;
      this.isLuxonInterval = true;
    }
    /**
     * Create an invalid Interval.
     * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Interval}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new _Interval({ invalid });
      }
    }
    /**
     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
     * @param {DateTime|Date|Object} start
     * @param {DateTime|Date|Object} end
     * @return {Interval}
     */
    static fromDateTimes(start2, end2) {
      const builtStart = friendlyDateTime(start2), builtEnd = friendlyDateTime(end2);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new _Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    /**
     * Create an Interval from a start DateTime and a Duration to extend to.
     * @param {DateTime|Date|Object} start
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static after(start2, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start2);
      return _Interval.fromDateTimes(dt, dt.plus(dur));
    }
    /**
     * Create an Interval from an end DateTime and a Duration to extend backwards to.
     * @param {DateTime|Date|Object} end
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static before(end2, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end2);
      return _Interval.fromDateTimes(dt.minus(dur), dt);
    }
    /**
     * Create an Interval from an ISO 8601 string.
     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
     * @param {string} text - the ISO string to parse
     * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {Interval}
     */
    static fromISO(text, opts) {
      const [s2, e3] = (text || "").split("/", 2);
      if (s2 && e3) {
        let start2, startIsValid;
        try {
          start2 = DateTime.fromISO(s2, opts);
          startIsValid = start2.isValid;
        } catch (e4) {
          startIsValid = false;
        }
        let end2, endIsValid;
        try {
          end2 = DateTime.fromISO(e3, opts);
          endIsValid = end2.isValid;
        } catch (e4) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return _Interval.fromDateTimes(start2, end2);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e3, opts);
          if (dur.isValid) {
            return _Interval.after(start2, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s2, opts);
          if (dur.isValid) {
            return _Interval.before(end2, dur);
          }
        }
      }
      return _Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
    /**
     * Check if an object is an Interval. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isInterval(o) {
      return o && o.isLuxonInterval || false;
    }
    /**
     * Returns the start of the Interval
     * @type {DateTime}
     */
    get start() {
      return this.isValid ? this.s : null;
    }
    /**
     * Returns the end of the Interval
     * @type {DateTime}
     */
    get end() {
      return this.isValid ? this.e : null;
    }
    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */
    get isValid() {
      return this.invalidReason === null;
    }
    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Returns the length of the Interval in the specified unit.
     * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
     * @return {number}
     */
    length(unit2 = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit2]).get(unit2) : NaN;
    }
    /**
     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
     * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
     * @param {string} [unit='milliseconds'] - the unit of time to count.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
     * @return {number}
     */
    count(unit2 = "milliseconds", opts) {
      if (!this.isValid)
        return NaN;
      const start2 = this.start.startOf(unit2, opts);
      let end2;
      if (opts?.useLocaleWeeks) {
        end2 = this.end.reconfigure({ locale: start2.locale });
      } else {
        end2 = this.end;
      }
      end2 = end2.startOf(unit2, opts);
      return Math.floor(end2.diff(start2, unit2).get(unit2)) + (end2.valueOf() !== this.end.valueOf());
    }
    /**
     * Returns whether this Interval's start and end are both in the same unit of time
     * @param {string} unit - the unit of time to check sameness on
     * @return {boolean}
     */
    hasSame(unit2) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit2) : false;
    }
    /**
     * Return whether this Interval has the same start and end DateTimes.
     * @return {boolean}
     */
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    /**
     * Return whether this Interval's start is after the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isAfter(dateTime) {
      if (!this.isValid)
        return false;
      return this.s > dateTime;
    }
    /**
     * Return whether this Interval's end is before the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isBefore(dateTime) {
      if (!this.isValid)
        return false;
      return this.e <= dateTime;
    }
    /**
     * Return whether this Interval contains the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    contains(dateTime) {
      if (!this.isValid)
        return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    /**
     * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
     * @param {Object} values - the values to set
     * @param {DateTime} values.start - the starting DateTime
     * @param {DateTime} values.end - the ending DateTime
     * @return {Interval}
     */
    set({ start: start2, end: end2 } = {}) {
      if (!this.isValid)
        return this;
      return _Interval.fromDateTimes(start2 || this.s, end2 || this.e);
    }
    /**
     * Split this Interval at each of the specified DateTimes
     * @param {...DateTime} dateTimes - the unit of time to count.
     * @return {Array}
     */
    splitAt(...dateTimes) {
      if (!this.isValid)
        return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
      let { s: s2 } = this, i = 0;
      while (s2 < this.e) {
        const added = sorted[i] || this.e, next2 = +added > +this.e ? this.e : added;
        results.push(_Interval.fromDateTimes(s2, next2));
        s2 = next2;
        i += 1;
      }
      return results;
    }
    /**
     * Split this Interval into smaller Intervals, each of the specified length.
     * Left over time is grouped into a smaller interval
     * @param {Duration|Object|number} duration - The length of each resulting interval.
     * @return {Array}
     */
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let { s: s2 } = this, idx = 1, next2;
      const results = [];
      while (s2 < this.e) {
        const added = this.start.plus(dur.mapUnits((x) => x * idx));
        next2 = +added > +this.e ? this.e : added;
        results.push(_Interval.fromDateTimes(s2, next2));
        s2 = next2;
        idx += 1;
      }
      return results;
    }
    /**
     * Split this Interval into the specified number of smaller intervals.
     * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
     * @return {Array}
     */
    divideEqually(numberOfParts) {
      if (!this.isValid)
        return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    /**
     * Return whether this Interval overlaps with the specified Interval
     * @param {Interval} other
     * @return {boolean}
     */
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }
    /**
     * Return whether this Interval's end is adjacent to the specified Interval's start.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsStart(other) {
      if (!this.isValid)
        return false;
      return +this.e === +other.s;
    }
    /**
     * Return whether this Interval's start is adjacent to the specified Interval's end.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsEnd(other) {
      if (!this.isValid)
        return false;
      return +other.e === +this.s;
    }
    /**
     * Return whether this Interval engulfs the start and end of the specified Interval.
     * @param {Interval} other
     * @return {boolean}
     */
    engulfs(other) {
      if (!this.isValid)
        return false;
      return this.s <= other.s && this.e >= other.e;
    }
    /**
     * Return whether this Interval has the same start and end as the specified Interval.
     * @param {Interval} other
     * @return {boolean}
     */
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      return this.s.equals(other.s) && this.e.equals(other.e);
    }
    /**
     * Return an Interval representing the intersection of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
     * Returns null if the intersection is empty, meaning, the intervals don't intersect.
     * @param {Interval} other
     * @return {Interval}
     */
    intersection(other) {
      if (!this.isValid)
        return this;
      const s2 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
      if (s2 >= e3) {
        return null;
      } else {
        return _Interval.fromDateTimes(s2, e3);
      }
    }
    /**
     * Return an Interval representing the union of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
     * @param {Interval} other
     * @return {Interval}
     */
    union(other) {
      if (!this.isValid)
        return this;
      const s2 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
      return _Interval.fromDateTimes(s2, e3);
    }
    /**
     * Merge an array of Intervals into a equivalent minimal set of Intervals.
     * Combines overlapping and adjacent Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static merge(intervals) {
      const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
        ([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        },
        [[], null]
      );
      if (final) {
        found.push(final);
      }
      return found;
    }
    /**
     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static xor(intervals) {
      let start2 = null, currentCount = 0;
      const results = [], ends = intervals.map((i) => [
        { time: i.s, type: "s" },
        { time: i.e, type: "e" }
      ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start2 = i.time;
        } else {
          if (start2 && +start2 !== +i.time) {
            results.push(_Interval.fromDateTimes(start2, i.time));
          }
          start2 = null;
        }
      }
      return _Interval.merge(results);
    }
    /**
     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
     * @param {...Interval} intervals
     * @return {Array}
     */
    difference(...intervals) {
      return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
    }
    /**
     * Returns a string representation of this Interval appropriate for debugging.
     * @return {string}
     */
    toString() {
      if (!this.isValid)
        return INVALID2;
      return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
    }
    /**
     * Returns a string representation of this Interval appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
      } else {
        return `Interval { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns a localized string representing this Interval. Accepts the same options as the
     * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
     * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
     * is browser-specific, but in general it will return an appropriate representation of the
     * Interval in the assigned locale. Defaults to the system's locale if no locale has been
     * specified.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
     * Intl.DateTimeFormat constructor options.
     * @param {Object} opts - Options to override the configuration of the start DateTime.
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Interval.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISO(opts) {
      if (!this.isValid)
        return INVALID2;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    /**
     * Returns an ISO 8601-compliant string representation of date of this Interval.
     * The time components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {string}
     */
    toISODate() {
      if (!this.isValid)
        return INVALID2;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    /**
     * Returns an ISO 8601-compliant string representation of time of this Interval.
     * The date components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISOTime(opts) {
      if (!this.isValid)
        return INVALID2;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    /**
     * Returns a string representation of this Interval formatted according to the specified format
     * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
     * formatting tool.
     * @param {string} dateFormat - The format string. This string formats the start and end time.
     * See {@link DateTime#toFormat} for details.
     * @param {Object} opts - Options.
     * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
     * representations.
     * @return {string}
     */
    toFormat(dateFormat, { separator = " \u2013 " } = {}) {
      if (!this.isValid)
        return INVALID2;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    /**
     * Return a Duration representing the time spanned by this interval.
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
     * @return {Duration}
     */
    toDuration(unit2, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit2, opts);
    }
    /**
     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
     * @param {function} mapFn
     * @return {Interval}
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
     */
    mapEndpoints(mapFn) {
      return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  };

  // node_modules/luxon/src/info.js
  var Info = class {
    /**
     * Return whether the specified zone contains a DST.
     * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
     * @return {boolean}
     */
    static hasDST(zone = Settings.defaultZone) {
      const proto = DateTime.now().setZone(zone).set({ month: 12 });
      return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
    }
    /**
     * Return whether the specified zone is a valid IANA specifier.
     * @param {string} zone - Zone to check
     * @return {boolean}
     */
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    /**
     * Converts the input into a {@link Zone} instance.
     *
     * * If `input` is already a Zone instance, it is returned unchanged.
     * * If `input` is a string containing a valid time zone name, a Zone instance
     *   with that name is returned.
     * * If `input` is a string that doesn't refer to a known time zone, a Zone
     *   instance with {@link Zone#isValid} == false is returned.
     * * If `input is a number, a Zone instance with the specified fixed offset
     *   in minutes is returned.
     * * If `input` is `null` or `undefined`, the default zone is returned.
     * @param {string|Zone|number} [input] - the value to be converted
     * @return {Zone}
     */
    static normalizeZone(input) {
      return normalizeZone(input, Settings.defaultZone);
    }
    /**
     * Get the weekday on which the week starts according to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
     */
    static getStartOfWeek({ locale: locale3 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale3)).getStartOfWeek();
    }
    /**
     * Get the minimum number of days necessary in a week before it is considered part of the next year according
     * to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number}
     */
    static getMinimumDaysInFirstWeek({ locale: locale3 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale3)).getMinDaysInFirstWeek();
    }
    /**
     * Get the weekdays, which are considered the weekend according to the given locale
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
     */
    static getWeekendWeekdays({ locale: locale3 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale3)).getWeekendDays().slice();
    }
    /**
     * Return an array of standalone month names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @example Info.months()[0] //=> 'January'
     * @example Info.months('short')[0] //=> 'Jan'
     * @example Info.months('numeric')[0] //=> '1'
     * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
     * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
     * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
     * @return {Array}
     */
    static months(length2 = "long", { locale: locale3 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
      return (locObj || Locale.create(locale3, numberingSystem, outputCalendar)).months(length2);
    }
    /**
     * Return an array of format month names.
     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
     * changes the string.
     * See {@link Info#months}
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @return {Array}
     */
    static monthsFormat(length2 = "long", { locale: locale3 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
      return (locObj || Locale.create(locale3, numberingSystem, outputCalendar)).months(length2, true);
    }
    /**
     * Return an array of standalone week names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @example Info.weekdays()[0] //=> 'Monday'
     * @example Info.weekdays('short')[0] //=> 'Mon'
     * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
     * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
     * @return {Array}
     */
    static weekdays(length2 = "long", { locale: locale3 = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale3, numberingSystem, null)).weekdays(length2);
    }
    /**
     * Return an array of format week names.
     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
     * changes the string.
     * See {@link Info#weekdays}
     * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale=null] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @return {Array}
     */
    static weekdaysFormat(length2 = "long", { locale: locale3 = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale3, numberingSystem, null)).weekdays(length2, true);
    }
    /**
     * Return an array of meridiems.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.meridiems() //=> [ 'AM', 'PM' ]
     * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
     * @return {Array}
     */
    static meridiems({ locale: locale3 = null } = {}) {
      return Locale.create(locale3).meridiems();
    }
    /**
     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
     * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.eras() //=> [ 'BC', 'AD' ]
     * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
     * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
     * @return {Array}
     */
    static eras(length2 = "short", { locale: locale3 = null } = {}) {
      return Locale.create(locale3, null, "gregory").eras(length2);
    }
    /**
     * Return the set of available features in this environment.
     * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
     * Keys:
     * * `relative`: whether this environment supports relative time formatting
     * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
     * @example Info.features() //=> { relative: false, localeWeek: true }
     * @return {Object}
     */
    static features() {
      return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
    }
  };

  // node_modules/luxon/src/impl/diff.js
  function dayDiff(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  }
  function highOrderDiffs(cursor2, later, units) {
    const differs = [
      ["years", (a, b) => b.year - a.year],
      ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
      ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
      [
        "weeks",
        (a, b) => {
          const days = dayDiff(a, b);
          return (days - days % 7) / 7;
        }
      ],
      ["days", dayDiff]
    ];
    const results = {};
    const earlier = cursor2;
    let lowestOrder, highWater;
    for (const [unit2, differ] of differs) {
      if (units.indexOf(unit2) >= 0) {
        lowestOrder = unit2;
        results[unit2] = differ(cursor2, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit2]--;
          cursor2 = earlier.plus(results);
          if (cursor2 > later) {
            highWater = cursor2;
            results[unit2]--;
            cursor2 = earlier.plus(results);
          }
        } else {
          cursor2 = highWater;
        }
      }
    }
    return [cursor2, results, highWater, lowestOrder];
  }
  function diff_default(earlier, later, units, opts) {
    let [cursor2, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor2;
    const lowerOrderUnits = units.filter(
      (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
    );
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor2.plus({ [lowestOrder]: 1 });
      }
      if (highWater !== cursor2) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor2);
      }
    }
    const duration = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
    } else {
      return duration;
    }
  }

  // node_modules/luxon/src/impl/digits.js
  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  function parseDigits(str) {
    let value = parseInt(str, 10);
    if (isNaN(value)) {
      value = "";
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (str[i].search(numberingSystems.hanidec) !== -1) {
          value += hanidecChars.indexOf(str[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min2, max2] = numberingSystemsUTF16[key];
            if (code >= min2 && code <= max2) {
              value += code - min2;
            }
          }
        }
      }
      return parseInt(value, 10);
    } else {
      return value;
    }
  }
  function digitRegex({ numberingSystem }, append2 = "") {
    return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append2}`);
  }

  // node_modules/luxon/src/impl/tokenParser.js
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  function intUnit(regex, post = (i) => i) {
    return { regex, deser: ([s2]) => post(parseDigits(s2)) };
  }
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  function fixListRegex(s2) {
    return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  }
  function stripInsensitivities(s2) {
    return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  }
  function oneOf(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
      };
    }
  }
  function offset2(regex, groups) {
    return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
  }
  function simple(regex) {
    return { regex, deser: ([s2]) => s2 };
  }
  function escapeToken(value) {
    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function unitForToken(token2, loc) {
    const one2 = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t4) => ({ regex: RegExp(escapeToken(t4.val)), deser: ([s2]) => s2, literal: true }), unitate = (t4) => {
      if (token2.literal) {
        return literal(t4);
      }
      switch (t4.val) {
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one2);
        case "a":
          return oneOf(loc.meridiems(), 0);
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        case "E":
        case "c":
          return intUnit(one2);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        case "Z":
        case "ZZ":
          return offset2(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset2(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal(t4);
      }
    };
    const unit2 = unitate(token2) || {
      invalidReason: MISSING_FTP
    };
    unit2.token = token2;
    return unit2;
  }
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  function tokenForPart(part, formatOpts, resolvedOpts) {
    const { type, value } = part;
    if (type === "literal") {
      const isSpace = /^\s+$/.test(value);
      return {
        literal: !isSpace,
        val: isSpace ? " " : value
      };
    }
    const style = formatOpts[type];
    let actualType = type;
    if (type === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return void 0;
  }
  function buildRegex(units) {
    const re2 = units.map((u) => u.regex).reduce((f, r3) => `${f}(${r3.source})`, "");
    return [`^${re2}$`, units];
  }
  function match2(input, regex, handlers4) {
    const matches = input.match(regex);
    if (matches) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers4) {
        if (hasOwnProperty(handlers4, i)) {
          const h = handlers4[i], groups = h.groups ? h.groups + 1 : 1;
          if (!h.literal && h.token) {
            all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches, all];
    } else {
      return [matches, {}];
    }
  }
  function dateTimeFromMatches(matches) {
    const toField = (token2) => {
      switch (token2) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined(matches.z)) {
      zone = IANAZone.create(matches.z);
    }
    if (!isUndefined(matches.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches.Z);
      }
      specificOffset = matches.Z;
    }
    if (!isUndefined(matches.q)) {
      matches.M = (matches.q - 1) * 3 + 1;
    }
    if (!isUndefined(matches.h)) {
      if (matches.h < 12 && matches.a === 1) {
        matches.h += 12;
      } else if (matches.h === 12 && matches.a === 0) {
        matches.h = 0;
      }
    }
    if (matches.G === 0 && matches.y) {
      matches.y = -matches.y;
    }
    if (!isUndefined(matches.u)) {
      matches.S = parseMillis(matches.u);
    }
    const vals = Object.keys(matches).reduce((r3, k) => {
      const f = toField(k);
      if (f) {
        r3[f] = matches[k];
      }
      return r3;
    }, {});
    return [vals, zone, specificOffset];
  }
  var dummyDateTimeCache = null;
  function getDummyDateTime() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  }
  function maybeExpandMacroToken(token2, locale3) {
    if (token2.literal) {
      return token2;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token2.val);
    const tokens2 = formatOptsToTokens(formatOpts, locale3);
    if (tokens2 == null || tokens2.includes(void 0)) {
      return token2;
    }
    return tokens2;
  }
  function expandMacroTokens(tokens2, locale3) {
    return Array.prototype.concat(...tokens2.map((t4) => maybeExpandMacroToken(t4, locale3)));
  }
  function explainFromTokens(locale3, input, format2) {
    const tokens2 = expandMacroTokens(Formatter.parseFormat(format2), locale3), units = tokens2.map((t4) => unitForToken(t4, locale3)), disqualifyingUnit = units.find((t4) => t4.invalidReason);
    if (disqualifyingUnit) {
      return { input, tokens: tokens2, invalidReason: disqualifyingUnit.invalidReason };
    } else {
      const [regexString, handlers4] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match2(input, regex, handlers4), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
      if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      }
      return { input, tokens: tokens2, regex, rawMatches, matches, result, zone, specificOffset };
    }
  }
  function parseFromTokens(locale3, input, format2) {
    const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale3, input, format2);
    return [result, zone, specificOffset, invalidReason];
  }
  function formatOptsToTokens(formatOpts, locale3) {
    if (!formatOpts) {
      return null;
    }
    const formatter = Formatter.create(locale3, formatOpts);
    const df = formatter.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
  }

  // node_modules/luxon/src/datetime.js
  var INVALID3 = "Invalid DateTime";
  var MAX_DATE = 864e13;
  function unsupportedZone(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  }
  function possiblyCachedWeekData(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  }
  function possiblyCachedLocalWeekData(dt) {
    if (dt.localWeekData === null) {
      dt.localWeekData = gregorianToWeek(
        dt.c,
        dt.loc.getMinDaysInFirstWeek(),
        dt.loc.getStartOfWeek()
      );
    }
    return dt.localWeekData;
  }
  function clone2(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({ ...current, ...alts, old: current });
  }
  function fixOffset(localTS, o, tz) {
    let utcGuess = localTS - o * 60 * 1e3;
    const o2 = tz.offset(utcGuess);
    if (o === o2) {
      return [utcGuess, o];
    }
    utcGuess -= (o2 - o) * 60 * 1e3;
    const o3 = tz.offset(utcGuess);
    if (o2 === o3) {
      return [utcGuess, o2];
    }
    return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
  }
  function tsToObj(ts, offset3) {
    ts += offset3 * 60 * 1e3;
    const d = new Date(ts);
    return {
      year: d.getUTCFullYear(),
      month: d.getUTCMonth() + 1,
      day: d.getUTCDate(),
      hour: d.getUTCHours(),
      minute: d.getUTCMinutes(),
      second: d.getUTCSeconds(),
      millisecond: d.getUTCMilliseconds()
    };
  }
  function objToTS(obj, offset3, zone) {
    return fixOffset(objToLocalTS(obj), offset3, zone);
  }
  function adjustTime(inst, dur) {
    const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c);
    let [ts, o] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o = inst.zone.offset(ts);
    }
    return { ts, o };
  }
  function parseDataToDateTime(parsed, parsedZone, opts, format2, text, specificOffset) {
    const { setZone, zone } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(
        new Invalid("unparsable", `the input "${text}" can't be parsed as ${format2}`)
      );
    }
  }
  function toTechFormat(dt, format2, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format2) : null;
  }
  function toISODate(o, extended) {
    const longFormat = o.c.year > 9999 || o.c.year < 0;
    let c = "";
    if (longFormat && o.c.year >= 0)
      c += "+";
    c += padStart(o.c.year, longFormat ? 6 : 4);
    if (extended) {
      c += "-";
      c += padStart(o.c.month);
      c += "-";
      c += padStart(o.c.day);
    } else {
      c += padStart(o.c.month);
      c += padStart(o.c.day);
    }
    return c;
  }
  function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
    let c = padStart(o.c.hour);
    if (extended) {
      c += ":";
      c += padStart(o.c.minute);
      if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
        c += ":";
      }
    } else {
      c += padStart(o.c.minute);
    }
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += padStart(o.c.second);
      if (o.c.millisecond !== 0 || !suppressMilliseconds) {
        c += ".";
        c += padStart(o.c.millisecond, 3);
      }
    }
    if (includeOffset) {
      if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
        c += "Z";
      } else if (o.o < 0) {
        c += "-";
        c += padStart(Math.trunc(-o.o / 60));
        c += ":";
        c += padStart(Math.trunc(-o.o % 60));
      } else {
        c += "+";
        c += padStart(Math.trunc(o.o / 60));
        c += ":";
        c += padStart(Math.trunc(o.o % 60));
      }
    }
    if (extendedZone) {
      c += "[" + o.zone.ianaName + "]";
    }
    return c;
  }
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
  function normalizeUnit(unit2) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit2.toLowerCase()];
    if (!normalized)
      throw new InvalidUnitError(unit2);
    return normalized;
  }
  function normalizeUnitWithLocalWeeks(unit2) {
    switch (unit2.toLowerCase()) {
      case "localweekday":
      case "localweekdays":
        return "localWeekday";
      case "localweeknumber":
      case "localweeknumbers":
        return "localWeekNumber";
      case "localweekyear":
      case "localweekyears":
        return "localWeekYear";
      default:
        return normalizeUnit(unit2);
    }
  }
  function quickDT(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
    let ts, o;
    if (!isUndefined(obj.year)) {
      for (const u of orderedUnits2) {
        if (isUndefined(obj[u])) {
          obj[u] = defaultUnitValues[u];
        }
      }
      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const offsetProvis = zone.offset(tsNow);
      [ts, o] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = tsNow;
    }
    return new DateTime({ ts, zone, loc, o });
  }
  function diffRelative(start2, end2, opts) {
    const round2 = isUndefined(opts.round) ? true : opts.round, format2 = (c, unit2) => {
      c = roundTo(c, round2 || opts.calendary ? 0 : 2, true);
      const formatter = end2.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit2);
    }, differ = (unit2) => {
      if (opts.calendary) {
        if (!end2.hasSame(start2, unit2)) {
          return end2.startOf(unit2).diff(start2.startOf(unit2), unit2).get(unit2);
        } else
          return 0;
      } else {
        return end2.diff(start2, unit2).get(unit2);
      }
    };
    if (opts.unit) {
      return format2(differ(opts.unit), opts.unit);
    }
    for (const unit2 of opts.units) {
      const count = differ(unit2);
      if (Math.abs(count) >= 1) {
        return format2(count, unit2);
      }
    }
    return format2(start2 > end2 ? -0 : 0, opts.units[opts.units.length - 1]);
  }
  function lastOpts(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  }
  var DateTime = class _DateTime {
    /**
     * @access private
     */
    constructor(config2) {
      const zone = config2.zone || Settings.defaultZone;
      let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined(config2.ts) ? Settings.now() : config2.ts;
      let c = null, o = null;
      if (!invalid) {
        const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
        if (unchanged) {
          [c, o] = [config2.old.c, config2.old.o];
        } else {
          const ot = zone.offset(this.ts);
          c = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
          c = invalid ? null : c;
          o = invalid ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config2.loc || Locale.create();
      this.invalid = invalid;
      this.weekData = null;
      this.localWeekData = null;
      this.c = c;
      this.o = o;
      this.isLuxonDateTime = true;
    }
    // CONSTRUCT
    /**
     * Create a DateTime for the current instant, in the system's time zone.
     *
     * Use Settings to override these default values if needed.
     * @example DateTime.now().toISO() //~> now in the ISO format
     * @return {DateTime}
     */
    static now() {
      return new _DateTime({});
    }
    /**
     * Create a local DateTime
     * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month, 1-indexed
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @example DateTime.local()                                  //~> now
     * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
     * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
     * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
     * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
     * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
     * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
     * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
     * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
     * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
     * @return {DateTime}
     */
    static local() {
      const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second2, millisecond2] = args;
      return quickDT({ year, month, day, hour, minute, second: second2, millisecond: millisecond2 }, opts);
    }
    /**
     * Create a DateTime in UTC
     * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @param {Object} options - configuration options for the DateTime
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @example DateTime.utc()                                              //~> now
     * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
     * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
     * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
     * @return {DateTime}
     */
    static utc() {
      const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second2, millisecond2] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({ year, month, day, hour, minute, second: second2, millisecond: millisecond2 }, opts);
    }
    /**
     * Create a DateTime from a JavaScript Date object. Uses the default zone.
     * @param {Date} date - a JavaScript Date object
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @return {DateTime}
     */
    static fromJSDate(date2, options = {}) {
      const ts = isDate(date2) ? date2.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return _DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return _DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new _DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options)
      });
    }
    /**
     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} milliseconds - a number of milliseconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromMillis(milliseconds2, options = {}) {
      if (!isNumber2(milliseconds2)) {
        throw new InvalidArgumentError(
          `fromMillis requires a numerical input, but received a ${typeof milliseconds2} with value ${milliseconds2}`
        );
      } else if (milliseconds2 < -MAX_DATE || milliseconds2 > MAX_DATE) {
        return _DateTime.invalid("Timestamp out of range");
      } else {
        return new _DateTime({
          ts: milliseconds2,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    /**
     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} seconds - a number of seconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromSeconds(seconds2, options = {}) {
      if (!isNumber2(seconds2)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new _DateTime({
          ts: seconds2 * 1e3,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    /**
     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.year - a year, such as 1987
     * @param {number} obj.month - a month, 1-12
     * @param {number} obj.day - a day of the month, 1-31, depending on the month
     * @param {number} obj.ordinal - day of the year, 1-365 or 366
     * @param {number} obj.weekYear - an ISO week year
     * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
     * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
     * @param {number} obj.localWeekYear - a week year, according to the locale
     * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
     * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
     * @param {number} obj.hour - hour of the day, 0-23
     * @param {number} obj.minute - minute of the hour, 0-59
     * @param {number} obj.second - second of the minute, 0-59
     * @param {number} obj.millisecond - millisecond of the second, 0-999
     * @param {Object} opts - options for creating this DateTime
     * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
     * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
     * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
     * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
     * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
     * @return {DateTime}
     */
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return _DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const loc = Locale.fromObject(opts);
      const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
      const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
      const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits2;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u of units) {
        const v = normalized[u];
        if (!isUndefined(v)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u] = defaultValues[u];
        } else {
          normalized[u] = objNow[u];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid) {
        return _DateTime.invalid(invalid);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return _DateTime.invalid(
          "mismatched weekday",
          `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
        );
      }
      return inst;
    }
    /**
     * Create a DateTime from an ISO 8601 string
     * @param {string} text - the ISO string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @example DateTime.fromISO('2016-05-25T09:08:34.123')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
     * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
     * @example DateTime.fromISO('2016-W05-4')
     * @return {DateTime}
     */
    static fromISO(text, opts = {}) {
      const [vals, parsedZone] = parseISODate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
    }
    /**
     * Create a DateTime from an RFC 2822 string
     * @param {string} text - the RFC 2822 string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
     * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
     * @return {DateTime}
     */
    static fromRFC2822(text, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
    }
    /**
     * Create a DateTime from an HTTP header date
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @param {string} text - the HTTP header date
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
     * @return {DateTime}
     */
    static fromHTTP(text, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    /**
     * Create a DateTime from an input string and format string.
     * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromFormat(text, fmt, opts = {}) {
      if (isUndefined(text) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const { locale: locale3 = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
        locale: locale3,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
      if (invalid) {
        return _DateTime.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
      }
    }
    /**
     * @deprecated use fromFormat instead
     */
    static fromString(text, fmt, opts = {}) {
      return _DateTime.fromFormat(text, fmt, opts);
    }
    /**
     * Create a DateTime from a SQL date, time, or datetime
     * Defaults to en-US if no locale has been specified, regardless of the system's locale
     * @param {string} text - the string to parse
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @example DateTime.fromSQL('2017-05-15')
     * @example DateTime.fromSQL('2017-05-15 09:12:34')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
     * @example DateTime.fromSQL('09:12:34.342')
     * @return {DateTime}
     */
    static fromSQL(text, opts = {}) {
      const [vals, parsedZone] = parseSQL(text);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
    }
    /**
     * Create an invalid DateTime.
     * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {DateTime}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new _DateTime({ invalid });
      }
    }
    /**
     * Check if an object is an instance of DateTime. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDateTime(o) {
      return o && o.isLuxonDateTime || false;
    }
    /**
     * Produce the format string for a set of options
     * @param formatOpts
     * @param localeOpts
     * @returns {string}
     */
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t4) => t4 ? t4.val : null).join("");
    }
    /**
     * Produce the the fully expanded format token for the locale
     * Does NOT quote characters, so quoted tokens will not round trip correctly
     * @param fmt
     * @param localeOpts
     * @returns {string}
     */
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t4) => t4.val).join("");
    }
    // INFO
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
     * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
     * @return {number}
     */
    get(unit2) {
      return this[unit2];
    }
    /**
     * Returns whether the DateTime is valid. Invalid DateTimes occur when:
     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
     * * The DateTime was created by an operation on another invalid date
     * @type {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */
    get zone() {
      return this._zone;
    }
    /**
     * Get the name of the time zone.
     * @type {string}
     */
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
     * @type {number}
     */
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    /**
     * Returns true if this date is on a weekend according to the locale, false otherwise
     * @returns {boolean}
     */
    get isWeekend() {
      return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
    }
    /**
     * Get the day of the week according to the locale.
     * 1 is the first day of the week and 7 is the last day of the week.
     * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
     * @returns {number}
     */
    get localWeekday() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
    }
    /**
     * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
     * because the week can start on different days of the week (see localWeekday) and because a different number of days
     * is required for a week to count as the first week of a year.
     * @returns {number}
     */
    get localWeekNumber() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
     * differently, see localWeekNumber.
     * @returns {number}
     */
    get localWeekYear() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
    }
    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */
    get monthShort() {
      return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */
    get monthLong() {
      return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.now().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
      }
    }
    /**
     * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
     * in this DateTime's zone. During DST changes local time can be ambiguous, for example
     * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
     * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
     * @returns {DateTime[]}
     */
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 864e5;
      const minuteMs = 6e4;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o2 = this.zone.offset(localTS - oLater * minuteMs);
      if (o1 === o2) {
        return [this];
      }
      const ts1 = localTS - o1 * minuteMs;
      const ts2 = localTS - o2 * minuteMs;
      const c1 = tsToObj(ts1, o1);
      const c2 = tsToObj(ts2, o2);
      if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
        return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
      }
      return [this];
    }
    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's local week year
     * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
     * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
     * @type {number}
     */
    get weeksInLocalWeekYear() {
      return this.isValid ? weeksInWeekYear(
        this.localWeekYear,
        this.loc.getMinDaysInFirstWeek(),
        this.loc.getStartOfWeek()
      ) : NaN;
    }
    /**
     * Returns the resolved Intl options for this DateTime.
     * This is useful in understanding the behavior of formatting methods
     * @param {Object} opts - the same options as toLocaleString
     * @return {Object}
     */
    resolvedLocaleOptions(opts = {}) {
      const { locale: locale3, numberingSystem, calendar: calendar2 } = Formatter.create(
        this.loc.clone(opts),
        opts
      ).resolvedOptions(this);
      return { locale: locale3, numberingSystem, outputCalendar: calendar2 };
    }
    // TRANSFORM
    /**
     * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
     *
     * Equivalent to {@link DateTime#setZone}('utc')
     * @param {number} [offset=0] - optionally, an offset from UTC in minutes
     * @param {Object} [opts={}] - options to pass to `setZone()`
     * @return {DateTime}
     */
    toUTC(offset3 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset3), opts);
    }
    /**
     * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
     *
     * Equivalent to `setZone('local')`
     * @return {DateTime}
     */
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    /**
     * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
     *
     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
     * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
     * @param {Object} opts - options
     * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
     * @return {DateTime}
     */
    setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return _DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone2(this, { ts: newTS, zone });
      }
    }
    /**
     * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
     * @param {Object} properties - the properties to set
     * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
     * @return {DateTime}
     */
    reconfigure({ locale: locale3, numberingSystem, outputCalendar } = {}) {
      const loc = this.loc.clone({ locale: locale3, numberingSystem, outputCalendar });
      return clone2(this, { loc });
    }
    /**
     * "Set" the locale. Returns a newly-constructed DateTime.
     * Just a convenient alias for reconfigure({ locale })
     * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
     * @return {DateTime}
     */
    setLocale(locale3) {
      return this.reconfigure({ locale: locale3 });
    }
    /**
     * "Set" the values of specified units. Returns a newly-constructed DateTime.
     * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
     *
     * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
     * They cannot be mixed with ISO-week units like `weekday`.
     * @param {Object} values - a mapping of units to numbers
     * @example dt.set({ year: 2017 })
     * @example dt.set({ hour: 8, minute: 30 })
     * @example dt.set({ weekday: 5 })
     * @example dt.set({ year: 2005, ordinal: 234 })
     * @return {DateTime}
     */
    set(values) {
      if (!this.isValid)
        return this;
      const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
      const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
      const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian(
          { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
          minDaysInFirstWeek,
          startOfWeek
        );
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
      } else {
        mixed = { ...this.toObject(), ...normalized };
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o] = objToTS(mixed, this.o, this.zone);
      return clone2(this, { ts, o });
    }
    /**
     * Add a period of time to this DateTime and return the resulting DateTime
     *
     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @example DateTime.now().plus(123) //~> in 123 milliseconds
     * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
     * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
     * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
     * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
     * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
     * @return {DateTime}
     */
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return clone2(this, adjustTime(this, dur));
    }
    /**
     * Subtract a period of time to this DateTime and return the resulting DateTime
     * See {@link DateTime#plus}
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     @return {DateTime}
     */
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone2(this, adjustTime(this, dur));
    }
    /**
     * "Set" this DateTime to the beginning of a unit of time.
     * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
     * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
     * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
     * @return {DateTime}
     */
    startOf(unit2, { useLocaleWeeks = false } = {}) {
      if (!this.isValid)
        return this;
      const o = {}, normalizedUnit = Duration.normalizeUnit(unit2);
      switch (normalizedUnit) {
        case "years":
          o.month = 1;
        case "quarters":
        case "months":
          o.day = 1;
        case "weeks":
        case "days":
          o.hour = 0;
        case "hours":
          o.minute = 0;
        case "minutes":
          o.second = 0;
        case "seconds":
          o.millisecond = 0;
          break;
        case "milliseconds":
          break;
      }
      if (normalizedUnit === "weeks") {
        if (useLocaleWeeks) {
          const startOfWeek = this.loc.getStartOfWeek();
          const { weekday } = this;
          if (weekday < startOfWeek) {
            o.weekNumber = this.weekNumber - 1;
          }
          o.weekday = startOfWeek;
        } else {
          o.weekday = 1;
        }
      }
      if (normalizedUnit === "quarters") {
        const q = Math.ceil(this.month / 3);
        o.month = (q - 1) * 3 + 1;
      }
      return this.set(o);
    }
    /**
     * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
     * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
     * @return {DateTime}
     */
    endOf(unit2, opts) {
      return this.isValid ? this.plus({ [unit2]: 1 }).startOf(unit2, opts).minus(1) : this;
    }
    // OUTPUT
    /**
     * Returns a string representation of this DateTime formatted according to the specified format string.
     * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
     * Defaults to en-US if no locale has been specified, regardless of the system's locale.
     * @param {string} fmt - the format string
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
     * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
     * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
     * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
    }
    /**
     * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
     * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
     * of the DateTime in the assigned locale.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toLocaleString(); //=> 4/20/2017
     * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
     * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
     * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
     * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
     * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
     * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
    }
    /**
     * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
     * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
     * @example DateTime.now().toLocaleParts(); //=> [
     *                                   //=>   { type: 'day', value: '25' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'month', value: '05' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'year', value: '1982' }
     *                                   //=> ]
     */
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
     * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
     * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
     * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
     * @return {string}
     */
    toISO({
      format: format2 = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      const ext = format2 === "extended";
      let c = toISODate(this, ext);
      c += "T";
      c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's date component
     * @param {Object} opts - options
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
     * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
     * @return {string}
     */
    toISODate({ format: format2 = "extended" } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format2 === "extended");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's week date
     * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
     * @return {string}
     */
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's time component
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
     * @return {string}
     */
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format: format2 = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      let c = includePrefix ? "T" : "";
      return c + toISOTime(
        this,
        format2 === "extended",
        suppressSeconds,
        suppressMilliseconds,
        includeOffset,
        extendedZone
      );
    }
    /**
     * Returns an RFC 2822-compatible string representation of this DateTime
     * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
     * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
     * @return {string}
     */
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
     * Specifically, the string conforms to RFC 1123.
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
     * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
     * @return {string}
     */
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Date
     * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
     * @return {string}
     */
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Time
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc().toSQL() //=> '05:15:16.345'
     * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
     * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
     * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
     * @return {string}
     */
    toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
     * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
     * @return {string}
     */
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    /**
     * Returns a string representation of this DateTime appropriate for debugging
     * @return {string}
     */
    toString() {
      return this.isValid ? this.toISO() : INVALID3;
    }
    /**
     * Returns a string representation of this DateTime appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
      } else {
        return `DateTime { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Returns the epoch milliseconds of this DateTime.
     * @return {number}
     */
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    /**
     * Returns the epoch seconds of this DateTime.
     * @return {number}
     */
    toSeconds() {
      return this.isValid ? this.ts / 1e3 : NaN;
    }
    /**
     * Returns the epoch seconds (as a whole number) of this DateTime.
     * @return {number}
     */
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
    }
    /**
     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns a BSON serializable equivalent to this DateTime.
     * @return {Date}
     */
    toBSON() {
      return this.toJSDate();
    }
    /**
     * Returns a JavaScript object with this DateTime's year, month, day, and so on.
     * @param opts - options for generating the object
     * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
     * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
     * @return {Object}
     */
    toObject(opts = {}) {
      if (!this.isValid)
        return {};
      const base = { ...this.c };
      if (opts.includeConfig) {
        base.outputCalendar = this.outputCalendar;
        base.numberingSystem = this.loc.numberingSystem;
        base.locale = this.loc.locale;
      }
      return base;
    }
    /**
     * Returns a JavaScript Date equivalent to this DateTime.
     * @return {Date}
     */
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    // COMPARE
    /**
     * Return the difference between two DateTimes as a Duration.
     * @param {DateTime} otherDateTime - the DateTime to compare this one to
     * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example
     * var i1 = DateTime.fromISO('1982-05-25T09:45'),
     *     i2 = DateTime.fromISO('1983-10-14T10:30');
     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
     * @return {Duration}
     */
    diff(otherDateTime, unit2 = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
      const units = maybeArray(unit2).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    /**
     * Return the difference between this DateTime and right now.
     * See {@link DateTime#diff}
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    diffNow(unit2 = "milliseconds", opts = {}) {
      return this.diff(_DateTime.now(), unit2, opts);
    }
    /**
     * Return an Interval spanning between this DateTime and another DateTime
     * @param {DateTime} otherDateTime - the other end point of the Interval
     * @return {Interval}
     */
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    /**
     * Return whether this DateTime is in the same unit of time as another DateTime.
     * Higher-order units must also be identical for this function to return `true`.
     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
     * @param {DateTime} otherDateTime - the other DateTime
     * @param {string} unit - the unit of time to check sameness on
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
     * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
     * @return {boolean}
     */
    hasSame(otherDateTime, unit2, opts) {
      if (!this.isValid)
        return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
      return adjustedToZone.startOf(unit2, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit2, opts);
    }
    /**
     * Equality check
     * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
     * To compare just the millisecond values, use `+dt1 === +dt2`.
     * @param {DateTime} other - the other DateTime
     * @return {boolean}
     */
    equals(other) {
      return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
    }
    /**
     * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
     * platform supports Intl.RelativeTimeFormat. Rounds down by default.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
     * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
     * @param {boolean} [options.round=true] - whether to round the numbers in the output.
     * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
     * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
     * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
     * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
     * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
     * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
     */
    toRelative(options = {}) {
      if (!this.isValid)
        return null;
      const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit2 = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit2 = void 0;
      }
      return diffRelative(base, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit: unit2
      });
    }
    /**
     * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
     * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
     * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
     */
    toRelativeCalendar(options = {}) {
      if (!this.isValid)
        return null;
      return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    /**
     * Return the min of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
     * @return {DateTime} the min DateTime, or undefined if called with no argument
     */
    static min(...dateTimes) {
      if (!dateTimes.every(_DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }
    /**
     * Return the max of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
     * @return {DateTime} the max DateTime, or undefined if called with no argument
     */
    static max(...dateTimes) {
      if (!dateTimes.every(_DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }
    // MISC
    /**
     * Explain how a string would be parsed by fromFormat()
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see description)
     * @param {Object} options - options taken by fromFormat()
     * @return {Object}
     */
    static fromFormatExplain(text, fmt, options = {}) {
      const { locale: locale3 = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
        locale: locale3,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text, fmt);
    }
    /**
     * @deprecated use fromFormatExplain instead
     */
    static fromStringExplain(text, fmt, options = {}) {
      return _DateTime.fromFormatExplain(text, fmt, options);
    }
    // FORMAT PRESETS
    /**
     * {@link DateTime#toLocaleString} format like 10/14/1983
     * @type {Object}
     */
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED() {
      return DATE_MED;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */
    static get DATE_FULL() {
      return DATE_FULL;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  };
  function friendlyDateTime(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(
        `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
      );
    }
  }

  // src/lib/math.ts
  function interpolate2(x1, y1, x2, y2, x) {
    return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
  }
  function interpolateClamped(x1, y1, x2, y2, x) {
    const min2 = Math.min(y1, y2);
    const max2 = Math.max(y1, y2);
    const interpolated = interpolate2(x1, y1, x2, y2, x);
    return clamp2(interpolated, min2, max2);
  }
  function clamp2(a, min2, max2) {
    return Math.min(max2, Math.max(a, min2));
  }

  // src/lib/weather.ts
  var oneHour = Duration.fromObject({ hours: 1 });
  var BinnedTemperatures = class {
    constructor(entries) {
      this.hoursByTempF = /* @__PURE__ */ new Map();
      this.sortedBins = [];
      this.sortedTempF = [];
      for (let entry of entries) {
        this.sortedTempF.push(entry.outsideAirTempF);
        this.hoursByTempF.set(
          Math.round(entry.outsideAirTempF),
          (this.hoursByTempF.get(entry.outsideAirTempF) || 0) + 1
        );
      }
      this.sortedTempF.sort();
      const binEntries = Array.from(this.hoursByTempF.entries());
      binEntries.sort((a, b) => a[0] - b[0]);
      for (let [outsideAirTempF, hourCount] of binEntries) {
        this.sortedBins.push({ outsideAirTempF, hourCount });
      }
    }
    getTempAtPercentile(percentile) {
      const idx = Math.floor(percentile / 100 * (this.sortedTempF.length - 1));
      return this.sortedTempF[idx];
    }
    forEachBin(cb) {
      this.sortedBins.forEach(cb);
    }
  };
  var JSONBackedHourlyWeatherSource = class {
    constructor(entries) {
      this.entryByHour = {};
      for (let entry of entries) {
        const dt = DateTime.fromISO(entry.datetime);
        this.entryByHour[this.hourKey(dt)] = entry;
      }
    }
    hourKey(datetime) {
      const dt = datetime.toUTC();
      return `${dt.year}-${dt.month}-${dt.day} ${dt.hour}:00`;
    }
    getWeatherForHour(localTime) {
      const hourKey = this.hourKey(localTime);
      if (!(hourKey in this.entryByHour)) {
        throw new Error(`No entry for ${hourKey}`);
      }
      return this.entryByHour[hourKey];
    }
    getWeather(localTime) {
      const utc = localTime.toUTC();
      const startOfHour = utc.startOf("hour");
      const endOfHour = startOfHour.plus(oneHour);
      const startWeather = this.getWeatherForHour(startOfHour);
      if (localTime.equals(startOfHour)) {
        return startWeather;
      }
      const endWeather = this.getWeatherForHour(endOfHour);
      const startMillis = startOfHour.toMillis();
      const endMillis = endOfHour.toMillis();
      const targetMillis = utc.toMillis();
      const outsideAirTempF = interpolate2(
        startMillis,
        startWeather.outsideAirTempF,
        endMillis,
        endWeather.outsideAirTempF,
        targetMillis
      );
      const relativeHumidityPercent = interpolate2(
        startMillis,
        startWeather.relativeHumidityPercent,
        endMillis,
        endWeather.relativeHumidityPercent,
        targetMillis
      );
      const windSpeedMph = interpolate2(
        startMillis,
        startWeather.windSpeedMph,
        endMillis,
        endWeather.windSpeedMph,
        targetMillis
      );
      const cloudCoverPercent = interpolate2(
        startMillis,
        startWeather.cloudCoverPercent,
        endMillis,
        endWeather.cloudCoverPercent,
        targetMillis
      );
      const solarIrradiance = {
        altitudeDegrees: interpolate2(
          startMillis,
          startWeather.solarIrradiance.altitudeDegrees,
          endMillis,
          endWeather.solarIrradiance.altitudeDegrees,
          targetMillis
        ),
        wattsPerSquareMeter: interpolate2(
          startMillis,
          startWeather.solarIrradiance.wattsPerSquareMeter,
          endMillis,
          endWeather.solarIrradiance.wattsPerSquareMeter,
          targetMillis
        )
      };
      if (solarIrradiance.altitudeDegrees < 0) {
        solarIrradiance.wattsPerSquareMeter = 0;
      }
      return {
        outsideAirTempF,
        relativeHumidityPercent,
        windSpeedMph,
        cloudCoverPercent,
        solarIrradiance
      };
    }
  };

  // src/app/fetch.ts
  async function fetchJSON(url, init3) {
    const response = await fetch(url, init3);
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    return await response.json();
  }

  // node_modules/jotai/esm/vanilla/utils.mjs
  var import_meta3 = {};
  var RESET = Symbol(
    (import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" ? "RESET" : ""
  );
  var isPromiseLike3 = (x) => typeof (x == null ? void 0 : x.then) === "function";
  function createJSONStorage(getStringStorage = () => {
    try {
      return window.localStorage;
    } catch (e3) {
      if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production") {
        if (typeof window !== "undefined") {
          console.warn(e3);
        }
      }
      return void 0;
    }
  }, options) {
    let lastStr;
    let lastValue;
    const storage = {
      getItem: (key, initialValue) => {
        var _a7, _b5;
        const parse3 = (str2) => {
          str2 = str2 || "";
          if (lastStr !== str2) {
            try {
              lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);
            } catch (e3) {
              return initialValue;
            }
            lastStr = str2;
          }
          return lastValue;
        };
        const str = (_b5 = (_a7 = getStringStorage()) == null ? void 0 : _a7.getItem(key)) != null ? _b5 : null;
        if (isPromiseLike3(str)) {
          return str.then(parse3);
        }
        return parse3(str);
      },
      setItem: (key, newValue) => {
        var _a7;
        return (_a7 = getStringStorage()) == null ? void 0 : _a7.setItem(
          key,
          JSON.stringify(newValue, options == null ? void 0 : options.replacer)
        );
      },
      removeItem: (key) => {
        var _a7;
        return (_a7 = getStringStorage()) == null ? void 0 : _a7.removeItem(key);
      }
    };
    if (typeof window !== "undefined" && typeof window.addEventListener === "function" && window.Storage) {
      storage.subscribe = (key, callback, initialValue) => {
        if (!(getStringStorage() instanceof window.Storage)) {
          return () => {
          };
        }
        const storageEventCallback = (e3) => {
          if (e3.storageArea === getStringStorage() && e3.key === key) {
            let newValue;
            try {
              newValue = JSON.parse(e3.newValue || "");
            } catch (e22) {
              newValue = initialValue;
            }
            callback(newValue);
          }
        };
        window.addEventListener("storage", storageEventCallback);
        return () => {
          window.removeEventListener("storage", storageEventCallback);
        };
      };
    }
    return storage;
  }
  var defaultStorage = createJSONStorage();
  var getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);
  var cache1 = /* @__PURE__ */ new WeakMap();
  var memo22 = (create, dep1, dep2) => {
    const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);
    return getCached(create, cache2, dep2);
  };
  var isPromise = (x) => x instanceof Promise;
  var defaultFallback = () => void 0;
  function unwrap(anAtom, fallback = defaultFallback) {
    return memo22(
      () => {
        const promiseErrorCache = /* @__PURE__ */ new WeakMap();
        const promiseResultCache = /* @__PURE__ */ new WeakMap();
        const refreshAtom = atom(0);
        if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production") {
          refreshAtom.debugPrivate = true;
        }
        const promiseAndValueAtom = atom(
          (get3, { setSelf }) => {
            get3(refreshAtom);
            const prev2 = get3(promiseAndValueAtom);
            const promise = get3(anAtom);
            if (!isPromise(promise)) {
              return { v: promise };
            }
            if (promise !== (prev2 == null ? void 0 : prev2.p)) {
              if (promise.status === "fulfilled") {
                promiseResultCache.set(promise, promise.value);
              } else if (promise.status === "rejected") {
                promiseErrorCache.set(promise, promise.reason);
              } else {
                promise.then(
                  (v) => promiseResultCache.set(promise, v),
                  (e3) => promiseErrorCache.set(promise, e3)
                ).finally(setSelf);
              }
            }
            if (promiseErrorCache.has(promise)) {
              throw promiseErrorCache.get(promise);
            }
            if (promiseResultCache.has(promise)) {
              return {
                p: promise,
                v: promiseResultCache.get(promise)
              };
            }
            if (prev2 && "v" in prev2) {
              return { p: promise, f: fallback(prev2.v), v: prev2.v };
            }
            return { p: promise, f: fallback() };
          },
          (_get, set) => {
            set(refreshAtom, (c) => c + 1);
          }
        );
        promiseAndValueAtom.init = void 0;
        if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production") {
          promiseAndValueAtom.debugPrivate = true;
        }
        return atom(
          (get3) => {
            const state2 = get3(promiseAndValueAtom);
            if ("f" in state2) {
              return state2.f;
            }
            return state2.v;
          },
          (_get, set, ...args) => set(anAtom, ...args)
        );
      },
      anAtom,
      fallback
    );
  }

  // src/app/app-state/utils.ts
  function asyncAtomOrNull(read2) {
    return unwrap(atom(read2), () => null);
  }
  function overridableDerivedAtom(read2) {
    const timestampedDerivedAtom = atom((get3) => {
      const value = read2(get3);
      return { value, timestamp: performance.now() };
    });
    const overrideAtom = atom(null);
    const timestampedWriteableAtom = atom((get3) => {
      const override = get3(overrideAtom);
      if (override == null)
        return null;
      return { value: override.value, timestamp: performance.now() };
    });
    return atom(
      (get3) => {
        const a = get3(timestampedDerivedAtom);
        const b = get3(timestampedWriteableAtom);
        if (b == null || b.timestamp < a.timestamp) {
          return a.value;
        } else {
          return b.value;
        }
      },
      (get3, set, value) => {
        set(overrideAtom, { value });
      }
    );
  }

  // src/app/app-state/canadian-weather-state.ts
  var caPostalCodesJsonAtom = asyncAtomOrNull(
    async (get3, { signal }) => {
      return await fetchJSON("./data/ca-postal-codes.json", {
        signal
      });
    }
  );
  var locationInfoAtom = atom((get3) => {
    const postalCode = get3(postalCodeAtom);
    const caPostalCodesJson = get3(caPostalCodesJsonAtom);
    if (postalCode == null || !caPostalCodesJson || !/^[A-Za-z][0-9][A-Za-z] ?[0-9][A-Za-z][0-9]$/.exec(postalCode)) {
      return null;
    }
    const forwardSortationArea = postalCode.substring(0, 3).toUpperCase();
    if (!(forwardSortationArea in caPostalCodesJson)) {
      return null;
    }
    const info = {
      ...caPostalCodesJson[forwardSortationArea],
      forwardSortationArea
    };
    return info;
  });
  var simplePlaceNameAtom = atom((get3) => {
    const locationInfo = get3(locationInfoAtom);
    if (locationInfo == null) {
      return null;
    }
    return locationInfo.placeName.replace(/\([^)]*\)/g, "");
  });
  var weatherInfoAtom = asyncAtomOrNull(
    async (get3, { signal }) => {
      const locationInfo = get3(locationInfoAtom);
      if (!locationInfo) {
        return null;
      }
      const json = await fetchJSON(
        `https://hvac-sim-public.s3.amazonaws.com/weather/ca/era/2023-era5-${locationInfo.forwardSortationArea}.json`,
        { signal }
      );
      return {
        timezoneName: json.timezoneName,
        elevationMeters: json.elevationMeters,
        weatherSource: new JSONBackedHourlyWeatherSource(json.weather),
        binnedTemperatures: new BinnedTemperatures(json.weather)
      };
    }
  );
  var elevationFeetAtom = atom((get3) => {
    const weatherInfo = get3(weatherInfoAtom);
    if (weatherInfo == null)
      return null;
    return metersToFeet(weatherInfo.elevationMeters);
  });

  // src/lib/building-geometry.ts
  var BuildingGeometry = class {
    constructor(geometry) {
      const {
        floorSpaceSqFt,
        ceilingHeightFt,
        numAboveGroundStories,
        lengthToWidthRatio,
        hasConditionedBasement
      } = geometry;
      const numFloors = numAboveGroundStories + (hasConditionedBasement ? 1 : 0);
      const footPrintSquareFeet = floorSpaceSqFt / numFloors;
      const footPrintLengthFeet = Math.sqrt(
        footPrintSquareFeet / lengthToWidthRatio
      );
      const footPrintWidthFeet = footPrintSquareFeet / footPrintLengthFeet;
      const perimeterFeet = footPrintLengthFeet * 2 + footPrintWidthFeet * 2;
      const exteriorWallsAndWindowsSquareFeet = perimeterFeet * ceilingHeightFt * numAboveGroundStories;
      const percentageWallsThatAreWindows = 20;
      const windowsSquareFeet = percentageWallsThatAreWindows / 100 * exteriorWallsAndWindowsSquareFeet;
      const exteriorWallsSquareFeeet = exteriorWallsAndWindowsSquareFeet - windowsSquareFeet;
      this.exteriorWallsSqFt = exteriorWallsSquareFeeet;
      this.windowsSqFt = windowsSquareFeet;
      this.ceilingSqFt = footPrintSquareFeet;
      this.exteriorFloorSqFt = footPrintSquareFeet;
      const airVolumeCubicFt = footPrintSquareFeet * ceilingHeightFt * numFloors;
      const airBtusPerLbDegreeF = 0.24;
      const airLbsPerCubicFoot = 0.075;
      const fractionOfThermalMassGivenToAir = 0.03;
      this.btusPerDegreeF = airVolumeCubicFt * airLbsPerCubicFoot * airBtusPerLbDegreeF / fractionOfThermalMassGivenToAir;
    }
  };

  // src/lib/thermal-loads.ts
  var OccupantsLoadSource = class {
    constructor(numOccupants) {
      this.numOccupants = numOccupants;
      this.name = "occupants";
    }
    getBtusPerHour(localDateTime, insideAirTempF, weather) {
      const hour = localDateTime.hour;
      if (9 < hour && hour < 14) {
        return 0;
      }
      const isAwake = 6 < hour && hour < 22;
      const perOccupantSensible = 230;
      const perOccupantLatent = 200;
      const sleepingDeflator = isAwake ? 1 : 0.85;
      return this.numOccupants * (perOccupantSensible + perOccupantLatent) * sleepingDeflator;
    }
  };
  var ConductionConvectionLoadSource = class {
    constructor(options) {
      this.options = options;
      this.name = "conduction-convection";
    }
    getBtusPerHour(localDateTime, insideAirTempF, weather) {
      const deltaTempF = weather.outsideAirTempF - insideAirTempF;
      const {
        exteriorWallsSqFt: wallsSqFt,
        windowsSqFt,
        ceilingSqFt,
        exteriorFloorSqFt: floorSqFt
      } = this.options.geometry;
      const wallUFactor = 0.086;
      const windowUFactor = 0.751;
      const ceilingUFactor = 0.076;
      const floorUFactor = 0.101;
      const wallLoadbtusPerHour = wallUFactor * wallsSqFt * deltaTempF * this.options.envelopeModifier;
      const ceilingLoadbtusPerHour = ceilingUFactor * ceilingSqFt * deltaTempF * this.options.envelopeModifier;
      const floorLoadbtusPerHour = floorUFactor * floorSqFt * deltaTempF * this.options.envelopeModifier;
      const windowCoolingDeflating = weather.outsideAirTempF > insideAirTempF ? 0.9 : 1;
      const windowLoadbtusPerHour = windowUFactor * windowsSqFt * windowCoolingDeflating * deltaTempF * this.options.envelopeModifier;
      const totalBtusPerHour = wallLoadbtusPerHour + windowLoadbtusPerHour + ceilingLoadbtusPerHour + floorLoadbtusPerHour;
      return totalBtusPerHour;
    }
  };
  var InfiltrationLoadSource = class {
    constructor(options) {
      this.options = options;
      this.name = "infiltration";
    }
    getBtusPerHour(localDateTime, insideAirTempF, weather) {
      let uFactor;
      if (weather.windSpeedMph <= 5) {
        uFactor = 47 / 894;
      } else {
        uFactor = 87 / 894;
      }
      let infiltrationMultiplier;
      const isColderOutside = weather.outsideAirTempF < insideAirTempF;
      if (this.options.envelopeModifier <= 0.6) {
        infiltrationMultiplier = interpolateClamped(
          0.3,
          1,
          0.6,
          isColderOutside ? 2.8 : 2.7,
          this.options.envelopeModifier
        );
      } else {
        infiltrationMultiplier = interpolateClamped(
          0.6,
          isColderOutside ? 2.8 : 2.7,
          1.05,
          isColderOutside ? 5.8 : 5.6,
          this.options.envelopeModifier
        );
      }
      let deltaT = weather.outsideAirTempF - insideAirTempF;
      let infiltrationGainbtusPerHour = uFactor * this.options.geometry.windowsSqFt * deltaT * infiltrationMultiplier;
      if (weather.relativeHumidityPercent > 50) {
        infiltrationGainbtusPerHour += 808 / 894 * this.options.geometry.windowsSqFt * infiltrationMultiplier;
      }
      return infiltrationGainbtusPerHour;
    }
  };
  var SolarGainLoadSource = class {
    constructor(options) {
      this.options = options;
      this.name = "solar-gain";
    }
    getBtusPerHour(localDateTime, insideAirTempF, conditions) {
      const { solarIrradiance } = conditions;
      if (solarIrradiance.altitudeDegrees < 0) {
        return 0;
      }
      const strengthUnderClouds = 0.15;
      const cloudCoverMultiplier = 1 - conditions.cloudCoverPercent / 100 + conditions.cloudCoverPercent / 100 * strengthUnderClouds;
      const altitudeRad = solarIrradiance.altitudeDegrees * (Math.PI / 180);
      const horizontalIrradiance = solarIrradiance.wattsPerSquareMeter * Math.cos(altitudeRad);
      const verticalIrradiance = solarIrradiance.wattsPerSquareMeter * Math.sin(altitudeRad);
      const horizontalIrradianceMultiplier = horizontalIrradiance / 883 * cloudCoverMultiplier;
      const veriticalIrradianceMultiplier = verticalIrradiance / 535 * cloudCoverMultiplier;
      const ceilingSolarGainPerSqFt = 1.4;
      const windowSolarGainPerSqFt = 3.5;
      const wallsSolarGainPerSqft = 0.5;
      const {
        windowsSqFt,
        exteriorWallsSqFt: wallsSqFt,
        ceilingSqFt
      } = this.options.geometry;
      const ceilingGain = ceilingSolarGainPerSqFt * ceilingSqFt * this.options.solarModifier * veriticalIrradianceMultiplier;
      const windowGain = windowSolarGainPerSqFt * windowsSqFt * this.options.solarModifier * horizontalIrradianceMultiplier;
      const wallGain = wallsSolarGainPerSqft * wallsSqFt * this.options.solarModifier * horizontalIrradianceMultiplier;
      return ceilingGain + windowGain + wallGain;
    }
  };

  // src/app/app-state/loads-state.ts
  var buildingGeometryAtom = atom((get3) => {
    const floorSpaceSqFt = get3(floorSpaceSqFtAtom);
    if (floorSpaceSqFt == null)
      return null;
    return new BuildingGeometry({
      floorSpaceSqFt,
      ceilingHeightFt: 9,
      numAboveGroundStories: 2,
      lengthToWidthRatio: 3,
      hasConditionedBasement: true
    });
  });
  var loadSourcesAtom = atom((get3) => {
    const buildingGeometry = get3(buildingGeometryAtom);
    if (buildingGeometry == null)
      return null;
    return [
      new OccupantsLoadSource(2),
      new SolarGainLoadSource({ geometry: buildingGeometry, solarModifier: 1 }),
      new ConductionConvectionLoadSource({
        geometry: buildingGeometry,
        envelopeModifier: 0.65
      }),
      new InfiltrationLoadSource({
        geometry: buildingGeometry,
        envelopeModifier: 0.65
      })
    ];
  });

  // src/app/views/forms.tsx
  var import_react74 = __toESM(require_react());

  // node_modules/@chakra-ui/icons/dist/chunk-SK7D2XJH.mjs
  var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
  var QuestionOutlineIcon = createIcon({
    displayName: "QuestionOutlineIcon",
    path: /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
        "path",
        {
          strokeLinecap: "round",
          fill: "none",
          d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
        "path",
        {
          fill: "none",
          strokeLinecap: "round",
          d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
    ] })
  });

  // src/app/views/forms.tsx
  var FormSectionView = (props) => {
    let stackProps = {
      spacing: "10px",
      paddingTop: "10px"
    };
    if (props.stripeColor != null) {
      stackProps.borderLeftColor = props.stripeColor;
      stackProps.borderLeftWidth = "5px";
      stackProps.paddingLeft = "10px";
      stackProps.paddingTop = "5px";
    }
    return /* @__PURE__ */ import_react74.default.createElement(Stack, { as: "section", gap: 0, w: "full" }, /* @__PURE__ */ import_react74.default.createElement(Box, null, /* @__PURE__ */ import_react74.default.createElement(Heading, { size: "small" }, props.title), /* @__PURE__ */ import_react74.default.createElement("hr", null)), /* @__PURE__ */ import_react74.default.createElement(Stack, { ...stackProps }, props.children));
  };
  var FormRow = (props) => {
    return /* @__PURE__ */ import_react74.default.createElement(
      Flex,
      {
        direction: { base: "column", med: "row" },
        alignItems: "end",
        gap: "10px"
      },
      props.children
    );
  };
  var FormLabelWithTooltipOption = ({ label, tooltip, ...props }) => {
    return /* @__PURE__ */ import_react74.default.createElement(FormLabel, { mb: "3px", marginInlineEnd: "1px", ...props }, /* @__PURE__ */ import_react74.default.createElement(HStack, { w: "full", gap: "5px" }, /* @__PURE__ */ import_react74.default.createElement(Text, { flex: 1 }, label), tooltip != null && /* @__PURE__ */ import_react74.default.createElement(InfoTooltipView, { message: tooltip })));
  };
  var FormInput = (0, import_react74.forwardRef)(({ label, tooltip, ...props }, ref) => /* @__PURE__ */ import_react74.default.createElement(FormControl, null, /* @__PURE__ */ import_react74.default.createElement(FormLabelWithTooltipOption, { label, tooltip }), /* @__PURE__ */ import_react74.default.createElement(Input, { ...props, ref })));
  var FormSelect = ({
    label,
    children,
    tooltip,
    ...props
  }) => /* @__PURE__ */ import_react74.default.createElement(FormControl, null, /* @__PURE__ */ import_react74.default.createElement(FormLabelWithTooltipOption, { label, tooltip }), /* @__PURE__ */ import_react74.default.createElement(Select, { ...props }, children));
  var NumericFormInputView = ({
    value,
    minValue,
    maxValue,
    setValue,
    isDisabled,
    prefix: prefix2,
    tooltip,
    ...props
  }) => {
    const [internalValue, setInternalValue] = (0, import_react74.useState)(value?.toString() ?? null);
    function isValid(numeric) {
      if (isNaN(numeric) || numeric < minValue || numeric > maxValue) {
        return false;
      }
      return true;
    }
    const isInvalid = internalValue != null && !isValid(parseFloat(internalValue));
    return /* @__PURE__ */ import_react74.default.createElement(FormControl, { isInvalid, isDisabled }, /* @__PURE__ */ import_react74.default.createElement(FormLabelWithTooltipOption, { label: props.label, tooltip }), /* @__PURE__ */ import_react74.default.createElement(InputGroup, null, prefix2 != null && /* @__PURE__ */ import_react74.default.createElement(InputLeftAddon, null, prefix2), /* @__PURE__ */ import_react74.default.createElement(
      Input,
      {
        ...props,
        type: "number",
        value: internalValue ?? void 0,
        min: minValue,
        max: maxValue,
        step: props.step ?? 1,
        onChange: (ev) => {
          const value2 = ev.target.value;
          setInternalValue(value2);
          const numericValue = parseFloat(value2);
          if (isValid(numericValue)) {
            setValue(numericValue);
          }
        },
        onBlur: () => {
          if (value != null) {
            setInternalValue(value.toString());
          }
        }
      }
    ), props.suffix != null && /* @__PURE__ */ import_react74.default.createElement(InputRightAddon, null, props.suffix)));
  };
  var InfoTooltipView = (props) => {
    const { isOpen, onOpen, onClose, onToggle } = useDisclosure();
    const isTouchDevice = window.matchMedia(
      "(hover: none) and (pointer: coarse)"
    ).matches;
    return /* @__PURE__ */ import_react74.default.createElement(import_react74.default.Fragment, null, /* @__PURE__ */ import_react74.default.createElement(
      Tooltip,
      {
        hasArrow: true,
        label: props.message,
        placement: "top",
        bg: "gray.50",
        color: "black",
        isOpen
      },
      /* @__PURE__ */ import_react74.default.createElement(
        QuestionOutlineIcon,
        {
          color: "gray.500",
          onMouseEnter: onOpen,
          onMouseLeave: onClose,
          onClick: (ev) => {
            if (isTouchDevice) {
              onToggle();
              ev.preventDefault();
              ev.stopPropagation();
            }
          }
        }
      )
    ));
  };

  // src/app/views/inputs.tsx
  var import_react75 = __toESM(require_react());
  var HeatPumpInstallCostInput = () => {
    const [heatpumpInstallCost, setHeatpumpInstallCost] = useAtom(
      heatpumpInstallCostAtom
    );
    return /* @__PURE__ */ import_react75.default.createElement(
      NumericFormInputView,
      {
        label: "New heat pump w/ backup",
        tooltip: /* @__PURE__ */ import_react75.default.createElement(Stack, null, /* @__PURE__ */ import_react75.default.createElement("p", null, "This is the cost to purchase and install a heat pump, including its backup heat source. The default values are based on a rough national estimate."), /* @__PURE__ */ import_react75.default.createElement("p", null, "If you have a real quote from a contractor, replace this value with that quote.")),
        value: heatpumpInstallCost,
        prefix: "$",
        setValue: setHeatpumpInstallCost,
        minValue: 0,
        step: 1e3,
        maxValue: 1e5
      }
    );
  };
  var HeatPumpBackupFuelSelect = () => {
    const [heatpumpBackupFuel, setHeatpumpBackupFuel] = useAtom(
      heatpumpBackupFuelAtom
    );
    return /* @__PURE__ */ import_react75.default.createElement(
      FormSelect,
      {
        label: "Backup heat source",
        tooltip: /* @__PURE__ */ import_react75.default.createElement(Stack, null, /* @__PURE__ */ import_react75.default.createElement("p", null, "Canada's cold climate means your heat pump will typically need a backup heat source. This is either an electric heating coil or a gas furnace that's used in conjunction with the heat pump when it's very cold."), /* @__PURE__ */ import_react75.default.createElement("p", null, "For electric backups, smart thermostats will automatically turn on the electric backup when the heat pump isn't able to maintain a comfortable indoor temperature."), /* @__PURE__ */ import_react75.default.createElement("p", null, "For gas backups, the switchover temperature is configured manually to allow owners to balance cost and emissions.")),
        value: heatpumpBackupFuel,
        onChange: (ev) => setHeatpumpBackupFuel(ev.currentTarget.value)
      },
      /* @__PURE__ */ import_react75.default.createElement("option", { value: "gas" }, "Gas"),
      /* @__PURE__ */ import_react75.default.createElement("option", { value: "electric" }, "Electric")
    );
  };
  var AirConditionerInstallCostInput = () => {
    const [airConditionerInstallCost, setAirConditionerInstallCost] = useAtom(
      airConditionerInstallCostAtom
    );
    return /* @__PURE__ */ import_react75.default.createElement(
      NumericFormInputView,
      {
        label: "New air conditioner",
        value: airConditionerInstallCost,
        tooltip: /* @__PURE__ */ import_react75.default.createElement(Stack, null, /* @__PURE__ */ import_react75.default.createElement("p", null, "The purchase and install cost for a new air conditioner."), /* @__PURE__ */ import_react75.default.createElement("p", null, "A heat pump can heat ", /* @__PURE__ */ import_react75.default.createElement("em", null, "and"), " cool your home, so a heat pump replaces your heating and cooling equipment.")),
        prefix: "$",
        setValue: setAirConditionerInstallCost,
        minValue: 0,
        step: 1e3,
        maxValue: 1e5
      }
    );
  };
  var FurnaceInstallCostInput = () => {
    const statusQuoFurnaceFuel = useAtomValue(statusQuoFurnaceFuelAtom);
    const [gasFurnaceInstallCost, setGasFurnaceInstallCost] = useAtom(
      gasFurnaceInstallCostAtom
    );
    const [electricFurnaceInstallCost, setElectricFurnaceInstallCost] = useAtom(
      electricFurnaceInstallCostAtom
    );
    let furnaceCost;
    let setFurnaceCost;
    switch (statusQuoFurnaceFuel) {
      case "electric":
        furnaceCost = electricFurnaceInstallCost;
        setFurnaceCost = setElectricFurnaceInstallCost;
        break;
      case "gas":
        furnaceCost = gasFurnaceInstallCost;
        setFurnaceCost = setGasFurnaceInstallCost;
        break;
      default:
        assertNever(statusQuoFurnaceFuel);
    }
    return /* @__PURE__ */ import_react75.default.createElement(
      NumericFormInputView,
      {
        label: `New ${statusQuoFurnaceFuel} furnace`,
        value: furnaceCost,
        tooltip: /* @__PURE__ */ import_react75.default.createElement(import_react75.default.Fragment, null, "The purchase and install cost for a new furnace."),
        prefix: "$",
        setValue: setFurnaceCost,
        minValue: 0,
        step: 1e3,
        maxValue: 1e5
      }
    );
  };
  var PostalCodeInput = () => {
    const [postalCode, setPostalCode] = useAtom(postalCodeAtom);
    const postalCodeInputRef = (0, import_react75.useRef)(null);
    (0, import_react75.useEffect)(() => {
      if (!postalCode) {
        postalCodeInputRef.current?.focus();
      }
    }, [postalCode]);
    return /* @__PURE__ */ import_react75.default.createElement(
      FormInput,
      {
        label: "Postal code",
        placeholder: "K2A 2Y3",
        value: postalCode ?? "",
        tooltip: "Your postal code is used to retrieve local weather data and local energy prices.",
        onChange: (ev) => setPostalCode(ev.currentTarget.value),
        ref: postalCodeInputRef
      }
    );
  };
  var FloorSpaceInput = () => {
    const [floorSpaceSqFt, setFloorSpaceSqFt] = useAtom(floorSpaceSqFtAtom);
    return /* @__PURE__ */ import_react75.default.createElement(
      NumericFormInputView,
      {
        label: "Square footage",
        placeholder: "2500",
        minValue: 100,
        maxValue: 1e5,
        value: floorSpaceSqFt,
        setValue: setFloorSpaceSqFt,
        textAlign: "right",
        tooltip: /* @__PURE__ */ import_react75.default.createElement(import_react75.default.Fragment, null, "The square footage of your house is used to better estimate heating and cooling costs. Larger homes tend to require more energy to heat and cool."),
        suffix: /* @__PURE__ */ import_react75.default.createElement(import_react75.default.Fragment, null, "ft", /* @__PURE__ */ import_react75.default.createElement("sup", null, "2"))
      }
    );
  };
  var HomeHeatingTypeSelect = (props) => {
    const [statusQuoFurnaceFuel, setStatusQuoFurnaceFuel] = useAtom(
      statusQuoFurnaceFuelAtom
    );
    return /* @__PURE__ */ import_react75.default.createElement(
      FormSelect,
      {
        label: props.label,
        tooltip: props.tooltip,
        value: statusQuoFurnaceFuel,
        onChange: (ev) => {
          const value = ev.currentTarget.value;
          if (value === "gas" || value === "electric") {
            setStatusQuoFurnaceFuel(value);
          }
        }
      },
      /* @__PURE__ */ import_react75.default.createElement("option", { value: "gas" }, "Gas"),
      /* @__PURE__ */ import_react75.default.createElement("option", { value: "electric" }, "Electricity")
    );
  };
  var OtherGasAppliancesSelect = () => {
    const [hasOtherGasAppliances, setHasOtherGasAppliances] = useAtom(
      hasOtherGasAppliancesAtom
    );
    return /* @__PURE__ */ import_react75.default.createElement(
      FormSelect,
      {
        label: "Other gas appliances (stove, water heater, etc.)",
        tooltip: /* @__PURE__ */ import_react75.default.createElement(Stack, null, /* @__PURE__ */ import_react75.default.createElement("p", null, "This is used to determine if switching to a heat pump might allow you to save money by canceling your gas service altogether."), /* @__PURE__ */ import_react75.default.createElement("p", null, "When you use little or no gas, you still spend money every month on a customer service fee. Cancelling your gas service allows you to stop paying that."), /* @__PURE__ */ import_react75.default.createElement("p", null, "If you have a gas furnace at the moment, but you're planning on removing ", /* @__PURE__ */ import_react75.default.createElement("em", null, "all"), ' gas appliances from your house, then choose "No" for more accurate estimates.')),
        value: hasOtherGasAppliances.toString(),
        onChange: (ev) => {
          const value = ev.currentTarget.value;
          setHasOtherGasAppliances(value === "true");
        }
      },
      /* @__PURE__ */ import_react75.default.createElement("option", { value: "true" }, "Yes"),
      /* @__PURE__ */ import_react75.default.createElement("option", { value: "false" }, "No")
    );
  };
  var AuxSwitchoverTempInput = () => {
    const [auxSwitchoverTempC, setAuxSwitchoverTempC] = useAtom(
      auxSwitchoverTempCAtom
    );
    return /* @__PURE__ */ import_react75.default.createElement(
      NumericFormInputView,
      {
        label: "Use backup\u2026",
        tooltip: /* @__PURE__ */ import_react75.default.createElement(Stack, null, /* @__PURE__ */ import_react75.default.createElement("p", null, "This controls when the heat pump will turn off and a backup gas furnace will take over."), /* @__PURE__ */ import_react75.default.createElement("p", null, "Try playing with this value to balance utility bill costs and emissions to your preference.")),
        minValue: -50,
        maxValue: 30,
        step: 1,
        value: auxSwitchoverTempC,
        setValue: setAuxSwitchoverTempC,
        prefix: "Below",
        textAlign: "right",
        suffix: "\xB0C"
      }
    );
  };

  // src/app/views/welcome-screen-view.tsx
  var WelcomeFormView = () => {
    const setWelcomeFormHasBeenSubmit = useSetAtom(welcomeFormHasBeenSubmitAtom);
    const locationInfo = useAtomValue(locationInfoAtom);
    const buildingGeometry = useAtomValue(buildingGeometryAtom);
    return /* @__PURE__ */ import_react78.default.createElement(Box, { maxW: "1280px", p: { base: 0, md: "20px" }, borderRadius: "md" }, /* @__PURE__ */ import_react78.default.createElement(Stack, { spacing: "20px" }, /* @__PURE__ */ import_react78.default.createElement(FormSectionView, { title: "About your home" }, /* @__PURE__ */ import_react78.default.createElement(FormRow, null, /* @__PURE__ */ import_react78.default.createElement(PostalCodeInput, null), /* @__PURE__ */ import_react78.default.createElement(FloorSpaceInput, null)), /* @__PURE__ */ import_react78.default.createElement(
      HomeHeatingTypeSelect,
      {
        label: "My home is heated with",
        tooltip: /* @__PURE__ */ import_react78.default.createElement(Stack, null, /* @__PURE__ */ import_react78.default.createElement("p", null, "We'll compare the costs for a heatpump against the costs for replacing the equipment you already have with something similar."), /* @__PURE__ */ import_react78.default.createElement("p", null, 'If you have a gas furnace, choose "gas". If you baseboard heaters or an electric furnace, choose "electricity".'))
      }
    ), /* @__PURE__ */ import_react78.default.createElement(OtherGasAppliancesSelect, null)), /* @__PURE__ */ import_react78.default.createElement(
      Button,
      {
        colorScheme: "blue",
        w: "full",
        mt: "4",
        isDisabled: locationInfo == null || buildingGeometry == null,
        onClick: () => {
          setWelcomeFormHasBeenSubmit(true);
        }
      },
      "Estimate Costs & Emissions"
    )));
  };
  var LocationLink = (props) => {
    const setPostalCode = useSetAtom(postalCodeAtom);
    const setFloorSpaceSqFt = useSetAtom(floorSpaceSqFtAtom);
    const setWelcomeFormHasBeenSubmit = useSetAtom(welcomeFormHasBeenSubmitAtom);
    const onClick = (ev) => {
      setPostalCode(props.postalCode);
      setFloorSpaceSqFt(2e3);
      setWelcomeFormHasBeenSubmit(true);
      ev.preventDefault();
    };
    return /* @__PURE__ */ import_react78.default.createElement(Box, { as: "a", href: "#", onClick, textDecoration: "underline" }, props.placeName, " (", props.postalCode, ")");
  };
  var WelcomeMessage = () => {
    return /* @__PURE__ */ import_react78.default.createElement(Center, { h: "full" }, /* @__PURE__ */ import_react78.default.createElement(Stack, { spacing: "30px", maxW: "400px" }, /* @__PURE__ */ import_react78.default.createElement("p", null, "This is an interactive tool to help you understand the tradeoffs involved with replacing your heating and cooling equipment with a heat pump in Canada."), /* @__PURE__ */ import_react78.default.createElement("p", null, /* @__PURE__ */ import_react78.default.createElement("strong", null, "Enter your home\u2019s information to get an instant cost estimate.")), /* @__PURE__ */ import_react78.default.createElement("p", null, "If you\u2019d like to see examples, click the links below:"), /* @__PURE__ */ import_react78.default.createElement(Flex, { direction: "row", w: "full", mt: "-20px" }, /* @__PURE__ */ import_react78.default.createElement(Box, { flex: 1 }, /* @__PURE__ */ import_react78.default.createElement(Center, null, /* @__PURE__ */ import_react78.default.createElement("ul", null, /* @__PURE__ */ import_react78.default.createElement("li", null, /* @__PURE__ */ import_react78.default.createElement(LocationLink, { postalCode: "M5V 0H8", placeName: "Toronto" })), /* @__PURE__ */ import_react78.default.createElement("li", null, /* @__PURE__ */ import_react78.default.createElement(LocationLink, { postalCode: "H3H 2H9", placeName: "Montreal" })), /* @__PURE__ */ import_react78.default.createElement("li", null, /* @__PURE__ */ import_react78.default.createElement(LocationLink, { postalCode: "V5K 0A1", placeName: "Vancouver" })), /* @__PURE__ */ import_react78.default.createElement("li", null, /* @__PURE__ */ import_react78.default.createElement(LocationLink, { postalCode: "T2P 0A9", placeName: "Calgary" }))))), /* @__PURE__ */ import_react78.default.createElement(Box, { flex: 1 }, /* @__PURE__ */ import_react78.default.createElement(Center, null, /* @__PURE__ */ import_react78.default.createElement("ul", null, /* @__PURE__ */ import_react78.default.createElement("li", null, /* @__PURE__ */ import_react78.default.createElement(LocationLink, { postalCode: "T6G 2R3", placeName: "Edmonton" })), /* @__PURE__ */ import_react78.default.createElement("li", null, /* @__PURE__ */ import_react78.default.createElement(LocationLink, { postalCode: "K2A 2Y3", placeName: "Ottawa" })), /* @__PURE__ */ import_react78.default.createElement("li", null, /* @__PURE__ */ import_react78.default.createElement(LocationLink, { postalCode: "R3T 2N2", placeName: "Winnipeg" })), /* @__PURE__ */ import_react78.default.createElement("li", null, /* @__PURE__ */ import_react78.default.createElement(LocationLink, { postalCode: "G1R 1R5", placeName: "Quebec City" })))))), /* @__PURE__ */ import_react78.default.createElement("p", null, "If you're curious about the methodology, you can", " ", /* @__PURE__ */ import_react78.default.createElement(
      Link,
      {
        href: "https://github.com/jlfwong/hvac-sim-app?tab=readme-ov-file#how-does-it-work",
        textDecoration: "underline"
      },
      "read about it here"
    ), ". You can also", " ", /* @__PURE__ */ import_react78.default.createElement(
      Link,
      {
        href: "https://github.com/jlfwong/hvac-sim-app",
        textDecoration: "underline"
      },
      "read the source code"
    ), ".")));
  };
  var WelcomeScreenView = () => {
    return /* @__PURE__ */ import_react78.default.createElement(Center, { h: "100vh", w: "full" }, /* @__PURE__ */ import_react78.default.createElement(Flex, { direction: { base: "column", md: "row" }, gap: "40px" }, /* @__PURE__ */ import_react78.default.createElement(Stack, null, /* @__PURE__ */ import_react78.default.createElement(Heading, { textAlign: "center" }, "XXX Heat Pump Calculator \u{1F1E8}\u{1F1E6}"), /* @__PURE__ */ import_react78.default.createElement(WelcomeFormView, null)), /* @__PURE__ */ import_react78.default.createElement(WelcomeMessage, null)));
  };

  // src/app/views/calculator-view.tsx
  var import_react126 = __toESM(require_react());

  // src/app/views/cards.tsx
  var import_react119 = __toESM(require_react());

  // src/lib/simulate.ts
  var FuelBilling = class {
    constructor() {
      this.electricalUtilityPlan = null;
      this.naturalGasUtilityPlan = null;
      this.fuelOilUtilityPlan = null;
    }
    setElectricalUtilityPlan(u) {
      this.electricalUtilityPlan = u;
    }
    setNaturalGasUtility(u) {
      this.naturalGasUtilityPlan = u;
    }
    setFuelOilUtilityPlan(u) {
      this.fuelOilUtilityPlan = u;
    }
    recordElectricityUsageKwh(kWh, localTime) {
    }
    recordNaturalGasUsageCcf(ccf, localTime) {
    }
    recordFuelOilUsageGallons(gallons, localTime) {
    }
    recordUsage(usageRate, durationInHours, localTime) {
      if (usageRate.electricityKw) {
        if (!this.electricalUtilityPlan) {
          throw new Error("No electrical utility configured");
        }
        this.electricalUtilityPlan.recordElectricityUsageKwh(
          usageRate.electricityKw * durationInHours,
          localTime
        );
      }
      if (usageRate.naturalGasCcfPerHour) {
        if (!this.naturalGasUtilityPlan) {
          throw new Error("No natural gas utility configured");
        }
        this.naturalGasUtilityPlan.recordNaturalGasUsageCcf(
          usageRate.naturalGasCcfPerHour * durationInHours,
          localTime
        );
      }
      if (usageRate.fuelOilGallonsPerHour) {
        if (!this.fuelOilUtilityPlan) {
          throw new Error("No fuel oil utility configured");
        }
        this.fuelOilUtilityPlan.recordFuelOilUsageGallons(
          usageRate.fuelOilGallonsPerHour * durationInHours,
          localTime
        );
      }
    }
    getBills(from2, to) {
      let bills = [];
      if (this.electricalUtilityPlan) {
        bills = bills.concat(this.electricalUtilityPlan.getBills(from2, to));
      }
      if (this.naturalGasUtilityPlan) {
        bills = bills.concat(this.naturalGasUtilityPlan.getBills(from2, to));
      }
      if (this.fuelOilUtilityPlan) {
        bills = bills.concat(this.fuelOilUtilityPlan.getBills(from2, to));
      }
      return bills;
    }
  };
  var cachedTimeSteps = null;
  function getTimeSteps(localStartTime, localEndTime, timeStepDuration, weatherSource) {
    const timezone = localStartTime.zone;
    if (localStartTime.zone !== localEndTime.zone) {
      throw new Error("Given a different timezone for start and end datetimes");
    }
    if (cachedTimeSteps && cachedTimeSteps.localStartTime.equals(localStartTime) && cachedTimeSteps.localEndTime.equals(localEndTime) && cachedTimeSteps.timeStepDuration.equals(timeStepDuration) && cachedTimeSteps.weatherSource == weatherSource) {
      return cachedTimeSteps.steps;
    }
    const steps2 = [];
    let utcTime2 = localStartTime.toUTC();
    const endTimeMillis = localEndTime.toMillis();
    while (utcTime2.toMillis() < endTimeMillis) {
      const weather = weatherSource.getWeather(utcTime2);
      const localTime = utcTime2.setZone(timezone);
      utcTime2 = utcTime2.plus(timeStepDuration);
      steps2.push({ localTime, weather });
    }
    cachedTimeSteps = {
      localStartTime,
      localEndTime,
      weatherSource,
      timeStepDuration,
      steps: steps2
    };
    return steps2;
  }
  function simulateBuildingHVAC(options) {
    const billing = new FuelBilling();
    if (options.utilityPlans.electrical) {
      billing.setElectricalUtilityPlan(options.utilityPlans.electrical());
    }
    if (options.utilityPlans.naturalGas) {
      billing.setNaturalGasUtility(options.utilityPlans.naturalGas());
    }
    if (options.utilityPlans.fuelOil) {
      billing.setFuelOilUtilityPlan(options.utilityPlans.fuelOil());
    }
    let results = [];
    const timezone = options.localStartTime.zone;
    if (options.localStartTime.zone !== options.localStartTime.zone) {
      throw new Error("Given a different timezone for start and end datetimes");
    }
    let utcTime2 = options.localStartTime.toUTC();
    let insideAirTempF = options.initialInsideAirTempF;
    const timeStepDuration = Duration.fromObject({ minutes: 20 });
    const timeStepInHours = timeStepDuration.as("hours");
    for (let { localTime, weather } of getTimeSteps(
      options.localStartTime,
      options.localEndTime,
      timeStepDuration,
      options.weatherSource
    )) {
      const hvacSystemResponse = options.hvacSystem.getThermalResponse({
        localTime,
        insideAirTempF,
        outsideAirTempF: weather.outsideAirTempF
      });
      billing.recordUsage(
        hvacSystemResponse.fuelUsage,
        timeStepInHours,
        localTime
      );
      let passiveBtusPerHour = 0;
      let passiveLoads = [];
      for (let loadSource of options.loadSources) {
        const btusPerHour = loadSource.getBtusPerHour(
          utcTime2,
          insideAirTempF,
          weather
        );
        passiveLoads.push({ name: loadSource.name, btusPerHour });
        passiveBtusPerHour += btusPerHour;
      }
      results.push({
        localTime,
        insideAirTempF,
        weather,
        hvacSystemResponse,
        passiveLoads
      });
      insideAirTempF += (passiveBtusPerHour + hvacSystemResponse.btusPerHour) * timeStepInHours / options.buildingGeometry.btusPerDegreeF;
    }
    const bills = billing.getBills(options.localStartTime, options.localEndTime);
    return {
      name: options.hvacSystem.name,
      timeSteps: results,
      bills,
      billsTotalCost: bills.reduce((acc, b) => acc + b.getTotalCost(), 0)
    };
  }

  // src/lib/billing.ts
  function getTotalFromItemized(items) {
    return items.reduce((acc, i) => acc + i.amount, 0);
  }
  var SimpleFuelBill = class {
    constructor(options) {
      this.options = options;
    }
    getBillingPeriodStart() {
      return this.options.billingPeriodStart;
    }
    getBillingPeriodEnd() {
      return this.options.billingPeriodEnd;
    }
    getLineItems() {
      return [
        { description: "Fixed charges", amount: this.options.fixedCost },
        {
          description: `${this.options.fuelUsage.toFixed(2)} ${this.options.fuelUnit} (at ${this.options.costPerFuelUnit}/${this.options.fuelUnit})`,
          amount: this.options.fuelUsage * this.options.costPerFuelUnit
        }
      ];
    }
    getTotalCost() {
      return getTotalFromItemized(this.getLineItems());
    }
    getFuelType() {
      return this.options.fuelType;
    }
    getFuelUsage() {
      return this.options.fuelUsage;
    }
    getFuelUnit() {
      return this.options.fuelUnit;
    }
  };
  function* eachMonthInclusive(from2, to) {
    let monthStart = from2.startOf("month");
    while (monthStart < to) {
      const monthEnd = monthStart.endOf("month");
      yield [monthStart, monthEnd];
      monthStart = monthStart.plus({ months: 1 });
    }
  }
  var SimpleMonthlyUsageTracker = class {
    constructor(options) {
      this.options = options;
      this.usageByMonth = {};
    }
    monthKeyFor(localTime) {
      return `${localTime.year}-${localTime.month}`;
    }
    recordUsage(amount, localTime) {
      if (amount < 0) {
        throw new Error(
          `Cannot record using negative amounts of fuel. Received: ${amount} ${this.options.fuelUnit}`
        );
      }
      const key = this.monthKeyFor(localTime);
      this.usageByMonth[key] = (this.usageByMonth[key] || 0) + amount;
    }
    getBills(from2, to) {
      const bills = [];
      for (let [monthStart, monthEnd] of eachMonthInclusive(from2, to)) {
        const usageForMonth = this.usageByMonth[this.monthKeyFor(monthStart)] || 0;
        bills.push(
          new SimpleFuelBill({
            billingPeriodStart: monthStart,
            billingPeriodEnd: monthEnd,
            fuelUsage: usageForMonth,
            fuelType: this.options.fuelType,
            fuelUnit: this.options.fuelUnit,
            fixedCost: this.options.fixedCostPerMonth,
            costPerFuelUnit: this.options.costPerFuelUnit
          })
        );
      }
      return bills;
    }
  };
  var SimpleNaturalGasUtilityPlan = class {
    constructor(options) {
      this.options = options;
      this.usageTracker = new SimpleMonthlyUsageTracker({
        fixedCostPerMonth: options.fixedCostPerMonth,
        fuelType: "natural gas",
        fuelUnit: "ccf",
        fixedCost: options.fixedCostPerMonth,
        costPerFuelUnit: options.costPerCcf
      });
    }
    recordNaturalGasUsageCcf(ccf, localTime) {
      this.usageTracker.recordUsage(ccf, localTime);
    }
    getBills(from2, to) {
      return this.usageTracker.getBills(from2, to);
    }
  };
  var SimpleElectricalUtilityPlan = class {
    constructor(options) {
      this.options = options;
      this.usageTracker = new SimpleMonthlyUsageTracker({
        fixedCostPerMonth: options.fixedCostPerMonth,
        fuelType: "electricity",
        fuelUnit: "kWh",
        fixedCost: options.fixedCostPerMonth,
        costPerFuelUnit: options.costPerKwh
      });
    }
    recordElectricityUsageKwh(kwh, localTime) {
      this.usageTracker.recordUsage(kwh, localTime);
    }
    getBills(from2, to) {
      return this.usageTracker.getBills(from2, to);
    }
  };

  // src/app/app-state/canadian-utilities-state.ts
  var naturalGasPricePerCubicMetreByProvince = {
    BC: 0.504,
    AB: 0.259,
    SK: 0.371,
    MB: 0.385,
    ON: 0.469,
    QC: 0.631,
    NB: 0.944,
    NS: 1.096,
    // Newfoundland and PEI seem to not have home natural gas
    // service at all! For these, we'll just match the price with Nova Scotia.
    PE: 1.096,
    NL: 1.096,
    // Northern territories are also unlikely to have access to natural gas.
    // We'll just assume it's expensive if it's available at all.
    YK: 1,
    NT: 1,
    NU: 1
  };
  var naturalGasPricePerCubicMetreAtom = overridableDerivedAtom((get3) => {
    const locationInfo = get3(locationInfoAtom);
    if (locationInfo == null) {
      return null;
    }
    const pricePerM3 = naturalGasPricePerCubicMetreByProvince[locationInfo.provinceCode];
    if (!pricePerM3) {
      throw new Error(
        `No gas pricing data for province ${locationInfo.provinceCode}`
      );
    }
    return pricePerM3;
  });
  var naturalGasFixedPricePerMonthByProvince = {
    // https://www.fortisbc.com/accounts-billing/billing-rates/natural-gas-rates/residential-rates
    BC: 13.1,
    // https://gas.atco.com/en-ca/products-services-rates/rates-billing-energy-savings-tips/rates-billing/natural-gas-rates.html
    AB: 30,
    // https://www.saskenergy.com/manage-account/rates/residential-rates
    SK: 26,
    // https://www.hydro.mb.ca/accounts_and_services/rates/residential_rates/
    MB: 14,
    // https://www.enbridgegas.com/-/media/Extranet-Pages/residential/myaccount/rates/EGD---Rate-1---Marketer-Notice.pdf?la=en&rev=65b794ed234a4bae830a962f0415945d&hash=8EC67E58BEBEEE35B73EB8377196EF23
    ON: 23,
    // https://energir.com/files/energir_common/conditionsservicetarif_an.pdf
    QC: 19,
    // https://naturalgasnb.com/en/for-home/accounts-billing/customer-rate-classes/#current-natural-gas-distribution-rates-charges
    NB: 21,
    // https://eastwardenergy.com/wp-content/uploads/2023/12/EEI-Rate-Table-December-2023-FINAL.pdf
    NS: 22,
    // Newfoundland and PEI seem to not have home natural gas
    // service at all! For these, we'll just match the price with Nova Scotia.
    PE: 22,
    NL: 22,
    // Northern territories are also unlikely to have access to natural gas.
    // We'll just assume it's expensive if it's available at all.
    YK: 30,
    NT: 30,
    NU: 30
  };
  var naturalGasFixedPricePerMonthAtom = atom((get3) => {
    const locationInfo = get3(locationInfoAtom);
    if (locationInfo == null) {
      return null;
    }
    const fixedCost = naturalGasFixedPricePerMonthByProvince[locationInfo.provinceCode];
    if (!fixedCost) {
      throw new Error(
        `No electricity pricing data for province ${locationInfo.provinceCode}`
      );
    }
    return fixedCost;
  });
  var electricityPricePerKwhByProvince = {
    BC: 0.1162,
    AB: 0.19,
    SK: 0.1789,
    MB: 0.1024,
    ON: 0.1368,
    QC: 0.0781,
    NS: 0.1827,
    NB: 0.1461,
    PE: 0.1778,
    NL: 0.1368,
    // https://www.ntpc.com/customer-service/residential-service/residential-electrical-rates
    NT: 0.31,
    // https://www.atcoelectricyukon.com/en-ca/customer-billing-rates/bill-calculator.html
    YK: 0.125,
    // https://www.qec.nu.ca/customer-care/accounts-and-billing/customer-rates
    NU: 0.61
  };
  var electricityPricePerKwhAtom = overridableDerivedAtom(
    (get3) => {
      const locationInfo = get3(locationInfoAtom);
      if (locationInfo == null) {
        return null;
      }
      const pricePerKwh = electricityPricePerKwhByProvince[locationInfo.provinceCode];
      if (!pricePerKwh) {
        throw new Error(
          `No electricity pricing data for province ${locationInfo.provinceCode}`
        );
      }
      return pricePerKwh;
    }
  );

  // src/lib/emissions.ts
  var gramsCo2ePerCcfNaturalGas = 0.054717 * 1e6 * 0.1;
  function emissionsForSimulationGramsCO2e(options) {
    let totalElectricalUsageKwh = 0;
    let totalNaturalGasUsageCcf = 0;
    for (let bill of options.simulationResult.bills) {
      switch (bill.getFuelType()) {
        case "electricity": {
          if (bill.getFuelUnit() != "kWh") {
            throw new Error(
              `Unexpected unit on an electricity bill: ${bill.getFuelUnit()}`
            );
          }
          totalElectricalUsageKwh += bill.getFuelUsage();
          break;
        }
        case "natural gas": {
          if (bill.getFuelUnit() != "ccf") {
            throw new Error(
              `Unexpected unit on a natural gas bill: ${bill.getFuelUnit()}`
            );
          }
          totalNaturalGasUsageCcf += bill.getFuelUsage();
          break;
        }
        default: {
          throw new Error(`Unimplemented fuel type: ${bill.getFuelType()}`);
        }
      }
    }
    const electricalEmissions = totalElectricalUsageKwh * options.gramsCO2ePerKwh;
    const naturalGasEmissions = totalNaturalGasUsageCcf * gramsCo2ePerCcfNaturalGas;
    return electricalEmissions + naturalGasEmissions;
  }

  // src/app/app-state/canadian-grid-emissions-state.ts
  var gridGramsCO2ePerKwhByProvince = {
    AB: 627.8,
    BC: 39.8,
    MB: 26.3,
    NB: 332.6,
    NL: 46,
    NS: 745.8,
    NT: 208,
    NU: 1034,
    ON: 45.7,
    PE: 4,
    QC: 16.9,
    SK: 809.2,
    YT: 101
  };
  var gramsCO2ePerKwhAtom = atom((get3) => {
    const locationInfo = get3(locationInfoAtom);
    if (locationInfo == null) {
      return null;
    }
    const gramsCo2ePerKwh = gridGramsCO2ePerKwhByProvince[locationInfo.provinceCode];
    if (!gramsCo2ePerKwh) {
      throw new Error(
        `No gas pricing data for province ${locationInfo.provinceCode}`
      );
    }
    return gramsCo2ePerKwh;
  });

  // src/lib/hvac-system.ts
  var SimpleHVACSystem = class {
    constructor(name, options) {
      this.name = name;
      this.options = options;
      this.mode = "off";
    }
    getThermalResponse(options) {
      const minTempDifferentialF = 0.8;
      if (this.mode === "heating") {
        if (options.insideAirTempF > this.options.heatingSetPointF) {
          this.mode = "off";
        }
      } else if (this.mode === "cooling") {
        if (options.insideAirTempF < this.options.coolingSetPointF) {
          this.mode = "off";
        }
      } else if (this.mode === "off") {
        if (options.insideAirTempF < this.options.heatingSetPointF - minTempDifferentialF) {
          this.mode = "heating";
        } else if (options.insideAirTempF > this.options.coolingSetPointF + minTempDifferentialF) {
          this.mode = "cooling";
        }
      }
      if (this.mode === "heating") {
        return this.options.heatingAppliance.getHeatingPerformanceInfo({
          insideAirTempF: options.insideAirTempF,
          outsideAirTempF: options.outsideAirTempF
        });
      } else if (this.mode === "cooling") {
        return this.options.coolingAppliance.getCoolingPerformanceInfo({
          insideAirTempF: options.insideAirTempF,
          outsideAirTempF: options.outsideAirTempF
        });
      }
      return {
        btusPerHour: 0,
        fuelUsage: {}
      };
    }
  };
  var TwoStageHeatPumpWithAuxHeating = class {
    constructor(name, options) {
      this.name = name;
      this.options = options;
      this.mode = "off";
      this.heatingModeStartTimestamp = 0;
      this.stage1MaxDurationMs = this.options.stage1MaxDurationMinutes * (60 * 1e3);
    }
    getThermalResponse(options) {
      const minTempDifferentialF = 0.8;
      if (this.mode === "heating") {
        if (options.insideAirTempF > this.options.heatingSetPointF) {
          this.mode = "off";
        }
      } else if (this.mode === "cooling") {
        if (options.insideAirTempF < this.options.coolingSetPointF) {
          this.mode = "off";
        }
      } else if (this.mode === "off") {
        if (options.insideAirTempF < this.options.heatingSetPointF - minTempDifferentialF) {
          this.mode = "heating";
          this.heatingModeStartTimestamp = options.localTime.toMillis();
        } else if (options.insideAirTempF > this.options.coolingSetPointF + minTempDifferentialF) {
          this.mode = "cooling";
        }
      }
      if (this.mode === "heating") {
        if (this.options.shouldEngageAuxHeating(options)) {
          return this.options.auxHeatingAppliance.getHeatingPerformanceInfo({
            insideAirTempF: options.insideAirTempF,
            outsideAirTempF: options.outsideAirTempF
          });
        } else {
          let percentPower = 70;
          if (options.localTime.toMillis() - this.heatingModeStartTimestamp > this.stage1MaxDurationMs || this.options.heatingSetPointF - options.insideAirTempF > this.options.stage2TemperatureDeltaF) {
            percentPower = 100;
          }
          return this.options.heatingAppliance.getHeatingPerformanceInfo({
            insideAirTempF: options.insideAirTempF,
            outsideAirTempF: options.outsideAirTempF,
            percentPower
          });
        }
      } else if (this.mode === "cooling") {
        return this.options.coolingAppliance.getCoolingPerformanceInfo({
          insideAirTempF: options.insideAirTempF,
          outsideAirTempF: options.outsideAirTempF
        });
      }
      return {
        btusPerHour: 0,
        fuelUsage: {}
      };
    }
  };

  // src/lib/heatpump.ts
  function absDeltaT(r3) {
    return Math.abs(r3.insideDryBulbFahrenheit - r3.outsideDryBulbFahrenheit);
  }
  function interpolateCOP(x1, cop1, x2, cop2, x) {
    return clamp2(interpolate2(x1, cop1, x2, cop2, x), 1, 8.5);
  }
  function interpolatePerformanceRatings(aDeltaT, a, bDeltaT, b, deltaT) {
    return {
      // We don't allow compressor capacity to go outside the range from the
      // laboratory results.
      btusPerHour: interpolateClamped(
        aDeltaT,
        a.btusPerHour,
        bDeltaT,
        b.btusPerHour,
        deltaT
      ),
      coefficientOfPerformance: interpolateCOP(
        aDeltaT,
        a.coefficientOfPerformance,
        bDeltaT,
        b.coefficientOfPerformance,
        deltaT
      )
    };
  }
  function derateHeatPumpForElevation(rating, elevationInFeet, speedSettings) {
    const elevationFactor = getAltitudeCorrectionFactor(elevationInFeet);
    let efficiencyDeratingMultiplier = 0.1;
    if (speedSettings === "single-speed") {
      efficiencyDeratingMultiplier = 0.5;
    } else if (speedSettings === "dual-speed") {
      efficiencyDeratingMultiplier = 0.25;
    } else if (speedSettings === "variable-speed") {
      efficiencyDeratingMultiplier = 0.1;
    }
    const efficiencyFactor = 1 - (1 - elevationFactor) * efficiencyDeratingMultiplier;
    return {
      btusPerHour: rating.btusPerHour * elevationFactor,
      coefficientOfPerformance: rating.coefficientOfPerformance * efficiencyFactor
    };
  }
  function derateCapacityPerformanceRating(rating, outsideAirTempF, elevationInFeet, minOrMaxCapacity) {
    const elevationDerated = derateHeatPumpForElevation(
      rating,
      elevationInFeet,
      "variable-speed"
    );
    if (outsideAirTempF > 50) {
      return elevationDerated;
    }
    let defrostFactor;
    const t4 = outsideAirTempF;
    const t22 = t4 * t4;
    if (t4 < 25) {
      defrostFactor = -2022e-7 * t22 + 4177e-6 * t4 + 0.9606;
    } else {
      if (minOrMaxCapacity == "max") {
        defrostFactor = -3917e-7 * t22 + 0.03786 * t4 + 0.0849;
      } else {
        defrostFactor = -1371e-7 * t22 + 0.01273 * t4 + 0.7045;
      }
    }
    const defrostCopDerateFactor = 0.978 * defrostFactor - 0.0998;
    return {
      btusPerHour: elevationDerated.btusPerHour * defrostFactor,
      coefficientOfPerformance: elevationDerated.coefficientOfPerformance * defrostCopDerateFactor
    };
  }
  function estimatePerformanceRange(options) {
    const deltaTempF = Math.abs(options.insideAirTempF - options.outsideAirTempF);
    if (options.elevationFeet == null) {
      options.elevationFeet = 0;
    }
    let left2 = null;
    let right2 = null;
    for (let i = 1; i < options.sortedRatings.length; i++) {
      left2 = options.sortedRatings[i - 1];
      right2 = options.sortedRatings[i];
      if (absDeltaT(left2) <= deltaTempF && deltaTempF <= absDeltaT(right2)) {
        break;
      }
    }
    if (!left2 || !right2) {
      throw new Error(
        `Not enough ratings. Expected a minimum of 2, got ${options.sortedRatings.length}`
      );
    }
    const deltaTempLeft = absDeltaT(left2);
    const deltaTempRight = absDeltaT(right2);
    let minCapacity = interpolatePerformanceRatings(
      deltaTempLeft,
      left2.minCapacity,
      deltaTempRight,
      right2.minCapacity,
      deltaTempF
    );
    minCapacity = derateCapacityPerformanceRating(
      minCapacity,
      options.outsideAirTempF,
      options.elevationFeet,
      "min"
    );
    let maxCapacity = interpolatePerformanceRatings(
      deltaTempLeft,
      left2.maxCapacity,
      deltaTempRight,
      right2.maxCapacity,
      deltaTempF
    );
    maxCapacity = derateCapacityPerformanceRating(
      maxCapacity,
      options.outsideAirTempF,
      options.elevationFeet,
      "max"
    );
    return {
      minCapacity,
      maxCapacity
    };
  }
  function estimatePerformanceRating(options) {
    const { minCapacity, maxCapacity } = estimatePerformanceRange(options);
    let btusPerHourNeeded = 0;
    switch (options.power.type) {
      case "btus": {
        btusPerHourNeeded = options.power.btusPerHourNeeded;
        break;
      }
      case "percent": {
        btusPerHourNeeded = maxCapacity.btusPerHour * (options.power.percentPower / 100);
        if (options.mode === "cooling") {
          btusPerHourNeeded = -btusPerHourNeeded;
        }
        break;
      }
      default: {
        throw new Error(`Unexpected power type: ${options.power}`);
      }
    }
    if (Math.abs(btusPerHourNeeded) > Math.abs(maxCapacity.btusPerHour)) {
      return {
        btusPerHour: options.mode == "cooling" ? -maxCapacity.btusPerHour : maxCapacity.btusPerHour,
        coefficientOfPerformance: maxCapacity.coefficientOfPerformance
      };
    } else if (Math.abs(btusPerHourNeeded) < Math.abs(minCapacity.btusPerHour)) {
      return {
        btusPerHour: options.mode == "cooling" ? -minCapacity.btusPerHour : minCapacity.btusPerHour,
        coefficientOfPerformance: minCapacity.coefficientOfPerformance
      };
    } else {
      const coefficientOfPerformance = interpolateCOP(
        minCapacity.btusPerHour,
        minCapacity.coefficientOfPerformance,
        maxCapacity.btusPerHour,
        maxCapacity.coefficientOfPerformance,
        Math.abs(btusPerHourNeeded)
      );
      return {
        btusPerHour: btusPerHourNeeded,
        coefficientOfPerformance
      };
    }
  }
  function getAltitudeCorrectionFactor(elevationInFeet) {
    if (elevationInFeet < 0) {
      return 1;
    }
    const factorByAltitude = {
      0: 1,
      1: 0.96,
      2: 0.93,
      3: 0.9,
      4: 0.86,
      5: 0.83,
      6: 0.8,
      7: 0.77,
      8: 0.74,
      9: 0.71,
      10: 0.69,
      11: 0.67,
      // guess
      12: 0.65,
      // guess
      13: 0.63
      // guess
    };
    const thousandsOfFeet = Math.floor(elevationInFeet / 1e3);
    const a = factorByAltitude[thousandsOfFeet];
    const b = factorByAltitude[thousandsOfFeet + 1];
    return interpolate2(
      thousandsOfFeet,
      a,
      thousandsOfFeet + 1,
      b,
      elevationInFeet / 1e3
    );
  }
  var AirSourceHeatPump = class {
    constructor(options) {
      this.name = "Air Source Heat Pump";
      if (options.name) {
        this.name = options.name;
      }
      this.elevationFeet = options.elevationFeet;
      this.sortedHeatingRatings = options.ratings.filter((r3) => r3.mode === "heating").sort((a, b) => absDeltaT(a) - absDeltaT(b));
      this.sortedCoolingRatings = options.ratings.filter((r3) => r3.mode === "cooling").sort((a, b) => absDeltaT(a) - absDeltaT(b));
    }
    getEstimatedPerformanceRating(options) {
      return estimatePerformanceRating({
        insideAirTempF: options.insideAirTempF,
        outsideAirTempF: options.outsideAirTempF,
        power: options.power,
        mode: options.mode,
        sortedRatings: options.mode == "heating" ? this.sortedHeatingRatings : this.sortedCoolingRatings,
        elevationFeet: this.elevationFeet
      });
    }
    getCoolingPerformanceInfo(options) {
      const rating = this.getEstimatedPerformanceRating({
        mode: "cooling",
        power: {
          type: "percent",
          percentPower: options.percentPower != null ? options.percentPower : 100
        },
        insideAirTempF: options.insideAirTempF,
        outsideAirTempF: options.outsideAirTempF
      });
      const kWNeeded = btusToKwh(Math.abs(rating.btusPerHour)) / rating.coefficientOfPerformance;
      return {
        btusPerHour: rating.btusPerHour,
        fuelUsage: {
          electricityKw: kWNeeded
        }
      };
    }
    getHeatingPerformanceInfo(options) {
      const rating = this.getEstimatedPerformanceRating({
        mode: "heating",
        power: {
          type: "percent",
          percentPower: options.percentPower != null ? options.percentPower : 100
        },
        insideAirTempF: options.insideAirTempF,
        outsideAirTempF: options.outsideAirTempF
      });
      const kWNeeded = btusToKwh(Math.abs(rating.btusPerHour)) / rating.coefficientOfPerformance;
      return {
        btusPerHour: rating.btusPerHour,
        fuelUsage: {
          electricityKw: kWNeeded
        }
      };
    }
  };

  // src/lib/air-conditioner.ts
  var AirConditioner = class {
    constructor(options) {
      this.options = options;
      this.name = "Air Conditioner";
      if (this.options.capacityBtusPerHour <= 0) {
        throw new Error(
          "Capacity values for air conditioners should be positive"
        );
      }
    }
    getEstimatedPerformanceRating(options) {
      const nameplaceCOP = this.options.seer * WATT_HOUR_PER_BTU;
      const deltaTempF = options.outsideAirTempF - options.insideAirTempF;
      const baselineCOPAdjustment = 0.7034;
      const dCOPdTempF = -0.0746;
      let coefficientOfPerformance = nameplaceCOP + baselineCOPAdjustment + deltaTempF * dCOPdTempF;
      if (coefficientOfPerformance < 0) {
        coefficientOfPerformance = 0.01;
      }
      return derateHeatPumpForElevation(
        {
          coefficientOfPerformance,
          btusPerHour: -this.options.capacityBtusPerHour
        },
        this.options.elevationFeet,
        this.options.speedSettings
      );
    }
    getCoolingPerformanceInfo(options) {
      const rating = this.getEstimatedPerformanceRating(options);
      const kWNeeded = btusToKwh(Math.abs(rating.btusPerHour)) / rating.coefficientOfPerformance;
      if (kWNeeded < 0) {
        throw new Error(
          `Reported a negative power demand from an air conditioner. Arguments: ${JSON.stringify(
            options
          )}, rating; ${JSON.stringify(rating)}`
        );
      }
      return {
        btusPerHour: rating.btusPerHour,
        fuelUsage: {
          electricityKw: kWNeeded
        }
      };
    }
  };

  // src/lib/electric-furnace.ts
  var ElectricFurnace = class {
    constructor(options) {
      this.options = options;
      this.name = "Electric Furnace";
    }
    getHeatingPerformanceInfo(options) {
      const capacityBtusPerHour = kWToBtusPerHour(this.options.capacityKw);
      return {
        btusPerHour: capacityBtusPerHour,
        fuelUsage: {
          // This assumes variable control
          electricityKw: this.options.capacityKw
        }
      };
    }
  };

  // src/lib/gas-furnace.ts
  var GasFurnace = class {
    constructor(options) {
      this.options = options;
      this.name = "Gas Furnace";
      let capacityElevationMultiplier = 1;
      if (this.options.elevationFeet > 2e3) {
        capacityElevationMultiplier = 1 - Math.floor(this.options.elevationFeet / 1e3) * 0.04;
      }
      this.deratedCapacityBtusPerHour = this.options.capacityBtusPerHour * capacityElevationMultiplier;
    }
    getHeatingPerformanceInfo(options) {
      const btusPerHourProduced = this.deratedCapacityBtusPerHour;
      const btuConsumptionRate = btusPerHourProduced / (this.options.afuePercent / 100);
      const ccfConsumptionRate = btuConsumptionRate / BTU_PER_CCF_NATURAL_GAS;
      return {
        btusPerHour: btusPerHourProduced,
        fuelUsage: {
          naturalGasCcfPerHour: ccfConsumptionRate
        }
      };
    }
  };

  // src/app/app-state/equipment-state.ts
  var airConditionerAtom = atom((get3) => {
    const elevationFeet = get3(elevationFeetAtom);
    if (!elevationFeet)
      return null;
    return new AirConditioner({
      seer: 11,
      capacityBtusPerHour: 4e4,
      elevationFeet,
      speedSettings: "single-speed"
    });
  });
  var gasFurnaceAtom = atom((get3) => {
    const elevationFeet = get3(elevationFeetAtom);
    if (elevationFeet == null)
      return null;
    return new GasFurnace({
      afuePercent: 96,
      capacityBtusPerHour: 8e4,
      elevationFeet
    });
  });
  var electricFurnaceAtom = atom((get3) => {
    return new ElectricFurnace({
      capacityKw: 20
    });
  });

  // src/lib/select-heatpump.ts
  function worstCaseWeatherConditions(insideAirTempF, outsideAirTempF) {
    const colderOutside = insideAirTempF > outsideAirTempF;
    return {
      outsideAirTempF,
      windSpeedMph: 0,
      // TODO(jlfwong): Choose sane values for humidity.
      relativeHumidityPercent: colderOutside ? 20 : 90,
      cloudCoverPercent: colderOutside ? 100 : 0,
      solarIrradiance: colderOutside ? {
        wattsPerSquareMeter: 0,
        altitudeDegrees: -90
      } : {
        // TODO(jlfwong): Ideally this would be based on the maximum
        // solar irradiance experienced at the given latitude.
        wattsPerSquareMeter: 850,
        altitudeDegrees: 58
      }
    };
  }
  function worstCaseThermalLoadBtusPerHour(options) {
    let colderOutside = options.insideAirTempF < options.outsideAirTempF;
    const dateTime = DateTime.fromObject({
      year: 2023,
      month: 1,
      day: 1,
      hour: colderOutside ? 2 : 14
    });
    const loads = options.loadSources.map((source) => {
      return source.getBtusPerHour(
        dateTime,
        options.insideAirTempF,
        worstCaseWeatherConditions(
          options.insideAirTempF,
          options.outsideAirTempF
        )
      );
    });
    const totalLoad = loads.reduce((acc, x) => acc + x, 0);
    return totalLoad;
  }
  function selectHeatpump(options) {
    const btusPerHourNeededHeating = Math.max(
      0,
      -worstCaseThermalLoadBtusPerHour({
        insideAirTempF: options.heatingSetPointInsideTempF,
        outsideAirTempF: options.designHeatingOutsideAirTempF,
        loadSources: options.loadSources
      })
    );
    const btusPerHourNeededCooling = Math.min(
      0,
      -worstCaseThermalLoadBtusPerHour({
        insideAirTempF: options.coolingSetPointInsideTempF,
        outsideAirTempF: options.designCoolingOutsideAirTempF,
        loadSources: options.loadSources
      })
    );
    const candidateHeatpumps = options.heatpumps.filter((pump) => {
      const heatingRating = pump.getEstimatedPerformanceRating({
        mode: "heating",
        power: { type: "btus", btusPerHourNeeded: btusPerHourNeededHeating },
        insideAirTempF: options.heatingSetPointInsideTempF,
        outsideAirTempF: options.designHeatingOutsideAirTempF
      });
      const coolingRating = pump.getEstimatedPerformanceRating({
        mode: "cooling",
        power: { type: "btus", btusPerHourNeeded: btusPerHourNeededCooling },
        insideAirTempF: options.coolingSetPointInsideTempF,
        outsideAirTempF: options.designCoolingOutsideAirTempF
      });
      return heatingRating.btusPerHour >= btusPerHourNeededHeating && -coolingRating.btusPerHour >= -btusPerHourNeededCooling;
    });
    const results = candidateHeatpumps.map((pump) => {
      let totalSum = 0;
      let totalWeight = 0;
      let underCapacityCoolingHours = 0;
      let underCapacityHeatingHours = 0;
      options.binnedTemperatures.forEachBin((bin) => {
        const { outsideAirTempF, hourCount } = bin;
        let mode2 = null;
        if (outsideAirTempF < options.heatingSetPointInsideTempF) {
          mode2 = "heating";
        } else if (outsideAirTempF > options.coolingSetPointInsideTempF) {
          mode2 = "cooling";
        }
        if (mode2 == null) {
          return;
        }
        const insideAirTempF = outsideAirTempF < options.designHeatingOutsideAirTempF ? options.designHeatingOutsideAirTempF : options.designCoolingOutsideAirTempF;
        const btusPerHourNeeded = -worstCaseThermalLoadBtusPerHour({
          insideAirTempF,
          outsideAirTempF,
          loadSources: options.loadSources
        });
        if (mode2 === "heating" && btusPerHourNeeded < 0) {
          return;
        }
        const rating = pump.getEstimatedPerformanceRating({
          power: { type: "btus", btusPerHourNeeded },
          mode: mode2,
          insideAirTempF,
          outsideAirTempF
        });
        if (Math.abs(rating.btusPerHour) < Math.abs(btusPerHourNeeded)) {
          if (insideAirTempF > outsideAirTempF) {
            underCapacityCoolingHours += hourCount;
          } else {
            underCapacityHeatingHours += hourCount;
          }
        }
        const weight = hourCount * Math.abs(btusPerHourNeeded);
        totalSum += rating.coefficientOfPerformance * weight;
        totalWeight += weight;
      });
      return {
        heatpump: pump,
        averageCoefficientOfPerformance: totalSum / totalWeight,
        underCapacityCoolingHours,
        underCapacityHeatingHours
      };
    });
    results.sort(
      (a, b) => b.averageCoefficientOfPerformance - a.averageCoefficientOfPerformance
    );
    return results;
  }

  // src/app/app-state/selected-heatpumps-state.ts
  var kelvinJsonAtom = asyncAtomOrNull(async (get3, { signal }) => {
    return await fetchJSON(`./data/equipment/kelvin-all.json`);
  });
  var kelvinHeatPumpCandidatesAtom = atom((get3) => {
    const heatPumpMetadata = get3(kelvinJsonAtom);
    const elevationFeet = get3(elevationFeetAtom);
    if (heatPumpMetadata == null || elevationFeet == null) {
      return null;
    }
    const pumps = [];
    for (let type in heatPumpMetadata) {
      for (let metadata of heatPumpMetadata[type]) {
        const pump = new AirSourceHeatPump({
          elevationFeet,
          name: `${metadata.brand} ${metadata.outdoor_unit_number}`,
          ratings: metadata.ratings.map((r3) => ({
            mode: r3.heat_cool.toLowerCase(),
            insideDryBulbFahrenheit: r3.indoor_dry_bulb,
            outsideDryBulbFahrenheit: r3.outdoor_dry_bulb,
            minCapacity: {
              btusPerHour: r3.capacity_min,
              coefficientOfPerformance: r3.cop_min
            },
            maxCapacity: {
              btusPerHour: r3.capacity_max,
              coefficientOfPerformance: r3.cop_max
            }
          }))
        });
        pumps.push(pump);
      }
    }
    return pumps;
  });
  var topRatedJsonAtom = asyncAtomOrNull((get3, { signal }) => {
    return fetchJSON(`./data/equipment/top_rated_ca.json`);
  });
  var topRatedHeatPumpCandidatesAtom = atom(
    (get3) => {
      const elevationFeet = get3(elevationFeetAtom);
      const json = get3(topRatedJsonAtom);
      if (json == null || elevationFeet == null)
        return null;
      const maxKey = Math.max(...Object.keys(json.brand).map((n2) => parseInt(n2)));
      const pumpInfo = {};
      for (let i = 0; i <= maxKey; i++) {
        const key = json.ahri_certificate_number[i];
        if (!(key in pumpInfo)) {
          pumpInfo[key] = {
            name: `${json.brand[i]} ${json.outdoor_unit_number[i]}`,
            ducted: json.ducted[i],
            ratings: []
          };
        }
        pumpInfo[key].ratings.push({
          mode: json.heat_cool[i].toLowerCase(),
          insideDryBulbFahrenheit: json.indoor_dry_bulb[i],
          outsideDryBulbFahrenheit: json.outdoor_dry_bulb[i],
          minCapacity: {
            btusPerHour: json.capacity_min[i],
            coefficientOfPerformance: json.cop_min[i]
          },
          maxCapacity: {
            btusPerHour: json.capacity_max[i],
            coefficientOfPerformance: json.cop_max[i]
          }
        });
      }
      const pumps = [];
      for (let key of Object.keys(pumpInfo)) {
        const { name, ducted, ratings } = pumpInfo[key];
        if (!ducted) {
          continue;
        }
        pumps.push(
          new AirSourceHeatPump({
            name,
            ratings,
            elevationFeet
          })
        );
      }
      return pumps;
    }
  );
  var selectedHeatpumpsAtom = atom(
    (get3) => {
      const weatherInfo = get3(weatherInfoAtom);
      const auxSwitchoverTempF = get3(auxSwitchoverTempFAtom);
      const loadSources = get3(loadSourcesAtom);
      const candidates = get3(topRatedHeatPumpCandidatesAtom);
      if (weatherInfo == null || candidates == null || loadSources == null) {
        return null;
      }
      const designCoolingOutsideAirTempF = weatherInfo.binnedTemperatures.getTempAtPercentile(99);
      let designHeatingOutsideAirTempF = weatherInfo.binnedTemperatures.getTempAtPercentile(1);
      if (designHeatingOutsideAirTempF && auxSwitchoverTempF != null) {
        designHeatingOutsideAirTempF = Math.max(
          designHeatingOutsideAirTempF,
          auxSwitchoverTempF
        );
      }
      return selectHeatpump({
        heatpumps: candidates,
        designCoolingOutsideAirTempF,
        coolingSetPointInsideTempF: get3(coolingSetPointFAtom),
        designHeatingOutsideAirTempF,
        heatingSetPointInsideTempF: get3(heatingSetPointFAtom),
        loadSources,
        binnedTemperatures: weatherInfo.binnedTemperatures
      });
    }
  );

  // src/app/app-state/hvac-systems-state.ts
  var gasFurnaceSystemAtom = atom((get3) => {
    const gasFurnace = get3(gasFurnaceAtom);
    const ac = get3(airConditionerAtom);
    if (!gasFurnace || !ac)
      return null;
    return new SimpleHVACSystem(`${gasFurnace.name} + ${ac.name}`, {
      coolingSetPointF: get3(coolingSetPointFAtom),
      coolingAppliance: ac,
      heatingSetPointF: get3(heatingSetPointFAtom),
      heatingAppliance: gasFurnace
    });
  });
  var electricFurnaceSystemAtom = atom((get3) => {
    const electricFurnace = get3(electricFurnaceAtom);
    const ac = get3(airConditionerAtom);
    if (!electricFurnace || !ac)
      return null;
    return new SimpleHVACSystem(`${electricFurnace.name} + ${ac.name}`, {
      coolingSetPointF: get3(coolingSetPointFAtom),
      coolingAppliance: ac,
      heatingSetPointF: get3(heatingSetPointFAtom),
      heatingAppliance: electricFurnace
    });
  });
  var heatPumpWithGasBackupSystemsAtom = atom((get3) => {
    const candidates = get3(selectedHeatpumpsAtom);
    const gasFurnace = get3(gasFurnaceAtom);
    const auxSwitchoverTempF = get3(auxSwitchoverTempFAtom);
    if (!candidates || !gasFurnace)
      return null;
    return candidates.map((c) => {
      const heatpump = c.heatpump;
      return new TwoStageHeatPumpWithAuxHeating(`Heat Pump (Gas Backup)`, {
        coolingSetPointF: get3(coolingSetPointFAtom),
        coolingAppliance: heatpump,
        heatingSetPointF: get3(heatingSetPointFAtom),
        heatingAppliance: heatpump,
        auxHeatingAppliance: gasFurnace,
        shouldEngageAuxHeating: (options) => {
          return options.outsideAirTempF <= auxSwitchoverTempF;
        },
        // Like the "Compressor Stage 1 Max Runtime" setting in
        // ecobee
        stage1MaxDurationMinutes: 120,
        // Like the "Compressor Stage 2 Temperature Delta" setting
        // in ecobee
        stage2TemperatureDeltaF: 1
      });
    });
  });
  var heatPumpWithElectricBackupSystemsAtom = atom(
    (get3) => {
      const candidates = get3(selectedHeatpumpsAtom);
      const electricFurnace = get3(electricFurnaceAtom);
      const heatingSetPointF = get3(heatingSetPointFAtom);
      if (!candidates || !electricFurnace)
        return null;
      return candidates.map((c) => {
        const heatpump = c.heatpump;
        return new TwoStageHeatPumpWithAuxHeating(`Heat Pump (Electric Backup)`, {
          coolingSetPointF: get3(coolingSetPointFAtom),
          coolingAppliance: heatpump,
          heatingSetPointF,
          heatingAppliance: heatpump,
          auxHeatingAppliance: electricFurnace,
          shouldEngageAuxHeating: (options) => {
            return options.insideAirTempF < heatingSetPointF - 2.6;
          },
          // Like the "Compressor Stage 1 Max Runtime" setting in
          // ecobee
          stage1MaxDurationMinutes: 120,
          // Like the "Compressor Stage 2 Temperature Delta" setting
          // in ecobee
          stage2TemperatureDeltaF: 1
        });
      });
    }
  );

  // src/app/app-state/simulations-state.ts
  var simulatorAtom = atom((get3) => {
    const loadSources = get3(loadSourcesAtom);
    const locationInfo = get3(locationInfoAtom);
    const weatherInfo = get3(weatherInfoAtom);
    const buildingGeometry = get3(buildingGeometryAtom);
    const naturalGasPricePerCubicMetre = get3(naturalGasPricePerCubicMetreAtom);
    const electricityPricePerKwh = get3(electricityPricePerKwhAtom);
    const gramsCO2ePerKwh = get3(gramsCO2ePerKwhAtom);
    if (loadSources == null || locationInfo == null || weatherInfo == null || buildingGeometry == null || naturalGasPricePerCubicMetre == null || electricityPricePerKwh == null || gramsCO2ePerKwh == null) {
      return null;
    }
    const dtOptions = { zone: weatherInfo.timezoneName };
    const localStartTime = DateTime.fromObject(
      {
        year: 2023,
        month: 1,
        day: 1
      },
      dtOptions
    );
    const localEndTime = DateTime.fromObject(
      {
        year: 2023,
        month: 12,
        day: 31
      },
      dtOptions
    ).endOf("day");
    return ({ hvacSystem, fixedGasCostPerMonth }) => {
      const utilityPlans = {
        electrical: () => new SimpleElectricalUtilityPlan({
          fixedCostPerMonth: 0,
          costPerKwh: electricityPricePerKwh
        }),
        naturalGas: () => new SimpleNaturalGasUtilityPlan({
          fixedCostPerMonth: fixedGasCostPerMonth,
          costPerCcf: naturalGasPricePerCubicMetre * CUBIC_METER_PER_CCF
        })
      };
      const result = simulateBuildingHVAC({
        localStartTime,
        localEndTime,
        initialInsideAirTempF: 72.5,
        buildingGeometry,
        hvacSystem,
        loadSources,
        weatherSource: weatherInfo.weatherSource,
        utilityPlans
      });
      return {
        ...result,
        emissionsGramsCO2e: emissionsForSimulationGramsCO2e({
          simulationResult: result,
          gramsCO2ePerKwh
        })
      };
    };
  });
  var heatPumpSimulationResultsAtom = atom((get3) => {
    const heatPumpWithGasBackupSystems = get3(heatPumpWithGasBackupSystemsAtom);
    const heatPumpWithElectricBackupSystems = get3(
      heatPumpWithElectricBackupSystemsAtom
    );
    const heatpumpBackupFuel = get3(heatpumpBackupFuelAtom);
    const hasOtherGasAppliances = get3(hasOtherGasAppliancesAtom);
    let fixedGasCostPerMonth = get3(naturalGasFixedPricePerMonthAtom);
    const simulator = get3(simulatorAtom);
    if (!simulator || !heatPumpWithGasBackupSystems || !heatPumpWithElectricBackupSystems || fixedGasCostPerMonth == null) {
      return null;
    }
    let systems;
    switch (heatpumpBackupFuel) {
      case "electric": {
        systems = heatPumpWithElectricBackupSystems;
        if (!hasOtherGasAppliances) {
          fixedGasCostPerMonth = 0;
        }
        break;
      }
      case "gas": {
        systems = heatPumpWithGasBackupSystems;
        break;
      }
      default: {
        assertNever(heatpumpBackupFuel);
      }
    }
    return systems.slice(0, 3).map(
      (hvacSystem) => simulator({
        hvacSystem,
        fixedGasCostPerMonth
      })
    );
  });
  var statusQuoSimulationResultAtom = atom((get3) => {
    const fuel = get3(statusQuoFurnaceFuelAtom);
    const hasOtherGasAppliances = get3(hasOtherGasAppliancesAtom);
    const statusQuoSystem = fuel == "gas" ? get3(gasFurnaceSystemAtom) : get3(electricFurnaceSystemAtom);
    let fixedGasCostPerMonth = get3(naturalGasFixedPricePerMonthAtom);
    const simulator = get3(simulatorAtom);
    if (!simulator || !statusQuoSystem || fixedGasCostPerMonth == null)
      return null;
    if (fuel != "gas" && !hasOtherGasAppliances) {
      fixedGasCostPerMonth = 0;
    }
    return simulator({ hvacSystem: statusQuoSystem, fixedGasCostPerMonth });
  });
  var optimizeFor = "cost";
  var bestHeatPumpSimulationResultAtom = atom((get3) => {
    const heatPumpResults = get3(heatPumpSimulationResultsAtom);
    if (!heatPumpResults)
      return null;
    let bestResult = null;
    switch (optimizeFor) {
      case "cost": {
        for (let sim of heatPumpResults) {
          if (!bestResult || sim.billsTotalCost < bestResult.billsTotalCost) {
            bestResult = sim;
          }
        }
        break;
      }
      case "emissions": {
        for (let sim of heatPumpResults) {
          if (!bestResult || sim.emissionsGramsCO2e < bestResult.emissionsGramsCO2e) {
            bestResult = sim;
          }
        }
        break;
      }
      default: {
        assertNever(optimizeFor);
      }
    }
    return bestResult;
  });
  var simulationsAtom = atom(
    (get3) => {
      const bestHeatPump = get3(bestHeatPumpSimulationResultAtom);
      const statusQuo = get3(statusQuoSimulationResultAtom);
      if (!bestHeatPump || !statusQuo)
        return null;
      return [bestHeatPump, statusQuo];
    }
  );

  // src/app/app-state/system-comparison.ts
  var systemComparisonAtom = atom((get3) => {
    const statusQuoFurnaceInstallCost = get3(statusQuoFurnaceInstallCostAtom);
    const airConditionerInstallCost = get3(airConditionerInstallCostAtom);
    const heatpumpInstallCost = get3(heatpumpInstallCostAtom);
    const statusQuoSimulationResult = get3(statusQuoSimulationResultAtom);
    const bestHeatPumpSimulationResult = get3(bestHeatPumpSimulationResultAtom);
    if (!statusQuoSimulationResult || !bestHeatPumpSimulationResult)
      return null;
    const heatpumpExcessInstallCost = heatpumpInstallCost - (statusQuoFurnaceInstallCost + airConditionerInstallCost);
    const annualOpexCostSavings = statusQuoSimulationResult.billsTotalCost - bestHeatPumpSimulationResult.billsTotalCost;
    const lifetimeCostSavings = annualOpexCostSavings * equipmentLifetimeYears - heatpumpExcessInstallCost;
    let paybackPeriod;
    if (heatpumpExcessInstallCost > 0) {
      if (annualOpexCostSavings > 0) {
        paybackPeriod = heatpumpExcessInstallCost / annualOpexCostSavings;
        if (paybackPeriod > equipmentLifetimeYears) {
          paybackPeriod = "never";
        }
      } else {
        paybackPeriod = "never";
      }
    } else {
      if (annualOpexCostSavings > 0) {
        paybackPeriod = "immediately";
      } else {
        paybackPeriod = "never";
      }
    }
    return {
      annualOpexCostSavings,
      annualEmissionsSavingGramsCo2e: statusQuoSimulationResult.emissionsGramsCO2e - bestHeatPumpSimulationResult.emissionsGramsCO2e,
      excessCapexCost: heatpumpExcessInstallCost,
      lifetimeCostSavings,
      paybackPeriod
    };
  });
  var statusQuoFurnaceInstallCostAtom = atom((get3) => {
    const statusQuoFurnaceFuel = get3(statusQuoFurnaceFuelAtom);
    switch (statusQuoFurnaceFuel) {
      case "electric":
        return get3(electricFurnaceInstallCostAtom);
      case "gas":
        return get3(gasFurnaceInstallCostAtom);
    }
  });
  var equipmentLifetimeYears = 15;
  var heatpumpLifetimeCostAtom = atom((get3) => {
    const heatpumpInstallCost = get3(heatpumpInstallCostAtom);
    const bestHeatPumpSimulationResult = get3(bestHeatPumpSimulationResultAtom);
    const locationInfo = get3(locationInfoAtom);
    if (!bestHeatPumpSimulationResult || !locationInfo)
      return null;
    return heatpumpInstallCost + bestHeatPumpSimulationResult.billsTotalCost * equipmentLifetimeYears;
  });
  var statusQuoLifetimeCostAtom = atom((get3) => {
    const statusQuoFurnaceInstallCost = get3(statusQuoFurnaceInstallCostAtom);
    const airConditionerInstallCost = get3(airConditionerInstallCostAtom);
    const statusQuoSimulationResult = get3(statusQuoSimulationResultAtom);
    if (!statusQuoSimulationResult)
      return null;
    return statusQuoFurnaceInstallCost + airConditionerInstallCost + statusQuoSimulationResult.billsTotalCost * equipmentLifetimeYears;
  });

  // src/app/views/lifetime-cost-of-ownership-view.tsx
  var import_react112 = __toESM(require_react());

  // src/app/chart.tsx
  var import_react80 = __toESM(require_react());
  var ChartHeader = (props) => {
    return /* @__PURE__ */ import_react80.default.createElement(Text, null, props.children);
  };
  var ChartGroup = (props) => {
    return /* @__PURE__ */ import_react80.default.createElement(
      Flex,
      {
        display: "inline-flex",
        direction: "column",
        fontFamily: "sans-serif",
        textAlign: "center",
        width: "full"
      },
      props.children
    );
  };

  // node_modules/d3-array/src/ascending.js
  function ascending(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-array/src/descending.js
  function descending(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d, x) => ascending(f(d), x);
      delta = (d, x) => f(d) - x;
    } else {
      compare1 = f === ascending || f === descending ? f : zero;
      compare2 = f;
      delta = f;
    }
    function left2(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) < 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) <= 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center(a, x, lo = 0, hi = a.length) {
      const i = left2(a, x, lo, hi - 1);
      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return { left: left2, center, right: right2 };
  }
  function zero() {
    return 0;
  }

  // node_modules/d3-array/src/number.js
  function number2(x) {
    return x === null ? NaN : +x;
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number2).center;
  var bisect_default = bisectRight;

  // node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null)
        for (const [key2, value] of entries)
          this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key))
      return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickSpec(start2, stop, count) {
    const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error2 = step / Math.pow(10, power), factor = error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start2 * inc);
      i2 = Math.round(stop * inc);
      if (i1 / inc < start2)
        ++i1;
      if (i2 / inc > stop)
        --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start2 / inc);
      i2 = Math.round(stop / inc);
      if (i1 * inc < start2)
        ++i1;
      if (i2 * inc > stop)
        --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2)
      return tickSpec(start2, stop, count * 2);
    return [i1, i2, inc];
  }
  function ticks(start2, stop, count) {
    stop = +stop, start2 = +start2, count = +count;
    if (!(count > 0))
      return [];
    if (start2 === stop)
      return [start2];
    const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
    if (!(i2 >= i1))
      return [];
    const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
    if (reverse) {
      if (inc < 0)
        for (let i = 0; i < n2; ++i)
          ticks2[i] = (i2 - i) / -inc;
      else
        for (let i = 0; i < n2; ++i)
          ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0)
        for (let i = 0; i < n2; ++i)
          ticks2[i] = (i1 + i) / -inc;
      else
        for (let i = 0; i < n2; ++i)
          ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start2, stop, count) {
    stop = +stop, start2 = +start2, count = +count;
    return tickSpec(start2, stop, count)[2];
  }
  function tickStep(start2, stop, count) {
    stop = +stop, start2 = +start2, count = +count;
    const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }

  // node_modules/d3-array/src/range.js
  function range(start2, stop, step) {
    start2 = +start2, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n2 < 3 ? 1 : +step;
    var i = -1, n2 = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n2);
    while (++i < n2) {
      range2[i] = start2 + i * step;
    }
    return range2;
  }

  // node_modules/d3-scale/src/init.js
  function initRange(domain, range2) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range2).domain(domain);
        break;
    }
    return this;
  }

  // node_modules/d3-scale/src/ordinal.js
  var implicit = Symbol("implicit");
  function ordinal() {
    var index = new InternMap(), domain = [], range2 = [], unknown = implicit;
    function scale3(d) {
      let i = index.get(d);
      if (i === void 0) {
        if (unknown !== implicit)
          return unknown;
        index.set(d, i = domain.push(d) - 1);
      }
      return range2[i % range2.length];
    }
    scale3.domain = function(_) {
      if (!arguments.length)
        return domain.slice();
      domain = [], index = new InternMap();
      for (const value of _) {
        if (index.has(value))
          continue;
        index.set(value, domain.push(value) - 1);
      }
      return scale3;
    };
    scale3.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), scale3) : range2.slice();
    };
    scale3.unknown = function(_) {
      return arguments.length ? (unknown = _, scale3) : unknown;
    };
    scale3.copy = function() {
      return ordinal(domain, range2).unknown(unknown);
    };
    initRange.apply(scale3, arguments);
    return scale3;
  }

  // node_modules/d3-scale/src/band.js
  function band() {
    var scale3 = ordinal().unknown(void 0), domain = scale3.domain, ordinalRange = scale3.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale3.unknown;
    function rescale() {
      var n2 = domain().length, reverse = r1 < r0, start2 = reverse ? r1 : r0, stop = reverse ? r0 : r1;
      step = (stop - start2) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
      if (round2)
        step = Math.floor(step);
      start2 += (stop - start2 - step * (n2 - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round2)
        start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
      var values = range(n2).map(function(i) {
        return start2 + step * i;
      });
      return ordinalRange(reverse ? values.reverse() : values);
    }
    scale3.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale3.range = function(_) {
      return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale3.rangeRound = function(_) {
      return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
    };
    scale3.bandwidth = function() {
      return bandwidth;
    };
    scale3.step = function() {
      return step;
    };
    scale3.round = function(_) {
      return arguments.length ? (round2 = !!_, rescale()) : round2;
    };
    scale3.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale3.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale3.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale3.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale3.copy = function() {
      return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory2, prototype) {
    constructor.prototype = factory2.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color3, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color3(format2) {
    var m, l2;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l2 = m[1].length, m = parseInt(m[1], 16), l2 === 6 ? rgbn(m) : l2 === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l2 === 8 ? rgba3(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l2 === 4 ? rgba3(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba3(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba3(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla3(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla3(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n2) {
    return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
  }
  function rgba3(r3, g, b, a) {
    if (a <= 0)
      r3 = g = b = NaN;
    return new Rgb(r3, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color))
      o = color3(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r3, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r3) : new Rgb(r3, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r3, g, b, opacity) {
    this.r = +r3;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}${hex2((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex2(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla3(h, s2, l2, a) {
    if (a <= 0)
      h = s2 = l2 = NaN;
    else if (l2 <= 0 || l2 >= 1)
      h = s2 = NaN;
    else if (s2 <= 0)
      h = NaN;
    return new Hsl(h, s2, l2, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color))
      o = color3(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r3 = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r3, g, b), max2 = Math.max(r3, g, b), h = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
    if (s2) {
      if (r3 === max2)
        h = (g - b) / s2 + (g < b) * 6;
      else if (g === max2)
        h = (b - r3) / s2 + 2;
      else
        h = (r3 - g) / s2 + 4;
      s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s2 = l2 > 0 && l2 < 1 ? 0 : h;
    }
    return new Hsl(h, s2, l2, o.opacity);
  }
  function hsl(h, s2, l2, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l2, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s2, l2, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // node_modules/d3-color/src/math.js
  var radians = Math.PI / 180;
  var degrees2 = 180 / Math.PI;

  // node_modules/d3-color/src/lab.js
  var K = 18;
  var Xn = 0.96422;
  var Yn = 1;
  var Zn = 0.82521;
  var t0 = 4 / 29;
  var t1 = 6 / 29;
  var t2 = 3 * t1 * t1;
  var t3 = t1 * t1 * t1;
  function labConvert(o) {
    if (o instanceof Lab)
      return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl)
      return hcl2lab(o);
    if (!(o instanceof Rgb))
      o = rgbConvert(o);
    var r3 = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r3 + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
    if (r3 === g && g === b)
      x = z = y;
    else {
      x = xyz2lab((0.4360747 * r3 + 0.3850649 * g + 0.1430804 * b) / Xn);
      z = xyz2lab((0.0139322 * r3 + 0.0971045 * g + 0.7141733 * b) / Zn);
    }
    return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
  }
  function lab(l2, a, b, opacity) {
    return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a, b, opacity == null ? 1 : opacity);
  }
  function Lab(l2, a, b, opacity) {
    this.l = +l2;
    this.a = +a;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Lab, lab, extend(Color, {
    brighter(k) {
      return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    darker(k) {
      return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    rgb() {
      var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
      x = Xn * lab2xyz(x);
      y = Yn * lab2xyz(y);
      z = Zn * lab2xyz(z);
      return new Rgb(
        lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
        lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
        lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
        this.opacity
      );
    }
  }));
  function xyz2lab(t4) {
    return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0;
  }
  function lab2xyz(t4) {
    return t4 > t1 ? t4 * t4 * t4 : t2 * (t4 - t0);
  }
  function lrgb2rgb(x) {
    return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
  }
  function rgb2lrgb(x) {
    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }
  function hclConvert(o) {
    if (o instanceof Hcl)
      return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab))
      o = labConvert(o);
    if (o.a === 0 && o.b === 0)
      return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
    var h = Math.atan2(o.b, o.a) * degrees2;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }
  function hcl(h, c, l2, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l2, opacity == null ? 1 : opacity);
  }
  function Hcl(h, c, l2, opacity) {
    this.h = +h;
    this.c = +c;
    this.l = +l2;
    this.opacity = +opacity;
  }
  function hcl2lab(o) {
    if (isNaN(o.h))
      return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * radians;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  define_default(Hcl, hcl, extend(Color, {
    brighter(k) {
      return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
    },
    darker(k) {
      return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
    },
    rgb() {
      return hcl2lab(this).rgb();
    }
  }));

  // node_modules/d3-color/src/cubehelix.js
  var A = -0.14861;
  var B = 1.78277;
  var C = -0.29227;
  var D = -0.90649;
  var E = 1.97294;
  var ED = E * D;
  var EB = E * B;
  var BC_DA = B * C - D * A;
  function cubehelixConvert(o) {
    if (o instanceof Cubehelix)
      return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb))
      o = rgbConvert(o);
    var r3 = o.r / 255, g = o.g / 255, b = o.b / 255, l2 = (BC_DA * b + ED * r3 - EB * g) / (BC_DA + ED - EB), bl = b - l2, k = (E * (g - l2) - C * bl) / D, s2 = Math.sqrt(k * k + bl * bl) / (E * l2 * (1 - l2)), h = s2 ? Math.atan2(k, bl) * degrees2 - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s2, l2, o.opacity);
  }
  function cubehelix(h, s2, l2, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l2, opacity == null ? 1 : opacity);
  }
  function Cubehelix(h, s2, l2, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Cubehelix, cubehelix, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l2 = +this.l, a = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh = Math.cos(h), sinh = Math.sin(h);
      return new Rgb(
        255 * (l2 + a * (A * cosh + B * sinh)),
        255 * (l2 + a * (C * cosh + D * sinh)),
        255 * (l2 + a * (E * cosh)),
        this.opacity
      );
    }
  }));

  // node_modules/d3-interpolate/src/basis.js
  function basis(t13, v0, v1, v2, v3) {
    var t22 = t13 * t13, t32 = t22 * t13;
    return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
  }
  function basis_default(values) {
    var n2 = values.length - 1;
    return function(t4) {
      var i = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n2 - 1) : Math.floor(t4 * n2), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n2 - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t4 - i / n2) * n2, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n2 = values.length;
    return function(t4) {
      var i = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n2), v0 = values[(i + n2 - 1) % n2], v1 = values[i % n2], v2 = values[(i + 1) % n2], v3 = values[(i + 2) % n2];
      return basis((t4 - i / n2) * n2, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default = (x) => () => x;

  // node_modules/d3-interpolate/src/color.js
  function linear(a, d) {
    return function(t4) {
      return a + t4 * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t4) {
      return Math.pow(a + t4 * b, y);
    };
  }
  function hue(a, b) {
    var d = b - a;
    return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a) ? b : a);
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y) {
    var color4 = gamma(y);
    function rgb2(start2, end2) {
      var r3 = color4((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g = color4(start2.g, end2.g), b = color4(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t4) {
        start2.r = r3(t4);
        start2.g = g(t4);
        start2.b = b(t4);
        start2.opacity = opacity(t4);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors2) {
      var n2 = colors2.length, r3 = new Array(n2), g = new Array(n2), b = new Array(n2), i, color4;
      for (i = 0; i < n2; ++i) {
        color4 = rgb(colors2[i]);
        r3[i] = color4.r || 0;
        g[i] = color4.g || 0;
        b[i] = color4.b || 0;
      }
      r3 = spline(r3);
      g = spline(g);
      b = spline(b);
      color4.opacity = 1;
      return function(t4) {
        color4.r = r3(t4);
        color4.g = g(t4);
        color4.b = b(t4);
        return color4 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b)
      b = [];
    var n2 = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t4) {
      for (i = 0; i < n2; ++i)
        c[i] = a[i] * (1 - t4) + b[i] * t4;
      return c;
    };
  }
  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i)
      x[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i)
      c[i] = b[i];
    return function(t4) {
      for (i = 0; i < na; ++i)
        c[i] = x[i](t4);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = /* @__PURE__ */ new Date();
    return a = +a, b = +b, function(t4) {
      return d.setTime(a * (1 - t4) + b * t4), d;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t4) {
      return a * (1 - t4) + b * t4;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object")
      a = {};
    if (b === null || typeof b !== "object")
      b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t4) {
      for (k in i)
        c[k] = i[k](t4);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero2(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t4) {
      return b(t4) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s2[i])
          s2[i] += bs;
        else
          s2[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s2[i])
          s2[i] += bm;
        else
          s2[++i] = bm;
      } else {
        s2[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t4) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s2[(o = q[i2]).i] = o.x(t4);
      return s2.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t4 = typeof b, c;
    return b == null || t4 === "boolean" ? constant_default(b) : (t4 === "number" ? number_default : t4 === "string" ? (c = color3(b)) ? (b = c, rgb_default) : string_default : b instanceof color3 ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
  }

  // node_modules/d3-interpolate/src/round.js
  function round_default(a, b) {
    return a = +a, b = +b, function(t4) {
      return Math.round(a * (1 - t4) + b * t4);
    };
  }

  // node_modules/d3-interpolate/src/hsl.js
  function hsl2(hue2) {
    return function(start2, end2) {
      var h = hue2((start2 = hsl(start2)).h, (end2 = hsl(end2)).h), s2 = nogamma(start2.s, end2.s), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t4) {
        start2.h = h(t4);
        start2.s = s2(t4);
        start2.l = l2(t4);
        start2.opacity = opacity(t4);
        return start2 + "";
      };
    };
  }
  var hsl_default = hsl2(hue);
  var hslLong = hsl2(nogamma);

  // node_modules/d3-interpolate/src/lab.js
  function lab2(start2, end2) {
    var l2 = nogamma((start2 = lab(start2)).l, (end2 = lab(end2)).l), a = nogamma(start2.a, end2.a), b = nogamma(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t4) {
      start2.l = l2(t4);
      start2.a = a(t4);
      start2.b = b(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  }

  // node_modules/d3-interpolate/src/hcl.js
  function hcl2(hue2) {
    return function(start2, end2) {
      var h = hue2((start2 = hcl(start2)).h, (end2 = hcl(end2)).h), c = nogamma(start2.c, end2.c), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t4) {
        start2.h = h(t4);
        start2.c = c(t4);
        start2.l = l2(t4);
        start2.opacity = opacity(t4);
        return start2 + "";
      };
    };
  }
  var hcl_default = hcl2(hue);
  var hclLong = hcl2(nogamma);

  // node_modules/d3-interpolate/src/cubehelix.js
  function cubehelix2(hue2) {
    return function cubehelixGamma(y) {
      y = +y;
      function cubehelix3(start2, end2) {
        var h = hue2((start2 = cubehelix(start2)).h, (end2 = cubehelix(end2)).h), s2 = nogamma(start2.s, end2.s), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
        return function(t4) {
          start2.h = h(t4);
          start2.s = s2(t4);
          start2.l = l2(Math.pow(t4, y));
          start2.opacity = opacity(t4);
          return start2 + "";
        };
      }
      cubehelix3.gamma = cubehelixGamma;
      return cubehelix3;
    }(1);
  }
  var cubehelix_default = cubehelix2(hue);
  var cubehelixLong = cubehelix2(nogamma);

  // node_modules/d3-scale/src/constant.js
  function constants(x) {
    return function() {
      return x;
    };
  }

  // node_modules/d3-scale/src/number.js
  function number3(x) {
    return +x;
  }

  // node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity(x) {
    return x;
  }
  function normalize3(a, b) {
    return (b -= a = +a) ? function(x) {
      return (x - a) / b;
    } : constants(isNaN(b) ? NaN : 0.5);
  }
  function clamper(a, b) {
    var t4;
    if (a > b)
      t4 = a, a = b, b = t4;
    return function(x) {
      return Math.max(a, Math.min(b, x));
    };
  }
  function bimap(domain, range2, interpolate3) {
    var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
    if (d1 < d0)
      d0 = normalize3(d1, d0), r0 = interpolate3(r1, r0);
    else
      d0 = normalize3(d0, d1), r0 = interpolate3(r0, r1);
    return function(x) {
      return r0(d0(x));
    };
  }
  function polymap(domain, range2, interpolate3) {
    var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r3 = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range2 = range2.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize3(domain[i], domain[i + 1]);
      r3[i] = interpolate3(range2[i], range2[i + 1]);
    }
    return function(x) {
      var i2 = bisect_default(domain, x, 1, j) - 1;
      return r3[i2](d[i2](x));
    };
  }
  function copy2(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer() {
    var domain = unit, range2 = unit, interpolate3 = value_default, transform2, untransform, unknown, clamp3 = identity, piecewise, output, input;
    function rescale() {
      var n2 = Math.min(domain.length, range2.length);
      if (clamp3 !== identity)
        clamp3 = clamper(domain[0], domain[n2 - 1]);
      piecewise = n2 > 2 ? polymap : bimap;
      output = input = null;
      return scale3;
    }
    function scale3(x) {
      return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform2), range2, interpolate3)))(transform2(clamp3(x)));
    }
    scale3.invert = function(y) {
      return clamp3(untransform((input || (input = piecewise(range2, domain.map(transform2), number_default)))(y)));
    };
    scale3.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
    };
    scale3.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
    };
    scale3.rangeRound = function(_) {
      return range2 = Array.from(_), interpolate3 = round_default, rescale();
    };
    scale3.clamp = function(_) {
      return arguments.length ? (clamp3 = _ ? true : identity, rescale()) : clamp3 !== identity;
    };
    scale3.interpolate = function(_) {
      return arguments.length ? (interpolate3 = _, rescale()) : interpolate3;
    };
    scale3.unknown = function(_) {
      return arguments.length ? (unknown = _, scale3) : unknown;
    };
    return function(t4, u) {
      transform2 = t4, untransform = u;
      return rescale();
    };
  }
  function continuous() {
    return transformer()(identity, identity);
  }

  // node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x) {
    return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
  }
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
      return null;
    var i, coefficient = x.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  // node_modules/d3-format/src/exponent.js
  function exponent_default(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  // node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width) {
      var i = value.length, t4 = [], j = 0, g = grouping[0], length2 = 0;
      while (i > 0 && g > 0) {
        if (length2 + g + 1 > width)
          g = Math.max(1, width - length2);
        t4.push(value.substring(i -= g, i + g));
        if ((length2 += g + 1) > width)
          break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t4.reverse().join(thousands);
    };
  }

  // node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match3 = re.exec(specifier)))
      throw new Error("invalid format: " + specifier);
    var match3;
    return new FormatSpecifier({
      fill: match3[1],
      align: match3[2],
      sign: match3[3],
      symbol: match3[4],
      zero: match3[5],
      width: match3[6],
      comma: match3[7],
      precision: match3[8] && match3[8].slice(1),
      trim: match3[9],
      type: match3[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s2) {
    out:
      for (var n2 = s2.length, i = 1, i0 = -1, i1; i < n2; ++i) {
        switch (s2[i]) {
          case ".":
            i0 = i1 = i;
            break;
          case "0":
            if (i0 === 0)
              i0 = i;
            i1 = i;
            break;
          default:
            if (!+s2[i])
              break out;
            if (i0 > 0)
              i0 = 0;
            break;
        }
      }
    return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
  }

  // node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d)
      return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
    return i === n2 ? coefficient : i > n2 ? coefficient + new Array(i - n2 + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
  }

  // node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d)
      return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x, p) => (x * 100).toFixed(p),
    "b": (x) => Math.round(x).toString(2),
    "c": (x) => x + "",
    "d": formatDecimal_default,
    "e": (x, p) => x.toExponential(p),
    "f": (x, p) => x.toFixed(p),
    "g": (x, p) => x.toPrecision(p),
    "o": (x) => Math.round(x).toString(8),
    "p": (x, p) => formatRounded_default(x * 100, p),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x) => Math.round(x).toString(16).toUpperCase(),
    "x": (x) => Math.round(x).toString(16)
  };

  // node_modules/d3-format/src/identity.js
  function identity_default(x) {
    return x;
  }

  // node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale3) {
    var group = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale3.numerals, String)), percent2 = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill2 = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero4 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
      if (type === "n")
        comma = true, type = "g";
      else if (!formatTypes_default[type])
        precision === void 0 && (precision = 12), trim2 = true, type = "g";
      if (zero4 || fill2 === "0" && align === "=")
        zero4 = true, fill2 = "0", align = "=";
      var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent2 : "";
      var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix2, valueSuffix = suffix, i, n2, c;
        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim2)
            value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign !== "+")
            valueNegative = false;
          valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n2 = value.length;
            while (++i < n2) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero4)
          value = group(value, Infinity);
        var length2 = valuePrefix.length + value.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill2) : "";
        if (comma && zero4)
          value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length2);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e3), prefix2 = prefixes[8 + e3 / 3];
      return function(value2) {
        return f(k * value2) + prefix2;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale2({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale2(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step) {
    return Math.max(0, -exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step, max2) {
    step = Math.abs(step), max2 = Math.abs(max2) - step;
    return Math.max(0, exponent_default(max2) - exponent_default(step)) + 1;
  }

  // node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start2, stop, count, specifier) {
    var step = tickStep(start2, stop, count), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start2), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
          specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
          specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
          specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // node_modules/d3-scale/src/linear.js
  function linearish(scale3) {
    var domain = scale3.domain;
    scale3.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale3.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale3.nice = function(count) {
      if (count == null)
        count = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start2 = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start2) {
        step = start2, start2 = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start2, stop, count);
        if (step === prestep) {
          d[i0] = start2;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start2 = Math.floor(start2 / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start2 = Math.ceil(start2 * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale3;
    };
    return scale3;
  }
  function linear2() {
    var scale3 = continuous();
    scale3.copy = function() {
      return copy2(scale3, linear2());
    };
    initRange.apply(scale3, arguments);
    return linearish(scale3);
  }

  // node_modules/d3-scale/src/nice.js
  function nice(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t4;
    if (x1 < x0) {
      t4 = i0, i0 = i1, i1 = t4;
      t4 = x0, x0 = x1, x1 = t4;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  // node_modules/d3-time/src/interval.js
  var t02 = /* @__PURE__ */ new Date();
  var t12 = /* @__PURE__ */ new Date();
  function timeInterval(floori, offseti, count, field) {
    function interval(date2) {
      return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
    }
    interval.floor = (date2) => {
      return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
    };
    interval.ceil = (date2) => {
      return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
    };
    interval.round = (date2) => {
      const d0 = interval(date2), d1 = interval.ceil(date2);
      return date2 - d0 < d1 - date2 ? d0 : d1;
    };
    interval.offset = (date2, step) => {
      return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
    };
    interval.range = (start2, stop, step) => {
      const range2 = [];
      start2 = interval.ceil(start2);
      step = step == null ? 1 : Math.floor(step);
      if (!(start2 < stop) || !(step > 0))
        return range2;
      let previous;
      do
        range2.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
      while (previous < start2 && start2 < stop);
      return range2;
    };
    interval.filter = (test2) => {
      return timeInterval((date2) => {
        if (date2 >= date2)
          while (floori(date2), !test2(date2))
            date2.setTime(date2 - 1);
      }, (date2, step) => {
        if (date2 >= date2) {
          if (step < 0)
            while (++step <= 0) {
              while (offseti(date2, -1), !test2(date2)) {
              }
            }
          else
            while (--step >= 0) {
              while (offseti(date2, 1), !test2(date2)) {
              }
            }
        }
      });
    };
    if (count) {
      interval.count = (start2, end2) => {
        t02.setTime(+start2), t12.setTime(+end2);
        floori(t02), floori(t12);
        return Math.floor(count(t02, t12));
      };
      interval.every = (step) => {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
      };
    }
    return interval;
  }

  // node_modules/d3-time/src/millisecond.js
  var millisecond = timeInterval(() => {
  }, (date2, step) => {
    date2.setTime(+date2 + step);
  }, (start2, end2) => {
    return end2 - start2;
  });
  millisecond.every = (k) => {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0))
      return null;
    if (!(k > 1))
      return millisecond;
    return timeInterval((date2) => {
      date2.setTime(Math.floor(date2 / k) * k);
    }, (date2, step) => {
      date2.setTime(+date2 + step * k);
    }, (start2, end2) => {
      return (end2 - start2) / k;
    });
  };
  var milliseconds = millisecond.range;

  // node_modules/d3-time/src/duration.js
  var durationSecond = 1e3;
  var durationMinute = durationSecond * 60;
  var durationHour = durationMinute * 60;
  var durationDay = durationHour * 24;
  var durationWeek = durationDay * 7;
  var durationMonth = durationDay * 30;
  var durationYear = durationDay * 365;

  // node_modules/d3-time/src/second.js
  var second = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds());
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationSecond);
  }, (start2, end2) => {
    return (end2 - start2) / durationSecond;
  }, (date2) => {
    return date2.getUTCSeconds();
  });
  var seconds = second.range;

  // node_modules/d3-time/src/minute.js
  var timeMinute = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start2, end2) => {
    return (end2 - start2) / durationMinute;
  }, (date2) => {
    return date2.getMinutes();
  });
  var timeMinutes = timeMinute.range;
  var utcMinute = timeInterval((date2) => {
    date2.setUTCSeconds(0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start2, end2) => {
    return (end2 - start2) / durationMinute;
  }, (date2) => {
    return date2.getUTCMinutes();
  });
  var utcMinutes = utcMinute.range;

  // node_modules/d3-time/src/hour.js
  var timeHour = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start2, end2) => {
    return (end2 - start2) / durationHour;
  }, (date2) => {
    return date2.getHours();
  });
  var timeHours = timeHour.range;
  var utcHour = timeInterval((date2) => {
    date2.setUTCMinutes(0, 0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start2, end2) => {
    return (end2 - start2) / durationHour;
  }, (date2) => {
    return date2.getUTCHours();
  });
  var utcHours = utcHour.range;

  // node_modules/d3-time/src/day.js
  var timeDay = timeInterval(
    (date2) => date2.setHours(0, 0, 0, 0),
    (date2, step) => date2.setDate(date2.getDate() + step),
    (start2, end2) => (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
    (date2) => date2.getDate() - 1
  );
  var timeDays = timeDay.range;
  var utcDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start2, end2) => {
    return (end2 - start2) / durationDay;
  }, (date2) => {
    return date2.getUTCDate() - 1;
  });
  var utcDays = utcDay.range;
  var unixDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start2, end2) => {
    return (end2 - start2) / durationDay;
  }, (date2) => {
    return Math.floor(date2 / durationDay);
  });
  var unixDays = unixDay.range;

  // node_modules/d3-time/src/week.js
  function timeWeekday(i) {
    return timeInterval((date2) => {
      date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setDate(date2.getDate() + step * 7);
    }, (start2, end2) => {
      return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }
  var timeSunday = timeWeekday(0);
  var timeMonday = timeWeekday(1);
  var timeTuesday = timeWeekday(2);
  var timeWednesday = timeWeekday(3);
  var timeThursday = timeWeekday(4);
  var timeFriday = timeWeekday(5);
  var timeSaturday = timeWeekday(6);
  var timeSundays = timeSunday.range;
  var timeMondays = timeMonday.range;
  var timeTuesdays = timeTuesday.range;
  var timeWednesdays = timeWednesday.range;
  var timeThursdays = timeThursday.range;
  var timeFridays = timeFriday.range;
  var timeSaturdays = timeSaturday.range;
  function utcWeekday(i) {
    return timeInterval((date2) => {
      date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step * 7);
    }, (start2, end2) => {
      return (end2 - start2) / durationWeek;
    });
  }
  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);
  var utcSundays = utcSunday.range;
  var utcMondays = utcMonday.range;
  var utcTuesdays = utcTuesday.range;
  var utcWednesdays = utcWednesday.range;
  var utcThursdays = utcThursday.range;
  var utcFridays = utcFriday.range;
  var utcSaturdays = utcSaturday.range;

  // node_modules/d3-time/src/month.js
  var timeMonth = timeInterval((date2) => {
    date2.setDate(1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setMonth(date2.getMonth() + step);
  }, (start2, end2) => {
    return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
  }, (date2) => {
    return date2.getMonth();
  });
  var timeMonths = timeMonth.range;
  var utcMonth = timeInterval((date2) => {
    date2.setUTCDate(1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCMonth(date2.getUTCMonth() + step);
  }, (start2, end2) => {
    return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
  }, (date2) => {
    return date2.getUTCMonth();
  });
  var utcMonths = utcMonth.range;

  // node_modules/d3-time/src/year.js
  var timeYear = timeInterval((date2) => {
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step);
  }, (start2, end2) => {
    return end2.getFullYear() - start2.getFullYear();
  }, (date2) => {
    return date2.getFullYear();
  });
  timeYear.every = (k) => {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date2) => {
      date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step * k);
    });
  };
  var timeYears = timeYear.range;
  var utcYear = timeInterval((date2) => {
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step);
  }, (start2, end2) => {
    return end2.getUTCFullYear() - start2.getUTCFullYear();
  }, (date2) => {
    return date2.getUTCFullYear();
  });
  utcYear.every = (k) => {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date2) => {
      date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
    });
  };
  var utcYears = utcYear.range;

  // node_modules/d3-time/src/ticks.js
  function ticker(year, month, week, day, hour, minute) {
    const tickIntervals = [
      [second, 1, durationSecond],
      [second, 5, 5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute, 1, durationMinute],
      [minute, 5, 5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [hour, 1, durationHour],
      [hour, 3, 3 * durationHour],
      [hour, 6, 6 * durationHour],
      [hour, 12, 12 * durationHour],
      [day, 1, durationDay],
      [day, 2, 2 * durationDay],
      [week, 1, durationWeek],
      [month, 1, durationMonth],
      [month, 3, 3 * durationMonth],
      [year, 1, durationYear]
    ];
    function ticks2(start2, stop, count) {
      const reverse = stop < start2;
      if (reverse)
        [start2, stop] = [stop, start2];
      const interval = count && typeof count.range === "function" ? count : tickInterval(start2, stop, count);
      const ticks3 = interval ? interval.range(start2, +stop + 1) : [];
      return reverse ? ticks3.reverse() : ticks3;
    }
    function tickInterval(start2, stop, count) {
      const target = Math.abs(stop - start2) / count;
      const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
      if (i === tickIntervals.length)
        return year.every(tickStep(start2 / durationYear, stop / durationYear, count));
      if (i === 0)
        return millisecond.every(Math.max(tickStep(start2, stop, count), 1));
      const [t4, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
      return t4.every(step);
    }
    return [ticks2, tickInterval];
  }
  var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
  var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

  // node_modules/d3-time-format/src/locale.js
  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date2.setFullYear(d.y);
      return date2;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }
  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date2.setUTCFullYear(d.y);
      return date2;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }
  function newDate(y, m, d) {
    return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
  }
  function formatLocale(locale3) {
    var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };
    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };
    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats2) {
      return function(date2) {
        var string = [], i = -1, j = 0, n2 = specifier.length, c, pad2, format2;
        if (!(date2 instanceof Date))
          date2 = /* @__PURE__ */ new Date(+date2);
        while (++i < n2) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad2 = pads[c = specifier.charAt(++i)]) != null)
              c = specifier.charAt(++i);
            else
              pad2 = c === "e" ? " " : "0";
            if (format2 = formats2[c])
              c = format2(date2, pad2);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }
    function newParse(specifier, Z) {
      return function(string) {
        var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
        if (i != string.length)
          return null;
        if ("Q" in d)
          return new Date(d.Q);
        if ("s" in d)
          return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
        if (Z && !("Z" in d))
          d.Z = 0;
        if ("p" in d)
          d.H = d.H % 12 + d.p * 12;
        if (d.m === void 0)
          d.m = "q" in d ? d.q : 0;
        if ("V" in d) {
          if (d.V < 1 || d.V > 53)
            return null;
          if (!("w" in d))
            d.w = 1;
          if ("Z" in d) {
            week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
            week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
            week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
            week = timeDay.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d))
            d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
        }
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }
        return localDate(d);
      };
    }
    function parseSpecifier(d, specifier, string, j) {
      var i = 0, n2 = specifier.length, m = string.length, c, parse3;
      while (i < n2) {
        if (j >= m)
          return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse3 = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse3 || (j = parse3(d, string, j)) < 0)
            return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    function parsePeriod(d, string, i) {
      var n2 = periodRe.exec(string.slice(i));
      return n2 ? (d.p = periodLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseShortWeekday(d, string, i) {
      var n2 = shortWeekdayRe.exec(string.slice(i));
      return n2 ? (d.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseWeekday(d, string, i) {
      var n2 = weekdayRe.exec(string.slice(i));
      return n2 ? (d.w = weekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseShortMonth(d, string, i) {
      var n2 = shortMonthRe.exec(string.slice(i));
      return n2 ? (d.m = shortMonthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseMonth(d, string, i) {
      var n2 = monthRe.exec(string.slice(i));
      return n2 ? (d.m = monthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }
    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }
    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }
    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }
    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }
    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }
    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }
    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }
    function formatQuarter(d) {
      return 1 + ~~(d.getMonth() / 3);
    }
    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }
    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }
    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }
    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }
    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d) {
      return 1 + ~~(d.getUTCMonth() / 3);
    }
    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", false);
        p.toString = function() {
          return specifier;
        };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier += "", true);
        p.toString = function() {
          return specifier;
        };
        return p;
      }
    };
  }
  var pads = { "-": "", "_": " ", "0": "0" };
  var numberRe = /^\s*\d+/;
  var percentRe = /^%/;
  var requoteRe = /[\\^$*+?|[\]().{}]/g;
  function pad(value, fill2, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length2 = string.length;
    return sign + (length2 < width ? new Array(width - length2 + 1).join(fill2) + string : string);
  }
  function requote(s2) {
    return s2.replace(requoteRe, "\\$&");
  }
  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }
  function formatLookup(names) {
    return new Map(names.map((name, i) => [name.toLowerCase(), i]));
  }
  function parseWeekdayNumberSunday(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 1));
    return n2 ? (d.w = +n2[0], i + n2[0].length) : -1;
  }
  function parseWeekdayNumberMonday(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 1));
    return n2 ? (d.u = +n2[0], i + n2[0].length) : -1;
  }
  function parseWeekNumberSunday(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.U = +n2[0], i + n2[0].length) : -1;
  }
  function parseWeekNumberISO(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.V = +n2[0], i + n2[0].length) : -1;
  }
  function parseWeekNumberMonday(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.W = +n2[0], i + n2[0].length) : -1;
  }
  function parseFullYear(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 4));
    return n2 ? (d.y = +n2[0], i + n2[0].length) : -1;
  }
  function parseYear(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i + n2[0].length) : -1;
  }
  function parseZone(d, string, i) {
    var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n2 ? (d.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i + n2[0].length) : -1;
  }
  function parseQuarter(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 1));
    return n2 ? (d.q = n2[0] * 3 - 3, i + n2[0].length) : -1;
  }
  function parseMonthNumber(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.m = n2[0] - 1, i + n2[0].length) : -1;
  }
  function parseDayOfMonth(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.d = +n2[0], i + n2[0].length) : -1;
  }
  function parseDayOfYear(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 3));
    return n2 ? (d.m = 0, d.d = +n2[0], i + n2[0].length) : -1;
  }
  function parseHour24(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.H = +n2[0], i + n2[0].length) : -1;
  }
  function parseMinutes(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.M = +n2[0], i + n2[0].length) : -1;
  }
  function parseSeconds(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d.S = +n2[0], i + n2[0].length) : -1;
  }
  function parseMilliseconds(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 3));
    return n2 ? (d.L = +n2[0], i + n2[0].length) : -1;
  }
  function parseMicroseconds(d, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 6));
    return n2 ? (d.L = Math.floor(n2[0] / 1e3), i + n2[0].length) : -1;
  }
  function parseLiteralPercent(d, string, i) {
    var n2 = percentRe.exec(string.slice(i, i + 1));
    return n2 ? i + n2[0].length : -1;
  }
  function parseUnixTimestamp(d, string, i) {
    var n2 = numberRe.exec(string.slice(i));
    return n2 ? (d.Q = +n2[0], i + n2[0].length) : -1;
  }
  function parseUnixTimestampSeconds(d, string, i) {
    var n2 = numberRe.exec(string.slice(i));
    return n2 ? (d.s = +n2[0], i + n2[0].length) : -1;
  }
  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }
  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }
  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }
  function formatDayOfYear(d, p) {
    return pad(1 + timeDay.count(timeYear(d), d), p, 3);
  }
  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }
  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }
  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }
  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }
  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }
  function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }
  function formatWeekNumberSunday(d, p) {
    return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
  }
  function dISO(d) {
    var day = d.getDay();
    return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  }
  function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
  }
  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }
  function formatWeekNumberMonday(d, p) {
    return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
  }
  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }
  function formatYearISO(d, p) {
    d = dISO(d);
    return pad(d.getFullYear() % 100, p, 2);
  }
  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 1e4, p, 4);
  }
  function formatFullYearISO(d, p) {
    var day = d.getDay();
    d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
    return pad(d.getFullYear() % 1e4, p, 4);
  }
  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
  }
  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }
  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }
  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }
  function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay.count(utcYear(d), d), p, 3);
  }
  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }
  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }
  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }
  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }
  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }
  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }
  function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
  }
  function UTCdISO(d) {
    var day = d.getUTCDay();
    return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  }
  function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
  }
  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }
  function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
  }
  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCFullYearISO(d, p) {
    var day = d.getUTCDay();
    d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    return pad(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCZone() {
    return "+0000";
  }
  function formatLiteralPercent() {
    return "%";
  }
  function formatUnixTimestamp(d) {
    return +d;
  }
  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1e3);
  }

  // node_modules/d3-time-format/src/defaultLocale.js
  var locale2;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;
  defaultLocale3({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function defaultLocale3(definition) {
    locale2 = formatLocale(definition);
    timeFormat = locale2.format;
    timeParse = locale2.parse;
    utcFormat = locale2.utcFormat;
    utcParse = locale2.utcParse;
    return locale2;
  }

  // node_modules/d3-scale/src/time.js
  function date(t4) {
    return new Date(t4);
  }
  function number4(t4) {
    return t4 instanceof Date ? +t4 : +/* @__PURE__ */ new Date(+t4);
  }
  function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
    var scale3 = continuous(), invert = scale3.invert, domain = scale3.domain;
    var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
    function tickFormat2(date2) {
      return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
    }
    scale3.invert = function(y) {
      return new Date(invert(y));
    };
    scale3.domain = function(_) {
      return arguments.length ? domain(Array.from(_, number4)) : domain().map(date);
    };
    scale3.ticks = function(interval) {
      var d = domain();
      return ticks2(d[0], d[d.length - 1], interval == null ? 10 : interval);
    };
    scale3.tickFormat = function(count, specifier) {
      return specifier == null ? tickFormat2 : format2(specifier);
    };
    scale3.nice = function(interval) {
      var d = domain();
      if (!interval || typeof interval.range !== "function")
        interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
      return interval ? domain(nice(d, interval)) : scale3;
    };
    scale3.copy = function() {
      return copy2(scale3, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
    };
    return scale3;
  }

  // node_modules/d3-scale/src/utcTime.js
  function utcTime() {
    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }

  // node_modules/@visx/scale/esm/operators/domain.js
  function applyDomain(scale3, config2) {
    if (config2.domain) {
      if ("nice" in scale3 || "quantiles" in scale3) {
        scale3.domain(config2.domain);
      } else if ("padding" in scale3) {
        scale3.domain(config2.domain);
      } else {
        scale3.domain(config2.domain);
      }
    }
  }

  // node_modules/@visx/scale/esm/operators/range.js
  function applyRange(scale3, config2) {
    if (config2.range) {
      if ("padding" in scale3) {
        scale3.range(config2.range);
      } else {
        scale3.range(config2.range);
      }
    }
  }

  // node_modules/@visx/scale/esm/operators/align.js
  function applyAlign(scale3, config2) {
    if ("align" in scale3 && "align" in config2 && typeof config2.align !== "undefined") {
      scale3.align(config2.align);
    }
  }

  // node_modules/@visx/scale/esm/operators/base.js
  function applyBase(scale3, config2) {
    if ("base" in scale3 && "base" in config2 && typeof config2.base !== "undefined") {
      scale3.base(config2.base);
    }
  }

  // node_modules/@visx/scale/esm/operators/clamp.js
  function applyClamp(scale3, config2) {
    if ("clamp" in scale3 && "clamp" in config2 && typeof config2.clamp !== "undefined") {
      scale3.clamp(config2.clamp);
    }
  }

  // node_modules/@visx/scale/esm/operators/constant.js
  function applyConstant(scale3, config2) {
    if ("constant" in scale3 && "constant" in config2 && typeof config2.constant !== "undefined") {
      scale3.constant(config2.constant);
    }
  }

  // node_modules/@visx/scale/esm/operators/exponent.js
  function applyExponent(scale3, config2) {
    if ("exponent" in scale3 && "exponent" in config2 && typeof config2.exponent !== "undefined") {
      scale3.exponent(config2.exponent);
    }
  }

  // node_modules/@visx/scale/esm/utils/createColorInterpolator.js
  var interpolatorMap = {
    lab: lab2,
    hcl: hcl_default,
    "hcl-long": hclLong,
    hsl: hsl_default,
    "hsl-long": hslLong,
    cubehelix: cubehelix_default,
    "cubehelix-long": cubehelixLong,
    rgb: rgb_default
  };
  function createColorInterpolator(interpolate3) {
    switch (interpolate3) {
      case "lab":
      case "hcl":
      case "hcl-long":
      case "hsl":
      case "hsl-long":
      case "cubehelix":
      case "cubehelix-long":
      case "rgb":
        return interpolatorMap[interpolate3];
      default:
    }
    var type = interpolate3.type, gamma2 = interpolate3.gamma;
    var interpolator = interpolatorMap[type];
    return typeof gamma2 === "undefined" ? interpolator : interpolator.gamma(gamma2);
  }

  // node_modules/@visx/scale/esm/operators/interpolate.js
  function applyInterpolate(scale3, config2) {
    if ("interpolate" in config2 && "interpolate" in scale3 && typeof config2.interpolate !== "undefined") {
      var interpolator = createColorInterpolator(config2.interpolate);
      scale3.interpolate(interpolator);
    }
  }

  // node_modules/@visx/scale/esm/utils/isUtcScale.js
  var TEST_TIME = new Date(Date.UTC(2020, 1, 2, 3, 4, 5));
  var TEST_FORMAT = "%Y-%m-%d %H:%M";
  function isUtcScale(scale3) {
    var output = scale3.tickFormat(1, TEST_FORMAT)(TEST_TIME);
    return output === "2020-02-02 03:04";
  }

  // node_modules/@visx/scale/esm/operators/nice.js
  var localTimeIntervals = {
    day: timeDay,
    hour: timeHour,
    minute: timeMinute,
    month: timeMonth,
    second,
    week: timeSunday,
    year: timeYear
  };
  var utcIntervals = {
    day: utcDay,
    hour: utcHour,
    minute: utcMinute,
    month: utcMonth,
    second,
    week: utcSunday,
    year: utcYear
  };
  function applyNice(scale3, config2) {
    if ("nice" in config2 && typeof config2.nice !== "undefined" && "nice" in scale3) {
      var nice2 = config2.nice;
      if (typeof nice2 === "boolean") {
        if (nice2) {
          scale3.nice();
        }
      } else if (typeof nice2 === "number") {
        scale3.nice(nice2);
      } else {
        var timeScale = scale3;
        var isUtc = isUtcScale(timeScale);
        if (typeof nice2 === "string") {
          timeScale.nice(isUtc ? utcIntervals[nice2] : localTimeIntervals[nice2]);
        } else {
          var interval = nice2.interval, step = nice2.step;
          var parsedInterval = (isUtc ? utcIntervals[interval] : localTimeIntervals[interval]).every(step);
          if (parsedInterval != null) {
            timeScale.nice(parsedInterval);
          }
        }
      }
    }
  }

  // node_modules/@visx/scale/esm/operators/padding.js
  function applyPadding(scale3, config2) {
    if ("padding" in scale3 && "padding" in config2 && typeof config2.padding !== "undefined") {
      scale3.padding(config2.padding);
    }
    if ("paddingInner" in scale3 && "paddingInner" in config2 && typeof config2.paddingInner !== "undefined") {
      scale3.paddingInner(config2.paddingInner);
    }
    if ("paddingOuter" in scale3 && "paddingOuter" in config2 && typeof config2.paddingOuter !== "undefined") {
      scale3.paddingOuter(config2.paddingOuter);
    }
  }

  // node_modules/@visx/scale/esm/operators/reverse.js
  function applyReverse(scale3, config2) {
    if (config2.reverse) {
      var reversedRange = scale3.range().slice().reverse();
      if ("padding" in scale3) {
        scale3.range(reversedRange);
      } else {
        scale3.range(reversedRange);
      }
    }
  }

  // node_modules/@visx/scale/esm/operators/round.js
  function applyRound(scale3, config2) {
    if ("round" in config2 && typeof config2.round !== "undefined") {
      if (config2.round && "interpolate" in config2 && typeof config2.interpolate !== "undefined") {
        console.warn("[visx/scale/applyRound] ignoring round: scale config contains round and interpolate. only applying interpolate. config:", config2);
      } else if ("round" in scale3) {
        scale3.round(config2.round);
      } else if ("interpolate" in scale3 && config2.round) {
        scale3.interpolate(round_default);
      }
    }
  }

  // node_modules/@visx/scale/esm/operators/unknown.js
  function applyUnknown(scale3, config2) {
    if ("unknown" in scale3 && "unknown" in config2 && typeof config2.unknown !== "undefined") {
      scale3.unknown(config2.unknown);
    }
  }

  // node_modules/@visx/scale/esm/operators/zero.js
  function applyZero(scale3, config2) {
    if ("zero" in config2 && config2.zero === true) {
      var domain = scale3.domain();
      var a = domain[0], b = domain[1];
      var isDescending = b < a;
      var _ref = isDescending ? [b, a] : [a, b], min2 = _ref[0], max2 = _ref[1];
      var domainWithZero = [Math.min(0, min2), Math.max(0, max2)];
      scale3.domain(isDescending ? domainWithZero.reverse() : domainWithZero);
    }
  }

  // node_modules/@visx/scale/esm/operators/scaleOperator.js
  var ALL_OPERATORS = [
    // domain => nice => zero
    "domain",
    "nice",
    "zero",
    // interpolate before round
    "interpolate",
    "round",
    // set range then reverse
    "range",
    "reverse",
    // Order does not matter for these operators
    "align",
    "base",
    "clamp",
    "constant",
    "exponent",
    "padding",
    "unknown"
  ];
  var operators = {
    domain: applyDomain,
    nice: applyNice,
    zero: applyZero,
    interpolate: applyInterpolate,
    round: applyRound,
    align: applyAlign,
    base: applyBase,
    clamp: applyClamp,
    constant: applyConstant,
    exponent: applyExponent,
    padding: applyPadding,
    range: applyRange,
    reverse: applyReverse,
    unknown: applyUnknown
  };
  function scaleOperator() {
    for (var _len = arguments.length, ops = new Array(_len), _key = 0; _key < _len; _key++) {
      ops[_key] = arguments[_key];
    }
    var selection = new Set(ops);
    var selectedOps = ALL_OPERATORS.filter(function(o) {
      return selection.has(o);
    });
    return function applyOperators(scale3, config2) {
      if (typeof config2 !== "undefined") {
        selectedOps.forEach(function(op) {
          operators[op](scale3, config2);
        });
      }
      return scale3;
    };
  }

  // node_modules/@visx/scale/esm/scales/band.js
  var updateBandScale = scaleOperator("domain", "range", "reverse", "align", "padding", "round");
  function createBandScale(config2) {
    return updateBandScale(band(), config2);
  }

  // node_modules/@visx/scale/esm/scales/linear.js
  var updateLinearScale = scaleOperator("domain", "range", "reverse", "clamp", "interpolate", "nice", "round", "zero");
  function createLinearScale(config2) {
    return updateLinearScale(linear2(), config2);
  }

  // node_modules/@visx/scale/esm/scales/utc.js
  var updateUtcScale = scaleOperator("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
  function createUtcScale(config2) {
    return updateUtcScale(utcTime(), config2);
  }

  // node_modules/@visx/scale/esm/scales/ordinal.js
  var updateOrdinalScale = scaleOperator("domain", "range", "reverse", "unknown");
  function createOrdinalScale(config2) {
    return updateOrdinalScale(ordinal(), config2);
  }

  // node_modules/@visx/scale/esm/utils/coerceNumber.js
  function coerceNumber(val) {
    if ((typeof val === "function" || typeof val === "object" && !!val) && "valueOf" in val) {
      var num = val.valueOf();
      if (typeof num === "number")
        return num;
    }
    return val;
  }

  // node_modules/@visx/scale/esm/utils/getTicks.js
  function getTicks(scale3, numTicks) {
    var s2 = scale3;
    if ("ticks" in s2) {
      return s2.ticks(numTicks);
    }
    return s2.domain().filter(function(_, index, arr) {
      return numTicks == null || arr.length <= numTicks || index % Math.round((arr.length - 1) / numTicks) === 0;
    });
  }

  // node_modules/@visx/scale/esm/utils/toString.js
  function toString(x) {
    return x == null ? void 0 : x.toString();
  }

  // node_modules/@visx/axis/esm/axis/Axis.js
  var import_react90 = __toESM(require_react());
  var import_classnames8 = __toESM(require_classnames());

  // node_modules/@visx/group/esm/Group.js
  var import_prop_types = __toESM(require_prop_types());
  var import_react81 = __toESM(require_react());
  var import_classnames = __toESM(require_classnames());
  var _excluded = ["top", "left", "transform", "className", "children", "innerRef"];
  function _extends2() {
    _extends2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function Group(_ref) {
    var _ref$top = _ref.top, top2 = _ref$top === void 0 ? 0 : _ref$top, _ref$left = _ref.left, left2 = _ref$left === void 0 ? 0 : _ref$left, transform2 = _ref.transform, className = _ref.className, children = _ref.children, innerRef = _ref.innerRef, restProps = _objectWithoutPropertiesLoose(_ref, _excluded);
    return /* @__PURE__ */ import_react81.default.createElement("g", _extends2({
      ref: innerRef,
      className: (0, import_classnames.default)("visx-group", className),
      transform: transform2 || "translate(" + left2 + ", " + top2 + ")"
    }, restProps), children);
  }
  Group.propTypes = {
    top: import_prop_types.default.number,
    left: import_prop_types.default.number,
    transform: import_prop_types.default.string,
    className: import_prop_types.default.string,
    children: import_prop_types.default.node,
    innerRef: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func, import_prop_types.default.object])
  };

  // node_modules/@visx/axis/esm/axis/AxisRenderer.js
  var import_react89 = __toESM(require_react());
  var import_classnames7 = __toESM(require_classnames());

  // node_modules/@visx/shape/esm/util/D3ShapeFactories.js
  var import_d3_shape = __toESM(require_d3_shape());

  // node_modules/@visx/shape/esm/util/setNumberOrNumberAccessor.js
  function setNumberOrNumberAccessor(func, value) {
    if (typeof value === "number")
      func(value);
    else
      func(value);
  }

  // node_modules/@visx/shape/esm/util/D3ShapeFactories.js
  function line2(_temp3) {
    var _ref3 = _temp3 === void 0 ? {} : _temp3, x = _ref3.x, y = _ref3.y, defined = _ref3.defined, curve = _ref3.curve;
    var path = (0, import_d3_shape.line)();
    if (x)
      setNumberOrNumberAccessor(path.x, x);
    if (y)
      setNumberOrNumberAccessor(path.y, y);
    if (defined)
      path.defined(defined);
    if (curve)
      path.curve(curve);
    return path;
  }

  // node_modules/@visx/shape/esm/shapes/Line.js
  var import_react82 = __toESM(require_react());
  var import_classnames2 = __toESM(require_classnames());
  var _excluded2 = ["from", "to", "fill", "className", "innerRef"];
  function _extends3() {
    _extends3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function Line(_ref) {
    var _ref$from = _ref.from, from2 = _ref$from === void 0 ? {
      x: 0,
      y: 0
    } : _ref$from, _ref$to = _ref.to, to = _ref$to === void 0 ? {
      x: 1,
      y: 1
    } : _ref$to, _ref$fill = _ref.fill, fill2 = _ref$fill === void 0 ? "transparent" : _ref$fill, className = _ref.className, innerRef = _ref.innerRef, restProps = _objectWithoutPropertiesLoose2(_ref, _excluded2);
    var isRectilinear = from2.x === to.x || from2.y === to.y;
    return /* @__PURE__ */ import_react82.default.createElement("line", _extends3({
      ref: innerRef,
      className: (0, import_classnames2.default)("visx-line", className),
      x1: from2.x,
      y1: from2.y,
      x2: to.x,
      y2: to.y,
      fill: fill2,
      shapeRendering: isRectilinear ? "crispEdges" : "auto"
    }, restProps));
  }

  // node_modules/@visx/shape/esm/shapes/LinePath.js
  var import_react83 = __toESM(require_react());
  var import_classnames3 = __toESM(require_classnames());
  var _excluded3 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
  function _extends4() {
    _extends4 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends4.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function LinePath(_ref) {
    var children = _ref.children, _ref$data = _ref.data, data = _ref$data === void 0 ? [] : _ref$data, x = _ref.x, y = _ref.y, _ref$fill = _ref.fill, fill2 = _ref$fill === void 0 ? "transparent" : _ref$fill, className = _ref.className, curve = _ref.curve, innerRef = _ref.innerRef, _ref$defined = _ref.defined, defined = _ref$defined === void 0 ? function() {
      return true;
    } : _ref$defined, restProps = _objectWithoutPropertiesLoose3(_ref, _excluded3);
    var path = line2({
      x,
      y,
      defined,
      curve
    });
    if (children)
      return /* @__PURE__ */ import_react83.default.createElement(import_react83.default.Fragment, null, children({
        path
      }));
    return /* @__PURE__ */ import_react83.default.createElement("path", _extends4({
      ref: innerRef,
      className: (0, import_classnames3.default)("visx-linepath", className),
      d: path(data) || "",
      fill: fill2,
      strokeLinecap: "round"
    }, restProps));
  }

  // node_modules/@visx/shape/esm/shapes/Bar.js
  var import_react84 = __toESM(require_react());
  var import_classnames4 = __toESM(require_classnames());
  var _excluded4 = ["className", "innerRef"];
  function _extends5() {
    _extends5 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends5.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose4(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function Bar(_ref) {
    var className = _ref.className, innerRef = _ref.innerRef, restProps = _objectWithoutPropertiesLoose4(_ref, _excluded4);
    return /* @__PURE__ */ import_react84.default.createElement("rect", _extends5({
      ref: innerRef,
      className: (0, import_classnames4.default)("visx-bar", className)
    }, restProps));
  }

  // node_modules/@visx/shape/esm/shapes/Circle.js
  var import_react85 = __toESM(require_react());
  var import_classnames5 = __toESM(require_classnames());
  var _excluded5 = ["className", "innerRef"];
  function _extends6() {
    _extends6 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends6.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose5(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function Circle3(_ref) {
    var className = _ref.className, innerRef = _ref.innerRef, restProps = _objectWithoutPropertiesLoose5(_ref, _excluded5);
    return /* @__PURE__ */ import_react85.default.createElement("circle", _extends6({
      ref: innerRef,
      className: (0, import_classnames5.default)("visx-circle", className)
    }, restProps));
  }

  // node_modules/@visx/text/esm/Text.js
  var import_react87 = __toESM(require_react());

  // node_modules/@visx/text/esm/hooks/useText.js
  var import_react86 = __toESM(require_react());
  var import_reduce_css_calc = __toESM(require_reduce_css_calc());

  // node_modules/@visx/text/esm/util/getStringWidth.js
  var import_memoize4 = __toESM(require_memoize());
  var MEASUREMENT_ELEMENT_ID = "__react_svg_text_measurement_id";
  function getStringWidth(str, style) {
    try {
      var textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);
      if (!textEl) {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("aria-hidden", "true");
        svg.style.width = "0";
        svg.style.height = "0";
        svg.style.position = "absolute";
        svg.style.top = "-100%";
        svg.style.left = "-100%";
        textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textEl.setAttribute("id", MEASUREMENT_ELEMENT_ID);
        svg.appendChild(textEl);
        document.body.appendChild(svg);
      }
      Object.assign(textEl.style, style);
      textEl.textContent = str;
      return textEl.getComputedTextLength();
    } catch (e3) {
      return null;
    }
  }
  var getStringWidth_default = (0, import_memoize4.default)(getStringWidth, function(str, style) {
    return str + "_" + JSON.stringify(style);
  });

  // node_modules/@visx/text/esm/hooks/useText.js
  var _excluded6 = ["verticalAnchor", "scaleToFit", "angle", "width", "lineHeight", "capHeight", "children", "style"];
  function _objectWithoutPropertiesLoose6(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function isNumber3(val) {
    return typeof val === "number";
  }
  function isXOrYInValid(xOrY) {
    return (
      // number that is not NaN or Infinity
      typeof xOrY === "number" && Number.isFinite(xOrY) || // for percentage
      typeof xOrY === "string"
    );
  }
  function useText(props) {
    var _props$verticalAnchor = props.verticalAnchor, verticalAnchor = _props$verticalAnchor === void 0 ? "end" : _props$verticalAnchor, _props$scaleToFit = props.scaleToFit, scaleToFit = _props$scaleToFit === void 0 ? false : _props$scaleToFit, angle = props.angle, width = props.width, _props$lineHeight = props.lineHeight, lineHeight = _props$lineHeight === void 0 ? "1em" : _props$lineHeight, _props$capHeight = props.capHeight, capHeight = _props$capHeight === void 0 ? "0.71em" : _props$capHeight, children = props.children, style = props.style, textProps = _objectWithoutPropertiesLoose6(props, _excluded6);
    var _textProps$x = textProps.x, x = _textProps$x === void 0 ? 0 : _textProps$x, _textProps$y = textProps.y, y = _textProps$y === void 0 ? 0 : _textProps$y;
    var isXOrYNotValid = !isXOrYInValid(x) || !isXOrYInValid(y);
    var _useMemo = (0, import_react86.useMemo)(function() {
      var words = children == null ? [] : children.toString().split(/(?:(?!\u00A0+)\s+)/);
      return {
        wordsWithWidth: words.map(function(word) {
          return {
            word,
            wordWidth: getStringWidth_default(word, style) || 0
          };
        }),
        spaceWidth: getStringWidth_default("\xA0", style) || 0
      };
    }, [children, style]), wordsWithWidth = _useMemo.wordsWithWidth, spaceWidth = _useMemo.spaceWidth;
    var wordsByLines = (0, import_react86.useMemo)(function() {
      if (isXOrYNotValid) {
        return [];
      }
      if (width || scaleToFit) {
        return wordsWithWidth.reduce(function(result, _ref) {
          var word = _ref.word, wordWidth = _ref.wordWidth;
          var currentLine = result[result.length - 1];
          if (currentLine && (width == null || scaleToFit || (currentLine.width || 0) + wordWidth + spaceWidth < width)) {
            currentLine.words.push(word);
            currentLine.width = currentLine.width || 0;
            currentLine.width += wordWidth + spaceWidth;
          } else {
            var newLine = {
              words: [word],
              width: wordWidth
            };
            result.push(newLine);
          }
          return result;
        }, []);
      }
      return [{
        words: children == null ? [] : children.toString().split(/(?:(?!\u00A0+)\s+)/)
      }];
    }, [isXOrYNotValid, width, scaleToFit, children, wordsWithWidth, spaceWidth]);
    var startDy = (0, import_react86.useMemo)(function() {
      var startDyStr = isXOrYNotValid ? "" : verticalAnchor === "start" ? (0, import_reduce_css_calc.default)("calc(" + capHeight + ")") : verticalAnchor === "middle" ? (0, import_reduce_css_calc.default)("calc(" + (wordsByLines.length - 1) / 2 + " * -" + lineHeight + " + (" + capHeight + " / 2))") : (0, import_reduce_css_calc.default)("calc(" + (wordsByLines.length - 1) + " * -" + lineHeight + ")");
      return startDyStr;
    }, [isXOrYNotValid, verticalAnchor, capHeight, wordsByLines.length, lineHeight]);
    var transform2 = (0, import_react86.useMemo)(function() {
      var transforms2 = [];
      if (isXOrYNotValid) {
        return "";
      }
      if (isNumber3(x) && isNumber3(y) && isNumber3(width) && scaleToFit && wordsByLines.length > 0) {
        var lineWidth = wordsByLines[0].width || 1;
        var sx = scaleToFit === "shrink-only" ? Math.min(width / lineWidth, 1) : width / lineWidth;
        var sy = sx;
        var originX = x - sx * x;
        var originY = y - sy * y;
        transforms2.push("matrix(" + sx + ", 0, 0, " + sy + ", " + originX + ", " + originY + ")");
      }
      if (angle) {
        transforms2.push("rotate(" + angle + ", " + x + ", " + y + ")");
      }
      return transforms2.length > 0 ? transforms2.join(" ") : "";
    }, [isXOrYNotValid, x, y, width, scaleToFit, wordsByLines, angle]);
    return {
      wordsByLines,
      startDy,
      transform: transform2
    };
  }

  // node_modules/@visx/text/esm/Text.js
  var _excluded7 = ["dx", "dy", "textAnchor", "innerRef", "innerTextRef", "verticalAnchor", "angle", "lineHeight", "scaleToFit", "capHeight", "width"];
  function _extends7() {
    _extends7 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends7.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose7(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var SVG_STYLE = {
    overflow: "visible"
  };
  function Text3(props) {
    var _props$dx = props.dx, dx = _props$dx === void 0 ? 0 : _props$dx, _props$dy = props.dy, dy = _props$dy === void 0 ? 0 : _props$dy, _props$textAnchor = props.textAnchor, textAnchor = _props$textAnchor === void 0 ? "start" : _props$textAnchor, innerRef = props.innerRef, innerTextRef = props.innerTextRef, verticalAnchor = props.verticalAnchor, angle = props.angle, _props$lineHeight = props.lineHeight, lineHeight = _props$lineHeight === void 0 ? "1em" : _props$lineHeight, _props$scaleToFit = props.scaleToFit, scaleToFit = _props$scaleToFit === void 0 ? false : _props$scaleToFit, capHeight = props.capHeight, width = props.width, textProps = _objectWithoutPropertiesLoose7(props, _excluded7);
    var _textProps$x = textProps.x, x = _textProps$x === void 0 ? 0 : _textProps$x, fontSize = textProps.fontSize;
    var _useText = useText(props), wordsByLines = _useText.wordsByLines, startDy = _useText.startDy, transform2 = _useText.transform;
    return /* @__PURE__ */ import_react87.default.createElement("svg", {
      ref: innerRef,
      x: dx,
      y: dy,
      fontSize,
      style: SVG_STYLE
    }, wordsByLines.length > 0 ? /* @__PURE__ */ import_react87.default.createElement("text", _extends7({
      ref: innerTextRef,
      transform: transform2
    }, textProps, {
      textAnchor
    }), wordsByLines.map(function(line3, index) {
      return /* @__PURE__ */ import_react87.default.createElement("tspan", {
        key: index,
        x,
        dy: index === 0 ? startDy : lineHeight
      }, line3.words.join(" "));
    })) : null);
  }

  // node_modules/@visx/axis/esm/constants/orientation.js
  var Orientation = {
    top: "top",
    left: "left",
    right: "right",
    bottom: "bottom"
  };
  var orientation_default = Orientation;

  // node_modules/@visx/axis/esm/utils/getLabelTransform.js
  function getLabelTransform(_ref) {
    var labelOffset = _ref.labelOffset, labelProps = _ref.labelProps, orientation = _ref.orientation, range2 = _ref.range, tickLabelFontSize = _ref.tickLabelFontSize, tickLength = _ref.tickLength;
    var sign = orientation === orientation_default.left || orientation === orientation_default.top ? -1 : 1;
    var x;
    var y;
    var transform2;
    if (orientation === orientation_default.top || orientation === orientation_default.bottom) {
      var yBottomOffset = orientation === orientation_default.bottom && typeof labelProps.fontSize === "number" ? labelProps.fontSize : 0;
      x = (Number(range2[0]) + Number(range2[range2.length - 1])) / 2;
      y = sign * (tickLength + labelOffset + tickLabelFontSize + yBottomOffset);
    } else {
      x = sign * ((Number(range2[0]) + Number(range2[range2.length - 1])) / 2);
      y = -(tickLength + labelOffset);
      transform2 = "rotate(" + sign * 90 + ")";
    }
    return {
      x,
      y,
      transform: transform2
    };
  }

  // node_modules/@visx/axis/esm/axis/Ticks.js
  var import_react88 = __toESM(require_react());
  var import_classnames6 = __toESM(require_classnames());
  function _extends8() {
    _extends8 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends8.apply(this, arguments);
  }
  function Ticks(_ref) {
    var hideTicks = _ref.hideTicks, horizontal = _ref.horizontal, orientation = _ref.orientation, tickClassName = _ref.tickClassName, tickComponent = _ref.tickComponent, allTickLabelProps = _ref.tickLabelProps, _ref$tickStroke = _ref.tickStroke, tickStroke = _ref$tickStroke === void 0 ? "#222" : _ref$tickStroke, tickTransform = _ref.tickTransform, ticks2 = _ref.ticks, strokeWidth = _ref.strokeWidth, tickLineProps = _ref.tickLineProps;
    return ticks2.map(function(_ref2) {
      var _allTickLabelProps$in;
      var value = _ref2.value, index = _ref2.index, from2 = _ref2.from, to = _ref2.to, formattedValue = _ref2.formattedValue;
      var tickLabelProps = (_allTickLabelProps$in = allTickLabelProps[index]) != null ? _allTickLabelProps$in : {};
      var tickLabelFontSize = Math.max(10, typeof tickLabelProps.fontSize === "number" && tickLabelProps.fontSize || 0);
      var tickYCoord = to.y + (horizontal && orientation !== orientation_default.top ? tickLabelFontSize : 0);
      return /* @__PURE__ */ import_react88.default.createElement(Group, {
        key: "visx-tick-" + value + "-" + index,
        className: (0, import_classnames6.default)("visx-axis-tick", tickClassName),
        transform: tickTransform
      }, !hideTicks && /* @__PURE__ */ import_react88.default.createElement(Line, _extends8({
        from: from2,
        to,
        stroke: tickStroke,
        strokeWidth,
        strokeLinecap: "square"
      }, tickLineProps)), tickComponent ? tickComponent(_extends8({}, tickLabelProps, {
        x: to.x,
        y: tickYCoord,
        formattedValue
      })) : /* @__PURE__ */ import_react88.default.createElement(Text3, _extends8({
        x: to.x,
        y: tickYCoord
      }, tickLabelProps), formattedValue));
    });
  }

  // node_modules/@visx/axis/esm/axis/AxisRenderer.js
  function _extends9() {
    _extends9 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends9.apply(this, arguments);
  }
  var defaultTextProps = {
    textAnchor: "middle",
    fontFamily: "Arial",
    fontSize: 10,
    fill: "#222"
  };
  function AxisRenderer(_ref) {
    var axisFromPoint = _ref.axisFromPoint, axisLineClassName = _ref.axisLineClassName, axisToPoint = _ref.axisToPoint, hideAxisLine = _ref.hideAxisLine, hideTicks = _ref.hideTicks, horizontal = _ref.horizontal, _ref$label = _ref.label, label = _ref$label === void 0 ? "" : _ref$label, labelClassName = _ref.labelClassName, _ref$labelOffset = _ref.labelOffset, labelOffset = _ref$labelOffset === void 0 ? 14 : _ref$labelOffset, labelProps = _ref.labelProps, _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? orientation_default.bottom : _ref$orientation, scale3 = _ref.scale, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? "#222" : _ref$stroke, strokeDasharray = _ref.strokeDasharray, _ref$strokeWidth = _ref.strokeWidth, strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth, tickClassName = _ref.tickClassName, tickComponent = _ref.tickComponent, tickLineProps = _ref.tickLineProps, tickLabelProps = _ref.tickLabelProps, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, _ref$tickStroke = _ref.tickStroke, tickStroke = _ref$tickStroke === void 0 ? "#222" : _ref$tickStroke, tickTransform = _ref.tickTransform, ticks2 = _ref.ticks, _ref$ticksComponent = _ref.ticksComponent, ticksComponent = _ref$ticksComponent === void 0 ? Ticks : _ref$ticksComponent;
    var combinedLabelProps = _extends9({}, defaultTextProps, labelProps);
    var tickLabelPropsDefault = _extends9({}, defaultTextProps, typeof tickLabelProps === "object" ? tickLabelProps : null);
    var allTickLabelProps = ticks2.map(function(_ref2) {
      var value = _ref2.value, index = _ref2.index;
      return typeof tickLabelProps === "function" ? tickLabelProps(value, index, ticks2) : tickLabelPropsDefault;
    });
    var maxTickLabelFontSize = Math.max.apply(Math, [10].concat(allTickLabelProps.map(function(props) {
      return typeof props.fontSize === "number" ? props.fontSize : 0;
    })));
    return /* @__PURE__ */ import_react89.default.createElement(import_react89.default.Fragment, null, ticksComponent({
      hideTicks,
      horizontal,
      orientation,
      scale: scale3,
      tickClassName,
      tickComponent,
      tickLabelProps: allTickLabelProps,
      tickStroke,
      tickTransform,
      ticks: ticks2,
      strokeWidth,
      tickLineProps
    }), !hideAxisLine && /* @__PURE__ */ import_react89.default.createElement(Line, {
      className: (0, import_classnames7.default)("visx-axis-line", axisLineClassName),
      from: axisFromPoint,
      to: axisToPoint,
      stroke,
      strokeWidth,
      strokeDasharray
    }), label && /* @__PURE__ */ import_react89.default.createElement(Text3, _extends9({
      className: (0, import_classnames7.default)("visx-axis-label", labelClassName)
    }, getLabelTransform({
      labelOffset,
      labelProps: combinedLabelProps,
      orientation,
      range: scale3.range(),
      tickLabelFontSize: maxTickLabelFontSize,
      tickLength
    }), combinedLabelProps), label));
  }

  // node_modules/@visx/axis/esm/utils/getTickPosition.js
  function getTickPosition(scale3, align) {
    if (align === void 0) {
      align = "center";
    }
    var s2 = scale3;
    if (align !== "start" && "bandwidth" in s2) {
      var offset3 = s2.bandwidth();
      if (align === "center")
        offset3 /= 2;
      if (s2.round())
        offset3 = Math.round(offset3);
      return function(d) {
        var scaledValue = s2(d);
        return typeof scaledValue === "number" ? scaledValue + offset3 : scaledValue;
      };
    }
    return scale3;
  }

  // node_modules/@visx/axis/esm/utils/getTickFormatter.js
  function getTickFormatter(scale3) {
    var s2 = scale3;
    if ("tickFormat" in s2) {
      return s2.tickFormat();
    }
    return toString;
  }

  // node_modules/@visx/point/esm/Point.js
  var Point = /* @__PURE__ */ function() {
    function Point2(_ref) {
      var _ref$x = _ref.x, x = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === void 0 ? 0 : _ref$y;
      this.x = 0;
      this.y = 0;
      this.x = x;
      this.y = y;
    }
    var _proto = Point2.prototype;
    _proto.value = function value() {
      return {
        x: this.x,
        y: this.y
      };
    };
    _proto.toArray = function toArray() {
      return [this.x, this.y];
    };
    return Point2;
  }();

  // node_modules/@visx/axis/esm/utils/createPoint.js
  function createPoint(_ref, horizontal) {
    var x = _ref.x, y = _ref.y;
    return new Point(horizontal ? {
      x,
      y
    } : {
      x: y,
      y: x
    });
  }

  // node_modules/@visx/axis/esm/utils/getAxisRangePaddingConfig.js
  function _extends10() {
    _extends10 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends10.apply(this, arguments);
  }
  var defaultAxisRangePadding = 0;
  function getAxisRangePaddingConfig(originalRangePadding) {
    if (originalRangePadding === void 0) {
      originalRangePadding = defaultAxisRangePadding;
    }
    return typeof originalRangePadding === "number" ? {
      start: originalRangePadding,
      end: originalRangePadding
    } : _extends10({
      start: defaultAxisRangePadding,
      end: defaultAxisRangePadding
    }, originalRangePadding);
  }

  // node_modules/@visx/axis/esm/axis/Axis.js
  var _excluded8 = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
  function _extends11() {
    _extends11 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends11.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose8(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function Axis(_ref) {
    var _ref$children = _ref.children, children = _ref$children === void 0 ? AxisRenderer : _ref$children, axisClassName = _ref.axisClassName, _ref$hideAxisLine = _ref.hideAxisLine, hideAxisLine = _ref$hideAxisLine === void 0 ? false : _ref$hideAxisLine, _ref$hideTicks = _ref.hideTicks, hideTicks = _ref$hideTicks === void 0 ? false : _ref$hideTicks, _ref$hideZero = _ref.hideZero, hideZero = _ref$hideZero === void 0 ? false : _ref$hideZero, innerRef = _ref.innerRef, _ref$left = _ref.left, left2 = _ref$left === void 0 ? 0 : _ref$left, _ref$numTicks = _ref.numTicks, numTicks = _ref$numTicks === void 0 ? 10 : _ref$numTicks, _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? orientation_default.bottom : _ref$orientation, _ref$rangePadding = _ref.rangePadding, rangePadding = _ref$rangePadding === void 0 ? 0 : _ref$rangePadding, scale3 = _ref.scale, tickFormat2 = _ref.tickFormat, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, tickValues = _ref.tickValues, _ref$top = _ref.top, top2 = _ref$top === void 0 ? 0 : _ref$top, restProps = _objectWithoutPropertiesLoose8(_ref, _excluded8);
    var format2 = tickFormat2 != null ? tickFormat2 : getTickFormatter(scale3);
    var isLeft = orientation === orientation_default.left;
    var isTop = orientation === orientation_default.top;
    var horizontal = isTop || orientation === orientation_default.bottom;
    var tickPosition = getTickPosition(scale3);
    var tickSign = isLeft || isTop ? -1 : 1;
    var range2 = scale3.range();
    var rangePaddingConfig = getAxisRangePaddingConfig(rangePadding);
    var axisFromPoint = createPoint({
      x: Number(range2[0]) + 0.5 - rangePaddingConfig.start,
      y: 0
    }, horizontal);
    var axisToPoint = createPoint({
      x: Number(range2[range2.length - 1]) + 0.5 + rangePaddingConfig.end,
      y: 0
    }, horizontal);
    var filteredTickValues = (tickValues != null ? tickValues : getTicks(scale3, numTicks)).filter(function(value) {
      return !hideZero || value !== 0 && value !== "0";
    }).map(function(value, index) {
      return {
        value,
        index
      };
    });
    var ticks2 = filteredTickValues.map(function(_ref2) {
      var value = _ref2.value, index = _ref2.index;
      var scaledValue = coerceNumber(tickPosition(value));
      return {
        value,
        index,
        from: createPoint({
          x: scaledValue,
          y: 0
        }, horizontal),
        to: createPoint({
          x: scaledValue,
          y: tickLength * tickSign
        }, horizontal),
        formattedValue: format2(value, index, filteredTickValues)
      };
    });
    return /* @__PURE__ */ import_react90.default.createElement(Group, {
      className: (0, import_classnames8.default)("visx-axis", axisClassName),
      innerRef,
      top: top2,
      left: left2
    }, children(_extends11({}, restProps, {
      axisFromPoint,
      axisToPoint,
      hideAxisLine,
      hideTicks,
      hideZero,
      horizontal,
      numTicks,
      orientation,
      rangePadding,
      scale: scale3,
      tickFormat: format2,
      tickLength,
      tickPosition,
      tickSign,
      ticks: ticks2
    })));
  }

  // node_modules/@visx/axis/esm/axis/AxisLeft.js
  var import_react91 = __toESM(require_react());
  var import_classnames9 = __toESM(require_classnames());
  var _excluded9 = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
  function _extends12() {
    _extends12 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends12.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose9(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var leftTickLabelProps = {
    dx: "-0.25em",
    dy: "0.25em",
    fill: "#222",
    fontFamily: "Arial",
    fontSize: 10,
    textAnchor: "end"
  };
  function AxisLeft(_ref) {
    var axisClassName = _ref.axisClassName, _ref$labelOffset = _ref.labelOffset, labelOffset = _ref$labelOffset === void 0 ? 36 : _ref$labelOffset, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, tickLabelProps = _ref.tickLabelProps, restProps = _objectWithoutPropertiesLoose9(_ref, _excluded9);
    var tickLabelPropsFinal = typeof tickLabelProps === "function" ? tickLabelProps : _extends12({}, leftTickLabelProps, tickLabelProps);
    return /* @__PURE__ */ import_react91.default.createElement(Axis, _extends12({
      axisClassName: (0, import_classnames9.default)("visx-axis-left", axisClassName),
      labelOffset,
      orientation: orientation_default.left,
      tickLabelProps: tickLabelPropsFinal,
      tickLength
    }, restProps));
  }

  // node_modules/@visx/axis/esm/axis/AxisBottom.js
  var import_react92 = __toESM(require_react());
  var import_classnames10 = __toESM(require_classnames());
  var _excluded10 = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
  function _extends13() {
    _extends13 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends13.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose10(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var bottomTickLabelProps = {
    dy: "0.25em",
    fill: "#222",
    fontFamily: "Arial",
    fontSize: 10,
    textAnchor: "middle"
  };
  function AxisBottom(_ref) {
    var axisClassName = _ref.axisClassName, _ref$labelOffset = _ref.labelOffset, labelOffset = _ref$labelOffset === void 0 ? 8 : _ref$labelOffset, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, tickLabelProps = _ref.tickLabelProps, restProps = _objectWithoutPropertiesLoose10(_ref, _excluded10);
    var tickLabelPropsFinal = typeof tickLabelProps === "function" ? tickLabelProps : _extends13({}, bottomTickLabelProps, tickLabelProps);
    return /* @__PURE__ */ import_react92.default.createElement(Axis, _extends13({
      axisClassName: (0, import_classnames10.default)("visx-axis-bottom", axisClassName),
      labelOffset,
      orientation: orientation_default.bottom,
      tickLabelProps: tickLabelPropsFinal,
      tickLength
    }, restProps));
  }

  // node_modules/@visx/curve/node_modules/d3-shape/src/curve/step.js
  function Step(context, t4) {
    this._context = context;
    this._t = t4;
  }
  Step.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2)
        this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      if (this._line >= 0)
        this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
          break;
        case 1:
          this._point = 2;
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);
            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;
            this._context.lineTo(x1, this._y);
            this._context.lineTo(x1, y);
          }
          break;
        }
      }
      this._x = x, this._y = y;
    }
  };
  function stepAfter(context) {
    return new Step(context, 1);
  }

  // node_modules/@visx/legend/esm/legends/Legend/index.js
  var import_prop_types8 = __toESM(require_prop_types());
  var import_react100 = __toESM(require_react());
  var import_classnames11 = __toESM(require_classnames());

  // node_modules/@visx/legend/esm/legends/Legend/LegendItem.js
  var import_prop_types2 = __toESM(require_prop_types());
  var import_react93 = __toESM(require_react());
  var _excluded11 = ["flexDirection", "alignItems", "margin", "display", "children"];
  function _extends14() {
    _extends14 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends14.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose11(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function LegendItem(_ref) {
    var _ref$flexDirection = _ref.flexDirection, flexDirection = _ref$flexDirection === void 0 ? "row" : _ref$flexDirection, _ref$alignItems = _ref.alignItems, alignItems = _ref$alignItems === void 0 ? "center" : _ref$alignItems, _ref$margin = _ref.margin, margin = _ref$margin === void 0 ? "0" : _ref$margin, _ref$display = _ref.display, display = _ref$display === void 0 ? "flex" : _ref$display, children = _ref.children, restProps = _objectWithoutPropertiesLoose11(_ref, _excluded11);
    return /* @__PURE__ */ import_react93.default.createElement("div", _extends14({
      className: "visx-legend-item",
      style: {
        display,
        alignItems,
        flexDirection,
        margin
      }
    }, restProps), children);
  }
  LegendItem.propTypes = {
    alignItems: import_prop_types2.default.string,
    margin: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.number]),
    children: import_prop_types2.default.node,
    display: import_prop_types2.default.string
  };

  // node_modules/@visx/legend/esm/legends/Legend/LegendLabel.js
  var import_prop_types3 = __toESM(require_prop_types());
  var import_react94 = __toESM(require_react());
  var _excluded12 = ["flex", "label", "margin", "align", "children"];
  function _extends15() {
    _extends15 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends15.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose12(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function LegendLabel(_ref) {
    var _ref$flex = _ref.flex, flex = _ref$flex === void 0 ? "1" : _ref$flex, label = _ref.label, _ref$margin = _ref.margin, margin = _ref$margin === void 0 ? "5px 0" : _ref$margin, _ref$align = _ref.align, align = _ref$align === void 0 ? "left" : _ref$align, children = _ref.children, restProps = _objectWithoutPropertiesLoose12(_ref, _excluded12);
    return /* @__PURE__ */ import_react94.default.createElement("div", _extends15({
      className: "visx-legend-label",
      style: {
        justifyContent: align,
        display: "flex",
        flex,
        margin
      }
    }, restProps), children || label);
  }
  LegendLabel.propTypes = {
    align: import_prop_types3.default.string,
    label: import_prop_types3.default.node,
    flex: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]),
    margin: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]),
    children: import_prop_types3.default.node
  };

  // node_modules/@visx/legend/esm/legends/Legend/LegendShape.js
  var import_prop_types7 = __toESM(require_prop_types());
  var import_react99 = __toESM(require_react());

  // node_modules/@visx/legend/esm/shapes/Rect.js
  var import_prop_types4 = __toESM(require_prop_types());
  var import_react95 = __toESM(require_react());
  function _extends16() {
    _extends16 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends16.apply(this, arguments);
  }
  function ShapeRect(_ref) {
    var fill2 = _ref.fill, width = _ref.width, height = _ref.height, style = _ref.style;
    return /* @__PURE__ */ import_react95.default.createElement("div", {
      style: _extends16({
        width,
        height,
        background: fill2
      }, style)
    });
  }
  ShapeRect.propTypes = {
    fill: import_prop_types4.default.string,
    width: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number]),
    height: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number])
  };

  // node_modules/@visx/legend/esm/util/renderShape.js
  var import_react98 = __toESM(require_react());

  // node_modules/@visx/legend/esm/shapes/Circle.js
  var import_prop_types5 = __toESM(require_prop_types());
  var import_react96 = __toESM(require_react());
  function ShapeCircle(_ref) {
    var fill2 = _ref.fill, width = _ref.width, height = _ref.height, style = _ref.style;
    var cleanWidth = typeof width === "string" || typeof width === "undefined" ? 0 : width;
    var cleanHeight = typeof height === "string" || typeof height === "undefined" ? 0 : height;
    var size2 = Math.max(cleanWidth, cleanHeight);
    var radius = size2 / 2;
    return /* @__PURE__ */ import_react96.default.createElement("svg", {
      width: size2,
      height: size2
    }, /* @__PURE__ */ import_react96.default.createElement(Group, {
      top: radius,
      left: radius
    }, /* @__PURE__ */ import_react96.default.createElement("circle", {
      r: radius,
      fill: fill2,
      style
    })));
  }
  ShapeCircle.propTypes = {
    fill: import_prop_types5.default.string,
    width: import_prop_types5.default.oneOfType([import_prop_types5.default.string, import_prop_types5.default.number]),
    height: import_prop_types5.default.oneOfType([import_prop_types5.default.string, import_prop_types5.default.number])
  };

  // node_modules/@visx/legend/esm/shapes/Line.js
  var import_prop_types6 = __toESM(require_prop_types());
  var import_react97 = __toESM(require_react());
  function ShapeLine(_ref) {
    var fill2 = _ref.fill, width = _ref.width, height = _ref.height, style = _ref.style;
    var cleanHeight = typeof height === "string" || typeof height === "undefined" ? 0 : height;
    var lineThickness = typeof (style == null ? void 0 : style.strokeWidth) === "number" ? style == null ? void 0 : style.strokeWidth : 2;
    return /* @__PURE__ */ import_react97.default.createElement("svg", {
      width,
      height
    }, /* @__PURE__ */ import_react97.default.createElement(Group, {
      top: cleanHeight / 2 - lineThickness / 2
    }, /* @__PURE__ */ import_react97.default.createElement("line", {
      x1: 0,
      x2: width,
      y1: 0,
      y2: 0,
      stroke: fill2,
      strokeWidth: lineThickness,
      style
    })));
  }
  ShapeLine.propTypes = {
    fill: import_prop_types6.default.string,
    width: import_prop_types6.default.oneOfType([import_prop_types6.default.string, import_prop_types6.default.number]),
    height: import_prop_types6.default.oneOfType([import_prop_types6.default.string, import_prop_types6.default.number])
  };

  // node_modules/@visx/legend/esm/util/renderShape.js
  function _extends17() {
    _extends17 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends17.apply(this, arguments);
  }
  var NO_OP = function NO_OP2() {
    return void 0;
  };
  function renderShape(_ref) {
    var _ref$shape = _ref.shape, shape = _ref$shape === void 0 ? "rect" : _ref$shape, _ref$fill = _ref.fill, fill2 = _ref$fill === void 0 ? NO_OP : _ref$fill, _ref$size = _ref.size, size2 = _ref$size === void 0 ? NO_OP : _ref$size, width = _ref.width, height = _ref.height, label = _ref.label, item = _ref.item, itemIndex = _ref.itemIndex, _ref$shapeStyle = _ref.shapeStyle, shapeStyle = _ref$shapeStyle === void 0 ? NO_OP : _ref$shapeStyle;
    var props = {
      width,
      height,
      item,
      itemIndex,
      label,
      fill: fill2(_extends17({}, label)),
      size: size2(_extends17({}, label)),
      style: shapeStyle(_extends17({}, label))
    };
    if (typeof shape === "string") {
      if (shape === "circle") {
        return /* @__PURE__ */ import_react98.default.createElement(ShapeCircle, props);
      }
      if (shape === "line") {
        return /* @__PURE__ */ import_react98.default.createElement(ShapeLine, props);
      }
      return /* @__PURE__ */ import_react98.default.createElement(ShapeRect, props);
    }
    if (/* @__PURE__ */ import_react98.default.isValidElement(shape)) {
      return /* @__PURE__ */ import_react98.default.cloneElement(shape, props);
    }
    if (shape) {
      return /* @__PURE__ */ import_react98.default.createElement(shape, props);
    }
    return null;
  }

  // node_modules/@visx/legend/esm/legends/Legend/LegendShape.js
  function _extends18() {
    _extends18 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends18.apply(this, arguments);
  }
  function LegendShape(_ref) {
    var _ref$shape = _ref.shape, shape = _ref$shape === void 0 ? ShapeRect : _ref$shape, width = _ref.width, height = _ref.height, margin = _ref.margin, label = _ref.label, item = _ref.item, itemIndex = _ref.itemIndex, fill2 = _ref.fill, size2 = _ref.size, shapeStyle = _ref.shapeStyle;
    return /* @__PURE__ */ import_react99.default.createElement("div", {
      className: "visx-legend-shape",
      style: {
        display: "flex",
        width: size2 ? size2(_extends18({}, label)) : width,
        height: size2 ? size2(_extends18({}, label)) : height,
        margin
      }
    }, renderShape({
      shape,
      item,
      itemIndex,
      label,
      width,
      height,
      fill: fill2,
      shapeStyle
    }));
  }
  LegendShape.propTypes = {
    itemIndex: import_prop_types7.default.number.isRequired,
    margin: import_prop_types7.default.oneOfType([import_prop_types7.default.string, import_prop_types7.default.number]),
    width: import_prop_types7.default.oneOfType([import_prop_types7.default.string, import_prop_types7.default.number]),
    height: import_prop_types7.default.oneOfType([import_prop_types7.default.string, import_prop_types7.default.number])
  };

  // node_modules/@visx/legend/esm/util/valueOrIdentity.js
  function valueOrIdentity(_) {
    if (_ && typeof _ === "object" && "value" in _ && typeof _.value !== "undefined")
      return _.value;
    return _;
  }
  function valueOrIdentityString(_) {
    return String(valueOrIdentity(_));
  }

  // node_modules/@visx/legend/esm/util/labelTransformFactory.js
  function labelTransformFactory(_ref) {
    var scale3 = _ref.scale, labelFormat = _ref.labelFormat;
    return function(d, i) {
      return {
        datum: d,
        index: i,
        text: "" + labelFormat(d, i),
        value: scale3(d)
      };
    };
  }

  // node_modules/@visx/legend/esm/legends/Legend/index.js
  var _excluded13 = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
  function _extends19() {
    _extends19 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends19.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose13(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var defaultStyle = {
    display: "flex"
  };
  function Legend(_ref) {
    var className = _ref.className, _ref$style = _ref.style, style = _ref$style === void 0 ? defaultStyle : _ref$style, scale3 = _ref.scale, shape = _ref.shape, inputDomain = _ref.domain, _ref$fill = _ref.fill, fill2 = _ref$fill === void 0 ? valueOrIdentityString : _ref$fill, _ref$size = _ref.size, size2 = _ref$size === void 0 ? valueOrIdentityString : _ref$size, _ref$labelFormat = _ref.labelFormat, labelFormat = _ref$labelFormat === void 0 ? valueOrIdentity : _ref$labelFormat, _ref$labelTransform = _ref.labelTransform, labelTransform = _ref$labelTransform === void 0 ? labelTransformFactory : _ref$labelTransform, _ref$shapeWidth = _ref.shapeWidth, shapeWidth = _ref$shapeWidth === void 0 ? 15 : _ref$shapeWidth, _ref$shapeHeight = _ref.shapeHeight, shapeHeight = _ref$shapeHeight === void 0 ? 15 : _ref$shapeHeight, _ref$shapeMargin = _ref.shapeMargin, shapeMargin = _ref$shapeMargin === void 0 ? "2px 4px 2px 0" : _ref$shapeMargin, shapeStyle = _ref.shapeStyle, _ref$labelAlign = _ref.labelAlign, labelAlign = _ref$labelAlign === void 0 ? "left" : _ref$labelAlign, _ref$labelFlex = _ref.labelFlex, labelFlex = _ref$labelFlex === void 0 ? "1" : _ref$labelFlex, _ref$labelMargin = _ref.labelMargin, labelMargin = _ref$labelMargin === void 0 ? "0 4px" : _ref$labelMargin, _ref$itemMargin = _ref.itemMargin, itemMargin = _ref$itemMargin === void 0 ? "0" : _ref$itemMargin, _ref$direction = _ref.direction, direction2 = _ref$direction === void 0 ? "column" : _ref$direction, _ref$itemDirection = _ref.itemDirection, itemDirection = _ref$itemDirection === void 0 ? "row" : _ref$itemDirection, legendLabelProps = _ref.legendLabelProps, children = _ref.children, legendItemProps = _objectWithoutPropertiesLoose13(_ref, _excluded13);
    var domain = inputDomain || ("domain" in scale3 ? scale3.domain() : []);
    var labelFormatter = labelTransform({
      scale: scale3,
      labelFormat
    });
    var labels = domain.map(labelFormatter);
    if (children)
      return /* @__PURE__ */ import_react100.default.createElement(import_react100.default.Fragment, null, children(labels));
    return /* @__PURE__ */ import_react100.default.createElement("div", {
      className: (0, import_classnames11.default)("visx-legend", className),
      style: _extends19({}, style, {
        flexDirection: direction2
      })
    }, labels.map(function(label, i) {
      return /* @__PURE__ */ import_react100.default.createElement(LegendItem, _extends19({
        key: "legend-" + label.text + "-" + i,
        margin: itemMargin,
        flexDirection: itemDirection
      }, legendItemProps), /* @__PURE__ */ import_react100.default.createElement(LegendShape, {
        shape,
        height: shapeHeight,
        width: shapeWidth,
        margin: shapeMargin,
        item: domain[i],
        itemIndex: i,
        label,
        fill: fill2,
        size: size2,
        shapeStyle
      }), /* @__PURE__ */ import_react100.default.createElement(LegendLabel, _extends19({
        label: label.text,
        flex: labelFlex,
        margin: labelMargin,
        align: labelAlign
      }, legendLabelProps)));
    }));
  }
  Legend.propTypes = {
    children: import_prop_types8.default.func,
    className: import_prop_types8.default.string,
    domain: import_prop_types8.default.array,
    shapeWidth: import_prop_types8.default.oneOfType([import_prop_types8.default.string, import_prop_types8.default.number]),
    shapeHeight: import_prop_types8.default.oneOfType([import_prop_types8.default.string, import_prop_types8.default.number]),
    shapeMargin: import_prop_types8.default.oneOfType([import_prop_types8.default.string, import_prop_types8.default.number]),
    labelAlign: import_prop_types8.default.string,
    labelFlex: import_prop_types8.default.oneOfType([import_prop_types8.default.string, import_prop_types8.default.number]),
    labelMargin: import_prop_types8.default.oneOfType([import_prop_types8.default.string, import_prop_types8.default.number]),
    itemMargin: import_prop_types8.default.oneOfType([import_prop_types8.default.string, import_prop_types8.default.number]),
    fill: import_prop_types8.default.func,
    size: import_prop_types8.default.func,
    shapeStyle: import_prop_types8.default.func
  };

  // node_modules/@visx/legend/esm/legends/Ordinal.js
  var import_react101 = __toESM(require_react());
  function Ordinal(props) {
    return /* @__PURE__ */ import_react101.default.createElement(Legend, props);
  }

  // node_modules/@visx/grid/esm/grids/GridRows.js
  var import_prop_types9 = __toESM(require_prop_types());
  var import_react102 = __toESM(require_react());
  var import_classnames12 = __toESM(require_classnames());
  var import_Line3 = __toESM(require_Line());

  // node_modules/@visx/grid/esm/utils/getScaleBandwidth.js
  function getScaleBandwidth(scale3) {
    return "bandwidth" in scale3 ? scale3.bandwidth() : 0;
  }

  // node_modules/@visx/grid/esm/grids/GridRows.js
  var _excluded14 = ["top", "left", "scale", "width", "stroke", "strokeWidth", "strokeDasharray", "className", "children", "numTicks", "lineStyle", "offset", "tickValues"];
  function _extends20() {
    _extends20 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends20.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose14(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function GridRows(_ref) {
    var _ref$top = _ref.top, top2 = _ref$top === void 0 ? 0 : _ref$top, _ref$left = _ref.left, left2 = _ref$left === void 0 ? 0 : _ref$left, scale3 = _ref.scale, width = _ref.width, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? "#eaf0f6" : _ref$stroke, _ref$strokeWidth = _ref.strokeWidth, strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth, strokeDasharray = _ref.strokeDasharray, className = _ref.className, children = _ref.children, _ref$numTicks = _ref.numTicks, numTicks = _ref$numTicks === void 0 ? 10 : _ref$numTicks, lineStyle = _ref.lineStyle, offset3 = _ref.offset, tickValues = _ref.tickValues, restProps = _objectWithoutPropertiesLoose14(_ref, _excluded14);
    var ticks2 = tickValues != null ? tickValues : getTicks(scale3, numTicks);
    var scaleOffset = (offset3 != null ? offset3 : 0) + getScaleBandwidth(scale3) / 2;
    var tickLines = ticks2.map(function(d, index) {
      var _coerceNumber;
      var y = ((_coerceNumber = coerceNumber(scale3(d))) != null ? _coerceNumber : 0) + scaleOffset;
      return {
        index,
        from: new Point({
          x: 0,
          y
        }),
        to: new Point({
          x: width,
          y
        })
      };
    });
    return /* @__PURE__ */ import_react102.default.createElement(Group, {
      className: (0, import_classnames12.default)("visx-rows", className),
      top: top2,
      left: left2
    }, children ? children({
      lines: tickLines
    }) : tickLines.map(function(_ref2) {
      var from2 = _ref2.from, to = _ref2.to, index = _ref2.index;
      return /* @__PURE__ */ import_react102.default.createElement(import_Line3.default, _extends20({
        key: "row-line-" + index,
        from: from2,
        to,
        stroke,
        strokeWidth,
        strokeDasharray,
        style: lineStyle
      }, restProps));
    }));
  }
  GridRows.propTypes = {
    tickValues: import_prop_types9.default.array,
    width: import_prop_types9.default.number.isRequired
  };

  // node_modules/@visx/tooltip/esm/hooks/useTooltip.js
  var import_react103 = __toESM(require_react());
  var _excluded15 = ["tooltipOpen"];
  function _objectWithoutPropertiesLoose15(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _extends21() {
    _extends21 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends21.apply(this, arguments);
  }
  function useTooltip2(initialTooltipState) {
    var _useState = (0, import_react103.useState)(_extends21({
      tooltipOpen: false
    }, initialTooltipState)), tooltipState = _useState[0], setTooltipState = _useState[1];
    var showTooltip = (0, import_react103.useCallback)(function(showArgs) {
      return setTooltipState(typeof showArgs === "function" ? function(_ref) {
        var tooltipOpen = _ref.tooltipOpen, show = _objectWithoutPropertiesLoose15(_ref, _excluded15);
        return _extends21({}, showArgs(show), {
          tooltipOpen: true
        });
      } : {
        tooltipOpen: true,
        tooltipLeft: showArgs.tooltipLeft,
        tooltipTop: showArgs.tooltipTop,
        tooltipData: showArgs.tooltipData
      });
    }, [setTooltipState]);
    var hideTooltip = (0, import_react103.useCallback)(function() {
      return setTooltipState({
        tooltipOpen: false,
        tooltipLeft: void 0,
        tooltipTop: void 0,
        tooltipData: void 0
      });
    }, [setTooltipState]);
    return {
      tooltipOpen: tooltipState.tooltipOpen,
      tooltipLeft: tooltipState.tooltipLeft,
      tooltipTop: tooltipState.tooltipTop,
      tooltipData: tooltipState.tooltipData,
      updateTooltip: setTooltipState,
      showTooltip,
      hideTooltip
    };
  }

  // node_modules/@visx/tooltip/esm/hooks/useTooltipInPortal.js
  var import_react110 = __toESM(require_react());

  // node_modules/react-use-measure/dist/web.js
  var import_react104 = __toESM(require_react());
  var import_debounce2 = __toESM(require_debounce());
  function useMeasure(_temp) {
    let {
      debounce: debounce3,
      scroll: scroll2,
      polyfill: polyfill2,
      offsetSize
    } = _temp === void 0 ? {
      debounce: 0,
      scroll: false,
      offsetSize: false
    } : _temp;
    const ResizeObserver = polyfill2 || (typeof window === "undefined" ? class ResizeObserver {
    } : window.ResizeObserver);
    if (!ResizeObserver) {
      throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    }
    const [bounds, set] = (0, import_react104.useState)({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0
    });
    const state2 = (0, import_react104.useRef)({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: bounds
    });
    const scrollDebounce = debounce3 ? typeof debounce3 === "number" ? debounce3 : debounce3.scroll : null;
    const resizeDebounce = debounce3 ? typeof debounce3 === "number" ? debounce3 : debounce3.resize : null;
    const mounted = (0, import_react104.useRef)(false);
    (0, import_react104.useEffect)(() => {
      mounted.current = true;
      return () => void (mounted.current = false);
    });
    const [forceRefresh, resizeChange, scrollChange] = (0, import_react104.useMemo)(() => {
      const callback = () => {
        if (!state2.current.element)
          return;
        const {
          left: left2,
          top: top2,
          width,
          height,
          bottom: bottom2,
          right: right2,
          x,
          y
        } = state2.current.element.getBoundingClientRect();
        const size2 = {
          left: left2,
          top: top2,
          width,
          height,
          bottom: bottom2,
          right: right2,
          x,
          y
        };
        if (state2.current.element instanceof HTMLElement && offsetSize) {
          size2.height = state2.current.element.offsetHeight;
          size2.width = state2.current.element.offsetWidth;
        }
        Object.freeze(size2);
        if (mounted.current && !areBoundsEqual(state2.current.lastBounds, size2))
          set(state2.current.lastBounds = size2);
      };
      return [callback, resizeDebounce ? (0, import_debounce2.default)(callback, resizeDebounce) : callback, scrollDebounce ? (0, import_debounce2.default)(callback, scrollDebounce) : callback];
    }, [set, offsetSize, scrollDebounce, resizeDebounce]);
    function removeListeners() {
      if (state2.current.scrollContainers) {
        state2.current.scrollContainers.forEach((element) => element.removeEventListener("scroll", scrollChange, true));
        state2.current.scrollContainers = null;
      }
      if (state2.current.resizeObserver) {
        state2.current.resizeObserver.disconnect();
        state2.current.resizeObserver = null;
      }
    }
    function addListeners() {
      if (!state2.current.element)
        return;
      state2.current.resizeObserver = new ResizeObserver(scrollChange);
      state2.current.resizeObserver.observe(state2.current.element);
      if (scroll2 && state2.current.scrollContainers) {
        state2.current.scrollContainers.forEach((scrollContainer) => scrollContainer.addEventListener("scroll", scrollChange, {
          capture: true,
          passive: true
        }));
      }
    }
    const ref = (node2) => {
      if (!node2 || node2 === state2.current.element)
        return;
      removeListeners();
      state2.current.element = node2;
      state2.current.scrollContainers = findScrollContainers(node2);
      addListeners();
    };
    useOnWindowScroll(scrollChange, Boolean(scroll2));
    useOnWindowResize(resizeChange);
    (0, import_react104.useEffect)(() => {
      removeListeners();
      addListeners();
    }, [scroll2, scrollChange, resizeChange]);
    (0, import_react104.useEffect)(() => removeListeners, []);
    return [ref, bounds, forceRefresh];
  }
  function useOnWindowResize(onWindowResize) {
    (0, import_react104.useEffect)(() => {
      const cb = onWindowResize;
      window.addEventListener("resize", cb);
      return () => void window.removeEventListener("resize", cb);
    }, [onWindowResize]);
  }
  function useOnWindowScroll(onScroll, enabled) {
    (0, import_react104.useEffect)(() => {
      if (enabled) {
        const cb = onScroll;
        window.addEventListener("scroll", cb, {
          capture: true,
          passive: true
        });
        return () => void window.removeEventListener("scroll", cb, true);
      }
    }, [onScroll, enabled]);
  }
  function findScrollContainers(element) {
    const result = [];
    if (!element || element === document.body)
      return result;
    const {
      overflow,
      overflowX,
      overflowY
    } = window.getComputedStyle(element);
    if ([overflow, overflowX, overflowY].some((prop) => prop === "auto" || prop === "scroll"))
      result.push(element);
    return [...result, ...findScrollContainers(element.parentElement)];
  }
  var keys2 = ["x", "y", "top", "bottom", "left", "right", "width", "height"];
  var areBoundsEqual = (a, b) => keys2.every((key) => a[key] === b[key]);

  // node_modules/@visx/tooltip/esm/Portal.js
  var import_prop_types10 = __toESM(require_prop_types());
  var import_react105 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Portal2 = /* @__PURE__ */ function(_React$PureComponent) {
    _inheritsLoose(Portal3, _React$PureComponent);
    function Portal3() {
      return _React$PureComponent.apply(this, arguments) || this;
    }
    var _proto = Portal3.prototype;
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.node && document.body) {
        document.body.removeChild(this.node);
        delete this.node;
      }
    };
    _proto.render = function render() {
      if (!this.node && typeof document !== "undefined") {
        this.node = document.createElement("div");
        if (this.props.zIndex != null)
          this.node.style.zIndex = "" + this.props.zIndex;
        document.body.append(this.node);
      }
      if (!this.node) {
        return null;
      }
      return /* @__PURE__ */ import_react_dom2.default.createPortal(this.props.children, this.node);
    };
    return Portal3;
  }(import_react105.default.PureComponent);
  Portal2.propTypes = {
    zIndex: import_prop_types10.default.oneOfType([import_prop_types10.default.number, import_prop_types10.default.string])
  };

  // node_modules/@visx/tooltip/esm/tooltips/Tooltip.js
  var import_prop_types11 = __toESM(require_prop_types());
  var import_react106 = __toESM(require_react());
  var import_classnames13 = __toESM(require_classnames());
  var _excluded16 = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
  function _extends22() {
    _extends22 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends22.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose16(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var defaultStyles = {
    position: "absolute",
    backgroundColor: "white",
    color: "#666666",
    padding: ".3rem .5rem",
    borderRadius: "3px",
    fontSize: "14px",
    boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
    lineHeight: "1em",
    pointerEvents: "none"
  };
  var Tooltip2 = /* @__PURE__ */ import_react106.default.forwardRef(function(_ref, ref) {
    var className = _ref.className, top2 = _ref.top, left2 = _ref.left, _ref$offsetLeft = _ref.offsetLeft, offsetLeft = _ref$offsetLeft === void 0 ? 10 : _ref$offsetLeft, _ref$offsetTop = _ref.offsetTop, offsetTop = _ref$offsetTop === void 0 ? 10 : _ref$offsetTop, _ref$style = _ref.style, style = _ref$style === void 0 ? defaultStyles : _ref$style, children = _ref.children, _ref$unstyled = _ref.unstyled, unstyled = _ref$unstyled === void 0 ? false : _ref$unstyled, _ref$applyPositionSty = _ref.applyPositionStyle, applyPositionStyle = _ref$applyPositionSty === void 0 ? false : _ref$applyPositionSty, restProps = _objectWithoutPropertiesLoose16(_ref, _excluded16);
    return /* @__PURE__ */ import_react106.default.createElement("div", _extends22({
      ref,
      className: (0, import_classnames13.default)("visx-tooltip", className),
      style: _extends22({
        top: top2 == null || offsetTop == null ? top2 : top2 + offsetTop,
        left: left2 == null || offsetLeft == null ? left2 : left2 + offsetLeft
      }, applyPositionStyle && {
        position: "absolute"
      }, !unstyled && style)
    }, restProps), children);
  });
  Tooltip2.propTypes = {
    children: import_prop_types11.default.node,
    className: import_prop_types11.default.string,
    left: import_prop_types11.default.number,
    offsetLeft: import_prop_types11.default.number,
    offsetTop: import_prop_types11.default.number,
    top: import_prop_types11.default.number,
    applyPositionStyle: import_prop_types11.default.bool,
    unstyled: import_prop_types11.default.bool
  };
  Tooltip2.displayName = "Tooltip";
  var Tooltip_default = Tooltip2;

  // node_modules/@visx/tooltip/esm/tooltips/TooltipWithBounds.js
  var import_prop_types12 = __toESM(require_prop_types());
  var import_react109 = __toESM(require_react());

  // node_modules/@visx/bounds/esm/enhancers/withBoundingRects.js
  var import_react107 = __toESM(require_react());
  var import_react_dom3 = __toESM(require_react_dom());
  function _extends23() {
    _extends23 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends23.apply(this, arguments);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf2(subClass, superClass);
  }
  function _setPrototypeOf2(o, p) {
    _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf2(o, p);
  }
  var emptyRect = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    width: 0,
    height: 0
  };
  function withBoundingRects(BaseComponent) {
    var _class;
    return _class = /* @__PURE__ */ function(_React$PureComponent) {
      _inheritsLoose2(WrappedComponent, _React$PureComponent);
      function WrappedComponent(props) {
        var _this;
        _this = _React$PureComponent.call(this, props) || this;
        _this.state = {
          rect: void 0,
          parentRect: void 0
        };
        _this.nodeRef = /* @__PURE__ */ import_react107.default.createRef();
        _this.getRects = _this.getRects.bind(_assertThisInitialized(_this));
        return _this;
      }
      var _proto = WrappedComponent.prototype;
      _proto.componentDidMount = function componentDidMount() {
        var _this$nodeRef, _this2 = this;
        this.node = (_this$nodeRef = this.nodeRef) != null && _this$nodeRef.current ? this.nodeRef.current : import_react_dom3.default.findDOMNode(this);
        this.setState(function() {
          return _this2.getRects();
        });
      };
      _proto.getRects = function getRects() {
        if (!this.node)
          return this.state;
        var node2 = this.node;
        var parentNode = node2.parentNode;
        var rect = node2.getBoundingClientRect ? node2.getBoundingClientRect() : emptyRect;
        var parentRect = parentNode != null && parentNode.getBoundingClientRect ? parentNode.getBoundingClientRect() : emptyRect;
        return {
          rect,
          parentRect
        };
      };
      _proto.render = function render() {
        return /* @__PURE__ */ import_react107.default.createElement(BaseComponent, _extends23({
          nodeRef: this.nodeRef,
          getRects: this.getRects
        }, this.state, this.props));
      };
      return WrappedComponent;
    }(import_react107.default.PureComponent), _class.displayName = "withBoundingRects(" + (BaseComponent.displayName || "") + ")", _class;
  }

  // node_modules/@visx/tooltip/esm/context/TooltipPositionContext.js
  var import_react108 = __toESM(require_react());
  var TooltipPositionContext = /* @__PURE__ */ (0, import_react108.createContext)({
    isFlippedVertically: false,
    isFlippedHorizontally: false
  });
  var TooltipPositionProvider = TooltipPositionContext.Provider;
  var TooltipPositionConsumer = TooltipPositionContext.Consumer;

  // node_modules/@visx/tooltip/esm/tooltips/TooltipWithBounds.js
  var _excluded17 = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
  function _extends24() {
    _extends24 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends24.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose17(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function TooltipWithBounds(_ref) {
    var children = _ref.children, getRects = _ref.getRects, _ref$left = _ref.left, initialLeft = _ref$left === void 0 ? 0 : _ref$left, _ref$offsetLeft = _ref.offsetLeft, offsetLeft = _ref$offsetLeft === void 0 ? 10 : _ref$offsetLeft, _ref$offsetTop = _ref.offsetTop, offsetTop = _ref$offsetTop === void 0 ? 10 : _ref$offsetTop, parentBounds = _ref.parentRect, ownBounds = _ref.rect, _ref$style = _ref.style, style = _ref$style === void 0 ? defaultStyles : _ref$style, _ref$top = _ref.top, initialTop = _ref$top === void 0 ? 0 : _ref$top, _ref$unstyled = _ref.unstyled, unstyled = _ref$unstyled === void 0 ? false : _ref$unstyled, nodeRef = _ref.nodeRef, otherProps = _objectWithoutPropertiesLoose17(_ref, _excluded17);
    var transform2;
    var placeTooltipLeft = false;
    var placeTooltipUp = false;
    if (ownBounds && parentBounds) {
      var left2 = initialLeft;
      var top2 = initialTop;
      if (parentBounds.width) {
        var rightPlacementClippedPx = left2 + offsetLeft + ownBounds.width - parentBounds.width;
        var leftPlacementClippedPx = ownBounds.width - left2 - offsetLeft;
        placeTooltipLeft = rightPlacementClippedPx > 0 && rightPlacementClippedPx > leftPlacementClippedPx;
      } else {
        var _rightPlacementClippedPx = left2 + offsetLeft + ownBounds.width - window.innerWidth;
        var _leftPlacementClippedPx = ownBounds.width - left2 - offsetLeft;
        placeTooltipLeft = _rightPlacementClippedPx > 0 && _rightPlacementClippedPx > _leftPlacementClippedPx;
      }
      if (parentBounds.height) {
        var bottomPlacementClippedPx = top2 + offsetTop + ownBounds.height - parentBounds.height;
        var topPlacementClippedPx = ownBounds.height - top2 - offsetTop;
        placeTooltipUp = bottomPlacementClippedPx > 0 && bottomPlacementClippedPx > topPlacementClippedPx;
      } else {
        placeTooltipUp = top2 + offsetTop + ownBounds.height > window.innerHeight;
      }
      left2 = placeTooltipLeft ? left2 - ownBounds.width - offsetLeft : left2 + offsetLeft;
      top2 = placeTooltipUp ? top2 - ownBounds.height - offsetTop : top2 + offsetTop;
      left2 = Math.round(left2);
      top2 = Math.round(top2);
      transform2 = "translate(" + left2 + "px, " + top2 + "px)";
    }
    return /* @__PURE__ */ import_react109.default.createElement(Tooltip_default, _extends24({
      ref: nodeRef,
      style: _extends24({
        left: 0,
        top: 0,
        transform: transform2
      }, !unstyled && style)
    }, otherProps), /* @__PURE__ */ import_react109.default.createElement(TooltipPositionProvider, {
      value: {
        isFlippedVertically: !placeTooltipUp,
        isFlippedHorizontally: !placeTooltipLeft
      }
    }, children));
  }
  TooltipWithBounds.propTypes = {
    nodeRef: import_prop_types12.default.oneOfType([import_prop_types12.default.string, import_prop_types12.default.func, import_prop_types12.default.object])
  };
  var TooltipWithBounds_default = withBoundingRects(TooltipWithBounds);

  // node_modules/@visx/tooltip/esm/hooks/useTooltipInPortal.js
  var _excluded18 = ["detectBounds", "zIndex"];
  var _excluded22 = ["left", "top", "detectBounds", "zIndex"];
  function _extends25() {
    _extends25 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends25.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose18(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function useTooltipInPortal(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, _ref$detectBounds = _ref.detectBounds, detectBoundsOption = _ref$detectBounds === void 0 ? true : _ref$detectBounds, zIndexOption = _ref.zIndex, useMeasureOptions = _objectWithoutPropertiesLoose18(_ref, _excluded18);
    var _useMeasure = useMeasure(useMeasureOptions), containerRef = _useMeasure[0], containerBounds = _useMeasure[1], forceRefreshBounds = _useMeasure[2];
    var _useState = (0, import_react110.useState)(false), isSsr = _useState[0], setIsSsr = _useState[1];
    (0, import_react110.useEffect)(function() {
      setIsSsr(false);
    }, []);
    var TooltipInPortal = (0, import_react110.useMemo)(function() {
      return function(_ref2) {
        var _ref2$left = _ref2.left, containerLeft = _ref2$left === void 0 ? 0 : _ref2$left, _ref2$top = _ref2.top, containerTop = _ref2$top === void 0 ? 0 : _ref2$top, detectBoundsProp = _ref2.detectBounds, zIndexProp = _ref2.zIndex, tooltipProps = _objectWithoutPropertiesLoose18(_ref2, _excluded22);
        var detectBounds = detectBoundsProp == null ? detectBoundsOption : detectBoundsProp;
        var zIndex = zIndexProp == null ? zIndexOption : zIndexProp;
        var TooltipComponent = detectBounds ? TooltipWithBounds_default : Tooltip_default;
        var scrollX = isSsr ? 0 : window.scrollX;
        var scrollY = isSsr ? 0 : window.scrollY;
        var portalLeft = containerLeft + (containerBounds.left || 0) + scrollX;
        var portalTop = containerTop + (containerBounds.top || 0) + scrollY;
        return /* @__PURE__ */ import_react110.default.createElement(Portal2, {
          zIndex
        }, /* @__PURE__ */ import_react110.default.createElement(TooltipComponent, _extends25({
          left: portalLeft,
          top: portalTop
        }, tooltipProps)));
      };
    }, [detectBoundsOption, zIndexOption, containerBounds.left, containerBounds.top, isSsr]);
    return {
      containerRef,
      containerBounds,
      forceRefreshBounds,
      TooltipInPortal
    };
  }

  // node_modules/@visx/vendor/node_modules/d3-array/src/ascending.js
  function ascending2(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/@visx/vendor/node_modules/d3-array/src/descending.js
  function descending2(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  // node_modules/@visx/vendor/node_modules/d3-array/src/bisector.js
  function bisector2(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending2;
      compare2 = (d, x) => ascending2(f(d), x);
      delta = (d, x) => f(d) - x;
    } else {
      compare1 = f === ascending2 || f === descending2 ? f : zero3;
      compare2 = f;
      delta = f;
    }
    function left2(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) < 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) <= 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center(a, x, lo = 0, hi = a.length) {
      const i = left2(a, x, lo, hi - 1);
      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return { left: left2, center, right: right2 };
  }
  function zero3() {
    return 0;
  }

  // src/app/views/colors.ts
  var Colors = {
    heatpump: "#1f77b4",
    statusQuo: "#8c564b"
  };

  // src/app/views/lifetime-cost-of-ownership-view.tsx
  var bisectSeries = bisector2((d) => d[0]).right;
  var LifetimeCostOfOwnershipView = (props) => {
    const systemComparison = useAtomValue(systemComparisonAtom);
    const heatpumpInstallCost = useAtomValue(heatpumpInstallCostAtom);
    const statusQuoFurnaceInstallCost = useAtomValue(
      statusQuoFurnaceInstallCostAtom
    );
    const airConditionerInstallCost = useAtomValue(airConditionerInstallCostAtom);
    const bestHeatPumpSimulationResult = useAtomValue(
      bestHeatPumpSimulationResultAtom
    );
    const statusQuoSimulationResult = useAtomValue(statusQuoSimulationResultAtom);
    const {
      tooltipData,
      tooltipLeft,
      tooltipTop,
      tooltipOpen,
      showTooltip,
      hideTooltip
    } = useTooltip2();
    const { containerRef, TooltipInPortal } = useTooltipInPortal({
      detectBounds: true,
      scroll: true
    });
    if (systemComparison == null || heatpumpInstallCost == null || bestHeatPumpSimulationResult == null || statusQuoFurnaceInstallCost == null || airConditionerInstallCost == null || statusQuoSimulationResult == null || bestHeatPumpSimulationResult == null) {
      return null;
    }
    function year(n2) {
      return DateTime.utc(DateTime.utc().year + n2).toJSDate();
    }
    const [heatPumpSeries, statusQuoSeries] = (0, import_react112.useMemo)(() => {
      const heatPumpSeries2 = [
        [year(0), 0],
        [year(0), heatpumpInstallCost]
      ];
      const statusQuoSeries2 = [
        [year(0), 0],
        [year(0), statusQuoFurnaceInstallCost + airConditionerInstallCost]
      ];
      let hp = heatPumpSeries2[1][1];
      let sq = statusQuoSeries2[1][1];
      const startYear = DateTime.utc().year;
      const sortedHPBills = [...bestHeatPumpSimulationResult.bills].sort(
        (a, b) => a.getBillingPeriodEnd().toMillis() - b.getBillingPeriodEnd().toMillis()
      );
      const sortedSQBills = [...statusQuoSimulationResult.bills].sort(
        (a, b) => a.getBillingPeriodEnd().toMillis() - b.getBillingPeriodEnd().toMillis()
      );
      for (let i = 0; i <= equipmentLifetimeYears; i++) {
        const year2 = startYear + i;
        for (let bill of sortedHPBills) {
          hp += bill.getTotalCost();
          heatPumpSeries2.push([
            bill.getBillingPeriodEnd().set({ year: year2 }).toUTC().toJSDate(),
            hp
          ]);
        }
        for (let bill of sortedSQBills) {
          sq += bill.getTotalCost();
          statusQuoSeries2.push([
            bill.getBillingPeriodEnd().set({ year: year2 }).toUTC().toJSDate(),
            sq
          ]);
        }
      }
      return [heatPumpSeries2, statusQuoSeries2];
    }, [
      heatpumpInstallCost,
      statusQuoFurnaceInstallCost,
      airConditionerInstallCost,
      bestHeatPumpSimulationResult,
      statusQuoSimulationResult
    ]);
    const margin = { top: 10, right: 30, bottom: 40, left: 60 }, width = 430 - margin.left - margin.right, height = 200 - margin.top - margin.bottom;
    const x = createUtcScale({
      domain: [
        year(-1),
        DateTime.fromJSDate(heatPumpSeries[heatPumpSeries.length - 1][0]).plus({ years: 1 }).toJSDate()
      ],
      range: [0, width]
    }).nice();
    const names = [
      bestHeatPumpSimulationResult.name,
      statusQuoSimulationResult.name
    ];
    const y = createLinearScale({
      domain: [
        0,
        Math.max(
          heatPumpSeries[heatPumpSeries.length - 1][1],
          statusQuoSeries[statusQuoSeries.length - 1][1]
        )
      ],
      range: [height, 0]
    }).nice();
    const color4 = createOrdinalScale().domain(names).range([Colors.heatpump, Colors.statusQuo]);
    const hpColor = color4(bestHeatPumpSimulationResult.name);
    const sqColor = color4(statusQuoSimulationResult.name);
    const handleMouseMove = (ev) => {
      const domSpaceRect = ev.currentTarget.getBoundingClientRect();
      const svgSpaceMouse = {
        x: ev.nativeEvent.offsetX * (margin.left + width + margin.right) / domSpaceRect.width,
        y: ev.nativeEvent.offsetY * (margin.top + height + margin.bottom) / domSpaceRect.height
      };
      const groupSpaceX = svgSpaceMouse.x - margin.left;
      const groupSpaceY = svgSpaceMouse.y - margin.top;
      const date2 = DateTime.utc(
        DateTime.fromJSDate(x.invert(groupSpaceX)).toUTC().year
      ).toJSDate();
      const hpIdx = bisectSeries(heatPumpSeries, date2);
      const hp = heatPumpSeries[Math.min(heatPumpSeries.length - 1, hpIdx)];
      const sqIdx = bisectSeries(statusQuoSeries, date2);
      const sq = statusQuoSeries[Math.min(statusQuoSeries.length - 1, sqIdx)];
      const groupSpaceTooltipX = x(hp[0]);
      const svgSpaceTooltipX = (groupSpaceTooltipX + margin.left) * domSpaceRect.width / (margin.left + width + margin.right);
      const tt = {
        tooltipTop: 0,
        tooltipLeft: svgSpaceTooltipX,
        tooltipData: {
          date: hp[0],
          heatPumpCost: hp[1],
          statusQuoCost: sq[1]
        }
      };
      showTooltip(tt);
    };
    return /* @__PURE__ */ import_react112.default.createElement(ChartGroup, null, /* @__PURE__ */ import_react112.default.createElement(ChartHeader, null, "Total Cost over Time"), /* @__PURE__ */ import_react112.default.createElement(
      "svg",
      {
        viewBox: `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`,
        style: { width: "100%", height: "auto", background: "white" },
        onMouseMove: handleMouseMove,
        onMouseLeave: hideTooltip,
        ref: containerRef
      },
      /* @__PURE__ */ import_react112.default.createElement(Group, { left: margin.left, top: margin.top }, /* @__PURE__ */ import_react112.default.createElement(GridRows, { scale: y, width }), tooltipOpen && tooltipData && /* @__PURE__ */ import_react112.default.createElement(
        Line,
        {
          from: { x: x(tooltipData.date), y: 0 },
          to: { x: x(tooltipData.date), y: height },
          stroke: "#eaf0f6",
          strokeWidth: 2
        }
      ), /* @__PURE__ */ import_react112.default.createElement(
        LinePath,
        {
          data: heatPumpSeries,
          x: (d) => x(d[0]),
          y: (d) => y(d[1]),
          stroke: hpColor,
          strokeWidth: 2,
          curve: stepAfter
        }
      ), /* @__PURE__ */ import_react112.default.createElement(
        LinePath,
        {
          data: statusQuoSeries,
          x: (d) => x(d[0]),
          y: (d) => y(d[1]),
          stroke: sqColor,
          strokeWidth: 2,
          curve: stepAfter
        }
      ), /* @__PURE__ */ import_react112.default.createElement(AxisBottom, { top: height, scale: x }), /* @__PURE__ */ import_react112.default.createElement(
        AxisLeft,
        {
          numTicks: 4,
          scale: y,
          tickFormat: (t4) => `$${t4.toLocaleString()}`
        }
      ), tooltipOpen && tooltipData && /* @__PURE__ */ import_react112.default.createElement(Group, null, /* @__PURE__ */ import_react112.default.createElement(
        Circle3,
        {
          cx: x(tooltipData.date),
          cy: y(tooltipData.heatPumpCost),
          r: 5,
          fill: color4(bestHeatPumpSimulationResult.name)
        }
      ), /* @__PURE__ */ import_react112.default.createElement(
        Circle3,
        {
          cx: x(tooltipData.date),
          cy: y(tooltipData.statusQuoCost),
          r: 5,
          fill: color4(statusQuoSimulationResult.name)
        }
      )))
    ), /* @__PURE__ */ import_react112.default.createElement("div", { style: { marginLeft: margin.left } }, /* @__PURE__ */ import_react112.default.createElement(Ordinal, { scale: color4 })), tooltipOpen && tooltipData && tooltipTop != null && tooltipLeft != null && /* @__PURE__ */ import_react112.default.createElement(
      TooltipInPortal,
      {
        key: Math.random(),
        top: tooltipTop - 12,
        left: tooltipLeft
      },
      /* @__PURE__ */ import_react112.default.createElement("div", null, DateTime.fromJSDate(tooltipData.date).toUTC().toFormat("yyyy")),
      /* @__PURE__ */ import_react112.default.createElement(Text, { color: hpColor }, "$", tooltipData.heatPumpCost.toLocaleString("en-CA", {
        maximumSignificantDigits: 3
      })),
      /* @__PURE__ */ import_react112.default.createElement(Text, { color: sqColor }, "$", tooltipData.statusQuoCost.toLocaleString("en-CA", {
        maximumSignificantDigits: 3
      }))
    ));
  };

  // src/app/views/emissions-view.tsx
  var import_react113 = __toESM(require_react());
  var EmissionsView = (props) => {
    const simulations = useAtomValue(simulationsAtom);
    if (!simulations)
      return null;
    const margin = { top: 10, right: 30, bottom: 40, left: 150 }, width = 430 - margin.left - margin.right, height = 120 - margin.top - margin.bottom;
    const tCO2e = (s2) => s2.emissionsGramsCO2e / 1e6;
    const x = createLinearScale({
      domain: [0, Math.max(...simulations.map((s2) => tCO2e(s2)))],
      range: [0, width]
    }).nice();
    const y = createBandScale({
      domain: simulations.map((s2) => s2.name),
      paddingInner: 0.1,
      paddingOuter: 0.1,
      range: [0, height]
    });
    const color4 = createOrdinalScale().domain(simulations.map((s2) => s2.name)).range([Colors.heatpump, Colors.statusQuo]);
    return /* @__PURE__ */ import_react113.default.createElement(ChartGroup, null, /* @__PURE__ */ import_react113.default.createElement(ChartHeader, null, "Annual Emissions from Heating and Cooling"), /* @__PURE__ */ import_react113.default.createElement(
      "svg",
      {
        viewBox: `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`,
        style: { width: "100%", height: "auto" }
      },
      /* @__PURE__ */ import_react113.default.createElement(Group, { left: margin.left, top: margin.top }, simulations.map((s2) => {
        return /* @__PURE__ */ import_react113.default.createElement(
          Bar,
          {
            key: s2.name,
            x: 0,
            y: y(s2.name),
            height: y.bandwidth(),
            fill: color4(s2.name),
            width: x(tCO2e(s2))
          }
        );
      }), /* @__PURE__ */ import_react113.default.createElement(
        AxisBottom,
        {
          top: height,
          scale: x,
          numTicks: 4,
          tickFormat: (t4) => `${t4} ton` + (t4 != 1 ? "s" : "")
        }
      ), /* @__PURE__ */ import_react113.default.createElement(AxisLeft, { scale: y }))
    ));
  };

  // src/app/views/monthly-billing-view.tsx
  var import_react116 = __toESM(require_react());

  // node_modules/@visx/pattern/esm/patterns/Pattern.js
  var import_prop_types13 = __toESM(require_prop_types());
  var import_react114 = __toESM(require_react());
  function Pattern(_ref) {
    var id3 = _ref.id, width = _ref.width, height = _ref.height, children = _ref.children;
    return /* @__PURE__ */ import_react114.default.createElement("defs", null, /* @__PURE__ */ import_react114.default.createElement("pattern", {
      id: id3,
      width,
      height,
      patternUnits: "userSpaceOnUse"
    }, children));
  }
  Pattern.propTypes = {
    id: import_prop_types13.default.string.isRequired,
    width: import_prop_types13.default.number.isRequired,
    height: import_prop_types13.default.number.isRequired,
    children: import_prop_types13.default.node.isRequired
  };

  // node_modules/@visx/pattern/esm/patterns/Lines.js
  var import_prop_types14 = __toESM(require_prop_types());
  var import_react115 = __toESM(require_react());
  var import_classnames14 = __toESM(require_classnames());

  // node_modules/@visx/pattern/esm/constants/index.js
  var PatternOrientation = {
    horizontal: "horizontal",
    vertical: "vertical",
    diagonal: "diagonal",
    diagonalRightToLeft: "diagonalRightToLeft"
  };

  // node_modules/@visx/pattern/esm/patterns/Lines.js
  function pathForOrientation(_ref) {
    var height = _ref.height, orientation = _ref.orientation;
    switch (orientation) {
      case PatternOrientation.horizontal:
        return "M 0," + height / 2 + " l " + height + ",0";
      case PatternOrientation.diagonal:
        return "M 0," + height + " l " + height + "," + -height + " M " + -height / 4 + "," + height / 4 + " l " + height / 2 + "," + -height / 2 + "\n             M " + 3 / 4 * height + "," + 5 / 4 * height + " l " + height / 2 + "," + -height / 2;
      case PatternOrientation.diagonalRightToLeft:
        return "M 0,0 l " + height + "," + height + "\n        M " + -height / 4 + "," + 3 / 4 * height + " l " + height / 2 + "," + height / 2 + "\n        M " + 3 / 4 * height + "," + -height / 4 + " l " + height / 2 + "," + height / 2;
      case PatternOrientation.vertical:
      default:
        return "M " + height / 2 + ", 0 l 0, " + height;
    }
  }
  function Lines(_ref2) {
    var id3 = _ref2.id, width = _ref2.width, height = _ref2.height, stroke = _ref2.stroke, strokeWidth = _ref2.strokeWidth, strokeDasharray = _ref2.strokeDasharray, _ref2$strokeLinecap = _ref2.strokeLinecap, strokeLinecap = _ref2$strokeLinecap === void 0 ? "square" : _ref2$strokeLinecap, _ref2$shapeRendering = _ref2.shapeRendering, shapeRendering = _ref2$shapeRendering === void 0 ? "auto" : _ref2$shapeRendering, _ref2$orientation = _ref2.orientation, orientation = _ref2$orientation === void 0 ? ["vertical"] : _ref2$orientation, background2 = _ref2.background, className = _ref2.className;
    var orientations = Array.isArray(orientation) ? orientation : [orientation];
    return /* @__PURE__ */ import_react115.default.createElement(Pattern, {
      id: id3,
      width,
      height
    }, !!background2 && /* @__PURE__ */ import_react115.default.createElement("rect", {
      className: (0, import_classnames14.default)("visx-pattern-line-background"),
      width,
      height,
      fill: background2
    }), orientations.map(function(o, i) {
      return /* @__PURE__ */ import_react115.default.createElement("path", {
        key: "visx-" + id3 + "-line-" + o + "-" + i,
        className: (0, import_classnames14.default)("visx-pattern-line", className),
        d: pathForOrientation({
          orientation: o,
          height
        }),
        stroke,
        strokeWidth,
        strokeDasharray,
        strokeLinecap,
        shapeRendering
      });
    }));
  }
  Lines.propTypes = {
    id: import_prop_types14.default.string.isRequired,
    width: import_prop_types14.default.number.isRequired,
    height: import_prop_types14.default.number.isRequired,
    className: import_prop_types14.default.string,
    background: import_prop_types14.default.string,
    stroke: import_prop_types14.default.string,
    strokeWidth: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]),
    strokeDasharray: import_prop_types14.default.oneOfType([import_prop_types14.default.string, import_prop_types14.default.number]),
    strokeLinecap: import_prop_types14.default.oneOf(["square", "butt", "round", "inherit"]),
    shapeRendering: import_prop_types14.default.oneOfType([import_prop_types14.default.string, import_prop_types14.default.number]),
    orientation: import_prop_types14.default.array
  };

  // node_modules/@visx/event/esm/typeGuards.js
  function isElement4(elem) {
    return !!elem && elem instanceof Element;
  }
  function isSVGElement2(elem) {
    return !!elem && (elem instanceof SVGElement || "ownerSVGElement" in elem);
  }
  function isSVGSVGElement(elem) {
    return !!elem && "createSVGPoint" in elem;
  }
  function isSVGGraphicsElement(elem) {
    return !!elem && "getScreenCTM" in elem;
  }
  function isTouchEvent(event) {
    return !!event && "changedTouches" in event;
  }
  function isMouseEvent(event) {
    return !!event && "clientX" in event;
  }
  function isEvent(event) {
    return !!event && (event instanceof Event || "nativeEvent" in event && event.nativeEvent instanceof Event);
  }

  // node_modules/@visx/event/esm/getXAndYFromEvent.js
  function _extends26() {
    _extends26 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends26.apply(this, arguments);
  }
  var DEFAULT_POINT = {
    x: 0,
    y: 0
  };
  function getXAndYFromEvent(event) {
    if (!event)
      return _extends26({}, DEFAULT_POINT);
    if (isTouchEvent(event)) {
      return event.changedTouches.length > 0 ? {
        x: event.changedTouches[0].clientX,
        y: event.changedTouches[0].clientY
      } : _extends26({}, DEFAULT_POINT);
    }
    if (isMouseEvent(event)) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
    var target = event == null ? void 0 : event.target;
    var boundingClientRect = target && "getBoundingClientRect" in target ? target.getBoundingClientRect() : null;
    if (!boundingClientRect)
      return _extends26({}, DEFAULT_POINT);
    return {
      x: boundingClientRect.x + boundingClientRect.width / 2,
      y: boundingClientRect.y + boundingClientRect.height / 2
    };
  }

  // node_modules/@visx/event/esm/localPointGeneric.js
  function localPoint(node2, event) {
    if (!node2 || !event)
      return null;
    var coords = getXAndYFromEvent(event);
    var svg = isSVGElement2(node2) ? node2.ownerSVGElement : node2;
    var screenCTM = isSVGGraphicsElement(svg) ? svg.getScreenCTM() : null;
    if (isSVGSVGElement(svg) && screenCTM) {
      var point2 = svg.createSVGPoint();
      point2.x = coords.x;
      point2.y = coords.y;
      point2 = point2.matrixTransform(screenCTM.inverse());
      return new Point({
        x: point2.x,
        y: point2.y
      });
    }
    var rect = node2.getBoundingClientRect();
    return new Point({
      x: coords.x - rect.left - node2.clientLeft,
      y: coords.y - rect.top - node2.clientTop
    });
  }

  // node_modules/@visx/event/esm/localPoint.js
  function localPoint2(nodeOrEvent, maybeEvent) {
    if (isElement4(nodeOrEvent) && maybeEvent) {
      return localPoint(nodeOrEvent, maybeEvent);
    }
    if (isEvent(nodeOrEvent)) {
      var event = nodeOrEvent;
      var node2 = event.target;
      if (node2)
        return localPoint(node2, event);
    }
    return null;
  }

  // src/app/views/monthly-billing-view.tsx
  function capitalizeWord(word) {
    return word.replace(/^./, (x) => x.toUpperCase());
  }
  function formatUsage(bill) {
    let usage = bill.getFuelUsage();
    let unit2 = bill.getFuelUnit();
    if (unit2 === "ccf") {
      usage = usage * CUBIC_METER_PER_CCF;
      unit2 = /* @__PURE__ */ import_react116.default.createElement(import_react116.default.Fragment, null, "m", /* @__PURE__ */ import_react116.default.createElement("sup", null, "3"));
    }
    const formattedUsage = usage.toLocaleString("en-CA", {
      maximumFractionDigits: 2,
      minimumFractionDigits: 2
    });
    return /* @__PURE__ */ import_react116.default.createElement(import_react116.default.Fragment, null, formattedUsage, " ", unit2);
  }
  var BillView = ({ bill }) => {
    return /* @__PURE__ */ import_react116.default.createElement(import_react116.default.Fragment, null, /* @__PURE__ */ import_react116.default.createElement(Stack, { key: bill.getFuelType(), gap: 0 }, /* @__PURE__ */ import_react116.default.createElement(Text, null, /* @__PURE__ */ import_react116.default.createElement("u", null, capitalizeWord(bill.getFuelType()), " bill")), /* @__PURE__ */ import_react116.default.createElement(Text, null, /* @__PURE__ */ import_react116.default.createElement("strong", null, "Usage"), ": ", formatUsage(bill)), /* @__PURE__ */ import_react116.default.createElement(Text, null, /* @__PURE__ */ import_react116.default.createElement("strong", null, "Total"), ": $", bill.getTotalCost().toFixed(2))));
  };
  var MonthlyBillingTooltipView = (props) => {
    const filteredBills = props.bills.filter((b) => b.getTotalCost() != 0);
    const grandTotal = props.bills.reduce((acc, b) => acc + b.getTotalCost(), 0);
    return /* @__PURE__ */ import_react116.default.createElement(Stack, { gap: "10px" }, /* @__PURE__ */ import_react116.default.createElement(Text, null, props.name), filteredBills.map((bill, i) => /* @__PURE__ */ import_react116.default.createElement(BillView, { bill, key: i })), filteredBills.length > 1 && /* @__PURE__ */ import_react116.default.createElement(Text, null, /* @__PURE__ */ import_react116.default.createElement("strong", null, "Grand total"), ": $", grandTotal.toFixed(2)));
  };
  var BillingView = () => {
    const simulations = useAtomValue(simulationsAtom);
    const {
      tooltipData,
      tooltipLeft,
      tooltipTop,
      tooltipOpen,
      showTooltip,
      hideTooltip
    } = useTooltip2();
    const { containerRef, TooltipInPortal } = useTooltipInPortal({
      detectBounds: true,
      scroll: true
    });
    if (!simulations)
      return null;
    const margin = { top: 10, right: 20, bottom: 40, left: 60 }, width = 430 - margin.left - margin.right, height = 200 - margin.top - margin.bottom;
    const monthKey = (date2) => date2.toFormat("yyyy-LL");
    let dateRange = simulations.flatMap((res) => res.bills.flatMap((b) => b.getBillingPeriodStart())).reduce(
      (acc, date2) => {
        if (!acc[0] || date2 < acc[0])
          acc[0] = date2;
        if (!acc[1] || date2 > acc[1])
          acc[1] = date2;
        return acc;
      },
      [void 0, void 0]
    );
    let xAxisDomain = [];
    if (dateRange[0] && dateRange[1]) {
      for (let date2 = dateRange[0]; date2 <= dateRange[1]; date2 = date2.plus({ months: 1 })) {
        xAxisDomain.push(monthKey(date2));
      }
    }
    const allBills = simulations.map((sim) => {
      let map2 = {};
      sim.bills.forEach((bill) => {
        const key = monthKey(bill.getBillingPeriodStart());
        if (!map2[key]) {
          map2[key] = [bill];
        } else {
          map2[key].push(bill);
        }
      });
      return map2;
    });
    const xMajor = createBandScale({
      domain: xAxisDomain,
      paddingInner: 0.2,
      paddingOuter: 0.2,
      range: [0, width]
    });
    const xMinor = createBandScale({
      domain: simulations.map((_, i) => i.toString()),
      paddingInner: 0.1,
      range: [0, xMajor.bandwidth()]
    });
    const y = createLinearScale({
      domain: [
        0,
        Math.max(
          ...allBills.flatMap(
            (billsByMonth) => Object.values(billsByMonth).flatMap(
              (bills) => bills.reduce((acc, bill) => acc + bill.getTotalCost(), 0)
            )
          )
        )
      ],
      range: [height, 0]
    }).nice();
    const color4 = createOrdinalScale().domain(simulations.map((s2) => s2.name)).range([Colors.heatpump, Colors.statusQuo]);
    const handleMouseOver = (event, simIdx, monthKey2) => {
      const coords = localPoint2(
        event.target.ownerSVGElement,
        event
      );
      showTooltip({
        tooltipLeft: coords.x,
        tooltipTop: coords.y,
        tooltipData: {
          name: simulations[simIdx].name,
          bills: allBills[simIdx][monthKey2]
        }
      });
    };
    const monthTickFormat = (value) => {
      return DateTime.fromObject({
        year: parseInt(value.split("-")[0]),
        month: parseInt(value.split("-")[1])
      }).toFormat("LLL");
    };
    return /* @__PURE__ */ import_react116.default.createElement(ChartGroup, null, /* @__PURE__ */ import_react116.default.createElement(ChartHeader, null, "Monthly Utility Bills for Heating and Cooling"), /* @__PURE__ */ import_react116.default.createElement(
      "svg",
      {
        viewBox: `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`,
        style: { width: "100%", height: "auto" },
        ref: containerRef
      },
      color4.range().map((value) => {
        return /* @__PURE__ */ import_react116.default.createElement(
          Lines,
          {
            key: `${value}`,
            id: `lines-${value}`,
            height: 5,
            width: 5,
            stroke: `${value}`,
            background: "white",
            strokeWidth: 2,
            orientation: ["diagonal"]
          }
        );
      }),
      /* @__PURE__ */ import_react116.default.createElement(Group, { left: margin.left, top: margin.top }, /* @__PURE__ */ import_react116.default.createElement(GridRows, { scale: y, width }), allBills.flatMap(
        (billsByMonth, idx) => Object.entries(billsByMonth).flatMap(([month, bills]) => {
          let runningTotalCost = 0;
          return /* @__PURE__ */ import_react116.default.createElement(
            Group,
            {
              key: `group-${month}-${idx}`,
              onMouseOver: (ev) => handleMouseOver(ev, idx, month),
              onMouseOut: hideTooltip
            },
            bills.map((bill, billIdx) => {
              const rectX = xMajor(month) + xMinor(idx.toString());
              runningTotalCost += bill.getTotalCost();
              const rectY = y(runningTotalCost);
              const fillColor = color4(simulations[idx].name);
              return /* @__PURE__ */ import_react116.default.createElement(
                Bar,
                {
                  key: `bar-${month}-${idx}-${billIdx}`,
                  x: rectX,
                  y: rectY,
                  width: xMinor.bandwidth(),
                  height: y(0) - y(bill.getTotalCost()),
                  fill: fillColor
                }
              );
            })
          );
        })
      ), /* @__PURE__ */ import_react116.default.createElement(
        AxisBottom,
        {
          top: height,
          scale: xMajor,
          tickFormat: monthTickFormat
        }
      ), /* @__PURE__ */ import_react116.default.createElement(AxisLeft, { numTicks: 4, scale: y, tickFormat: (v) => `$${v}` }))
    ), /* @__PURE__ */ import_react116.default.createElement("div", { style: { marginLeft: margin.left } }, /* @__PURE__ */ import_react116.default.createElement(Ordinal, { scale: color4 })), tooltipOpen && tooltipData && /* @__PURE__ */ import_react116.default.createElement(
      TooltipInPortal,
      {
        key: Math.random(),
        top: tooltipTop,
        left: tooltipLeft
      },
      /* @__PURE__ */ import_react116.default.createElement(MonthlyBillingTooltipView, { ...tooltipData })
    ));
  };

  // src/app/views/temperatures-view.tsx
  var import_react118 = __toESM(require_react());
  function formatDate(date2) {
    const dt = DateTime.fromMillis(+date2).toUTC();
    const shortMonth = dt.toFormat("LLL");
    if (shortMonth === "Jan") {
      return dt.toFormat("yyyy");
    } else {
      return shortMonth;
    }
  }
  var TemperaturesView = (props) => {
    const margin = { top: 10, right: 30, bottom: 30, left: 60 }, width = 430 - margin.left - margin.right, height = 200 - margin.top - margin.bottom;
    const tzOffsetMinutes = props.simulationResult.timeSteps[0].localTime.offset;
    const tzOffsetMs = tzOffsetMinutes * 60 * 1e3;
    let minTempC = 1e3;
    let maxTempC = -1e3;
    const data = props.simulationResult.timeSteps.map((snapshot2) => {
      const insideAirTempC = fahrenheitToCelcius(snapshot2.insideAirTempF);
      const outsideAirTempC = fahrenheitToCelcius(
        snapshot2.weather.outsideAirTempF
      );
      minTempC = Math.min(minTempC, insideAirTempC, outsideAirTempC);
      maxTempC = Math.max(maxTempC, insideAirTempC, outsideAirTempC);
      return {
        // Because we're using scaleUTC, dates will be formatted as UTC. What we
        // want, however, is for dates to be displayed in local time. D3 (somewhat
        // reasonably) does not include direct support for this:
        // https://github.com/d3/d3/issues/2375
        //
        // As a gross hack, we'll modify it by the associated timezone so that when
        // it's formatted as UTC, it will display the local time.
        //
        // This is a hack, and doesn't correctly account for DST or other
        // single-location variations in timezone offset, but it's still much more
        // intuitively accurate than displaying UTC or browser local time.
        date: new Date(snapshot2.localTime.toMillis() + tzOffsetMs),
        insideAirTempC: fahrenheitToCelcius(snapshot2.insideAirTempF),
        outsideAirTempC: fahrenheitToCelcius(snapshot2.weather.outsideAirTempF)
      };
    });
    const xScale = createUtcScale({
      domain: [data[0].date, data[data.length - 1].date],
      range: [0, width]
    }).nice();
    const yScale = createLinearScale({
      domain: [minTempC - 2, maxTempC + 2],
      range: [height, 0]
    }).nice();
    const color4 = createOrdinalScale().domain(["outside", "inside", "comfort-range"]).range(["#1D82F8", "#F8861D", "rgba(248, 134, 29, 0.2)"]);
    return /* @__PURE__ */ import_react118.default.createElement(ChartGroup, null, /* @__PURE__ */ import_react118.default.createElement(ChartHeader, null, "Historical Outside & Simulated Inside Temperatures"), /* @__PURE__ */ import_react118.default.createElement(
      "svg",
      {
        viewBox: `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`,
        style: { width: "100%", height: "auto" }
      },
      /* @__PURE__ */ import_react118.default.createElement(Group, { left: margin.left, top: margin.top }, /* @__PURE__ */ import_react118.default.createElement(GridRows, { scale: yScale, width }), /* @__PURE__ */ import_react118.default.createElement(
        Bar,
        {
          x: xScale.range()[0],
          y: yScale(props.coolingSetPointC),
          width: xScale.range()[1] - xScale.range()[0],
          height: yScale(props.heatingSetPointC) - yScale(props.coolingSetPointC),
          fill: color4("comfort-range")
        }
      ), /* @__PURE__ */ import_react118.default.createElement(
        LinePath,
        {
          data,
          x: (d) => xScale(d.date),
          y: (d) => yScale(d.outsideAirTempC),
          stroke: color4("outside"),
          strokeWidth: 1
        }
      ), /* @__PURE__ */ import_react118.default.createElement(
        LinePath,
        {
          data,
          x: (d) => xScale(d.date),
          y: (d) => yScale(d.insideAirTempC),
          stroke: color4("inside"),
          strokeWidth: 1
        }
      ), /* @__PURE__ */ import_react118.default.createElement(AxisBottom, { scale: xScale, top: height, tickFormat: formatDate }), /* @__PURE__ */ import_react118.default.createElement(
        AxisLeft,
        {
          scale: yScale,
          numTicks: 5,
          tickFormat: (temp) => `${(+temp).toFixed(0)}\xB0C`
        }
      ))
    ), /* @__PURE__ */ import_react118.default.createElement("div", { style: { marginLeft: margin.left } }, /* @__PURE__ */ import_react118.default.createElement(
      Ordinal,
      {
        scale: color4,
        labelFormat: (name) => {
          switch (name) {
            case "comfort-range": {
              return "Target inside air temperature range";
            }
            case "inside": {
              return `Simulated inside air temperature`;
            }
            case "outside": {
              return "Outside air temperature";
            }
          }
        }
      }
    )));
  };

  // src/app/views/cards.tsx
  var InfoCardView = ({
    title,
    children,
    ...props
  }) => {
    return /* @__PURE__ */ import_react119.default.createElement(
      VStack,
      {
        w: "full",
        bg: "white",
        borderRadius: "10px",
        p: { base: "5px", md: "20px" },
        gap: "5px",
        align: "start",
        ...props
      },
      /* @__PURE__ */ import_react119.default.createElement(Text, { textTransform: "uppercase" }, title),
      children
    );
  };
  var LoadingCardView = (props) => {
    return /* @__PURE__ */ import_react119.default.createElement(InfoCardView, { title: "" }, /* @__PURE__ */ import_react119.default.createElement(Box, { w: "full", height: `${props.height}px` }));
  };
  var CardColumnStackView = (props) => {
    return /* @__PURE__ */ import_react119.default.createElement(HStack, { flex: "1", p: "20px", bg: "#E7E7E7", gap: "20px", align: "start" }, props.children);
  };
  var CardStackView = (props) => {
    return /* @__PURE__ */ import_react119.default.createElement(VStack, { gap: "20px", flex: "1" }, props.children);
  };
  function sigDigs(num, digits = 1) {
    return num.toLocaleString("en-CA", { maximumSignificantDigits: digits });
  }
  function formatDollars(num) {
    return (num < 0 ? "-$" : "$") + sigDigs(Math.abs(num), 2);
  }
  var LifetimeCostsCardView = () => {
    const systemComparison = useAtomValue(systemComparisonAtom);
    const statusQuoFurnaceFuel = useAtomValue(statusQuoFurnaceFuelAtom);
    if (!systemComparison)
      return null;
    const savings = systemComparison.lifetimeCostSavings;
    let heading = formatDollars(Math.abs(savings));
    if (savings < 0) {
      heading += " more";
    } else {
      heading += " less";
    }
    heading += " over 15 years";
    let message = "Installing a heat pump could";
    if (savings < 0) {
      message += ` cost you ${formatDollars(Math.abs(savings))} more than`;
    } else {
      message += ` save you ${formatDollars(Math.abs(savings))} compared to`;
    }
    if (statusQuoFurnaceFuel === "gas") {
      message += ` a gas furnace`;
    } else if (statusQuoFurnaceFuel === "electric") {
      message += ` an electric furnace`;
    } else {
      assertNever(statusQuoFurnaceFuel);
    }
    message += " and an air conditioner over the lifetime of the equipment.";
    message += " This takes into account both up-front costs and utility bills.";
    return /* @__PURE__ */ import_react119.default.createElement(InfoCardView, { title: "Lifetime Costs" }, /* @__PURE__ */ import_react119.default.createElement(Heading, null, heading), /* @__PURE__ */ import_react119.default.createElement(Text, null, message), /* @__PURE__ */ import_react119.default.createElement(LifetimeCostOfOwnershipView, null));
  };
  var emissionsGramsCO2eRoundTripFlight = 275e3 + 275e3;
  var EmissionsReductionCardView = () => {
    const systemComparison = useAtomValue(systemComparisonAtom);
    if (!systemComparison)
      return null;
    const savings = systemComparison.annualEmissionsSavingGramsCo2e;
    let heading = /* @__PURE__ */ import_react119.default.createElement(import_react119.default.Fragment, null, sigDigs(Math.abs(savings) / 1e6, 2), " tCO", /* @__PURE__ */ import_react119.default.createElement("sub", null, "2"), "e", savings < 0 ? " more" : " less", " per year");
    let message;
    if (savings < 0) {
      message = /* @__PURE__ */ import_react119.default.createElement(Text, null, "It looks like a heat pump might increase emissions by", " ", sigDigs(-savings / 1e6, 2), " tons per year. This tends to happen in areas where electrical power generation has exceptionally high emissions.");
    } else {
      const flightCount = sigDigs(savings / emissionsGramsCO2eRoundTripFlight);
      message = /* @__PURE__ */ import_react119.default.createElement(Text, null, "This is roughly equivalent to ", flightCount, " round-trip flight", flightCount !== "1" ? "s" : "", " between Toronto and Vancouver. This is based on province-specific data for the carbon intensity of the electrical grid.");
    }
    return /* @__PURE__ */ import_react119.default.createElement(InfoCardView, { title: "Greenhouse Gas Emissions" }, /* @__PURE__ */ import_react119.default.createElement(Heading, null, heading), message, /* @__PURE__ */ import_react119.default.createElement(EmissionsView, null));
  };
  var UtilityBillsCardView = () => {
    const systemComparison = useAtomValue(systemComparisonAtom);
    const simplePlaceName = useAtomValue(simplePlaceNameAtom);
    const naturalGasPricePerCubicMetre = useAtomValue(
      naturalGasPricePerCubicMetreAtom
    );
    const electricityPricePerKwh = useAtomValue(electricityPricePerKwhAtom);
    if (!systemComparison || !simplePlaceName)
      return null;
    const costSavings = systemComparison.annualOpexCostSavings;
    let heading = formatDollars(Math.abs(costSavings));
    if (costSavings < 0) {
      heading += " more";
    } else {
      heading += " less";
    }
    heading += " per year";
    return /* @__PURE__ */ import_react119.default.createElement(InfoCardView, { title: "Utility Bills" }, /* @__PURE__ */ import_react119.default.createElement(Heading, null, heading), /* @__PURE__ */ import_react119.default.createElement(Text, null, "Based on weather data from ", simplePlaceName, " and utility prices of $", electricityPricePerKwh, "/kWh for electricity and $", naturalGasPricePerCubicMetre, "/m", /* @__PURE__ */ import_react119.default.createElement("sup", null, "3"), " for natural gas."), /* @__PURE__ */ import_react119.default.createElement(BillingView, null));
  };
  var GasServiceFixedCostsCardView = () => {
    const naturalGasFixedCostPerMonth = useAtomValue(
      naturalGasFixedPricePerMonthAtom
    );
    const heatpumpBackupFuel = useAtomValue(heatpumpBackupFuelAtom);
    const hasOtherGasAppliances = useAtomValue(hasOtherGasAppliancesAtom);
    if (naturalGasFixedCostPerMonth == null)
      return null;
    const reasonsPreventingCancellation = [];
    if (heatpumpBackupFuel === "gas") {
      reasonsPreventingCancellation.push(
        "You've selected a heatpump using a gas furnace as its backup heat source"
      );
    }
    if (hasOtherGasAppliances) {
      reasonsPreventingCancellation.push("Your house has other gas appliances");
    }
    return /* @__PURE__ */ import_react119.default.createElement(InfoCardView, { title: "Annual Gas Service Fee" }, /* @__PURE__ */ import_react119.default.createElement(Heading, null, formatDollars(naturalGasFixedCostPerMonth * 12), " per year"), /* @__PURE__ */ import_react119.default.createElement(Text, null, "This is how much you could save per year if you cancel your gas service entirely. Gas utilities in your area charge a fixed fee of around", " ", formatDollars(naturalGasFixedCostPerMonth), "/month on top of usage charges."), reasonsPreventingCancellation.length > 0 ? /* @__PURE__ */ import_react119.default.createElement(import_react119.default.Fragment, null, /* @__PURE__ */ import_react119.default.createElement(Text, null, "The utility bills for the heat pump shown in this calculator still contain this charge because\u2026"), /* @__PURE__ */ import_react119.default.createElement(Box, { as: "ul", ml: "2em" }, reasonsPreventingCancellation.map((r3, i) => /* @__PURE__ */ import_react119.default.createElement("li", { key: i }, r3))), /* @__PURE__ */ import_react119.default.createElement(Text, null, "If you replace all gas appliances and fully electrify your home, then you'd be able to cancel your gas service and benefit from these savings.")) : /* @__PURE__ */ import_react119.default.createElement(Text, null, "Since you've chosen a fully electric heat pump, and your home has no other gas appliances, the utility bills for the heat pump shown in this calculator reflect the savings from cancelling this service."));
  };
  var AboutThisCalculatorCardView = () => {
    const bestHeatPumpSimulationResult = useAtomValue(
      bestHeatPumpSimulationResultAtom
    );
    const heatingSetPointC = useAtomValue(heatingSetPointCAtom);
    const coolingSetPointC = useAtomValue(coolingSetPointCAtom);
    if (!bestHeatPumpSimulationResult)
      return null;
    return /* @__PURE__ */ import_react119.default.createElement(InfoCardView, { title: "About This Calculator" }, /* @__PURE__ */ import_react119.default.createElement(Text, null, "This calculator uses real historical weather data, and province-specific electricity and natural gas prices to simulate monthly utility bills and greenhouse gas emissions."), /* @__PURE__ */ import_react119.default.createElement(
      TemperaturesView,
      {
        heatingSetPointC,
        coolingSetPointC,
        simulationResult: bestHeatPumpSimulationResult
      }
    ), /* @__PURE__ */ import_react119.default.createElement(Text, null, "For more details,", " ", /* @__PURE__ */ import_react119.default.createElement(
      Link,
      {
        href: "https://github.com/jlfwong/hvac-sim-app?tab=readme-ov-file#how-does-it-work",
        textDecoration: "underline"
      },
      "read about the simulation method"
    ), " ", "used by this calculator. This calculator is", " ", /* @__PURE__ */ import_react119.default.createElement(
      Link,
      {
        href: "https://github.com/jlfwong/hvac-sim-app",
        textDecoration: "underline"
      },
      "open source"
    ), "."));
  };

  // src/app/views/equipment-purchase-and-install-form-section-view.tsx
  var import_react121 = __toESM(require_react());
  var EquipmentPurchaseAndInstallFormSectionView = () => {
    const heatpumpBackupFuel = useAtomValue(heatpumpBackupFuelAtom);
    return /* @__PURE__ */ import_react121.default.createElement(import_react121.default.Fragment, null, /* @__PURE__ */ import_react121.default.createElement(FormSectionView, { title: "Heat pump details", stripeColor: Colors.heatpump }, /* @__PURE__ */ import_react121.default.createElement(HeatPumpInstallCostInput, null), /* @__PURE__ */ import_react121.default.createElement(FormRow, null, /* @__PURE__ */ import_react121.default.createElement(HeatPumpBackupFuelSelect, null), heatpumpBackupFuel == "gas" && /* @__PURE__ */ import_react121.default.createElement(AuxSwitchoverTempInput, null))), /* @__PURE__ */ import_react121.default.createElement(
      FormSectionView,
      {
        title: "Compare costs and emissions with\u2026",
        stripeColor: Colors.statusQuo
      },
      /* @__PURE__ */ import_react121.default.createElement(FormRow, null, /* @__PURE__ */ import_react121.default.createElement(
        HomeHeatingTypeSelect,
        {
          label: "Heating equipment",
          tooltip: /* @__PURE__ */ import_react121.default.createElement("p", null, 'To compare a heatpump against a gas furnace, choose "gas". To compare against baseboard heaters or an electric furnace, choose "electricity".')
        }
      ), /* @__PURE__ */ import_react121.default.createElement(FurnaceInstallCostInput, null)),
      /* @__PURE__ */ import_react121.default.createElement(AirConditionerInstallCostInput, null)
    ));
  };

  // src/app/views/utility-prices-form-section-view.tsx
  var import_react122 = __toESM(require_react());
  var UtilityPricesFormSectionView = () => {
    const [electricityPricePerKwh, setElectricityPricePerKwh] = useAtom(
      electricityPricePerKwhAtom
    );
    const [naturalGasPricePerCubicMetre, setNaturalGasPricePerCubicMetre] = useAtom(naturalGasPricePerCubicMetreAtom);
    if (electricityPricePerKwh == null || naturalGasPricePerCubicMetre == null) {
      return null;
    }
    return /* @__PURE__ */ import_react122.default.createElement(FormSectionView, { title: "Utility prices" }, /* @__PURE__ */ import_react122.default.createElement(FormRow, null, /* @__PURE__ */ import_react122.default.createElement(
      NumericFormInputView,
      {
        label: "Electricity",
        tooltip: /* @__PURE__ */ import_react122.default.createElement(Stack, null, /* @__PURE__ */ import_react122.default.createElement("p", null, "This assumes a single variable cost, without time-of-use pricing. The values here are based on provincial averages for 2023."), /* @__PURE__ */ import_react122.default.createElement("p", null, "Try changing this value to see how sensitive the lifetime costs are to utility rates.")),
        minValue: 0,
        maxValue: 100,
        step: 0.01,
        value: electricityPricePerKwh,
        setValue: setElectricityPricePerKwh,
        textAlign: "right",
        suffix: "$/kWh"
      }
    ), /* @__PURE__ */ import_react122.default.createElement(
      NumericFormInputView,
      {
        label: "Natural Gas",
        tooltip: /* @__PURE__ */ import_react122.default.createElement("p", null, 'This includes all variable costs (transport, delivery, carbon tax, etc.), but does not include the fixed monthly "Customer Charge". The values here are based on provincial averages for 2023.'),
        minValue: 0,
        maxValue: 100,
        step: 0.01,
        value: naturalGasPricePerCubicMetre,
        setValue: setNaturalGasPricePerCubicMetre,
        textAlign: "right",
        suffix: /* @__PURE__ */ import_react122.default.createElement(import_react122.default.Fragment, null, "$/m", /* @__PURE__ */ import_react122.default.createElement("sup", null, "3"))
      }
    )));
  };

  // src/app/views/thermostat-form-section-view.tsx
  var import_react124 = __toESM(require_react());
  var ThermostatFormSectionView = () => {
    const [heatingSetPointC, setHeatingSetPointC] = useAtom(heatingSetPointCAtom);
    const [coolingSetPointC, setCoolingSetPointC] = useAtom(coolingSetPointCAtom);
    return /* @__PURE__ */ import_react124.default.createElement(FormSectionView, { title: "Thermostat settings" }, /* @__PURE__ */ import_react124.default.createElement(FormRow, null, /* @__PURE__ */ import_react124.default.createElement(
      NumericFormInputView,
      {
        label: "Heat to\u2026",
        tooltip: /* @__PURE__ */ import_react124.default.createElement(Stack, null, /* @__PURE__ */ import_react124.default.createElement("p", null, `This is the "heating set point". When your home's temperature drops below this value by too much, your heating equipment (heatpump or furnace) will be turned on until the temperature is comfortably above this value.`), /* @__PURE__ */ import_react124.default.createElement("p", null, "Higher values will use more energy, costing you more money, and emitting more greenhouse gases.")),
        minValue: 0,
        maxValue: 40,
        step: 1,
        value: heatingSetPointC,
        setValue: setHeatingSetPointC,
        textAlign: "right",
        suffix: "\xB0C"
      }
    ), /* @__PURE__ */ import_react124.default.createElement(
      NumericFormInputView,
      {
        label: "Cool to\u2026",
        tooltip: /* @__PURE__ */ import_react124.default.createElement(Stack, null, /* @__PURE__ */ import_react124.default.createElement("p", null, `This is the "cooling set point". When your home's temperature rises past this value by too much, your cooling equipment (heatpump or air conditioner) will be turned on until the temperature is comfortably above this value.`), /* @__PURE__ */ import_react124.default.createElement("p", null, "Lower values will use more energy, costing you more money, and emitting more greenhouse gases.")),
        minValue: 0,
        maxValue: 40,
        step: 1,
        value: coolingSetPointC,
        setValue: setCoolingSetPointC,
        textAlign: "right",
        suffix: "\xB0C"
      }
    )));
  };

  // src/app/views/calculator-view.tsx
  var CalculatorView = () => {
    const statusQuoFurnaceFuel = useAtomValue(statusQuoFurnaceFuelAtom);
    const systemComparison = useAtomValue(systemComparisonAtom);
    const isLoading = systemComparison == null;
    const columns = useBreakpointValue(
      {
        base: 1,
        md: 2,
        lg: 3
      },
      { ssr: false }
    );
    let column1 = [];
    let column2 = [];
    if (isLoading) {
      column1.push(/* @__PURE__ */ import_react126.default.createElement(LoadingCardView, { height: 400 }));
      column2.push(/* @__PURE__ */ import_react126.default.createElement(LoadingCardView, { height: 300 }));
      column1.push(/* @__PURE__ */ import_react126.default.createElement(LoadingCardView, { height: 300 }));
      column2.push(/* @__PURE__ */ import_react126.default.createElement(LoadingCardView, { height: 200 }));
    } else {
      if (columns == null || columns < 3) {
        column2 = column1;
      }
      column1.push(/* @__PURE__ */ import_react126.default.createElement(LifetimeCostsCardView, { key: "life" }));
      column2.push(/* @__PURE__ */ import_react126.default.createElement(EmissionsReductionCardView, { key: "emissions" }));
      column1.push(/* @__PURE__ */ import_react126.default.createElement(UtilityBillsCardView, { key: "utility-bills" }));
      if (statusQuoFurnaceFuel === "gas") {
        column2.push(/* @__PURE__ */ import_react126.default.createElement(GasServiceFixedCostsCardView, { key: "gas-service" }));
      }
      column2.push(/* @__PURE__ */ import_react126.default.createElement(AboutThisCalculatorCardView, { key: "about" }));
    }
    let formSections = [
      /* @__PURE__ */ import_react126.default.createElement(FormSectionView, { title: "About your home", key: "about-your-home" }, /* @__PURE__ */ import_react126.default.createElement(FormRow, null, /* @__PURE__ */ import_react126.default.createElement(PostalCodeInput, null), /* @__PURE__ */ import_react126.default.createElement(FloorSpaceInput, null)), /* @__PURE__ */ import_react126.default.createElement(OtherGasAppliancesSelect, null)),
      /* @__PURE__ */ import_react126.default.createElement(EquipmentPurchaseAndInstallFormSectionView, { key: "equipment" })
    ];
    if (columns == null || columns > 1) {
      formSections.push(
        /* @__PURE__ */ import_react126.default.createElement(UtilityPricesFormSectionView, { key: "utilityprices" }),
        /* @__PURE__ */ import_react126.default.createElement(ThermostatFormSectionView, { key: "thermostat" })
      );
    }
    if (columns === 3) {
      return /* @__PURE__ */ import_react126.default.createElement(Flex, { direction: "row", w: "full" }, /* @__PURE__ */ import_react126.default.createElement(Flex, { direction: "column", h: "full", w: "400px", p: "20px", gap: "20px" }, /* @__PURE__ */ import_react126.default.createElement(Heading, { textAlign: "center" }, "Heat Pump Calculator \u{1F1E8}\u{1F1E6}"), formSections), /* @__PURE__ */ import_react126.default.createElement(CardColumnStackView, null, /* @__PURE__ */ import_react126.default.createElement(CardStackView, null, column1), /* @__PURE__ */ import_react126.default.createElement(CardStackView, null, column2)));
    } else if (columns === 2) {
      return /* @__PURE__ */ import_react126.default.createElement(Flex, { direction: "row", w: "full" }, /* @__PURE__ */ import_react126.default.createElement(Flex, { direction: "column", h: "full", w: "400px", p: "20px", gap: "20px" }, /* @__PURE__ */ import_react126.default.createElement(Heading, { textAlign: "center" }, "Heat Pump Calculator \u{1F1E8}\u{1F1E6}"), formSections), /* @__PURE__ */ import_react126.default.createElement(CardColumnStackView, null, /* @__PURE__ */ import_react126.default.createElement(CardStackView, null, column1)));
    } else {
      return /* @__PURE__ */ import_react126.default.createElement(VStack, { gap: "20px", w: "full" }, /* @__PURE__ */ import_react126.default.createElement(Heading, { textAlign: "center" }, "Heat Pump Calculator \u{1F1E8}\u{1F1E6}"), formSections, column1);
    }
  };

  // src/app/views/calculator-app-view.tsx
  var CalculatorAppView = () => {
    const welcomeFormHasBeenSubmit = useAtomValue(welcomeFormHasBeenSubmitAtom);
    return /* @__PURE__ */ import_react129.default.createElement(
      Container2,
      {
        maxW: "1600px",
        minH: "100vh",
        display: "flex",
        padding: { base: "10px", md: 0 }
      },
      welcomeFormHasBeenSubmit ? /* @__PURE__ */ import_react129.default.createElement(CalculatorView, null) : /* @__PURE__ */ import_react129.default.createElement(WelcomeScreenView, null)
    );
  };

  // node_modules/@sentry/utils/esm/is.js
  var objectToString = Object.prototype.toString;
  function isError(wat) {
    switch (objectToString.call(wat)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
        return true;
      default:
        return isInstanceOf(wat, Error);
    }
  }
  function isBuiltin(wat, className) {
    return objectToString.call(wat) === `[object ${className}]`;
  }
  function isErrorEvent(wat) {
    return isBuiltin(wat, "ErrorEvent");
  }
  function isDOMError(wat) {
    return isBuiltin(wat, "DOMError");
  }
  function isDOMException(wat) {
    return isBuiltin(wat, "DOMException");
  }
  function isString3(wat) {
    return isBuiltin(wat, "String");
  }
  function isParameterizedString(wat) {
    return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
  }
  function isPrimitive(wat) {
    return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
  }
  function isPlainObject(wat) {
    return isBuiltin(wat, "Object");
  }
  function isEvent2(wat) {
    return typeof Event !== "undefined" && isInstanceOf(wat, Event);
  }
  function isElement5(wat) {
    return typeof Element !== "undefined" && isInstanceOf(wat, Element);
  }
  function isRegExp(wat) {
    return isBuiltin(wat, "RegExp");
  }
  function isThenable(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  }
  function isSyntheticEvent(wat) {
    return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
  }
  function isNaN2(wat) {
    return typeof wat === "number" && wat !== wat;
  }
  function isInstanceOf(wat, base) {
    try {
      return wat instanceof base;
    } catch (_e3) {
      return false;
    }
  }
  function isVueViewModel(wat) {
    return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
  }

  // node_modules/@sentry/utils/esm/string.js
  function truncate(str, max2 = 0) {
    if (typeof str !== "string" || max2 === 0) {
      return str;
    }
    return str.length <= max2 ? str : `${str.slice(0, max2)}...`;
  }
  function safeJoin(input, delimiter2) {
    if (!Array.isArray(input)) {
      return "";
    }
    const output = [];
    for (let i = 0; i < input.length; i++) {
      const value = input[i];
      try {
        if (isVueViewModel(value)) {
          output.push("[VueViewModel]");
        } else {
          output.push(String(value));
        }
      } catch (e3) {
        output.push("[value cannot be serialized]");
      }
    }
    return output.join(delimiter2);
  }
  function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
    if (!isString3(value)) {
      return false;
    }
    if (isRegExp(pattern)) {
      return pattern.test(value);
    }
    if (isString3(pattern)) {
      return requireExactStringMatch ? value === pattern : value.includes(pattern);
    }
    return false;
  }
  function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
    return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
  }

  // node_modules/@sentry/utils/esm/aggregate-errors.js
  function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {
    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
      return;
    }
    const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
    if (originalException) {
      event.exception.values = truncateAggregateExceptions(
        aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          hint.originalException,
          key,
          event.exception.values,
          originalException,
          0
        ),
        maxValueLimit
      );
    }
  }
  function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error2, key, prevExceptions, exception, exceptionId) {
    if (prevExceptions.length >= limit + 1) {
      return prevExceptions;
    }
    let newExceptions = [...prevExceptions];
    if (isInstanceOf(error2[key], Error)) {
      applyExceptionGroupFieldsForParentException(exception, exceptionId);
      const newException = exceptionFromErrorImplementation(parser, error2[key]);
      const newExceptionId = newExceptions.length;
      applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
      newExceptions = aggregateExceptionsFromError(
        exceptionFromErrorImplementation,
        parser,
        limit,
        error2[key],
        key,
        [newException, ...newExceptions],
        newException,
        newExceptionId
      );
    }
    if (Array.isArray(error2.errors)) {
      error2.errors.forEach((childError, i) => {
        if (isInstanceOf(childError, Error)) {
          applyExceptionGroupFieldsForParentException(exception, exceptionId);
          const newException = exceptionFromErrorImplementation(parser, childError);
          const newExceptionId = newExceptions.length;
          applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);
          newExceptions = aggregateExceptionsFromError(
            exceptionFromErrorImplementation,
            parser,
            limit,
            childError,
            key,
            [newException, ...newExceptions],
            newException,
            newExceptionId
          );
        }
      });
    }
    return newExceptions;
  }
  function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
    exception.mechanism = exception.mechanism || { type: "generic", handled: true };
    exception.mechanism = {
      ...exception.mechanism,
      ...exception.type === "AggregateError" && { is_exception_group: true },
      exception_id: exceptionId
    };
  }
  function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
    exception.mechanism = exception.mechanism || { type: "generic", handled: true };
    exception.mechanism = {
      ...exception.mechanism,
      type: "chained",
      source,
      exception_id: exceptionId,
      parent_id: parentId
    };
  }
  function truncateAggregateExceptions(exceptions, maxValueLength) {
    return exceptions.map((exception) => {
      if (exception.value) {
        exception.value = truncate(exception.value, maxValueLength);
      }
      return exception;
    });
  }

  // node_modules/@sentry/utils/esm/worldwide.js
  function isGlobalObj(obj) {
    return obj && obj.Math == Math ? obj : void 0;
  }
  var GLOBAL_OBJ = typeof globalThis == "object" && isGlobalObj(globalThis) || // eslint-disable-next-line no-restricted-globals
  typeof window == "object" && isGlobalObj(window) || typeof self == "object" && isGlobalObj(self) || typeof global == "object" && isGlobalObj(global) || /* @__PURE__ */ function() {
    return this;
  }() || {};
  function getGlobalObject() {
    return GLOBAL_OBJ;
  }
  function getGlobalSingleton(name, creator, obj) {
    const gbl = obj || GLOBAL_OBJ;
    const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
    const singleton3 = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton3;
  }

  // node_modules/@sentry/utils/esm/browser.js
  var WINDOW = getGlobalObject();
  var DEFAULT_MAX_STRING_LENGTH = 80;
  function htmlTreeAsString(elem, options = {}) {
    if (!elem) {
      return "<unknown>";
    }
    try {
      let currentElem = elem;
      const MAX_TRAVERSE_HEIGHT = 5;
      const out = [];
      let height = 0;
      let len = 0;
      const separator = " > ";
      const sepLength = separator.length;
      let nextStr;
      const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
      const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
      while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
        nextStr = _htmlElementAsString(currentElem, keyAttrs);
        if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
          break;
        }
        out.push(nextStr);
        len += nextStr.length;
        currentElem = currentElem.parentNode;
      }
      return out.reverse().join(separator);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function _htmlElementAsString(el, keyAttrs) {
    const elem = el;
    const out = [];
    let className;
    let classes;
    let key;
    let attr;
    let i;
    if (!elem || !elem.tagName) {
      return "";
    }
    if (WINDOW.HTMLElement) {
      if (elem instanceof HTMLElement && elem.dataset && elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
    }
    out.push(elem.tagName.toLowerCase());
    const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
    if (keyAttrPairs && keyAttrPairs.length) {
      keyAttrPairs.forEach((keyAttrPair) => {
        out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
      });
    } else {
      if (elem.id) {
        out.push(`#${elem.id}`);
      }
      className = elem.className;
      if (className && isString3(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
          out.push(`.${classes[i]}`);
        }
      }
    }
    const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
    for (i = 0; i < allowedAttrs.length; i++) {
      key = allowedAttrs[i];
      attr = elem.getAttribute(key);
      if (attr) {
        out.push(`[${key}="${attr}"]`);
      }
    }
    return out.join("");
  }
  function getLocationHref() {
    try {
      return WINDOW.document.location.href;
    } catch (oO) {
      return "";
    }
  }
  function getDomElement(selector) {
    if (WINDOW.document && WINDOW.document.querySelector) {
      return WINDOW.document.querySelector(selector);
    }
    return null;
  }
  function getComponentName(elem) {
    if (!WINDOW.HTMLElement) {
      return null;
    }
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    for (let i = 0; i < MAX_TRAVERSE_HEIGHT; i++) {
      if (!currentElem) {
        return null;
      }
      if (currentElem instanceof HTMLElement && currentElem.dataset["sentryComponent"]) {
        return currentElem.dataset["sentryComponent"];
      }
      currentElem = currentElem.parentNode;
    }
    return null;
  }

  // node_modules/@sentry/utils/esm/debug-build.js
  var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

  // node_modules/@sentry/utils/esm/logger.js
  var PREFIX = "Sentry Logger ";
  var CONSOLE_LEVELS = [
    "debug",
    "info",
    "warn",
    "error",
    "log",
    "assert",
    "trace"
  ];
  var originalConsoleMethods = {};
  function consoleSandbox(callback) {
    if (!("console" in GLOBAL_OBJ)) {
      return callback();
    }
    const console2 = GLOBAL_OBJ.console;
    const wrappedFuncs = {};
    const wrappedLevels = Object.keys(originalConsoleMethods);
    wrappedLevels.forEach((level) => {
      const originalConsoleMethod = originalConsoleMethods[level];
      wrappedFuncs[level] = console2[level];
      console2[level] = originalConsoleMethod;
    });
    try {
      return callback();
    } finally {
      wrappedLevels.forEach((level) => {
        console2[level] = wrappedFuncs[level];
      });
    }
  }
  function makeLogger() {
    let enabled = false;
    const logger2 = {
      enable: () => {
        enabled = true;
      },
      disable: () => {
        enabled = false;
      },
      isEnabled: () => enabled
    };
    if (DEBUG_BUILD) {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = (...args) => {
          if (enabled) {
            consoleSandbox(() => {
              GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = () => void 0;
      });
    }
    return logger2;
  }
  var logger = makeLogger();

  // node_modules/@sentry/utils/esm/dsn.js
  var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
  function isValidProtocol(protocol) {
    return protocol === "http" || protocol === "https";
  }
  function dsnToString(dsn, withPassword = false) {
    const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
    return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
  }
  function dsnFromString(str) {
    const match3 = DSN_REGEX.exec(str);
    if (!match3) {
      consoleSandbox(() => {
        console.error(`Invalid Sentry Dsn: ${str}`);
      });
      return void 0;
    }
    const [protocol, publicKey, pass = "", host, port = "", lastPath] = match3.slice(1);
    let path = "";
    let projectId = lastPath;
    const split3 = projectId.split("/");
    if (split3.length > 1) {
      path = split3.slice(0, -1).join("/");
      projectId = split3.pop();
    }
    if (projectId) {
      const projectMatch = projectId.match(/^\d+/);
      if (projectMatch) {
        projectId = projectMatch[0];
      }
    }
    return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
  }
  function dsnFromComponents(components2) {
    return {
      protocol: components2.protocol,
      publicKey: components2.publicKey || "",
      pass: components2.pass || "",
      host: components2.host,
      port: components2.port || "",
      path: components2.path || "",
      projectId: components2.projectId
    };
  }
  function validateDsn(dsn) {
    if (!DEBUG_BUILD) {
      return true;
    }
    const { port, projectId, protocol } = dsn;
    const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
    const hasMissingRequiredComponent = requiredComponents.find((component) => {
      if (!dsn[component]) {
        logger.error(`Invalid Sentry Dsn: ${component} missing`);
        return true;
      }
      return false;
    });
    if (hasMissingRequiredComponent) {
      return false;
    }
    if (!projectId.match(/^\d+$/)) {
      logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
      return false;
    }
    if (!isValidProtocol(protocol)) {
      logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
      return false;
    }
    if (port && isNaN(parseInt(port, 10))) {
      logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
      return false;
    }
    return true;
  }
  function makeDsn(from2) {
    const components2 = typeof from2 === "string" ? dsnFromString(from2) : dsnFromComponents(from2);
    if (!components2 || !validateDsn(components2)) {
      return void 0;
    }
    return components2;
  }

  // node_modules/@sentry/utils/esm/error.js
  var SentryError = class extends Error {
    /** Display name of this error instance. */
    constructor(message, logLevel = "warn") {
      super(message);
      this.message = message;
      this.name = new.target.prototype.constructor.name;
      Object.setPrototypeOf(this, new.target.prototype);
      this.logLevel = logLevel;
    }
  };

  // node_modules/@sentry/utils/esm/object.js
  function fill(source, name, replacementFactory) {
    if (!(name in source)) {
      return;
    }
    const original = source[name];
    const wrapped = replacementFactory(original);
    if (typeof wrapped === "function") {
      markFunctionWrapped(wrapped, original);
    }
    source[name] = wrapped;
  }
  function addNonEnumerableProperty(obj, name, value) {
    try {
      Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value,
        writable: true,
        configurable: true
      });
    } catch (o_O) {
      DEBUG_BUILD && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
    }
  }
  function markFunctionWrapped(wrapped, original) {
    try {
      const proto = original.prototype || {};
      wrapped.prototype = original.prototype = proto;
      addNonEnumerableProperty(wrapped, "__sentry_original__", original);
    } catch (o_O) {
    }
  }
  function getOriginalFunction(func) {
    return func.__sentry_original__;
  }
  function urlEncode(object) {
    return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join("&");
  }
  function convertToPlainObject(value) {
    if (isError(value)) {
      return {
        message: value.message,
        name: value.name,
        stack: value.stack,
        ...getOwnProperties(value)
      };
    } else if (isEvent2(value)) {
      const newObj = {
        type: value.type,
        target: serializeEventTarget(value.target),
        currentTarget: serializeEventTarget(value.currentTarget),
        ...getOwnProperties(value)
      };
      if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
        newObj.detail = value.detail;
      }
      return newObj;
    } else {
      return value;
    }
  }
  function serializeEventTarget(target) {
    try {
      return isElement5(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function getOwnProperties(obj) {
    if (typeof obj === "object" && obj !== null) {
      const extractedProps = {};
      for (const property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
          extractedProps[property] = obj[property];
        }
      }
      return extractedProps;
    } else {
      return {};
    }
  }
  function extractExceptionKeysForMessage(exception, maxLength = 40) {
    const keys3 = Object.keys(convertToPlainObject(exception));
    keys3.sort();
    if (!keys3.length) {
      return "[object has no keys]";
    }
    if (keys3[0].length >= maxLength) {
      return truncate(keys3[0], maxLength);
    }
    for (let includedKeys = keys3.length; includedKeys > 0; includedKeys--) {
      const serialized = keys3.slice(0, includedKeys).join(", ");
      if (serialized.length > maxLength) {
        continue;
      }
      if (includedKeys === keys3.length) {
        return serialized;
      }
      return truncate(serialized, maxLength);
    }
    return "";
  }
  function dropUndefinedKeys(inputValue) {
    const memoizationMap = /* @__PURE__ */ new Map();
    return _dropUndefinedKeys(inputValue, memoizationMap);
  }
  function _dropUndefinedKeys(inputValue, memoizationMap) {
    if (isPojo(inputValue)) {
      const memoVal = memoizationMap.get(inputValue);
      if (memoVal !== void 0) {
        return memoVal;
      }
      const returnValue = {};
      memoizationMap.set(inputValue, returnValue);
      for (const key of Object.keys(inputValue)) {
        if (typeof inputValue[key] !== "undefined") {
          returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
        }
      }
      return returnValue;
    }
    if (Array.isArray(inputValue)) {
      const memoVal = memoizationMap.get(inputValue);
      if (memoVal !== void 0) {
        return memoVal;
      }
      const returnValue = [];
      memoizationMap.set(inputValue, returnValue);
      inputValue.forEach((item) => {
        returnValue.push(_dropUndefinedKeys(item, memoizationMap));
      });
      return returnValue;
    }
    return inputValue;
  }
  function isPojo(input) {
    if (!isPlainObject(input)) {
      return false;
    }
    try {
      const name = Object.getPrototypeOf(input).constructor.name;
      return !name || name === "Object";
    } catch (e3) {
      return true;
    }
  }

  // node_modules/@sentry/utils/esm/stacktrace.js
  var STACKTRACE_FRAME_LIMIT = 50;
  var WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
  var STRIP_FRAME_REGEXP = /captureMessage|captureException/;
  function createStackParser(...parsers) {
    const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map((p) => p[1]);
    return (stack, skipFirst = 0) => {
      const frames = [];
      const lines = stack.split("\n");
      for (let i = skipFirst; i < lines.length; i++) {
        const line3 = lines[i];
        if (line3.length > 1024) {
          continue;
        }
        const cleanedLine = WEBPACK_ERROR_REGEXP.test(line3) ? line3.replace(WEBPACK_ERROR_REGEXP, "$1") : line3;
        if (cleanedLine.match(/\S*Error: /)) {
          continue;
        }
        for (const parser of sortedParsers) {
          const frame2 = parser(cleanedLine);
          if (frame2) {
            frames.push(frame2);
            break;
          }
        }
        if (frames.length >= STACKTRACE_FRAME_LIMIT) {
          break;
        }
      }
      return stripSentryFramesAndReverse(frames);
    };
  }
  function stackParserFromStackParserOptions(stackParser) {
    if (Array.isArray(stackParser)) {
      return createStackParser(...stackParser);
    }
    return stackParser;
  }
  function stripSentryFramesAndReverse(stack) {
    if (!stack.length) {
      return [];
    }
    const localStack = Array.from(stack);
    if (/sentryWrapped/.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
    }
    localStack.reverse();
    if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
      if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
        localStack.pop();
      }
    }
    return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame2) => ({
      ...frame2,
      filename: frame2.filename || localStack[localStack.length - 1].filename,
      function: frame2.function || "?"
    }));
  }
  var defaultFunctionName = "<anonymous>";
  function getFunctionName(fn2) {
    try {
      if (!fn2 || typeof fn2 !== "function") {
        return defaultFunctionName;
      }
      return fn2.name || defaultFunctionName;
    } catch (e3) {
      return defaultFunctionName;
    }
  }

  // node_modules/@sentry/utils/esm/instrument/_handlers.js
  var handlers = {};
  var instrumented = {};
  function addHandler(type, handler) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(handler);
  }
  function maybeInstrument(type, instrumentFn) {
    if (!instrumented[type]) {
      instrumentFn();
      instrumented[type] = true;
    }
  }
  function triggerHandlers(type, data) {
    const typeHandlers = type && handlers[type];
    if (!typeHandlers) {
      return;
    }
    for (const handler of typeHandlers) {
      try {
        handler(data);
      } catch (e3) {
        DEBUG_BUILD && logger.error(
          `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
          e3
        );
      }
    }
  }

  // node_modules/@sentry/utils/esm/instrument/console.js
  function addConsoleInstrumentationHandler(handler) {
    const type = "console";
    addHandler(type, handler);
    maybeInstrument(type, instrumentConsole);
  }
  function instrumentConsole() {
    if (!("console" in GLOBAL_OBJ)) {
      return;
    }
    CONSOLE_LEVELS.forEach(function(level) {
      if (!(level in GLOBAL_OBJ.console)) {
        return;
      }
      fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
        originalConsoleMethods[level] = originalConsoleMethod;
        return function(...args) {
          const handlerData = { args, level };
          triggerHandlers("console", handlerData);
          const log = originalConsoleMethods[level];
          log && log.apply(GLOBAL_OBJ.console, args);
        };
      });
    });
  }

  // node_modules/@sentry/utils/esm/misc.js
  function uuid4() {
    const gbl = GLOBAL_OBJ;
    const crypto = gbl.crypto || gbl.msCrypto;
    let getRandomByte = () => Math.random() * 16;
    try {
      if (crypto && crypto.randomUUID) {
        return crypto.randomUUID().replace(/-/g, "");
      }
      if (crypto && crypto.getRandomValues) {
        getRandomByte = () => {
          const typedArray = new Uint8Array(1);
          crypto.getRandomValues(typedArray);
          return typedArray[0];
        };
      }
    } catch (_) {
    }
    return ("10000000100040008000" + 1e11).replace(
      /[018]/g,
      (c) => (
        // eslint-disable-next-line no-bitwise
        (c ^ (getRandomByte() & 15) >> c / 4).toString(16)
      )
    );
  }
  function getFirstException(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : void 0;
  }
  function getEventDescription(event) {
    const { message, event_id: eventId } = event;
    if (message) {
      return message;
    }
    const firstException = getFirstException(event);
    if (firstException) {
      if (firstException.type && firstException.value) {
        return `${firstException.type}: ${firstException.value}`;
      }
      return firstException.type || firstException.value || eventId || "<unknown>";
    }
    return eventId || "<unknown>";
  }
  function addExceptionTypeValue(event, value, type) {
    const exception = event.exception = event.exception || {};
    const values = exception.values = exception.values || [];
    const firstException = values[0] = values[0] || {};
    if (!firstException.value) {
      firstException.value = value || "";
    }
    if (!firstException.type) {
      firstException.type = type || "Error";
    }
  }
  function addExceptionMechanism(event, newMechanism) {
    const firstException = getFirstException(event);
    if (!firstException) {
      return;
    }
    const defaultMechanism = { type: "generic", handled: true };
    const currentMechanism = firstException.mechanism;
    firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
    if (newMechanism && "data" in newMechanism) {
      const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
      firstException.mechanism.data = mergedData;
    }
  }
  function checkOrSetAlreadyCaught(exception) {
    if (exception && exception.__sentry_captured__) {
      return true;
    }
    try {
      addNonEnumerableProperty(exception, "__sentry_captured__", true);
    } catch (err) {
    }
    return false;
  }
  function arrayify(maybeArray2) {
    return Array.isArray(maybeArray2) ? maybeArray2 : [maybeArray2];
  }

  // node_modules/@sentry/utils/esm/instrument/dom.js
  var WINDOW2 = GLOBAL_OBJ;
  var DEBOUNCE_DURATION = 1e3;
  var debounceTimerID;
  var lastCapturedEventType;
  var lastCapturedEventTargetId;
  function addClickKeypressInstrumentationHandler(handler) {
    const type = "dom";
    addHandler(type, handler);
    maybeInstrument(type, instrumentDOM);
  }
  function instrumentDOM() {
    if (!WINDOW2.document) {
      return;
    }
    const triggerDOMHandler = triggerHandlers.bind(null, "dom");
    const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    WINDOW2.document.addEventListener("click", globalDOMEventHandler, false);
    WINDOW2.document.addEventListener("keypress", globalDOMEventHandler, false);
    ["EventTarget", "Node"].forEach((target) => {
      const proto = WINDOW2[target] && WINDOW2[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      fill(proto, "addEventListener", function(originalAddEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              const el = this;
              const handlers4 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers4[type] = handlers4[type] || { refCount: 0 };
              if (!handlerForType.handler) {
                const handler = makeDOMEventHandler(triggerDOMHandler);
                handlerForType.handler = handler;
                originalAddEventListener.call(this, type, handler, options);
              }
              handlerForType.refCount++;
            } catch (e3) {
            }
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
      });
      fill(
        proto,
        "removeEventListener",
        function(originalRemoveEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                const el = this;
                const handlers4 = el.__sentry_instrumentation_handlers__ || {};
                const handlerForType = handlers4[type];
                if (handlerForType) {
                  handlerForType.refCount--;
                  if (handlerForType.refCount <= 0) {
                    originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                    handlerForType.handler = void 0;
                    delete handlers4[type];
                  }
                  if (Object.keys(handlers4).length === 0) {
                    delete el.__sentry_instrumentation_handlers__;
                  }
                }
              } catch (e3) {
              }
            }
            return originalRemoveEventListener.call(this, type, listener, options);
          };
        }
      );
    });
  }
  function isSimilarToLastCapturedEvent(event) {
    if (event.type !== lastCapturedEventType) {
      return false;
    }
    try {
      if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
        return false;
      }
    } catch (e3) {
    }
    return true;
  }
  function shouldSkipDOMEvent(eventType, target) {
    if (eventType !== "keypress") {
      return false;
    }
    if (!target || !target.tagName) {
      return true;
    }
    if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
      return false;
    }
    return true;
  }
  function makeDOMEventHandler(handler, globalListener = false) {
    return (event) => {
      if (!event || event["_sentryCaptured"]) {
        return;
      }
      const target = getEventTarget(event);
      if (shouldSkipDOMEvent(event.type, target)) {
        return;
      }
      addNonEnumerableProperty(event, "_sentryCaptured", true);
      if (target && !target._sentryId) {
        addNonEnumerableProperty(target, "_sentryId", uuid4());
      }
      const name = event.type === "keypress" ? "input" : event.type;
      if (!isSimilarToLastCapturedEvent(event)) {
        const handlerData = { event, name, global: globalListener };
        handler(handlerData);
        lastCapturedEventType = event.type;
        lastCapturedEventTargetId = target ? target._sentryId : void 0;
      }
      clearTimeout(debounceTimerID);
      debounceTimerID = WINDOW2.setTimeout(() => {
        lastCapturedEventTargetId = void 0;
        lastCapturedEventType = void 0;
      }, DEBOUNCE_DURATION);
    };
  }
  function getEventTarget(event) {
    try {
      return event.target;
    } catch (e3) {
      return null;
    }
  }

  // node_modules/@sentry/utils/esm/supports.js
  var WINDOW3 = getGlobalObject();
  function supportsFetch() {
    if (!("fetch" in WINDOW3)) {
      return false;
    }
    try {
      new Headers();
      new Request("http://www.example.com");
      new Response();
      return true;
    } catch (e3) {
      return false;
    }
  }
  function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
  }
  function supportsNativeFetch() {
    if (typeof EdgeRuntime === "string") {
      return true;
    }
    if (!supportsFetch()) {
      return false;
    }
    if (isNativeFetch(WINDOW3.fetch)) {
      return true;
    }
    let result = false;
    const doc = WINDOW3.document;
    if (doc && typeof doc.createElement === "function") {
      try {
        const sandbox = doc.createElement("iframe");
        sandbox.hidden = true;
        doc.head.appendChild(sandbox);
        if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
          result = isNativeFetch(sandbox.contentWindow.fetch);
        }
        doc.head.removeChild(sandbox);
      } catch (err) {
        DEBUG_BUILD && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
      }
    }
    return result;
  }

  // node_modules/@sentry/utils/esm/instrument/fetch.js
  function addFetchInstrumentationHandler(handler) {
    const type = "fetch";
    addHandler(type, handler);
    maybeInstrument(type, instrumentFetch);
  }
  function instrumentFetch() {
    if (!supportsNativeFetch()) {
      return;
    }
    fill(GLOBAL_OBJ, "fetch", function(originalFetch) {
      return function(...args) {
        const { method, url } = parseFetchArgs(args);
        const handlerData = {
          args,
          fetchData: {
            method,
            url
          },
          startTimestamp: Date.now()
        };
        triggerHandlers("fetch", {
          ...handlerData
        });
        return originalFetch.apply(GLOBAL_OBJ, args).then(
          (response) => {
            const finishedHandlerData = {
              ...handlerData,
              endTimestamp: Date.now(),
              response
            };
            triggerHandlers("fetch", finishedHandlerData);
            return response;
          },
          (error2) => {
            const erroredHandlerData = {
              ...handlerData,
              endTimestamp: Date.now(),
              error: error2
            };
            triggerHandlers("fetch", erroredHandlerData);
            throw error2;
          }
        );
      };
    });
  }
  function hasProp(obj, prop) {
    return !!obj && typeof obj === "object" && !!obj[prop];
  }
  function getUrlFromResource(resource) {
    if (typeof resource === "string") {
      return resource;
    }
    if (!resource) {
      return "";
    }
    if (hasProp(resource, "url")) {
      return resource.url;
    }
    if (resource.toString) {
      return resource.toString();
    }
    return "";
  }
  function parseFetchArgs(fetchArgs) {
    if (fetchArgs.length === 0) {
      return { method: "GET", url: "" };
    }
    if (fetchArgs.length === 2) {
      const [url, options] = fetchArgs;
      return {
        url: getUrlFromResource(url),
        method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
      };
    }
    const arg = fetchArgs[0];
    return {
      url: getUrlFromResource(arg),
      method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
    };
  }

  // node_modules/@sentry/utils/esm/instrument/globalError.js
  var _oldOnErrorHandler = null;
  function addGlobalErrorInstrumentationHandler(handler) {
    const type = "error";
    addHandler(type, handler);
    maybeInstrument(type, instrumentError);
  }
  function instrumentError() {
    _oldOnErrorHandler = GLOBAL_OBJ.onerror;
    GLOBAL_OBJ.onerror = function(msg, url, line3, column2, error2) {
      const handlerData = {
        column: column2,
        error: error2,
        line: line3,
        msg,
        url
      };
      triggerHandlers("error", handlerData);
      if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
        return _oldOnErrorHandler.apply(this, arguments);
      }
      return false;
    };
    GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
  }

  // node_modules/@sentry/utils/esm/instrument/globalUnhandledRejection.js
  var _oldOnUnhandledRejectionHandler = null;
  function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
    const type = "unhandledrejection";
    addHandler(type, handler);
    maybeInstrument(type, instrumentUnhandledRejection);
  }
  function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
    GLOBAL_OBJ.onunhandledrejection = function(e3) {
      const handlerData = e3;
      triggerHandlers("unhandledrejection", handlerData);
      if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
        return _oldOnUnhandledRejectionHandler.apply(this, arguments);
      }
      return true;
    };
    GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
  }

  // node_modules/@sentry/utils/esm/vendor/supportsHistory.js
  var WINDOW4 = getGlobalObject();
  function supportsHistory() {
    const chromeVar = WINDOW4.chrome;
    const isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime;
    const hasHistoryApi = "history" in WINDOW4 && !!WINDOW4.history.pushState && !!WINDOW4.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
  }

  // node_modules/@sentry/utils/esm/instrument/history.js
  var WINDOW5 = GLOBAL_OBJ;
  var lastHref;
  function addHistoryInstrumentationHandler(handler) {
    const type = "history";
    addHandler(type, handler);
    maybeInstrument(type, instrumentHistory);
  }
  function instrumentHistory() {
    if (!supportsHistory()) {
      return;
    }
    const oldOnPopState = WINDOW5.onpopstate;
    WINDOW5.onpopstate = function(...args) {
      const to = WINDOW5.location.href;
      const from2 = lastHref;
      lastHref = to;
      const handlerData = { from: from2, to };
      triggerHandlers("history", handlerData);
      if (oldOnPopState) {
        try {
          return oldOnPopState.apply(this, args);
        } catch (_oO) {
        }
      }
    };
    function historyReplacementFunction(originalHistoryFunction) {
      return function(...args) {
        const url = args.length > 2 ? args[2] : void 0;
        if (url) {
          const from2 = lastHref;
          const to = String(url);
          lastHref = to;
          const handlerData = { from: from2, to };
          triggerHandlers("history", handlerData);
        }
        return originalHistoryFunction.apply(this, args);
      };
    }
    fill(WINDOW5.history, "pushState", historyReplacementFunction);
    fill(WINDOW5.history, "replaceState", historyReplacementFunction);
  }

  // node_modules/@sentry/utils/esm/instrument/xhr.js
  var WINDOW6 = GLOBAL_OBJ;
  var SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
  function addXhrInstrumentationHandler(handler) {
    const type = "xhr";
    addHandler(type, handler);
    maybeInstrument(type, instrumentXHR);
  }
  function instrumentXHR() {
    if (!WINDOW6.XMLHttpRequest) {
      return;
    }
    const xhrproto = XMLHttpRequest.prototype;
    fill(xhrproto, "open", function(originalOpen) {
      return function(...args) {
        const startTimestamp = Date.now();
        const method = isString3(args[0]) ? args[0].toUpperCase() : void 0;
        const url = parseUrl(args[1]);
        if (!method || !url) {
          return originalOpen.apply(this, args);
        }
        this[SENTRY_XHR_DATA_KEY] = {
          method,
          url,
          request_headers: {}
        };
        if (method === "POST" && url.match(/sentry_key/)) {
          this.__sentry_own_request__ = true;
        }
        const onreadystatechangeHandler = () => {
          const xhrInfo = this[SENTRY_XHR_DATA_KEY];
          if (!xhrInfo) {
            return;
          }
          if (this.readyState === 4) {
            try {
              xhrInfo.status_code = this.status;
            } catch (e3) {
            }
            const handlerData = {
              args: [method, url],
              endTimestamp: Date.now(),
              startTimestamp,
              xhr: this
            };
            triggerHandlers("xhr", handlerData);
          }
        };
        if ("onreadystatechange" in this && typeof this.onreadystatechange === "function") {
          fill(this, "onreadystatechange", function(original) {
            return function(...readyStateArgs) {
              onreadystatechangeHandler();
              return original.apply(this, readyStateArgs);
            };
          });
        } else {
          this.addEventListener("readystatechange", onreadystatechangeHandler);
        }
        fill(this, "setRequestHeader", function(original) {
          return function(...setRequestHeaderArgs) {
            const [header, value] = setRequestHeaderArgs;
            const xhrInfo = this[SENTRY_XHR_DATA_KEY];
            if (xhrInfo && isString3(header) && isString3(value)) {
              xhrInfo.request_headers[header.toLowerCase()] = value;
            }
            return original.apply(this, setRequestHeaderArgs);
          };
        });
        return originalOpen.apply(this, args);
      };
    });
    fill(xhrproto, "send", function(originalSend) {
      return function(...args) {
        const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
        if (!sentryXhrData) {
          return originalSend.apply(this, args);
        }
        if (args[0] !== void 0) {
          sentryXhrData.body = args[0];
        }
        const handlerData = {
          args: [sentryXhrData.method, sentryXhrData.url],
          startTimestamp: Date.now(),
          xhr: this
        };
        triggerHandlers("xhr", handlerData);
        return originalSend.apply(this, args);
      };
    });
  }
  function parseUrl(url) {
    if (isString3(url)) {
      return url;
    }
    try {
      return url.toString();
    } catch (e22) {
    }
    return void 0;
  }

  // node_modules/@sentry/utils/esm/env.js
  function isBrowserBundle() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
  }
  function getSDKSource() {
    return "npm";
  }

  // node_modules/@sentry/utils/esm/node.js
  function isNodeEnv() {
    return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  }

  // node_modules/@sentry/utils/esm/isBrowser.js
  function isBrowser5() {
    return typeof window !== "undefined" && (!isNodeEnv() || isElectronNodeRenderer());
  }
  function isElectronNodeRenderer() {
    return (
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
      GLOBAL_OBJ.process !== void 0 && GLOBAL_OBJ.process.type === "renderer"
    );
  }

  // node_modules/@sentry/utils/esm/memo.js
  function memoBuilder() {
    const hasWeakSet = typeof WeakSet === "function";
    const inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
    function memoize5(obj) {
      if (hasWeakSet) {
        if (inner.has(obj)) {
          return true;
        }
        inner.add(obj);
        return false;
      }
      for (let i = 0; i < inner.length; i++) {
        const value = inner[i];
        if (value === obj) {
          return true;
        }
      }
      inner.push(obj);
      return false;
    }
    function unmemoize(obj) {
      if (hasWeakSet) {
        inner.delete(obj);
      } else {
        for (let i = 0; i < inner.length; i++) {
          if (inner[i] === obj) {
            inner.splice(i, 1);
            break;
          }
        }
      }
    }
    return [memoize5, unmemoize];
  }

  // node_modules/@sentry/utils/esm/normalize.js
  function normalize4(input, depth = 100, maxProperties = Infinity) {
    try {
      return visit("", input, depth, maxProperties);
    } catch (err) {
      return { ERROR: `**non-serializable** (${err})` };
    }
  }
  function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
    const normalized = normalize4(object, depth);
    if (jsonSize(normalized) > maxSize) {
      return normalizeToSize(object, depth - 1, maxSize);
    }
    return normalized;
  }
  function visit(key, value, depth = Infinity, maxProperties = Infinity, memo3 = memoBuilder()) {
    const [memoize5, unmemoize] = memo3;
    if (value == null || // this matches null and undefined -> eqeq not eqeqeq
    ["number", "boolean", "string"].includes(typeof value) && !isNaN2(value)) {
      return value;
    }
    const stringified = stringifyValue(key, value);
    if (!stringified.startsWith("[object ")) {
      return stringified;
    }
    if (value["__sentry_skip_normalization__"]) {
      return value;
    }
    const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
    if (remainingDepth === 0) {
      return stringified.replace("object ", "");
    }
    if (memoize5(value)) {
      return "[Circular ~]";
    }
    const valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
      try {
        const jsonValue = valueWithToJSON.toJSON();
        return visit("", jsonValue, remainingDepth - 1, maxProperties, memo3);
      } catch (err) {
      }
    }
    const normalized = Array.isArray(value) ? [] : {};
    let numAdded = 0;
    const visitable = convertToPlainObject(value);
    for (const visitKey in visitable) {
      if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
        continue;
      }
      if (numAdded >= maxProperties) {
        normalized[visitKey] = "[MaxProperties ~]";
        break;
      }
      const visitValue = visitable[visitKey];
      normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo3);
      numAdded++;
    }
    unmemoize(value);
    return normalized;
  }
  function stringifyValue(key, value) {
    try {
      if (key === "domain" && value && typeof value === "object" && value._events) {
        return "[Domain]";
      }
      if (key === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && value === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && value === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && value === document) {
        return "[Document]";
      }
      if (isVueViewModel(value)) {
        return "[VueViewModel]";
      }
      if (isSyntheticEvent(value)) {
        return "[SyntheticEvent]";
      }
      if (typeof value === "number" && value !== value) {
        return "[NaN]";
      }
      if (typeof value === "function") {
        return `[Function: ${getFunctionName(value)}]`;
      }
      if (typeof value === "symbol") {
        return `[${String(value)}]`;
      }
      if (typeof value === "bigint") {
        return `[BigInt: ${String(value)}]`;
      }
      const objName = getConstructorName(value);
      if (/^HTML(\w*)Element$/.test(objName)) {
        return `[HTMLElement: ${objName}]`;
      }
      return `[object ${objName}]`;
    } catch (err) {
      return `**non-serializable** (${err})`;
    }
  }
  function getConstructorName(value) {
    const prototype = Object.getPrototypeOf(value);
    return prototype ? prototype.constructor.name : "null prototype";
  }
  function utf8Length(value) {
    return ~-encodeURI(value).split(/%..|./).length;
  }
  function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
  }

  // node_modules/@sentry/utils/esm/syncpromise.js
  var States;
  (function(States2) {
    const PENDING = 0;
    States2[States2["PENDING"] = PENDING] = "PENDING";
    const RESOLVED = 1;
    States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
    const REJECTED = 2;
    States2[States2["REJECTED"] = REJECTED] = "REJECTED";
  })(States || (States = {}));
  function resolvedSyncPromise(value) {
    return new SyncPromise((resolve) => {
      resolve(value);
    });
  }
  function rejectedSyncPromise(reason) {
    return new SyncPromise((_, reject) => {
      reject(reason);
    });
  }
  var SyncPromise = class _SyncPromise {
    constructor(executor) {
      _SyncPromise.prototype.__init.call(this);
      _SyncPromise.prototype.__init2.call(this);
      _SyncPromise.prototype.__init3.call(this);
      _SyncPromise.prototype.__init4.call(this);
      this._state = States.PENDING;
      this._handlers = [];
      try {
        executor(this._resolve, this._reject);
      } catch (e3) {
        this._reject(e3);
      }
    }
    /** JSDoc */
    then(onfulfilled, onrejected) {
      return new _SyncPromise((resolve, reject) => {
        this._handlers.push([
          false,
          (result) => {
            if (!onfulfilled) {
              resolve(result);
            } else {
              try {
                resolve(onfulfilled(result));
              } catch (e3) {
                reject(e3);
              }
            }
          },
          (reason) => {
            if (!onrejected) {
              reject(reason);
            } else {
              try {
                resolve(onrejected(reason));
              } catch (e3) {
                reject(e3);
              }
            }
          }
        ]);
        this._executeHandlers();
      });
    }
    /** JSDoc */
    catch(onrejected) {
      return this.then((val) => val, onrejected);
    }
    /** JSDoc */
    finally(onfinally) {
      return new _SyncPromise((resolve, reject) => {
        let val;
        let isRejected;
        return this.then(
          (value) => {
            isRejected = false;
            val = value;
            if (onfinally) {
              onfinally();
            }
          },
          (reason) => {
            isRejected = true;
            val = reason;
            if (onfinally) {
              onfinally();
            }
          }
        ).then(() => {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve(val);
        });
      });
    }
    /** JSDoc */
    __init() {
      this._resolve = (value) => {
        this._setResult(States.RESOLVED, value);
      };
    }
    /** JSDoc */
    __init2() {
      this._reject = (reason) => {
        this._setResult(States.REJECTED, reason);
      };
    }
    /** JSDoc */
    __init3() {
      this._setResult = (state2, value) => {
        if (this._state !== States.PENDING) {
          return;
        }
        if (isThenable(value)) {
          void value.then(this._resolve, this._reject);
          return;
        }
        this._state = state2;
        this._value = value;
        this._executeHandlers();
      };
    }
    /** JSDoc */
    __init4() {
      this._executeHandlers = () => {
        if (this._state === States.PENDING) {
          return;
        }
        const cachedHandlers = this._handlers.slice();
        this._handlers = [];
        cachedHandlers.forEach((handler) => {
          if (handler[0]) {
            return;
          }
          if (this._state === States.RESOLVED) {
            handler[1](this._value);
          }
          if (this._state === States.REJECTED) {
            handler[2](this._value);
          }
          handler[0] = true;
        });
      };
    }
  };

  // node_modules/@sentry/utils/esm/promisebuffer.js
  function makePromiseBuffer(limit) {
    const buffer = [];
    function isReady() {
      return limit === void 0 || buffer.length < limit;
    }
    function remove(task) {
      return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    function add3(taskProducer) {
      if (!isReady()) {
        return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
      }
      const task = taskProducer();
      if (buffer.indexOf(task) === -1) {
        buffer.push(task);
      }
      void task.then(() => remove(task)).then(
        null,
        () => remove(task).then(null, () => {
        })
      );
      return task;
    }
    function drain(timeout) {
      return new SyncPromise((resolve, reject) => {
        let counter2 = buffer.length;
        if (!counter2) {
          return resolve(true);
        }
        const capturedSetTimeout = setTimeout(() => {
          if (timeout && timeout > 0) {
            resolve(false);
          }
        }, timeout);
        buffer.forEach((item) => {
          void resolvedSyncPromise(item).then(() => {
            if (!--counter2) {
              clearTimeout(capturedSetTimeout);
              resolve(true);
            }
          }, reject);
        });
      });
    }
    return {
      $: buffer,
      add: add3,
      drain
    };
  }

  // node_modules/@sentry/utils/esm/url.js
  function parseUrl2(url) {
    if (!url) {
      return {};
    }
    const match3 = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match3) {
      return {};
    }
    const query = match3[6] || "";
    const fragment = match3[8] || "";
    return {
      host: match3[4],
      path: match3[5],
      protocol: match3[2],
      search: query,
      hash: fragment,
      relative: match3[5] + query + fragment
      // everything minus origin
    };
  }

  // node_modules/@sentry/utils/esm/severity.js
  var validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
  function severityLevelFromString(level) {
    return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
  }

  // node_modules/@sentry/utils/esm/time.js
  var ONE_SECOND_IN_MS = 1e3;
  function dateTimestampInSeconds() {
    return Date.now() / ONE_SECOND_IN_MS;
  }
  function createUnixTimestampInSecondsFunc() {
    const { performance: performance2 } = GLOBAL_OBJ;
    if (!performance2 || !performance2.now) {
      return dateTimestampInSeconds;
    }
    const approxStartingTimeOrigin = Date.now() - performance2.now();
    const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
    return () => {
      return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
    };
  }
  var timestampInSeconds = createUnixTimestampInSecondsFunc();
  var _browserPerformanceTimeOriginMode;
  var browserPerformanceTimeOrigin = (() => {
    const { performance: performance2 } = GLOBAL_OBJ;
    if (!performance2 || !performance2.now) {
      _browserPerformanceTimeOriginMode = "none";
      return void 0;
    }
    const threshold = 3600 * 1e3;
    const performanceNow = performance2.now();
    const dateNow = Date.now();
    const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
    const timeOriginIsReliable = timeOriginDelta < threshold;
    const navigationStart = performance2.timing && performance2.timing.navigationStart;
    const hasNavigationStart = typeof navigationStart === "number";
    const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    const navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
      if (timeOriginDelta <= navigationStartDelta) {
        _browserPerformanceTimeOriginMode = "timeOrigin";
        return performance2.timeOrigin;
      } else {
        _browserPerformanceTimeOriginMode = "navigationStart";
        return navigationStart;
      }
    }
    _browserPerformanceTimeOriginMode = "dateNow";
    return dateNow;
  })();

  // node_modules/@sentry/utils/esm/baggage.js
  var BAGGAGE_HEADER_NAME = "baggage";
  var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
  var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
  var MAX_BAGGAGE_STRING_LENGTH = 8192;
  function baggageHeaderToDynamicSamplingContext(baggageHeader) {
    if (!isString3(baggageHeader) && !Array.isArray(baggageHeader)) {
      return void 0;
    }
    let baggageObject = {};
    if (Array.isArray(baggageHeader)) {
      baggageObject = baggageHeader.reduce((acc, curr) => {
        const currBaggageObject = baggageHeaderToObject(curr);
        for (const key of Object.keys(currBaggageObject)) {
          acc[key] = currBaggageObject[key];
        }
        return acc;
      }, {});
    } else {
      if (!baggageHeader) {
        return void 0;
      }
      baggageObject = baggageHeaderToObject(baggageHeader);
    }
    const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
      if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
        const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
        acc[nonPrefixedKey] = value;
      }
      return acc;
    }, {});
    if (Object.keys(dynamicSamplingContext).length > 0) {
      return dynamicSamplingContext;
    } else {
      return void 0;
    }
  }
  function dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext) {
    if (!dynamicSamplingContext) {
      return void 0;
    }
    const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(
      (acc, [dscKey, dscValue]) => {
        if (dscValue) {
          acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;
        }
        return acc;
      },
      {}
    );
    return objectToBaggageHeader(sentryPrefixedDSC);
  }
  function baggageHeaderToObject(baggageHeader) {
    return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {});
  }
  function objectToBaggageHeader(object) {
    if (Object.keys(object).length === 0) {
      return void 0;
    }
    return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {
      const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;
      const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;
      if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {
        DEBUG_BUILD && logger.warn(
          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`
        );
        return baggageHeader;
      } else {
        return newBaggageHeader;
      }
    }, "");
  }

  // node_modules/@sentry/utils/esm/tracing.js
  var TRACEPARENT_REGEXP = new RegExp(
    "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
    // whitespace
  );
  function extractTraceparentData(traceparent) {
    if (!traceparent) {
      return void 0;
    }
    const matches = traceparent.match(TRACEPARENT_REGEXP);
    if (!matches) {
      return void 0;
    }
    let parentSampled;
    if (matches[3] === "1") {
      parentSampled = true;
    } else if (matches[3] === "0") {
      parentSampled = false;
    }
    return {
      traceId: matches[1],
      parentSampled,
      parentSpanId: matches[2]
    };
  }
  function propagationContextFromHeaders(sentryTrace, baggage) {
    const traceparentData = extractTraceparentData(sentryTrace);
    const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);
    const { traceId, parentSpanId, parentSampled } = traceparentData || {};
    if (!traceparentData) {
      return {
        traceId: traceId || uuid4(),
        spanId: uuid4().substring(16)
      };
    } else {
      return {
        traceId: traceId || uuid4(),
        parentSpanId: parentSpanId || uuid4().substring(16),
        spanId: uuid4().substring(16),
        sampled: parentSampled,
        dsc: dynamicSamplingContext || {}
        // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
      };
    }
  }
  function generateSentryTraceHeader(traceId = uuid4(), spanId = uuid4().substring(16), sampled) {
    let sampledString = "";
    if (sampled !== void 0) {
      sampledString = sampled ? "-1" : "-0";
    }
    return `${traceId}-${spanId}${sampledString}`;
  }

  // node_modules/@sentry/utils/esm/envelope.js
  function createEnvelope(headers, items = []) {
    return [headers, items];
  }
  function addItemToEnvelope(envelope, newItem) {
    const [headers, items] = envelope;
    return [headers, [...items, newItem]];
  }
  function forEachEnvelopeItem(envelope, callback) {
    const envelopeItems = envelope[1];
    for (const envelopeItem of envelopeItems) {
      const envelopeItemType = envelopeItem[0].type;
      const result = callback(envelopeItem, envelopeItemType);
      if (result) {
        return true;
      }
    }
    return false;
  }
  function encodeUTF8(input, textEncoder) {
    const utf8 = textEncoder || new TextEncoder();
    return utf8.encode(input);
  }
  function serializeEnvelope(envelope, textEncoder) {
    const [envHeaders, items] = envelope;
    let parts = JSON.stringify(envHeaders);
    function append2(next2) {
      if (typeof parts === "string") {
        parts = typeof next2 === "string" ? parts + next2 : [encodeUTF8(parts, textEncoder), next2];
      } else {
        parts.push(typeof next2 === "string" ? encodeUTF8(next2, textEncoder) : next2);
      }
    }
    for (const item of items) {
      const [itemHeaders, payload] = item;
      append2(`
${JSON.stringify(itemHeaders)}
`);
      if (typeof payload === "string" || payload instanceof Uint8Array) {
        append2(payload);
      } else {
        let stringifiedPayload;
        try {
          stringifiedPayload = JSON.stringify(payload);
        } catch (e3) {
          stringifiedPayload = JSON.stringify(normalize4(payload));
        }
        append2(stringifiedPayload);
      }
    }
    return typeof parts === "string" ? parts : concatBuffers(parts);
  }
  function concatBuffers(buffers) {
    const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
    const merged = new Uint8Array(totalLength);
    let offset3 = 0;
    for (const buffer of buffers) {
      merged.set(buffer, offset3);
      offset3 += buffer.length;
    }
    return merged;
  }
  function createAttachmentEnvelopeItem(attachment, textEncoder) {
    const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data, textEncoder) : attachment.data;
    return [
      dropUndefinedKeys({
        type: "attachment",
        length: buffer.length,
        filename: attachment.filename,
        content_type: attachment.contentType,
        attachment_type: attachment.attachmentType
      }),
      buffer
    ];
  }
  var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor",
    feedback: "feedback",
    span: "span",
    statsd: "metric_bucket"
  };
  function envelopeItemTypeToDataCategory(type) {
    return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
  }
  function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
    if (!metadataOrEvent || !metadataOrEvent.sdk) {
      return;
    }
    const { name, version } = metadataOrEvent.sdk;
    return { name, version };
  }
  function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
    const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
    return {
      event_id: event.event_id,
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...sdkInfo && { sdk: sdkInfo },
      ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
      ...dynamicSamplingContext && {
        trace: dropUndefinedKeys({ ...dynamicSamplingContext })
      }
    };
  }

  // node_modules/@sentry/utils/esm/clientreport.js
  function createClientReportEnvelope(discarded_events, dsn, timestamp) {
    const clientReportItem = [
      { type: "client_report" },
      {
        timestamp: timestamp || dateTimestampInSeconds(),
        discarded_events
      }
    ];
    return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
  }

  // node_modules/@sentry/utils/esm/ratelimit.js
  var DEFAULT_RETRY_AFTER = 60 * 1e3;
  function parseRetryAfterHeader(header, now3 = Date.now()) {
    const headerDelay = parseInt(`${header}`, 10);
    if (!isNaN(headerDelay)) {
      return headerDelay * 1e3;
    }
    const headerDate = Date.parse(`${header}`);
    if (!isNaN(headerDate)) {
      return headerDate - now3;
    }
    return DEFAULT_RETRY_AFTER;
  }
  function disabledUntil(limits, dataCategory) {
    return limits[dataCategory] || limits.all || 0;
  }
  function isRateLimited(limits, dataCategory, now3 = Date.now()) {
    return disabledUntil(limits, dataCategory) > now3;
  }
  function updateRateLimits(limits, { statusCode, headers }, now3 = Date.now()) {
    const updatedRateLimits = {
      ...limits
    };
    const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
    const retryAfterHeader = headers && headers["retry-after"];
    if (rateLimitHeader) {
      for (const limit of rateLimitHeader.trim().split(",")) {
        const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
        const headerDelay = parseInt(retryAfter, 10);
        const delay2 = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
        if (!categories) {
          updatedRateLimits.all = now3 + delay2;
        } else {
          for (const category of categories.split(";")) {
            if (category === "metric_bucket") {
              if (!namespaces || namespaces.split(";").includes("custom")) {
                updatedRateLimits[category] = now3 + delay2;
              }
            } else {
              updatedRateLimits[category] = now3 + delay2;
            }
          }
        }
      }
    } else if (retryAfterHeader) {
      updatedRateLimits.all = now3 + parseRetryAfterHeader(retryAfterHeader, now3);
    } else if (statusCode === 429) {
      updatedRateLimits.all = now3 + 60 * 1e3;
    }
    return updatedRateLimits;
  }

  // node_modules/@sentry/utils/esm/eventbuilder.js
  function parseStackFrames(stackParser, error2) {
    return stackParser(error2.stack || "", 1);
  }
  function exceptionFromError(stackParser, error2) {
    const exception = {
      type: error2.name || error2.constructor.name,
      value: error2.message
    };
    const frames = parseStackFrames(stackParser, error2);
    if (frames.length) {
      exception.stacktrace = { frames };
    }
    return exception;
  }

  // node_modules/@sentry/utils/esm/buildPolyfills/_nullishCoalesce.js
  function _nullishCoalesce(lhs, rhsFn) {
    return lhs != null ? lhs : rhsFn();
  }

  // node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js
  function _optionalChain(ops) {
    let lastAccessLHS = void 0;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn2 = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn2(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn2((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = void 0;
      }
    }
    return value;
  }

  // node_modules/@sentry/core/esm/debug-build.js
  var DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

  // node_modules/@sentry/core/esm/constants.js
  var DEFAULT_ENVIRONMENT = "production";

  // node_modules/@sentry/core/esm/eventProcessors.js
  function getGlobalEventProcessors() {
    return getGlobalSingleton("globalEventProcessors", () => []);
  }
  function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
  }
  function notifyEventProcessors(processors, event, hint, index = 0) {
    return new SyncPromise((resolve, reject) => {
      const processor = processors[index];
      if (event === null || typeof processor !== "function") {
        resolve(event);
      } else {
        const result = processor({ ...event }, hint);
        DEBUG_BUILD2 && processor.id && result === null && logger.log(`Event processor "${processor.id}" dropped event`);
        if (isThenable(result)) {
          void result.then((final) => notifyEventProcessors(processors, final, hint, index + 1).then(resolve)).then(null, reject);
        } else {
          void notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
        }
      }
    });
  }

  // node_modules/@sentry/core/esm/session.js
  function makeSession(context) {
    const startingTime = timestampInSeconds();
    const session = {
      sid: uuid4(),
      init: true,
      timestamp: startingTime,
      started: startingTime,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: false,
      toJSON: () => sessionToJSON(session)
    };
    if (context) {
      updateSession(session, context);
    }
    return session;
  }
  function updateSession(session, context = {}) {
    if (context.user) {
      if (!session.ipAddress && context.user.ip_address) {
        session.ipAddress = context.user.ip_address;
      }
      if (!session.did && !context.did) {
        session.did = context.user.id || context.user.email || context.user.username;
      }
    }
    session.timestamp = context.timestamp || timestampInSeconds();
    if (context.abnormal_mechanism) {
      session.abnormal_mechanism = context.abnormal_mechanism;
    }
    if (context.ignoreDuration) {
      session.ignoreDuration = context.ignoreDuration;
    }
    if (context.sid) {
      session.sid = context.sid.length === 32 ? context.sid : uuid4();
    }
    if (context.init !== void 0) {
      session.init = context.init;
    }
    if (!session.did && context.did) {
      session.did = `${context.did}`;
    }
    if (typeof context.started === "number") {
      session.started = context.started;
    }
    if (session.ignoreDuration) {
      session.duration = void 0;
    } else if (typeof context.duration === "number") {
      session.duration = context.duration;
    } else {
      const duration = session.timestamp - session.started;
      session.duration = duration >= 0 ? duration : 0;
    }
    if (context.release) {
      session.release = context.release;
    }
    if (context.environment) {
      session.environment = context.environment;
    }
    if (!session.ipAddress && context.ipAddress) {
      session.ipAddress = context.ipAddress;
    }
    if (!session.userAgent && context.userAgent) {
      session.userAgent = context.userAgent;
    }
    if (typeof context.errors === "number") {
      session.errors = context.errors;
    }
    if (context.status) {
      session.status = context.status;
    }
  }
  function closeSession(session, status) {
    let context = {};
    if (status) {
      context = { status };
    } else if (session.status === "ok") {
      context = { status: "exited" };
    }
    updateSession(session, context);
  }
  function sessionToJSON(session) {
    return dropUndefinedKeys({
      sid: `${session.sid}`,
      init: session.init,
      // Make sure that sec is converted to ms for date constructor
      started: new Date(session.started * 1e3).toISOString(),
      timestamp: new Date(session.timestamp * 1e3).toISOString(),
      status: session.status,
      errors: session.errors,
      did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
      duration: session.duration,
      abnormal_mechanism: session.abnormal_mechanism,
      attrs: {
        release: session.release,
        environment: session.environment,
        ip_address: session.ipAddress,
        user_agent: session.userAgent
      }
    });
  }

  // node_modules/@sentry/core/esm/utils/spanUtils.js
  var TRACE_FLAG_NONE = 0;
  var TRACE_FLAG_SAMPLED = 1;
  function spanToTraceContext(span) {
    const { spanId: span_id, traceId: trace_id } = span.spanContext();
    const { data, op, parent_span_id, status, tags: tags2, origin } = spanToJSON(span);
    return dropUndefinedKeys({
      data,
      op,
      parent_span_id,
      span_id,
      status,
      tags: tags2,
      trace_id,
      origin
    });
  }
  function spanToTraceHeader(span) {
    const { traceId, spanId } = span.spanContext();
    const sampled = spanIsSampled(span);
    return generateSentryTraceHeader(traceId, spanId, sampled);
  }
  function spanTimeInputToSeconds(input) {
    if (typeof input === "number") {
      return ensureTimestampInSeconds(input);
    }
    if (Array.isArray(input)) {
      return input[0] + input[1] / 1e9;
    }
    if (input instanceof Date) {
      return ensureTimestampInSeconds(input.getTime());
    }
    return timestampInSeconds();
  }
  function ensureTimestampInSeconds(timestamp) {
    const isMs = timestamp > 9999999999;
    return isMs ? timestamp / 1e3 : timestamp;
  }
  function spanToJSON(span) {
    if (spanIsSpanClass(span)) {
      return span.getSpanJSON();
    }
    if (typeof span.toJSON === "function") {
      return span.toJSON();
    }
    return {};
  }
  function spanIsSpanClass(span) {
    return typeof span.getSpanJSON === "function";
  }
  function spanIsSampled(span) {
    const { traceFlags } = span.spanContext();
    return Boolean(traceFlags & TRACE_FLAG_SAMPLED);
  }

  // node_modules/@sentry/core/esm/utils/prepareEvent.js
  function prepareEvent(options, event, hint, scope, client, isolationScope) {
    const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
    const prepared = {
      ...event,
      event_id: event.event_id || hint.event_id || uuid4(),
      timestamp: event.timestamp || dateTimestampInSeconds()
    };
    const integrations = hint.integrations || options.integrations.map((i) => i.name);
    applyClientOptions(prepared, options);
    applyIntegrationsMetadata(prepared, integrations);
    if (event.type === void 0) {
      applyDebugIds(prepared, options.stackParser);
    }
    const finalScope = getFinalScope(scope, hint.captureContext);
    if (hint.mechanism) {
      addExceptionMechanism(prepared, hint.mechanism);
    }
    const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];
    const data = getGlobalScope().getScopeData();
    if (isolationScope) {
      const isolationData = isolationScope.getScopeData();
      mergeScopeData(data, isolationData);
    }
    if (finalScope) {
      const finalScopeData = finalScope.getScopeData();
      mergeScopeData(data, finalScopeData);
    }
    const attachments = [...hint.attachments || [], ...data.attachments];
    if (attachments.length) {
      hint.attachments = attachments;
    }
    applyScopeDataToEvent(prepared, data);
    const eventProcessors = [
      ...clientEventProcessors,
      // eslint-disable-next-line deprecation/deprecation
      ...getGlobalEventProcessors(),
      // Run scope event processors _after_ all other processors
      ...data.eventProcessors
    ];
    const result = notifyEventProcessors(eventProcessors, prepared, hint);
    return result.then((evt) => {
      if (evt) {
        applyDebugMeta(evt);
      }
      if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
        return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
      }
      return evt;
    });
  }
  function applyClientOptions(event, options) {
    const { environment, release, dist, maxValueLength = 250 } = options;
    if (!("environment" in event)) {
      event.environment = "environment" in options ? environment : DEFAULT_ENVIRONMENT;
    }
    if (event.release === void 0 && release !== void 0) {
      event.release = release;
    }
    if (event.dist === void 0 && dist !== void 0) {
      event.dist = dist;
    }
    if (event.message) {
      event.message = truncate(event.message, maxValueLength);
    }
    const exception = event.exception && event.exception.values && event.exception.values[0];
    if (exception && exception.value) {
      exception.value = truncate(exception.value, maxValueLength);
    }
    const request = event.request;
    if (request && request.url) {
      request.url = truncate(request.url, maxValueLength);
    }
  }
  var debugIdStackParserCache = /* @__PURE__ */ new WeakMap();
  function applyDebugIds(event, stackParser) {
    const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
    if (!debugIdMap) {
      return;
    }
    let debugIdStackFramesCache;
    const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
    if (cachedDebugIdStackFrameCache) {
      debugIdStackFramesCache = cachedDebugIdStackFrameCache;
    } else {
      debugIdStackFramesCache = /* @__PURE__ */ new Map();
      debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
    }
    const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {
      let parsedStack;
      const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
      if (cachedParsedStack) {
        parsedStack = cachedParsedStack;
      } else {
        parsedStack = stackParser(debugIdStackTrace);
        debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
      }
      for (let i = parsedStack.length - 1; i >= 0; i--) {
        const stackFrame = parsedStack[i];
        if (stackFrame.filename) {
          acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
          break;
        }
      }
      return acc;
    }, {});
    try {
      event.exception.values.forEach((exception) => {
        exception.stacktrace.frames.forEach((frame2) => {
          if (frame2.filename) {
            frame2.debug_id = filenameDebugIdMap[frame2.filename];
          }
        });
      });
    } catch (e3) {
    }
  }
  function applyDebugMeta(event) {
    const filenameDebugIdMap = {};
    try {
      event.exception.values.forEach((exception) => {
        exception.stacktrace.frames.forEach((frame2) => {
          if (frame2.debug_id) {
            if (frame2.abs_path) {
              filenameDebugIdMap[frame2.abs_path] = frame2.debug_id;
            } else if (frame2.filename) {
              filenameDebugIdMap[frame2.filename] = frame2.debug_id;
            }
            delete frame2.debug_id;
          }
        });
      });
    } catch (e3) {
    }
    if (Object.keys(filenameDebugIdMap).length === 0) {
      return;
    }
    event.debug_meta = event.debug_meta || {};
    event.debug_meta.images = event.debug_meta.images || [];
    const images = event.debug_meta.images;
    Object.keys(filenameDebugIdMap).forEach((filename) => {
      images.push({
        type: "sourcemap",
        code_file: filename,
        debug_id: filenameDebugIdMap[filename]
      });
    });
  }
  function applyIntegrationsMetadata(event, integrationNames) {
    if (integrationNames.length > 0) {
      event.sdk = event.sdk || {};
      event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
    }
  }
  function normalizeEvent(event, depth, maxBreadth) {
    if (!event) {
      return null;
    }
    const normalized = {
      ...event,
      ...event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map((b) => ({
          ...b,
          ...b.data && {
            data: normalize4(b.data, depth, maxBreadth)
          }
        }))
      },
      ...event.user && {
        user: normalize4(event.user, depth, maxBreadth)
      },
      ...event.contexts && {
        contexts: normalize4(event.contexts, depth, maxBreadth)
      },
      ...event.extra && {
        extra: normalize4(event.extra, depth, maxBreadth)
      }
    };
    if (event.contexts && event.contexts.trace && normalized.contexts) {
      normalized.contexts.trace = event.contexts.trace;
      if (event.contexts.trace.data) {
        normalized.contexts.trace.data = normalize4(event.contexts.trace.data, depth, maxBreadth);
      }
    }
    if (event.spans) {
      normalized.spans = event.spans.map((span) => {
        const data = spanToJSON(span).data;
        if (data) {
          span.data = normalize4(data, depth, maxBreadth);
        }
        return span;
      });
    }
    return normalized;
  }
  function getFinalScope(scope, captureContext) {
    if (!captureContext) {
      return scope;
    }
    const finalScope = scope ? scope.clone() : new Scope();
    finalScope.update(captureContext);
    return finalScope;
  }
  function parseEventHintOrCaptureContext(hint) {
    if (!hint) {
      return void 0;
    }
    if (hintIsScopeOrFunction(hint)) {
      return { captureContext: hint };
    }
    if (hintIsScopeContext(hint)) {
      return {
        captureContext: hint
      };
    }
    return hint;
  }
  function hintIsScopeOrFunction(hint) {
    return hint instanceof Scope || typeof hint === "function";
  }
  var captureContextKeys = [
    "user",
    "level",
    "extra",
    "contexts",
    "tags",
    "fingerprint",
    "requestSession",
    "propagationContext"
  ];
  function hintIsScopeContext(hint) {
    return Object.keys(hint).some((key) => captureContextKeys.includes(key));
  }

  // node_modules/@sentry/core/esm/exports.js
  function captureException(exception, hint) {
    return getCurrentHub().captureException(exception, parseEventHintOrCaptureContext(hint));
  }
  function captureEvent(event, hint) {
    return getCurrentHub().captureEvent(event, hint);
  }
  function addBreadcrumb(breadcrumb, hint) {
    getCurrentHub().addBreadcrumb(breadcrumb, hint);
  }
  function setContext(name, context) {
    getCurrentHub().setContext(name, context);
  }
  function withScope(...rest) {
    const hub = getCurrentHub();
    if (rest.length === 2) {
      const [scope, callback] = rest;
      if (!scope) {
        return hub.withScope(callback);
      }
      return hub.withScope(() => {
        hub.getStackTop().scope = scope;
        return callback(scope);
      });
    }
    return hub.withScope(rest[0]);
  }
  function getClient() {
    return getCurrentHub().getClient();
  }
  function getCurrentScope() {
    return getCurrentHub().getScope();
  }
  function startSession(context) {
    const client = getClient();
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
    const { userAgent } = GLOBAL_OBJ.navigator || {};
    const session = makeSession({
      release,
      environment,
      user: currentScope.getUser() || isolationScope.getUser(),
      ...userAgent && { userAgent },
      ...context
    });
    const currentSession = isolationScope.getSession();
    if (currentSession && currentSession.status === "ok") {
      updateSession(currentSession, { status: "exited" });
    }
    endSession();
    isolationScope.setSession(session);
    currentScope.setSession(session);
    return session;
  }
  function endSession() {
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const session = currentScope.getSession() || isolationScope.getSession();
    if (session) {
      closeSession(session);
    }
    _sendSessionUpdate();
    isolationScope.setSession();
    currentScope.setSession();
  }
  function _sendSessionUpdate() {
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const client = getClient();
    const session = currentScope.getSession() || isolationScope.getSession();
    if (session && client && client.captureSession) {
      client.captureSession(session);
    }
  }
  function captureSession(end2 = false) {
    if (end2) {
      endSession();
      return;
    }
    _sendSessionUpdate();
  }

  // node_modules/@sentry/core/esm/utils/getRootSpan.js
  function getRootSpan(span) {
    return span.transaction;
  }

  // node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js
  function getDynamicSamplingContextFromClient(trace_id, client, scope) {
    const options = client.getOptions();
    const { publicKey: public_key } = client.getDsn() || {};
    const { segment: user_segment } = scope && scope.getUser() || {};
    const dsc = dropUndefinedKeys({
      environment: options.environment || DEFAULT_ENVIRONMENT,
      release: options.release,
      user_segment,
      public_key,
      trace_id
    });
    client.emit && client.emit("createDsc", dsc);
    return dsc;
  }
  function getDynamicSamplingContextFromSpan(span) {
    const client = getClient();
    if (!client) {
      return {};
    }
    const dsc = getDynamicSamplingContextFromClient(spanToJSON(span).trace_id || "", client, getCurrentScope());
    const txn = getRootSpan(span);
    if (!txn) {
      return dsc;
    }
    const v7FrozenDsc = txn && txn._frozenDynamicSamplingContext;
    if (v7FrozenDsc) {
      return v7FrozenDsc;
    }
    const { sampleRate: maybeSampleRate, source } = txn.metadata;
    if (maybeSampleRate != null) {
      dsc.sample_rate = `${maybeSampleRate}`;
    }
    const jsonSpan = spanToJSON(txn);
    if (source && source !== "url") {
      dsc.transaction = jsonSpan.description;
    }
    dsc.sampled = String(spanIsSampled(txn));
    client.emit && client.emit("createDsc", dsc);
    return dsc;
  }

  // node_modules/@sentry/core/esm/utils/applyScopeDataToEvent.js
  function applyScopeDataToEvent(event, data) {
    const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
    applyDataToEvent(event, data);
    if (span) {
      applySpanToEvent(event, span);
    }
    applyFingerprintToEvent(event, fingerprint);
    applyBreadcrumbsToEvent(event, breadcrumbs);
    applySdkMetadataToEvent(event, sdkProcessingMetadata);
  }
  function mergeScopeData(data, mergeData) {
    const {
      extra,
      tags: tags2,
      user,
      contexts,
      level,
      sdkProcessingMetadata,
      breadcrumbs,
      fingerprint,
      eventProcessors,
      attachments,
      propagationContext,
      // eslint-disable-next-line deprecation/deprecation
      transactionName,
      span
    } = mergeData;
    mergeAndOverwriteScopeData(data, "extra", extra);
    mergeAndOverwriteScopeData(data, "tags", tags2);
    mergeAndOverwriteScopeData(data, "user", user);
    mergeAndOverwriteScopeData(data, "contexts", contexts);
    mergeAndOverwriteScopeData(data, "sdkProcessingMetadata", sdkProcessingMetadata);
    if (level) {
      data.level = level;
    }
    if (transactionName) {
      data.transactionName = transactionName;
    }
    if (span) {
      data.span = span;
    }
    if (breadcrumbs.length) {
      data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
    }
    if (fingerprint.length) {
      data.fingerprint = [...data.fingerprint, ...fingerprint];
    }
    if (eventProcessors.length) {
      data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
    }
    if (attachments.length) {
      data.attachments = [...data.attachments, ...attachments];
    }
    data.propagationContext = { ...data.propagationContext, ...propagationContext };
  }
  function mergeAndOverwriteScopeData(data, prop, mergeVal) {
    if (mergeVal && Object.keys(mergeVal).length) {
      data[prop] = { ...data[prop] };
      for (const key in mergeVal) {
        if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {
          data[prop][key] = mergeVal[key];
        }
      }
    }
  }
  function applyDataToEvent(event, data) {
    const {
      extra,
      tags: tags2,
      user,
      contexts,
      level,
      // eslint-disable-next-line deprecation/deprecation
      transactionName
    } = data;
    const cleanedExtra = dropUndefinedKeys(extra);
    if (cleanedExtra && Object.keys(cleanedExtra).length) {
      event.extra = { ...cleanedExtra, ...event.extra };
    }
    const cleanedTags = dropUndefinedKeys(tags2);
    if (cleanedTags && Object.keys(cleanedTags).length) {
      event.tags = { ...cleanedTags, ...event.tags };
    }
    const cleanedUser = dropUndefinedKeys(user);
    if (cleanedUser && Object.keys(cleanedUser).length) {
      event.user = { ...cleanedUser, ...event.user };
    }
    const cleanedContexts = dropUndefinedKeys(contexts);
    if (cleanedContexts && Object.keys(cleanedContexts).length) {
      event.contexts = { ...cleanedContexts, ...event.contexts };
    }
    if (level) {
      event.level = level;
    }
    if (transactionName) {
      event.transaction = transactionName;
    }
  }
  function applyBreadcrumbsToEvent(event, breadcrumbs) {
    const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
    event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
  }
  function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
    event.sdkProcessingMetadata = {
      ...event.sdkProcessingMetadata,
      ...sdkProcessingMetadata
    };
  }
  function applySpanToEvent(event, span) {
    event.contexts = { trace: spanToTraceContext(span), ...event.contexts };
    const rootSpan = getRootSpan(span);
    if (rootSpan) {
      event.sdkProcessingMetadata = {
        dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
        ...event.sdkProcessingMetadata
      };
      const transactionName = spanToJSON(rootSpan).description;
      if (transactionName) {
        event.tags = { transaction: transactionName, ...event.tags };
      }
    }
  }
  function applyFingerprintToEvent(event, fingerprint) {
    event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];
    if (fingerprint) {
      event.fingerprint = event.fingerprint.concat(fingerprint);
    }
    if (event.fingerprint && !event.fingerprint.length) {
      delete event.fingerprint;
    }
  }

  // node_modules/@sentry/core/esm/scope.js
  var DEFAULT_MAX_BREADCRUMBS = 100;
  var globalScope;
  var Scope = class _Scope {
    /** Flag if notifying is happening. */
    /** Callback for client to receive scope changes. */
    /** Callback list that will be called after {@link applyToEvent}. */
    /** Array of breadcrumbs. */
    /** User */
    /** Tags */
    /** Extra */
    /** Contexts */
    /** Attachments */
    /** Propagation Context for distributed tracing */
    /**
     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
     * sent to Sentry
     */
    /** Fingerprint */
    /** Severity */
    // eslint-disable-next-line deprecation/deprecation
    /**
     * Transaction Name
     */
    /** Span */
    /** Session */
    /** Request Mode Session Status */
    /** The client on this scope */
    // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
    constructor() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._attachments = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
      this._sdkProcessingMetadata = {};
      this._propagationContext = generatePropagationContext();
    }
    /**
     * Inherit values from the parent scope.
     * @deprecated Use `scope.clone()` and `new Scope()` instead.
     */
    static clone(scope) {
      return scope ? scope.clone() : new _Scope();
    }
    /**
     * Clone this scope instance.
     */
    clone() {
      const newScope = new _Scope();
      newScope._breadcrumbs = [...this._breadcrumbs];
      newScope._tags = { ...this._tags };
      newScope._extra = { ...this._extra };
      newScope._contexts = { ...this._contexts };
      newScope._user = this._user;
      newScope._level = this._level;
      newScope._span = this._span;
      newScope._session = this._session;
      newScope._transactionName = this._transactionName;
      newScope._fingerprint = this._fingerprint;
      newScope._eventProcessors = [...this._eventProcessors];
      newScope._requestSession = this._requestSession;
      newScope._attachments = [...this._attachments];
      newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
      newScope._propagationContext = { ...this._propagationContext };
      newScope._client = this._client;
      return newScope;
    }
    /** Update the client on the scope. */
    setClient(client) {
      this._client = client;
    }
    /**
     * Get the client assigned to this scope.
     *
     * It is generally recommended to use the global function `Sentry.getClient()` instead, unless you know what you are doing.
     */
    getClient() {
      return this._client;
    }
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    addScopeListener(callback) {
      this._scopeListeners.push(callback);
    }
    /**
     * @inheritDoc
     */
    addEventProcessor(callback) {
      this._eventProcessors.push(callback);
      return this;
    }
    /**
     * @inheritDoc
     */
    setUser(user) {
      this._user = user || {
        email: void 0,
        id: void 0,
        ip_address: void 0,
        segment: void 0,
        username: void 0
      };
      if (this._session) {
        updateSession(this._session, { user });
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getUser() {
      return this._user;
    }
    /**
     * @inheritDoc
     */
    getRequestSession() {
      return this._requestSession;
    }
    /**
     * @inheritDoc
     */
    setRequestSession(requestSession) {
      this._requestSession = requestSession;
      return this;
    }
    /**
     * @inheritDoc
     */
    setTags(tags2) {
      this._tags = {
        ...this._tags,
        ...tags2
      };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setTag(key, value) {
      this._tags = { ...this._tags, [key]: value };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setExtras(extras) {
      this._extra = {
        ...this._extra,
        ...extras
      };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setExtra(key, extra) {
      this._extra = { ...this._extra, [key]: extra };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setFingerprint(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setLevel(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the transaction name on the scope for future events.
     */
    setTransactionName(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setContext(key, context) {
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts[key] = context;
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the Span on the scope.
     * @param span Span
     * @deprecated Instead of setting a span on a scope, use `startSpan()`/`startSpanManual()` instead.
     */
    setSpan(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Returns the `Span` if there is one.
     * @deprecated Use `getActiveSpan()` instead.
     */
    getSpan() {
      return this._span;
    }
    /**
     * Returns the `Transaction` attached to the scope (if there is one).
     * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
     */
    getTransaction() {
      const span = this._span;
      return span && span.transaction;
    }
    /**
     * @inheritDoc
     */
    setSession(session) {
      if (!session) {
        delete this._session;
      } else {
        this._session = session;
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getSession() {
      return this._session;
    }
    /**
     * @inheritDoc
     */
    update(captureContext) {
      if (!captureContext) {
        return this;
      }
      const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
      if (scopeToMerge instanceof _Scope) {
        const scopeData = scopeToMerge.getScopeData();
        this._tags = { ...this._tags, ...scopeData.tags };
        this._extra = { ...this._extra, ...scopeData.extra };
        this._contexts = { ...this._contexts, ...scopeData.contexts };
        if (scopeData.user && Object.keys(scopeData.user).length) {
          this._user = scopeData.user;
        }
        if (scopeData.level) {
          this._level = scopeData.level;
        }
        if (scopeData.fingerprint.length) {
          this._fingerprint = scopeData.fingerprint;
        }
        if (scopeToMerge.getRequestSession()) {
          this._requestSession = scopeToMerge.getRequestSession();
        }
        if (scopeData.propagationContext) {
          this._propagationContext = scopeData.propagationContext;
        }
      } else if (isPlainObject(scopeToMerge)) {
        const scopeContext = captureContext;
        this._tags = { ...this._tags, ...scopeContext.tags };
        this._extra = { ...this._extra, ...scopeContext.extra };
        this._contexts = { ...this._contexts, ...scopeContext.contexts };
        if (scopeContext.user) {
          this._user = scopeContext.user;
        }
        if (scopeContext.level) {
          this._level = scopeContext.level;
        }
        if (scopeContext.fingerprint) {
          this._fingerprint = scopeContext.fingerprint;
        }
        if (scopeContext.requestSession) {
          this._requestSession = scopeContext.requestSession;
        }
        if (scopeContext.propagationContext) {
          this._propagationContext = scopeContext.propagationContext;
        }
      }
      return this;
    }
    /**
     * @inheritDoc
     */
    clear() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._requestSession = void 0;
      this._span = void 0;
      this._session = void 0;
      this._notifyScopeListeners();
      this._attachments = [];
      this._propagationContext = generatePropagationContext();
      return this;
    }
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb, maxBreadcrumbs) {
      const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
      if (maxCrumbs <= 0) {
        return this;
      }
      const mergedBreadcrumb = {
        timestamp: dateTimestampInSeconds(),
        ...breadcrumb
      };
      const breadcrumbs = this._breadcrumbs;
      breadcrumbs.push(mergedBreadcrumb);
      this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getLastBreadcrumb() {
      return this._breadcrumbs[this._breadcrumbs.length - 1];
    }
    /**
     * @inheritDoc
     */
    clearBreadcrumbs() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    addAttachment(attachment) {
      this._attachments.push(attachment);
      return this;
    }
    /**
     * @inheritDoc
     * @deprecated Use `getScopeData()` instead.
     */
    getAttachments() {
      const data = this.getScopeData();
      return data.attachments;
    }
    /**
     * @inheritDoc
     */
    clearAttachments() {
      this._attachments = [];
      return this;
    }
    /** @inheritDoc */
    getScopeData() {
      const {
        _breadcrumbs,
        _attachments,
        _contexts,
        _tags,
        _extra,
        _user,
        _level,
        _fingerprint,
        _eventProcessors,
        _propagationContext,
        _sdkProcessingMetadata,
        _transactionName,
        _span
      } = this;
      return {
        breadcrumbs: _breadcrumbs,
        attachments: _attachments,
        contexts: _contexts,
        tags: _tags,
        extra: _extra,
        user: _user,
        level: _level,
        fingerprint: _fingerprint || [],
        eventProcessors: _eventProcessors,
        propagationContext: _propagationContext,
        sdkProcessingMetadata: _sdkProcessingMetadata,
        transactionName: _transactionName,
        span: _span
      };
    }
    /**
     * Applies data from the scope to the event and runs all event processors on it.
     *
     * @param event Event
     * @param hint Object containing additional information about the original exception, for use by the event processors.
     * @hidden
     * @deprecated Use `applyScopeDataToEvent()` directly
     */
    applyToEvent(event, hint = {}, additionalEventProcessors = []) {
      applyScopeDataToEvent(event, this.getScopeData());
      const eventProcessors = [
        ...additionalEventProcessors,
        // eslint-disable-next-line deprecation/deprecation
        ...getGlobalEventProcessors(),
        ...this._eventProcessors
      ];
      return notifyEventProcessors(eventProcessors, event, hint);
    }
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    setSDKProcessingMetadata(newData) {
      this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
      return this;
    }
    /**
     * @inheritDoc
     */
    setPropagationContext(context) {
      this._propagationContext = context;
      return this;
    }
    /**
     * @inheritDoc
     */
    getPropagationContext() {
      return this._propagationContext;
    }
    /**
     * Capture an exception for this scope.
     *
     * @param exception The exception to capture.
     * @param hint Optinal additional data to attach to the Sentry event.
     * @returns the id of the captured Sentry event.
     */
    captureException(exception, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture exception!");
        return eventId;
      }
      const syntheticException = new Error("Sentry syntheticException");
      this._client.captureException(
        exception,
        {
          originalException: exception,
          syntheticException,
          ...hint,
          event_id: eventId
        },
        this
      );
      return eventId;
    }
    /**
     * Capture a message for this scope.
     *
     * @param message The message to capture.
     * @param level An optional severity level to report the message with.
     * @param hint Optional additional data to attach to the Sentry event.
     * @returns the id of the captured message.
     */
    captureMessage(message, level, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture message!");
        return eventId;
      }
      const syntheticException = new Error(message);
      this._client.captureMessage(
        message,
        level,
        {
          originalException: message,
          syntheticException,
          ...hint,
          event_id: eventId
        },
        this
      );
      return eventId;
    }
    /**
     * Captures a manually created event for this scope and sends it to Sentry.
     *
     * @param exception The event to capture.
     * @param hint Optional additional data to attach to the Sentry event.
     * @returns the id of the captured event.
     */
    captureEvent(event, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture event!");
        return eventId;
      }
      this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
      return eventId;
    }
    /**
     * This will be called on every set call.
     */
    _notifyScopeListeners() {
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach((callback) => {
          callback(this);
        });
        this._notifyingListeners = false;
      }
    }
  };
  function getGlobalScope() {
    if (!globalScope) {
      globalScope = new Scope();
    }
    return globalScope;
  }
  function generatePropagationContext() {
    return {
      traceId: uuid4(),
      spanId: uuid4().substring(16)
    };
  }

  // node_modules/@sentry/core/esm/version.js
  var SDK_VERSION = "7.111.0";

  // node_modules/@sentry/core/esm/hub.js
  var API_VERSION = parseFloat(SDK_VERSION);
  var DEFAULT_BREADCRUMBS = 100;
  var Hub = class {
    /** Is a {@link Layer}[] containing the client and scope */
    /** Contains the last event id of a captured event.  */
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     *
     * @deprecated Instantiation of Hub objects is deprecated and the constructor will be removed in version 8 of the SDK.
     *
     * If you are currently using the Hub for multi-client use like so:
     *
     * ```
     * // OLD
     * const hub = new Hub();
     * hub.bindClient(client);
     * makeMain(hub)
     * ```
     *
     * instead initialize the client as follows:
     *
     * ```
     * // NEW
     * Sentry.withIsolationScope(() => {
     *    Sentry.setCurrentClient(client);
     *    client.init();
     * });
     * ```
     *
     * If you are using the Hub to capture events like so:
     *
     * ```
     * // OLD
     * const client = new Client();
     * const hub = new Hub(client);
     * hub.captureException()
     * ```
     *
     * instead capture isolated events as follows:
     *
     * ```
     * // NEW
     * const client = new Client();
     * const scope = new Scope();
     * scope.setClient(client);
     * scope.captureException();
     * ```
     */
    constructor(client, scope, isolationScope, _version = API_VERSION) {
      this._version = _version;
      let assignedScope;
      if (!scope) {
        assignedScope = new Scope();
        assignedScope.setClient(client);
      } else {
        assignedScope = scope;
      }
      let assignedIsolationScope;
      if (!isolationScope) {
        assignedIsolationScope = new Scope();
        assignedIsolationScope.setClient(client);
      } else {
        assignedIsolationScope = isolationScope;
      }
      this._stack = [{ scope: assignedScope }];
      if (client) {
        this.bindClient(client);
      }
      this._isolationScope = assignedIsolationScope;
    }
    /**
     * Checks if this hub's version is older than the given version.
     *
     * @param version A version number to compare to.
     * @return True if the given version is newer; otherwise false.
     *
     * @deprecated This will be removed in v8.
     */
    isOlderThan(version) {
      return this._version < version;
    }
    /**
     * This binds the given client to the current scope.
     * @param client An SDK client (client) instance.
     *
     * @deprecated Use `initAndBind()` directly, or `setCurrentClient()` and/or `client.init()` instead.
     */
    bindClient(client) {
      const top2 = this.getStackTop();
      top2.client = client;
      top2.scope.setClient(client);
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `withScope` instead.
     */
    pushScope() {
      const scope = this.getScope().clone();
      this.getStack().push({
        // eslint-disable-next-line deprecation/deprecation
        client: this.getClient(),
        scope
      });
      return scope;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `withScope` instead.
     */
    popScope() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.withScope()` instead.
     */
    withScope(callback) {
      const scope = this.pushScope();
      let maybePromiseResult;
      try {
        maybePromiseResult = callback(scope);
      } catch (e3) {
        this.popScope();
        throw e3;
      }
      if (isThenable(maybePromiseResult)) {
        return maybePromiseResult.then(
          (res) => {
            this.popScope();
            return res;
          },
          (e3) => {
            this.popScope();
            throw e3;
          }
        );
      }
      this.popScope();
      return maybePromiseResult;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.getClient()` instead.
     */
    getClient() {
      return this.getStackTop().client;
    }
    /**
     * Returns the scope of the top stack.
     *
     * @deprecated Use `Sentry.getCurrentScope()` instead.
     */
    getScope() {
      return this.getStackTop().scope;
    }
    /**
     * @deprecated Use `Sentry.getIsolationScope()` instead.
     */
    getIsolationScope() {
      return this._isolationScope;
    }
    /**
     * Returns the scope stack for domains or the process.
     * @deprecated This will be removed in v8.
     */
    getStack() {
      return this._stack;
    }
    /**
     * Returns the topmost scope layer in the order domain > local > process.
     * @deprecated This will be removed in v8.
     */
    getStackTop() {
      return this._stack[this._stack.length - 1];
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.captureException()` instead.
     */
    captureException(exception, hint) {
      const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      const syntheticException = new Error("Sentry syntheticException");
      this.getScope().captureException(exception, {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use  `Sentry.captureMessage()` instead.
     */
    captureMessage(message, level, hint) {
      const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      const syntheticException = new Error(message);
      this.getScope().captureMessage(message, level, {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.captureEvent()` instead.
     */
    captureEvent(event, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!event.type) {
        this._lastEventId = eventId;
      }
      this.getScope().captureEvent(event, { ...hint, event_id: eventId });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated This will be removed in v8.
     */
    lastEventId() {
      return this._lastEventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.addBreadcrumb()` instead.
     */
    addBreadcrumb(breadcrumb, hint) {
      const { scope, client } = this.getStackTop();
      if (!client)
        return;
      const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions && client.getOptions() || {};
      if (maxBreadcrumbs <= 0)
        return;
      const timestamp = dateTimestampInSeconds();
      const mergedBreadcrumb = { timestamp, ...breadcrumb };
      const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      if (client.emit) {
        client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
      }
      scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setUser()` instead.
     */
    setUser(user) {
      this.getScope().setUser(user);
      this.getIsolationScope().setUser(user);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setTags()` instead.
     */
    setTags(tags2) {
      this.getScope().setTags(tags2);
      this.getIsolationScope().setTags(tags2);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setExtras()` instead.
     */
    setExtras(extras) {
      this.getScope().setExtras(extras);
      this.getIsolationScope().setExtras(extras);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setTag()` instead.
     */
    setTag(key, value) {
      this.getScope().setTag(key, value);
      this.getIsolationScope().setTag(key, value);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setExtra()` instead.
     */
    setExtra(key, extra) {
      this.getScope().setExtra(key, extra);
      this.getIsolationScope().setExtra(key, extra);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setContext()` instead.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setContext(name, context) {
      this.getScope().setContext(name, context);
      this.getIsolationScope().setContext(name, context);
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `getScope()` directly.
     */
    configureScope(callback) {
      const { scope, client } = this.getStackTop();
      if (client) {
        callback(scope);
      }
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line deprecation/deprecation
    run(callback) {
      const oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.getClient().getIntegrationByName()` instead.
     */
    getIntegration(integration) {
      const client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        DEBUG_BUILD2 && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
        return null;
      }
    }
    /**
     * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
     *
     * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
     * new child span within the transaction or any span, call the respective `.startChild()` method.
     *
     * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
     *
     * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its
     * finished child spans will be sent to Sentry.
     *
     * @param context Properties of the new `Transaction`.
     * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
     * default values). See {@link Options.tracesSampler}.
     *
     * @returns The transaction which was just started
     *
     * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
     */
    startTransaction(context, customSamplingContext) {
      const result = this._callExtensionMethod("startTransaction", context, customSamplingContext);
      if (DEBUG_BUILD2 && !result) {
        const client = this.getClient();
        if (!client) {
          logger.warn(
            "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
          );
        } else {
          logger.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`);
        }
      }
      return result;
    }
    /**
     * @inheritDoc
     * @deprecated Use `spanToTraceHeader()` instead.
     */
    traceHeaders() {
      return this._callExtensionMethod("traceHeaders");
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use top level `captureSession` instead.
     */
    captureSession(endSession2 = false) {
      if (endSession2) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    }
    /**
     * @inheritDoc
     * @deprecated Use top level `endSession` instead.
     */
    endSession() {
      const layer = this.getStackTop();
      const scope = layer.scope;
      const session = scope.getSession();
      if (session) {
        closeSession(session);
      }
      this._sendSessionUpdate();
      scope.setSession();
    }
    /**
     * @inheritDoc
     * @deprecated Use top level `startSession` instead.
     */
    startSession(context) {
      const { scope, client } = this.getStackTop();
      const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
      const { userAgent } = GLOBAL_OBJ.navigator || {};
      const session = makeSession({
        release,
        environment,
        user: scope.getUser(),
        ...userAgent && { userAgent },
        ...context
      });
      const currentSession = scope.getSession && scope.getSession();
      if (currentSession && currentSession.status === "ok") {
        updateSession(currentSession, { status: "exited" });
      }
      this.endSession();
      scope.setSession(session);
      return session;
    }
    /**
     * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
     * when Tracing is used.
     *
     * @deprecated Use top-level `getClient().getOptions().sendDefaultPii` instead. This function
     * only unnecessarily increased API surface but only wrapped accessing the option.
     */
    shouldSendDefaultPii() {
      const client = this.getClient();
      const options = client && client.getOptions();
      return Boolean(options && options.sendDefaultPii);
    }
    /**
     * Sends the current Session on the scope
     */
    _sendSessionUpdate() {
      const { scope, client } = this.getStackTop();
      const session = scope.getSession();
      if (session && client && client.captureSession) {
        client.captureSession(session);
      }
    }
    /**
     * Calls global extension method and binding current instance to the function call
     */
    // @ts-expect-error Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _callExtensionMethod(method, ...args) {
      const carrier = getMainCarrier();
      const sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args);
      }
      DEBUG_BUILD2 && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
    }
  };
  function getMainCarrier() {
    GLOBAL_OBJ.__SENTRY__ = GLOBAL_OBJ.__SENTRY__ || {
      extensions: {},
      hub: void 0
    };
    return GLOBAL_OBJ;
  }
  function makeMain(hub) {
    const registry = getMainCarrier();
    const oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
  }
  function getCurrentHub() {
    const registry = getMainCarrier();
    if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
      const hub = registry.__SENTRY__.acs.getCurrentHub();
      if (hub) {
        return hub;
      }
    }
    return getGlobalHub(registry);
  }
  function getIsolationScope() {
    return getCurrentHub().getIsolationScope();
  }
  function getGlobalHub(registry = getMainCarrier()) {
    if (!hasHubOnCarrier(registry) || // eslint-disable-next-line deprecation/deprecation
    getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
      setHubOnCarrier(registry, new Hub());
    }
    return getHubFromCarrier(registry);
  }
  function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  }
  function getHubFromCarrier(carrier) {
    return getGlobalSingleton("hub", () => new Hub(), carrier);
  }
  function setHubOnCarrier(carrier, hub) {
    if (!carrier)
      return false;
    const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.hub = hub;
    return true;
  }

  // node_modules/@sentry/core/esm/tracing/utils.js
  function getActiveTransaction(maybeHub) {
    const hub = maybeHub || getCurrentHub();
    const scope = hub.getScope();
    return scope.getTransaction();
  }

  // node_modules/@sentry/core/esm/tracing/errors.js
  var errorsInstrumented = false;
  function registerErrorInstrumentation() {
    if (errorsInstrumented) {
      return;
    }
    errorsInstrumented = true;
    addGlobalErrorInstrumentationHandler(errorCallback);
    addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);
  }
  function errorCallback() {
    const activeTransaction = getActiveTransaction();
    if (activeTransaction) {
      const status = "internal_error";
      DEBUG_BUILD2 && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);
      activeTransaction.setStatus(status);
    }
  }
  errorCallback.tag = "sentry_tracingErrorCallback";

  // node_modules/@sentry/core/esm/tracing/spanstatus.js
  var SpanStatus;
  (function(SpanStatus2) {
    const Ok = "ok";
    SpanStatus2["Ok"] = Ok;
    const DeadlineExceeded = "deadline_exceeded";
    SpanStatus2["DeadlineExceeded"] = DeadlineExceeded;
    const Unauthenticated = "unauthenticated";
    SpanStatus2["Unauthenticated"] = Unauthenticated;
    const PermissionDenied = "permission_denied";
    SpanStatus2["PermissionDenied"] = PermissionDenied;
    const NotFound = "not_found";
    SpanStatus2["NotFound"] = NotFound;
    const ResourceExhausted = "resource_exhausted";
    SpanStatus2["ResourceExhausted"] = ResourceExhausted;
    const InvalidArgument = "invalid_argument";
    SpanStatus2["InvalidArgument"] = InvalidArgument;
    const Unimplemented = "unimplemented";
    SpanStatus2["Unimplemented"] = Unimplemented;
    const Unavailable = "unavailable";
    SpanStatus2["Unavailable"] = Unavailable;
    const InternalError = "internal_error";
    SpanStatus2["InternalError"] = InternalError;
    const UnknownError = "unknown_error";
    SpanStatus2["UnknownError"] = UnknownError;
    const Cancelled = "cancelled";
    SpanStatus2["Cancelled"] = Cancelled;
    const AlreadyExists = "already_exists";
    SpanStatus2["AlreadyExists"] = AlreadyExists;
    const FailedPrecondition = "failed_precondition";
    SpanStatus2["FailedPrecondition"] = FailedPrecondition;
    const Aborted = "aborted";
    SpanStatus2["Aborted"] = Aborted;
    const OutOfRange = "out_of_range";
    SpanStatus2["OutOfRange"] = OutOfRange;
    const DataLoss = "data_loss";
    SpanStatus2["DataLoss"] = DataLoss;
  })(SpanStatus || (SpanStatus = {}));
  function getSpanStatusFromHttpCode(httpStatus) {
    if (httpStatus < 400 && httpStatus >= 100) {
      return "ok";
    }
    if (httpStatus >= 400 && httpStatus < 500) {
      switch (httpStatus) {
        case 401:
          return "unauthenticated";
        case 403:
          return "permission_denied";
        case 404:
          return "not_found";
        case 409:
          return "already_exists";
        case 413:
          return "failed_precondition";
        case 429:
          return "resource_exhausted";
        default:
          return "invalid_argument";
      }
    }
    if (httpStatus >= 500 && httpStatus < 600) {
      switch (httpStatus) {
        case 501:
          return "unimplemented";
        case 503:
          return "unavailable";
        case 504:
          return "deadline_exceeded";
        default:
          return "internal_error";
      }
    }
    return "unknown_error";
  }
  function setHttpStatus(span, httpStatus) {
    span.setTag("http.status_code", String(httpStatus));
    span.setData("http.response.status_code", httpStatus);
    const spanStatus = getSpanStatusFromHttpCode(httpStatus);
    if (spanStatus !== "unknown_error") {
      span.setStatus(spanStatus);
    }
  }

  // node_modules/@sentry/core/esm/utils/hasTracingEnabled.js
  function hasTracingEnabled(maybeOptions) {
    if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
      return false;
    }
    const client = getClient();
    const options = maybeOptions || client && client.getOptions();
    return !!options && (options.enableTracing || "tracesSampleRate" in options || "tracesSampler" in options);
  }

  // node_modules/@sentry/core/esm/tracing/trace.js
  function startInactiveSpan(context) {
    if (!hasTracingEnabled()) {
      return void 0;
    }
    const spanContext = normalizeContext(context);
    const hub = getCurrentHub();
    const parentSpan = context.scope ? (
      // eslint-disable-next-line deprecation/deprecation
      context.scope.getSpan()
    ) : getActiveSpan();
    const shouldSkipSpan = context.onlyIfParent && !parentSpan;
    if (shouldSkipSpan) {
      return void 0;
    }
    const scope = context.scope || getCurrentScope();
    const temporaryScope = scope.clone();
    return createChildSpanOrTransaction(hub, {
      parentSpan,
      spanContext,
      forceTransaction: context.forceTransaction,
      scope: temporaryScope
    });
  }
  function getActiveSpan() {
    return getCurrentScope().getSpan();
  }
  function createChildSpanOrTransaction(hub, {
    parentSpan,
    spanContext,
    forceTransaction,
    scope
  }) {
    if (!hasTracingEnabled()) {
      return void 0;
    }
    const isolationScope = getIsolationScope();
    let span;
    if (parentSpan && !forceTransaction) {
      span = parentSpan.startChild(spanContext);
    } else if (parentSpan) {
      const dsc = getDynamicSamplingContextFromSpan(parentSpan);
      const { traceId, spanId: parentSpanId } = parentSpan.spanContext();
      const sampled = spanIsSampled(parentSpan);
      span = hub.startTransaction({
        traceId,
        parentSpanId,
        parentSampled: sampled,
        ...spanContext,
        metadata: {
          dynamicSamplingContext: dsc,
          // eslint-disable-next-line deprecation/deprecation
          ...spanContext.metadata
        }
      });
    } else {
      const { traceId, dsc, parentSpanId, sampled } = {
        ...isolationScope.getPropagationContext(),
        ...scope.getPropagationContext()
      };
      span = hub.startTransaction({
        traceId,
        parentSpanId,
        parentSampled: sampled,
        ...spanContext,
        metadata: {
          dynamicSamplingContext: dsc,
          // eslint-disable-next-line deprecation/deprecation
          ...spanContext.metadata
        }
      });
    }
    scope.setSpan(span);
    setCapturedScopesOnSpan(span, scope, isolationScope);
    return span;
  }
  function normalizeContext(context) {
    if (context.startTime) {
      const ctx = { ...context };
      ctx.startTimestamp = spanTimeInputToSeconds(context.startTime);
      delete ctx.startTime;
      return ctx;
    }
    return context;
  }
  var SCOPE_ON_START_SPAN_FIELD = "_sentryScope";
  var ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
  function setCapturedScopesOnSpan(span, scope, isolationScope) {
    if (span) {
      addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);
      addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);
    }
  }
  function getCapturedScopesOnSpan(span) {
    return {
      scope: span[SCOPE_ON_START_SPAN_FIELD],
      isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
    };
  }

  // node_modules/@sentry/core/esm/metrics/metric-summary.js
  var SPAN_METRIC_SUMMARY;
  function getMetricStorageForSpan(span) {
    return SPAN_METRIC_SUMMARY ? SPAN_METRIC_SUMMARY.get(span) : void 0;
  }
  function getMetricSummaryJsonForSpan(span) {
    const storage = getMetricStorageForSpan(span);
    if (!storage) {
      return void 0;
    }
    const output = {};
    for (const [, [exportKey, summary]] of storage) {
      if (!output[exportKey]) {
        output[exportKey] = [];
      }
      output[exportKey].push(dropUndefinedKeys(summary));
    }
    return output;
  }

  // node_modules/@sentry/core/esm/semanticAttributes.js
  var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
  var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
  var SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
  var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
  var SEMANTIC_ATTRIBUTE_PROFILE_ID = "profile_id";

  // node_modules/@sentry/core/esm/tracing/span.js
  var SpanRecorder = class {
    constructor(maxlen = 1e3) {
      this._maxlen = maxlen;
      this.spans = [];
    }
    /**
     * This is just so that we don't run out of memory while recording a lot
     * of spans. At some point we just stop and flush out the start of the
     * trace tree (i.e.the first n spans with the smallest
     * start_timestamp).
     */
    add(span) {
      if (this.spans.length > this._maxlen) {
        span.spanRecorder = void 0;
      } else {
        this.spans.push(span);
      }
    }
  };
  var Span = class _Span {
    /**
     * Tags for the span.
     * @deprecated Use `spanToJSON(span).atttributes` instead.
     */
    /**
     * Data for the span.
     * @deprecated Use `spanToJSON(span).atttributes` instead.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    /**
     * List of spans that were finalized
     *
     * @deprecated This property will no longer be public. Span recording will be handled internally.
     */
    /**
     * @inheritDoc
     * @deprecated Use top level `Sentry.getRootSpan()` instead
     */
    /**
     * The instrumenter that created this span.
     *
     * TODO (v8): This can probably be replaced by an `instanceOf` check of the span class.
     *            the instrumenter can only be sentry or otel so we can check the span instance
     *            to verify which one it is and remove this field entirely.
     *
     * @deprecated This field will be removed.
     */
    /** Epoch timestamp in seconds when the span started. */
    /** Epoch timestamp in seconds when the span ended. */
    /** Internal keeper of the status */
    /**
     * You should never call the constructor manually, always use `Sentry.startTransaction()`
     * or call `startChild()` on an existing span.
     * @internal
     * @hideconstructor
     * @hidden
     */
    constructor(spanContext = {}) {
      this._traceId = spanContext.traceId || uuid4();
      this._spanId = spanContext.spanId || uuid4().substring(16);
      this._startTime = spanContext.startTimestamp || timestampInSeconds();
      this.tags = spanContext.tags ? { ...spanContext.tags } : {};
      this.data = spanContext.data ? { ...spanContext.data } : {};
      this.instrumenter = spanContext.instrumenter || "sentry";
      this._attributes = {};
      this.setAttributes({
        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanContext.origin || "manual",
        [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,
        ...spanContext.attributes
      });
      this._name = spanContext.name || spanContext.description;
      if (spanContext.parentSpanId) {
        this._parentSpanId = spanContext.parentSpanId;
      }
      if ("sampled" in spanContext) {
        this._sampled = spanContext.sampled;
      }
      if (spanContext.status) {
        this._status = spanContext.status;
      }
      if (spanContext.endTimestamp) {
        this._endTime = spanContext.endTimestamp;
      }
      if (spanContext.exclusiveTime !== void 0) {
        this._exclusiveTime = spanContext.exclusiveTime;
      }
      this._measurements = spanContext.measurements ? { ...spanContext.measurements } : {};
    }
    // This rule conflicts with another eslint rule :(
    /* eslint-disable @typescript-eslint/member-ordering */
    /**
     * An alias for `description` of the Span.
     * @deprecated Use `spanToJSON(span).description` instead.
     */
    get name() {
      return this._name || "";
    }
    /**
     * Update the name of the span.
     * @deprecated Use `spanToJSON(span).description` instead.
     */
    set name(name) {
      this.updateName(name);
    }
    /**
     * Get the description of the Span.
     * @deprecated Use `spanToJSON(span).description` instead.
     */
    get description() {
      return this._name;
    }
    /**
     * Get the description of the Span.
     * @deprecated Use `spanToJSON(span).description` instead.
     */
    set description(description) {
      this._name = description;
    }
    /**
     * The ID of the trace.
     * @deprecated Use `spanContext().traceId` instead.
     */
    get traceId() {
      return this._traceId;
    }
    /**
     * The ID of the trace.
     * @deprecated You cannot update the traceId of a span after span creation.
     */
    set traceId(traceId) {
      this._traceId = traceId;
    }
    /**
     * The ID of the span.
     * @deprecated Use `spanContext().spanId` instead.
     */
    get spanId() {
      return this._spanId;
    }
    /**
     * The ID of the span.
     * @deprecated You cannot update the spanId of a span after span creation.
     */
    set spanId(spanId) {
      this._spanId = spanId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `startSpan` functions instead.
     */
    set parentSpanId(string) {
      this._parentSpanId = string;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `spanToJSON(span).parent_span_id` instead.
     */
    get parentSpanId() {
      return this._parentSpanId;
    }
    /**
     * Was this span chosen to be sent as part of the sample?
     * @deprecated Use `isRecording()` instead.
     */
    get sampled() {
      return this._sampled;
    }
    /**
     * Was this span chosen to be sent as part of the sample?
     * @deprecated You cannot update the sampling decision of a span after span creation.
     */
    set sampled(sampled) {
      this._sampled = sampled;
    }
    /**
     * Attributes for the span.
     * @deprecated Use `spanToJSON(span).atttributes` instead.
     */
    get attributes() {
      return this._attributes;
    }
    /**
     * Attributes for the span.
     * @deprecated Use `setAttributes()` instead.
     */
    set attributes(attributes) {
      this._attributes = attributes;
    }
    /**
     * Timestamp in seconds (epoch time) indicating when the span started.
     * @deprecated Use `spanToJSON()` instead.
     */
    get startTimestamp() {
      return this._startTime;
    }
    /**
     * Timestamp in seconds (epoch time) indicating when the span started.
     * @deprecated In v8, you will not be able to update the span start time after creation.
     */
    set startTimestamp(startTime) {
      this._startTime = startTime;
    }
    /**
     * Timestamp in seconds when the span ended.
     * @deprecated Use `spanToJSON()` instead.
     */
    get endTimestamp() {
      return this._endTime;
    }
    /**
     * Timestamp in seconds when the span ended.
     * @deprecated Set the end time via `span.end()` instead.
     */
    set endTimestamp(endTime) {
      this._endTime = endTime;
    }
    /**
     * The status of the span.
     *
     * @deprecated Use `spanToJSON().status` instead to get the status.
     */
    get status() {
      return this._status;
    }
    /**
     * The status of the span.
     *
     * @deprecated Use `.setStatus()` instead to set or update the status.
     */
    set status(status) {
      this._status = status;
    }
    /**
     * Operation of the span
     *
     * @deprecated Use `spanToJSON().op` to read the op instead.
     */
    get op() {
      return this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP];
    }
    /**
     * Operation of the span
     *
     * @deprecated Use `startSpan()` functions to set or `span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'op')
     *             to update the span instead.
     */
    set op(op) {
      this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, op);
    }
    /**
     * The origin of the span, giving context about what created the span.
     *
     * @deprecated Use `spanToJSON().origin` to read the origin instead.
     */
    get origin() {
      return this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN];
    }
    /**
     * The origin of the span, giving context about what created the span.
     *
     * @deprecated Use `startSpan()` functions to set the origin instead.
     */
    set origin(origin) {
      this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
    }
    /* eslint-enable @typescript-eslint/member-ordering */
    /** @inheritdoc */
    spanContext() {
      const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;
      return {
        spanId,
        traceId,
        traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE
      };
    }
    /**
     * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.
     * Also the `sampled` decision will be inherited.
     *
     * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
     */
    startChild(spanContext) {
      const childSpan = new _Span({
        ...spanContext,
        parentSpanId: this._spanId,
        sampled: this._sampled,
        traceId: this._traceId
      });
      childSpan.spanRecorder = this.spanRecorder;
      if (childSpan.spanRecorder) {
        childSpan.spanRecorder.add(childSpan);
      }
      const rootSpan = getRootSpan(this);
      childSpan.transaction = rootSpan;
      if (DEBUG_BUILD2 && rootSpan) {
        const opStr = spanContext && spanContext.op || "< unknown op >";
        const nameStr = spanToJSON(childSpan).description || "< unknown name >";
        const idStr = rootSpan.spanContext().spanId;
        const logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;
        logger.log(logMessage);
        this._logMessage = logMessage;
      }
      return childSpan;
    }
    /**
     * Sets the tag attribute on the current span.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key Tag key
     * @param value Tag value
     * @deprecated Use `setAttribute()` instead.
     */
    setTag(key, value) {
      this.tags = { ...this.tags, [key]: value };
      return this;
    }
    /**
     * Sets the data attribute on the current span
     * @param key Data key
     * @param value Data value
     * @deprecated Use `setAttribute()` instead.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setData(key, value) {
      this.data = { ...this.data, [key]: value };
      return this;
    }
    /** @inheritdoc */
    setAttribute(key, value) {
      if (value === void 0) {
        delete this._attributes[key];
      } else {
        this._attributes[key] = value;
      }
    }
    /** @inheritdoc */
    setAttributes(attributes) {
      Object.keys(attributes).forEach((key) => this.setAttribute(key, attributes[key]));
    }
    /**
     * @inheritDoc
     */
    setStatus(value) {
      this._status = value;
      return this;
    }
    /**
     * @inheritDoc
     * @deprecated Use top-level `setHttpStatus()` instead.
     */
    setHttpStatus(httpStatus) {
      setHttpStatus(this, httpStatus);
      return this;
    }
    /**
     * @inheritdoc
     *
     * @deprecated Use `.updateName()` instead.
     */
    setName(name) {
      this.updateName(name);
    }
    /**
     * @inheritDoc
     */
    updateName(name) {
      this._name = name;
      return this;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `spanToJSON(span).status === 'ok'` instead.
     */
    isSuccess() {
      return this._status === "ok";
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `.end()` instead.
     */
    finish(endTimestamp) {
      return this.end(endTimestamp);
    }
    /** @inheritdoc */
    end(endTimestamp) {
      if (this._endTime) {
        return;
      }
      const rootSpan = getRootSpan(this);
      if (DEBUG_BUILD2 && // Don't call this for transactions
      rootSpan && rootSpan.spanContext().spanId !== this._spanId) {
        const logMessage = this._logMessage;
        if (logMessage) {
          logger.log(logMessage.replace("Starting", "Finishing"));
        }
      }
      this._endTime = spanTimeInputToSeconds(endTimestamp);
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `spanToTraceHeader()` instead.
     */
    toTraceparent() {
      return spanToTraceHeader(this);
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `spanToJSON()` or access the fields directly instead.
     */
    toContext() {
      return dropUndefinedKeys({
        data: this._getData(),
        description: this._name,
        endTimestamp: this._endTime,
        // eslint-disable-next-line deprecation/deprecation
        op: this.op,
        parentSpanId: this._parentSpanId,
        sampled: this._sampled,
        spanId: this._spanId,
        startTimestamp: this._startTime,
        status: this._status,
        // eslint-disable-next-line deprecation/deprecation
        tags: this.tags,
        traceId: this._traceId
      });
    }
    /**
     * @inheritDoc
     *
     * @deprecated Update the fields directly instead.
     */
    updateWithContext(spanContext) {
      this.data = spanContext.data || {};
      this._name = spanContext.name || spanContext.description;
      this._endTime = spanContext.endTimestamp;
      this.op = spanContext.op;
      this._parentSpanId = spanContext.parentSpanId;
      this._sampled = spanContext.sampled;
      this._spanId = spanContext.spanId || this._spanId;
      this._startTime = spanContext.startTimestamp || this._startTime;
      this._status = spanContext.status;
      this.tags = spanContext.tags || {};
      this._traceId = spanContext.traceId || this._traceId;
      return this;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `spanToTraceContext()` util function instead.
     */
    getTraceContext() {
      return spanToTraceContext(this);
    }
    /**
     * Get JSON representation of this span.
     *
     * @hidden
     * @internal This method is purely for internal purposes and should not be used outside
     * of SDK code. If you need to get a JSON representation of a span,
     * use `spanToJSON(span)` instead.
     */
    getSpanJSON() {
      return dropUndefinedKeys({
        data: this._getData(),
        description: this._name,
        op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
        parent_span_id: this._parentSpanId,
        span_id: this._spanId,
        start_timestamp: this._startTime,
        status: this._status,
        // eslint-disable-next-line deprecation/deprecation
        tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
        timestamp: this._endTime,
        trace_id: this._traceId,
        origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
        _metrics_summary: getMetricSummaryJsonForSpan(this),
        profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID],
        exclusive_time: this._exclusiveTime,
        measurements: Object.keys(this._measurements).length > 0 ? this._measurements : void 0
      });
    }
    /** @inheritdoc */
    isRecording() {
      return !this._endTime && !!this._sampled;
    }
    /**
     * Convert the object to JSON.
     * @deprecated Use `spanToJSON(span)` instead.
     */
    toJSON() {
      return this.getSpanJSON();
    }
    /**
     * Get the merged data for this span.
     * For now, this combines `data` and `attributes` together,
     * until eventually we can ingest `attributes` directly.
     */
    _getData() {
      const { data, _attributes: attributes } = this;
      const hasData = Object.keys(data).length > 0;
      const hasAttributes = Object.keys(attributes).length > 0;
      if (!hasData && !hasAttributes) {
        return void 0;
      }
      if (hasData && hasAttributes) {
        return {
          ...data,
          ...attributes
        };
      }
      return hasData ? data : attributes;
    }
  };

  // node_modules/@sentry/core/esm/tracing/transaction.js
  var Transaction = class extends Span {
    /**
     * The reference to the current hub.
     */
    // eslint-disable-next-line deprecation/deprecation
    // DO NOT yet remove this property, it is used in a hack for v7 backwards compatibility.
    /**
     * This constructor should never be called manually. Those instrumenting tracing should use
     * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
     * @internal
     * @hideconstructor
     * @hidden
     *
     * @deprecated Transactions will be removed in v8. Use spans instead.
     */
    // eslint-disable-next-line deprecation/deprecation
    constructor(transactionContext, hub) {
      super(transactionContext);
      this._contexts = {};
      this._hub = hub || getCurrentHub();
      this._name = transactionContext.name || "";
      this._metadata = {
        // eslint-disable-next-line deprecation/deprecation
        ...transactionContext.metadata
      };
      this._trimEnd = transactionContext.trimEnd;
      this.transaction = this;
      const incomingDynamicSamplingContext = this._metadata.dynamicSamplingContext;
      if (incomingDynamicSamplingContext) {
        this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };
      }
    }
    // This sadly conflicts with the getter/setter ordering :(
    /* eslint-disable @typescript-eslint/member-ordering */
    /**
     * Getter for `name` property.
     * @deprecated Use `spanToJSON(span).description` instead.
     */
    get name() {
      return this._name;
    }
    /**
     * Setter for `name` property, which also sets `source` as custom.
     * @deprecated Use `updateName()` and `setMetadata()` instead.
     */
    set name(newName) {
      this.setName(newName);
    }
    /**
     * Get the metadata for this transaction.
     * @deprecated Use `spanGetMetadata(transaction)` instead.
     */
    get metadata() {
      return {
        // Defaults
        // eslint-disable-next-line deprecation/deprecation
        source: "custom",
        spanMetadata: {},
        // Legacy metadata
        ...this._metadata,
        // From attributes
        ...this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] && {
          source: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]
        },
        ...this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] && {
          sampleRate: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]
        }
      };
    }
    /**
     * Update the metadata for this transaction.
     * @deprecated Use `spanGetMetadata(transaction)` instead.
     */
    set metadata(metadata) {
      this._metadata = metadata;
    }
    /* eslint-enable @typescript-eslint/member-ordering */
    /**
     * Setter for `name` property, which also sets `source` on the metadata.
     *
     * @deprecated Use `.updateName()` and `.setAttribute()` instead.
     */
    setName(name, source = "custom") {
      this._name = name;
      this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);
    }
    /** @inheritdoc */
    updateName(name) {
      this._name = name;
      return this;
    }
    /**
     * Attaches SpanRecorder to the span itself
     * @param maxlen maximum number of spans that can be recorded
     */
    initSpanRecorder(maxlen = 1e3) {
      if (!this.spanRecorder) {
        this.spanRecorder = new SpanRecorder(maxlen);
      }
      this.spanRecorder.add(this);
    }
    /**
     * Set the context of a transaction event.
     * @deprecated Use either `.setAttribute()`, or set the context on the scope before creating the transaction.
     */
    setContext(key, context) {
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts[key] = context;
      }
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use top-level `setMeasurement()` instead.
     */
    setMeasurement(name, value, unit2 = "") {
      this._measurements[name] = { value, unit: unit2 };
    }
    /**
     * Store metadata on this transaction.
     * @deprecated Use attributes or store data on the scope instead.
     */
    setMetadata(newMetadata) {
      this._metadata = { ...this._metadata, ...newMetadata };
    }
    /**
     * @inheritDoc
     */
    end(endTimestamp) {
      const timestampInS = spanTimeInputToSeconds(endTimestamp);
      const transaction = this._finishTransaction(timestampInS);
      if (!transaction) {
        return void 0;
      }
      return this._hub.captureEvent(transaction);
    }
    /**
     * @inheritDoc
     */
    toContext() {
      const spanContext = super.toContext();
      return dropUndefinedKeys({
        ...spanContext,
        name: this._name,
        trimEnd: this._trimEnd
      });
    }
    /**
     * @inheritDoc
     */
    updateWithContext(transactionContext) {
      super.updateWithContext(transactionContext);
      this._name = transactionContext.name || "";
      this._trimEnd = transactionContext.trimEnd;
      return this;
    }
    /**
     * @inheritdoc
     *
     * @experimental
     *
     * @deprecated Use top-level `getDynamicSamplingContextFromSpan` instead.
     */
    getDynamicSamplingContext() {
      return getDynamicSamplingContextFromSpan(this);
    }
    /**
     * Override the current hub with a new one.
     * Used if you want another hub to finish the transaction.
     *
     * @internal
     */
    // eslint-disable-next-line deprecation/deprecation
    setHub(hub) {
      this._hub = hub;
    }
    /**
     * Get the profile id of the transaction.
     */
    getProfileId() {
      if (this._contexts !== void 0 && this._contexts["profile"] !== void 0) {
        return this._contexts["profile"].profile_id;
      }
      return void 0;
    }
    /**
     * Finish the transaction & prepare the event to send to Sentry.
     */
    _finishTransaction(endTimestamp) {
      if (this._endTime !== void 0) {
        return void 0;
      }
      if (!this._name) {
        DEBUG_BUILD2 && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
        this._name = "<unlabeled transaction>";
      }
      super.end(endTimestamp);
      const client = this._hub.getClient();
      if (client && client.emit) {
        client.emit("finishTransaction", this);
      }
      if (this._sampled !== true) {
        DEBUG_BUILD2 && logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
        if (client) {
          client.recordDroppedEvent("sample_rate", "transaction");
        }
        return void 0;
      }
      const finishedSpans = this.spanRecorder ? (
        // eslint-disable-next-line deprecation/deprecation
        this.spanRecorder.spans.filter((span) => span !== this && spanToJSON(span).timestamp)
      ) : [];
      if (this._trimEnd && finishedSpans.length > 0) {
        const endTimes = finishedSpans.map((span) => spanToJSON(span).timestamp).filter(Boolean);
        this._endTime = endTimes.reduce((prev2, current) => {
          return prev2 > current ? prev2 : current;
        });
      }
      const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = getCapturedScopesOnSpan(this);
      const { metadata } = this;
      const { source } = metadata;
      const transaction = {
        contexts: {
          ...this._contexts,
          // We don't want to override trace context
          trace: spanToTraceContext(this)
        },
        // TODO: Pass spans serialized via `spanToJSON()` here instead in v8.
        spans: finishedSpans,
        start_timestamp: this._startTime,
        // eslint-disable-next-line deprecation/deprecation
        tags: this.tags,
        timestamp: this._endTime,
        transaction: this._name,
        type: "transaction",
        sdkProcessingMetadata: {
          ...metadata,
          capturedSpanScope,
          capturedSpanIsolationScope,
          ...dropUndefinedKeys({
            dynamicSamplingContext: getDynamicSamplingContextFromSpan(this)
          })
        },
        _metrics_summary: getMetricSummaryJsonForSpan(this),
        ...source && {
          transaction_info: {
            source
          }
        }
      };
      const hasMeasurements = Object.keys(this._measurements).length > 0;
      if (hasMeasurements) {
        DEBUG_BUILD2 && logger.log(
          "[Measurements] Adding measurements to transaction",
          JSON.stringify(this._measurements, void 0, 2)
        );
        transaction.measurements = this._measurements;
      }
      DEBUG_BUILD2 && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this._name}.`);
      return transaction;
    }
  };

  // node_modules/@sentry/core/esm/tracing/idletransaction.js
  var TRACING_DEFAULTS = {
    idleTimeout: 1e3,
    finalTimeout: 3e4,
    heartbeatInterval: 5e3
  };
  var FINISH_REASON_TAG = "finishReason";
  var IDLE_TRANSACTION_FINISH_REASONS = [
    "heartbeatFailed",
    "idleTimeout",
    "documentHidden",
    "finalTimeout",
    "externalFinish",
    "cancelled"
  ];
  var IdleTransactionSpanRecorder = class extends SpanRecorder {
    constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {
      super(maxlen);
      this._pushActivity = _pushActivity;
      this._popActivity = _popActivity;
      this.transactionSpanId = transactionSpanId;
    }
    /**
     * @inheritDoc
     */
    add(span) {
      if (span.spanContext().spanId !== this.transactionSpanId) {
        const originalEnd = span.end;
        span.end = (...rest) => {
          this._popActivity(span.spanContext().spanId);
          return originalEnd.apply(span, rest);
        };
        if (spanToJSON(span).timestamp === void 0) {
          this._pushActivity(span.spanContext().spanId);
        }
      }
      super.add(span);
    }
  };
  var IdleTransaction = class extends Transaction {
    // Activities store a list of active spans
    // Track state of activities in previous heartbeat
    // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.
    // We should not use heartbeat if we finished a transaction
    // Idle timeout was canceled and we should finish the transaction with the last span end.
    /**
     * Timer that tracks Transaction idleTimeout
     */
    /**
     * @deprecated Transactions will be removed in v8. Use spans instead.
     */
    constructor(transactionContext, _idleHub, _idleTimeout = TRACING_DEFAULTS.idleTimeout, _finalTimeout = TRACING_DEFAULTS.finalTimeout, _heartbeatInterval = TRACING_DEFAULTS.heartbeatInterval, _onScope = false, delayAutoFinishUntilSignal = false) {
      super(transactionContext, _idleHub);
      this._idleHub = _idleHub;
      this._idleTimeout = _idleTimeout;
      this._finalTimeout = _finalTimeout;
      this._heartbeatInterval = _heartbeatInterval;
      this._onScope = _onScope;
      this.activities = {};
      this._heartbeatCounter = 0;
      this._finished = false;
      this._idleTimeoutCanceledPermanently = false;
      this._beforeFinishCallbacks = [];
      this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];
      this._autoFinishAllowed = !delayAutoFinishUntilSignal;
      if (_onScope) {
        DEBUG_BUILD2 && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`);
        _idleHub.getScope().setSpan(this);
      }
      if (!delayAutoFinishUntilSignal) {
        this._restartIdleTimeout();
      }
      setTimeout(() => {
        if (!this._finished) {
          this.setStatus("deadline_exceeded");
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];
          this.end();
        }
      }, this._finalTimeout);
    }
    /** {@inheritDoc} */
    end(endTimestamp) {
      const endTimestampInS = spanTimeInputToSeconds(endTimestamp);
      this._finished = true;
      this.activities = {};
      if (this.op === "ui.action.click") {
        this.setAttribute(FINISH_REASON_TAG, this._finishReason);
      }
      if (this.spanRecorder) {
        DEBUG_BUILD2 && // eslint-disable-next-line deprecation/deprecation
        logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestampInS * 1e3).toISOString(), this.op);
        for (const callback of this._beforeFinishCallbacks) {
          callback(this, endTimestampInS);
        }
        this.spanRecorder.spans = this.spanRecorder.spans.filter((span) => {
          if (span.spanContext().spanId === this.spanContext().spanId) {
            return true;
          }
          if (!spanToJSON(span).timestamp) {
            span.setStatus("cancelled");
            span.end(endTimestampInS);
            DEBUG_BUILD2 && logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
          }
          const { start_timestamp: startTime, timestamp: endTime } = spanToJSON(span);
          const spanStartedBeforeTransactionFinish = startTime && startTime < endTimestampInS;
          const timeoutWithMarginOfError = (this._finalTimeout + this._idleTimeout) / 1e3;
          const spanEndedBeforeFinalTimeout = endTime && startTime && endTime - startTime < timeoutWithMarginOfError;
          if (DEBUG_BUILD2) {
            const stringifiedSpan = JSON.stringify(span, void 0, 2);
            if (!spanStartedBeforeTransactionFinish) {
              logger.log("[Tracing] discarding Span since it happened after Transaction was finished", stringifiedSpan);
            } else if (!spanEndedBeforeFinalTimeout) {
              logger.log("[Tracing] discarding Span since it finished after Transaction final timeout", stringifiedSpan);
            }
          }
          return spanStartedBeforeTransactionFinish && spanEndedBeforeFinalTimeout;
        });
        DEBUG_BUILD2 && logger.log("[Tracing] flushing IdleTransaction");
      } else {
        DEBUG_BUILD2 && logger.log("[Tracing] No active IdleTransaction");
      }
      if (this._onScope) {
        const scope = this._idleHub.getScope();
        if (scope.getTransaction() === this) {
          scope.setSpan(void 0);
        }
      }
      return super.end(endTimestamp);
    }
    /**
     * Register a callback function that gets executed before the transaction finishes.
     * Useful for cleanup or if you want to add any additional spans based on current context.
     *
     * This is exposed because users have no other way of running something before an idle transaction
     * finishes.
     */
    registerBeforeFinishCallback(callback) {
      this._beforeFinishCallbacks.push(callback);
    }
    /**
     * @inheritDoc
     */
    initSpanRecorder(maxlen) {
      if (!this.spanRecorder) {
        const pushActivity = (id3) => {
          if (this._finished) {
            return;
          }
          this._pushActivity(id3);
        };
        const popActivity = (id3) => {
          if (this._finished) {
            return;
          }
          this._popActivity(id3);
        };
        this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanContext().spanId, maxlen);
        DEBUG_BUILD2 && logger.log("Starting heartbeat");
        this._pingHeartbeat();
      }
      this.spanRecorder.add(this);
    }
    /**
     * Cancels the existing idle timeout, if there is one.
     * @param restartOnChildSpanChange Default is `true`.
     *                                 If set to false the transaction will end
     *                                 with the last child span.
     */
    cancelIdleTimeout(endTimestamp, {
      restartOnChildSpanChange
    } = {
      restartOnChildSpanChange: true
    }) {
      this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;
      if (this._idleTimeoutID) {
        clearTimeout(this._idleTimeoutID);
        this._idleTimeoutID = void 0;
        if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];
          this.end(endTimestamp);
        }
      }
    }
    /**
     * Temporary method used to externally set the transaction's `finishReason`
     *
     * ** WARNING**
     * This is for the purpose of experimentation only and will be removed in the near future, do not use!
     *
     * @internal
     *
     */
    setFinishReason(reason) {
      this._finishReason = reason;
    }
    /**
     * Permits the IdleTransaction to automatically end itself via the idle timeout and heartbeat mechanisms when the `delayAutoFinishUntilSignal` option was set to `true`.
     */
    sendAutoFinishSignal() {
      if (!this._autoFinishAllowed) {
        DEBUG_BUILD2 && logger.log("[Tracing] Received finish signal for idle transaction.");
        this._restartIdleTimeout();
        this._autoFinishAllowed = true;
      }
    }
    /**
     * Restarts idle timeout, if there is no running idle timeout it will start one.
     */
    _restartIdleTimeout(endTimestamp) {
      this.cancelIdleTimeout();
      this._idleTimeoutID = setTimeout(() => {
        if (!this._finished && Object.keys(this.activities).length === 0) {
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];
          this.end(endTimestamp);
        }
      }, this._idleTimeout);
    }
    /**
     * Start tracking a specific activity.
     * @param spanId The span id that represents the activity
     */
    _pushActivity(spanId) {
      this.cancelIdleTimeout(void 0, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently });
      DEBUG_BUILD2 && logger.log(`[Tracing] pushActivity: ${spanId}`);
      this.activities[spanId] = true;
      DEBUG_BUILD2 && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
    }
    /**
     * Remove an activity from usage
     * @param spanId The span id that represents the activity
     */
    _popActivity(spanId) {
      if (this.activities[spanId]) {
        DEBUG_BUILD2 && logger.log(`[Tracing] popActivity ${spanId}`);
        delete this.activities[spanId];
        DEBUG_BUILD2 && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      }
      if (Object.keys(this.activities).length === 0) {
        const endTimestamp = timestampInSeconds();
        if (this._idleTimeoutCanceledPermanently) {
          if (this._autoFinishAllowed) {
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];
            this.end(endTimestamp);
          }
        } else {
          this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1e3);
        }
      }
    }
    /**
     * Checks when entries of this.activities are not changing for 3 beats.
     * If this occurs we finish the transaction.
     */
    _beat() {
      if (this._finished) {
        return;
      }
      const heartbeatString = Object.keys(this.activities).join("");
      if (heartbeatString === this._prevHeartbeatString) {
        this._heartbeatCounter++;
      } else {
        this._heartbeatCounter = 1;
      }
      this._prevHeartbeatString = heartbeatString;
      if (this._heartbeatCounter >= 3) {
        if (this._autoFinishAllowed) {
          DEBUG_BUILD2 && logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
          this.setStatus("deadline_exceeded");
          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];
          this.end();
        }
      } else {
        this._pingHeartbeat();
      }
    }
    /**
     * Pings the heartbeat
     */
    _pingHeartbeat() {
      DEBUG_BUILD2 && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);
      setTimeout(() => {
        this._beat();
      }, this._heartbeatInterval);
    }
  };

  // node_modules/@sentry/core/esm/tracing/sampling.js
  function sampleTransaction(transaction, options, samplingContext) {
    if (!hasTracingEnabled(options)) {
      transaction.sampled = false;
      return transaction;
    }
    if (transaction.sampled !== void 0) {
      transaction.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(transaction.sampled));
      return transaction;
    }
    let sampleRate;
    if (typeof options.tracesSampler === "function") {
      sampleRate = options.tracesSampler(samplingContext);
      transaction.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(sampleRate));
    } else if (samplingContext.parentSampled !== void 0) {
      sampleRate = samplingContext.parentSampled;
    } else if (typeof options.tracesSampleRate !== "undefined") {
      sampleRate = options.tracesSampleRate;
      transaction.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(sampleRate));
    } else {
      sampleRate = 1;
      transaction.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, sampleRate);
    }
    if (!isValidSampleRate(sampleRate)) {
      DEBUG_BUILD2 && logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
      transaction.sampled = false;
      return transaction;
    }
    if (!sampleRate) {
      DEBUG_BUILD2 && logger.log(
        `[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
      );
      transaction.sampled = false;
      return transaction;
    }
    transaction.sampled = Math.random() < sampleRate;
    if (!transaction.sampled) {
      DEBUG_BUILD2 && logger.log(
        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
          sampleRate
        )})`
      );
      return transaction;
    }
    DEBUG_BUILD2 && // eslint-disable-next-line deprecation/deprecation
    logger.log(`[Tracing] starting ${transaction.op} transaction - ${spanToJSON(transaction).description}`);
    return transaction;
  }
  function isValidSampleRate(rate) {
    if (isNaN2(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
      DEBUG_BUILD2 && logger.warn(
        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
          rate
        )} of type ${JSON.stringify(typeof rate)}.`
      );
      return false;
    }
    if (rate < 0 || rate > 1) {
      DEBUG_BUILD2 && logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);
      return false;
    }
    return true;
  }

  // node_modules/@sentry/core/esm/tracing/hubextensions.js
  function traceHeaders() {
    const scope = this.getScope();
    const span = scope.getSpan();
    return span ? {
      "sentry-trace": spanToTraceHeader(span)
    } : {};
  }
  function _startTransaction(transactionContext, customSamplingContext) {
    const client = this.getClient();
    const options = client && client.getOptions() || {};
    const configInstrumenter = options.instrumenter || "sentry";
    const transactionInstrumenter = transactionContext.instrumenter || "sentry";
    if (configInstrumenter !== transactionInstrumenter) {
      DEBUG_BUILD2 && logger.error(
        `A transaction was started with instrumenter=\`${transactionInstrumenter}\`, but the SDK is configured with the \`${configInstrumenter}\` instrumenter.
The transaction will not be sampled. Please use the ${configInstrumenter} instrumentation to start transactions.`
      );
      transactionContext.sampled = false;
    }
    let transaction = new Transaction(transactionContext, this);
    transaction = sampleTransaction(transaction, options, {
      name: transactionContext.name,
      parentSampled: transactionContext.parentSampled,
      transactionContext,
      attributes: {
        // eslint-disable-next-line deprecation/deprecation
        ...transactionContext.data,
        ...transactionContext.attributes
      },
      ...customSamplingContext
    });
    if (transaction.isRecording()) {
      transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
    }
    if (client && client.emit) {
      client.emit("startTransaction", transaction);
    }
    return transaction;
  }
  function startIdleTransaction(hub, transactionContext, idleTimeout, finalTimeout, onScope, customSamplingContext, heartbeatInterval, delayAutoFinishUntilSignal = false) {
    const client = hub.getClient();
    const options = client && client.getOptions() || {};
    let transaction = new IdleTransaction(
      transactionContext,
      hub,
      idleTimeout,
      finalTimeout,
      heartbeatInterval,
      onScope,
      delayAutoFinishUntilSignal
    );
    transaction = sampleTransaction(transaction, options, {
      name: transactionContext.name,
      parentSampled: transactionContext.parentSampled,
      transactionContext,
      attributes: {
        // eslint-disable-next-line deprecation/deprecation
        ...transactionContext.data,
        ...transactionContext.attributes
      },
      ...customSamplingContext
    });
    if (transaction.isRecording()) {
      transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
    }
    if (client && client.emit) {
      client.emit("startTransaction", transaction);
    }
    return transaction;
  }
  function addTracingExtensions() {
    const carrier = getMainCarrier();
    if (!carrier.__SENTRY__) {
      return;
    }
    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
    if (!carrier.__SENTRY__.extensions.startTransaction) {
      carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
    }
    if (!carrier.__SENTRY__.extensions.traceHeaders) {
      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
    }
    registerErrorInstrumentation();
  }

  // node_modules/@sentry/core/esm/tracing/measurement.js
  function setMeasurement(name, value, unit2) {
    const transaction = getActiveTransaction();
    if (transaction) {
      transaction.setMeasurement(name, value, unit2);
    }
  }

  // node_modules/@sentry/core/esm/envelope.js
  function enhanceEventWithSdkInfo(event, sdkInfo) {
    if (!sdkInfo) {
      return event;
    }
    event.sdk = event.sdk || {};
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
    event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
    return event;
  }
  function createSessionEnvelope(session, dsn, metadata, tunnel) {
    const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
    const envelopeHeaders = {
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...sdkInfo && { sdk: sdkInfo },
      ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
    };
    const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
    return createEnvelope(envelopeHeaders, [envelopeItem]);
  }
  function createEventEnvelope(event, dsn, metadata, tunnel) {
    const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
    const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
    enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
    const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
    delete event.sdkProcessingMetadata;
    const eventItem = [{ type: eventType }, event];
    return createEnvelope(envelopeHeaders, [eventItem]);
  }

  // node_modules/@sentry/core/esm/api.js
  var SENTRY_API_VERSION = "7";
  function getBaseApiEndpoint(dsn) {
    const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
    const port = dsn.port ? `:${dsn.port}` : "";
    return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
  }
  function _getIngestEndpoint(dsn) {
    return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
  }
  function _encodedAuth(dsn, sdkInfo) {
    return urlEncode({
      // We send only the minimum set of required information. See
      // https://github.com/getsentry/sentry-javascript/issues/2572.
      sentry_key: dsn.publicKey,
      sentry_version: SENTRY_API_VERSION,
      ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
    });
  }
  function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnelOrOptions = {}) {
    const tunnel = typeof tunnelOrOptions === "string" ? tunnelOrOptions : tunnelOrOptions.tunnel;
    const sdkInfo = typeof tunnelOrOptions === "string" || !tunnelOrOptions._metadata ? void 0 : tunnelOrOptions._metadata.sdk;
    return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
  }

  // node_modules/@sentry/core/esm/integration.js
  var installedIntegrations = [];
  function filterDuplicates(integrations) {
    const integrationsByName = {};
    integrations.forEach((currentInstance) => {
      const { name } = currentInstance;
      const existingInstance = integrationsByName[name];
      if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
        return;
      }
      integrationsByName[name] = currentInstance;
    });
    return Object.keys(integrationsByName).map((k) => integrationsByName[k]);
  }
  function getIntegrationsToSetup(options) {
    const defaultIntegrations2 = options.defaultIntegrations || [];
    const userIntegrations = options.integrations;
    defaultIntegrations2.forEach((integration) => {
      integration.isDefaultInstance = true;
    });
    let integrations;
    if (Array.isArray(userIntegrations)) {
      integrations = [...defaultIntegrations2, ...userIntegrations];
    } else if (typeof userIntegrations === "function") {
      integrations = arrayify(userIntegrations(defaultIntegrations2));
    } else {
      integrations = defaultIntegrations2;
    }
    const finalIntegrations = filterDuplicates(integrations);
    const debugIndex = findIndex(finalIntegrations, (integration) => integration.name === "Debug");
    if (debugIndex !== -1) {
      const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
      finalIntegrations.push(debugInstance);
    }
    return finalIntegrations;
  }
  function setupIntegrations(client, integrations) {
    const integrationIndex = {};
    integrations.forEach((integration) => {
      if (integration) {
        setupIntegration(client, integration, integrationIndex);
      }
    });
    return integrationIndex;
  }
  function afterSetupIntegrations(client, integrations) {
    for (const integration of integrations) {
      if (integration && integration.afterAllSetup) {
        integration.afterAllSetup(client);
      }
    }
  }
  function setupIntegration(client, integration, integrationIndex) {
    if (integrationIndex[integration.name]) {
      DEBUG_BUILD2 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
      return;
    }
    integrationIndex[integration.name] = integration;
    if (installedIntegrations.indexOf(integration.name) === -1) {
      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
      installedIntegrations.push(integration.name);
    }
    if (integration.setup && typeof integration.setup === "function") {
      integration.setup(client);
    }
    if (client.on && typeof integration.preprocessEvent === "function") {
      const callback = integration.preprocessEvent.bind(integration);
      client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
    }
    if (client.addEventProcessor && typeof integration.processEvent === "function") {
      const callback = integration.processEvent.bind(integration);
      const processor = Object.assign((event, hint) => callback(event, hint, client), {
        id: integration.name
      });
      client.addEventProcessor(processor);
    }
    DEBUG_BUILD2 && logger.log(`Integration installed: ${integration.name}`);
  }
  function findIndex(arr, callback) {
    for (let i = 0; i < arr.length; i++) {
      if (callback(arr[i]) === true) {
        return i;
      }
    }
    return -1;
  }
  function convertIntegrationFnToClass(name, fn2) {
    return Object.assign(
      function ConvertedIntegration(...args) {
        return fn2(...args);
      },
      { id: name }
    );
  }
  function defineIntegration(fn2) {
    return fn2;
  }

  // node_modules/@sentry/core/esm/metrics/utils.js
  function serializeMetricBuckets(metricBucketItems) {
    let out = "";
    for (const item of metricBucketItems) {
      const tagEntries = Object.entries(item.tags);
      const maybeTags = tagEntries.length > 0 ? `|#${tagEntries.map(([key, value]) => `${key}:${value}`).join(",")}` : "";
      out += `${item.name}@${item.unit}:${item.metric}|${item.metricType}${maybeTags}|T${item.timestamp}
`;
    }
    return out;
  }

  // node_modules/@sentry/core/esm/metrics/envelope.js
  function createMetricEnvelope(metricBucketItems, dsn, metadata, tunnel) {
    const headers = {
      sent_at: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (metadata && metadata.sdk) {
      headers.sdk = {
        name: metadata.sdk.name,
        version: metadata.sdk.version
      };
    }
    if (!!tunnel && dsn) {
      headers.dsn = dsnToString(dsn);
    }
    const item = createMetricEnvelopeItem(metricBucketItems);
    return createEnvelope(headers, [item]);
  }
  function createMetricEnvelopeItem(metricBucketItems) {
    const payload = serializeMetricBuckets(metricBucketItems);
    const metricHeaders = {
      type: "statsd",
      length: payload.length
    };
    return [metricHeaders, payload];
  }

  // node_modules/@sentry/core/esm/baseclient.js
  var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
  var BaseClient = class {
    /**
     * A reference to a metrics aggregator
     *
     * @experimental Note this is alpha API. It may experience breaking changes in the future.
     */
    /** Options passed to the SDK. */
    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
    /** Array of set up integrations. */
    /** Indicates whether this client's integrations have been set up. */
    /** Number of calls being processed */
    /** Holds flushable  */
    // eslint-disable-next-line @typescript-eslint/ban-types
    /**
     * Initializes this client instance.
     *
     * @param options Options for the client.
     */
    constructor(options) {
      this._options = options;
      this._integrations = {};
      this._integrationsInitialized = false;
      this._numProcessing = 0;
      this._outcomes = {};
      this._hooks = {};
      this._eventProcessors = [];
      if (options.dsn) {
        this._dsn = makeDsn(options.dsn);
      } else {
        DEBUG_BUILD2 && logger.warn("No DSN provided, client will not send events.");
      }
      if (this._dsn) {
        const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
        this._transport = options.transport({
          recordDroppedEvent: this.recordDroppedEvent.bind(this),
          ...options.transportOptions,
          url
        });
      }
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    captureException(exception, hint, scope) {
      if (checkOrSetAlreadyCaught(exception)) {
        DEBUG_BUILD2 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      let eventId = hint && hint.event_id;
      this._process(
        this.eventFromException(exception, hint).then((event) => this._captureEvent(event, hint, scope)).then((result) => {
          eventId = result;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureMessage(message, level, hint, scope) {
      let eventId = hint && hint.event_id;
      const eventMessage = isParameterizedString(message) ? message : String(message);
      const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hint) : this.eventFromException(message, hint);
      this._process(
        promisedEvent.then((event) => this._captureEvent(event, hint, scope)).then((result) => {
          eventId = result;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureEvent(event, hint, scope) {
      if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
        DEBUG_BUILD2 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      let eventId = hint && hint.event_id;
      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
      const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
      this._process(
        this._captureEvent(event, hint, capturedSpanScope || scope).then((result) => {
          eventId = result;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureSession(session) {
      if (!(typeof session.release === "string")) {
        DEBUG_BUILD2 && logger.warn("Discarded session because of missing or non-string release");
      } else {
        this.sendSession(session);
        updateSession(session, { init: false });
      }
    }
    /**
     * @inheritDoc
     */
    getDsn() {
      return this._dsn;
    }
    /**
     * @inheritDoc
     */
    getOptions() {
      return this._options;
    }
    /**
     * @see SdkMetadata in @sentry/types
     *
     * @return The metadata of the SDK
     */
    getSdkMetadata() {
      return this._options._metadata;
    }
    /**
     * @inheritDoc
     */
    getTransport() {
      return this._transport;
    }
    /**
     * @inheritDoc
     */
    flush(timeout) {
      const transport = this._transport;
      if (transport) {
        if (this.metricsAggregator) {
          this.metricsAggregator.flush();
        }
        return this._isClientDoneProcessing(timeout).then((clientFinished) => {
          return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
        });
      } else {
        return resolvedSyncPromise(true);
      }
    }
    /**
     * @inheritDoc
     */
    close(timeout) {
      return this.flush(timeout).then((result) => {
        this.getOptions().enabled = false;
        if (this.metricsAggregator) {
          this.metricsAggregator.close();
        }
        return result;
      });
    }
    /** Get all installed event processors. */
    getEventProcessors() {
      return this._eventProcessors;
    }
    /** @inheritDoc */
    addEventProcessor(eventProcessor) {
      this._eventProcessors.push(eventProcessor);
    }
    /**
     * This is an internal function to setup all integrations that should run on the client.
     * @deprecated Use `client.init()` instead.
     */
    setupIntegrations(forceInitialize) {
      if (forceInitialize && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) {
        this._setupIntegrations();
      }
    }
    /** @inheritdoc */
    init() {
      if (this._isEnabled()) {
        this._setupIntegrations();
      }
    }
    /**
     * Gets an installed integration by its `id`.
     *
     * @returns The installed integration or `undefined` if no integration with that `id` was installed.
     * @deprecated Use `getIntegrationByName()` instead.
     */
    getIntegrationById(integrationId) {
      return this.getIntegrationByName(integrationId);
    }
    /**
     * Gets an installed integration by its name.
     *
     * @returns The installed integration or `undefined` if no integration with that `name` was installed.
     */
    getIntegrationByName(integrationName) {
      return this._integrations[integrationName];
    }
    /**
     * Returns the client's instance of the given integration class, it any.
     * @deprecated Use `getIntegrationByName()` instead.
     */
    getIntegration(integration) {
      try {
        return this._integrations[integration.id] || null;
      } catch (_oO) {
        DEBUG_BUILD2 && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);
        return null;
      }
    }
    /**
     * @inheritDoc
     */
    addIntegration(integration) {
      const isAlreadyInstalled = this._integrations[integration.name];
      setupIntegration(this, integration, this._integrations);
      if (!isAlreadyInstalled) {
        afterSetupIntegrations(this, [integration]);
      }
    }
    /**
     * @inheritDoc
     */
    sendEvent(event, hint = {}) {
      this.emit("beforeSendEvent", event, hint);
      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
      for (const attachment of hint.attachments || []) {
        env = addItemToEnvelope(
          env,
          createAttachmentEnvelopeItem(
            attachment,
            this._options.transportOptions && this._options.transportOptions.textEncoder
          )
        );
      }
      const promise = this._sendEnvelope(env);
      if (promise) {
        promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
      }
    }
    /**
     * @inheritDoc
     */
    sendSession(session) {
      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(env);
    }
    /**
     * @inheritDoc
     */
    recordDroppedEvent(reason, category, _event) {
      if (this._options.sendClientReports) {
        const key = `${reason}:${category}`;
        DEBUG_BUILD2 && logger.log(`Adding outcome: "${key}"`);
        this._outcomes[key] = this._outcomes[key] + 1 || 1;
      }
    }
    /**
     * @inheritDoc
     */
    captureAggregateMetrics(metricBucketItems) {
      DEBUG_BUILD2 && logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);
      const metricsEnvelope = createMetricEnvelope(
        metricBucketItems,
        this._dsn,
        this._options._metadata,
        this._options.tunnel
      );
      this._sendEnvelope(metricsEnvelope);
    }
    // Keep on() & emit() signatures in sync with types' client.ts interface
    /* eslint-disable @typescript-eslint/unified-signatures */
    /** @inheritdoc */
    /** @inheritdoc */
    on(hook, callback) {
      if (!this._hooks[hook]) {
        this._hooks[hook] = [];
      }
      this._hooks[hook].push(callback);
    }
    /** @inheritdoc */
    /** @inheritdoc */
    emit(hook, ...rest) {
      if (this._hooks[hook]) {
        this._hooks[hook].forEach((callback) => callback(...rest));
      }
    }
    /* eslint-enable @typescript-eslint/unified-signatures */
    /** Setup integrations for this client. */
    _setupIntegrations() {
      const { integrations } = this._options;
      this._integrations = setupIntegrations(this, integrations);
      afterSetupIntegrations(this, integrations);
      this._integrationsInitialized = true;
    }
    /** Updates existing session based on the provided event */
    _updateSessionFromEvent(session, event) {
      let crashed = false;
      let errored = false;
      const exceptions = event.exception && event.exception.values;
      if (exceptions) {
        errored = true;
        for (const ex of exceptions) {
          const mechanism = ex.mechanism;
          if (mechanism && mechanism.handled === false) {
            crashed = true;
            break;
          }
        }
      }
      const sessionNonTerminal = session.status === "ok";
      const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
      if (shouldUpdateAndSend) {
        updateSession(session, {
          ...crashed && { status: "crashed" },
          errors: session.errors || Number(errored || crashed)
        });
        this.captureSession(session);
      }
    }
    /**
     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
     * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
     * `false` otherwise
     */
    _isClientDoneProcessing(timeout) {
      return new SyncPromise((resolve) => {
        let ticked = 0;
        const tick = 1;
        const interval = setInterval(() => {
          if (this._numProcessing == 0) {
            clearInterval(interval);
            resolve(true);
          } else {
            ticked += tick;
            if (timeout && ticked >= timeout) {
              clearInterval(interval);
              resolve(false);
            }
          }
        }, tick);
      });
    }
    /** Determines whether this SDK is enabled and a transport is present. */
    _isEnabled() {
      return this.getOptions().enabled !== false && this._transport !== void 0;
    }
    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     */
    _prepareEvent(event, hint, scope, isolationScope = getIsolationScope()) {
      const options = this.getOptions();
      const integrations = Object.keys(this._integrations);
      if (!hint.integrations && integrations.length > 0) {
        hint.integrations = integrations;
      }
      this.emit("preprocessEvent", event, hint);
      return prepareEvent(options, event, hint, scope, this, isolationScope).then((evt) => {
        if (evt === null) {
          return evt;
        }
        const propagationContext = {
          ...isolationScope.getPropagationContext(),
          ...scope ? scope.getPropagationContext() : void 0
        };
        const trace2 = evt.contexts && evt.contexts.trace;
        if (!trace2 && propagationContext) {
          const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;
          evt.contexts = {
            trace: {
              trace_id,
              span_id: spanId,
              parent_span_id: parentSpanId
            },
            ...evt.contexts
          };
          const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this, scope);
          evt.sdkProcessingMetadata = {
            dynamicSamplingContext,
            ...evt.sdkProcessingMetadata
          };
        }
        return evt;
      });
    }
    /**
     * Processes the event and logs an error in case of rejection
     * @param event
     * @param hint
     * @param scope
     */
    _captureEvent(event, hint = {}, scope) {
      return this._processEvent(event, hint, scope).then(
        (finalEvent) => {
          return finalEvent.event_id;
        },
        (reason) => {
          if (DEBUG_BUILD2) {
            const sentryError = reason;
            if (sentryError.logLevel === "log") {
              logger.log(sentryError.message);
            } else {
              logger.warn(sentryError);
            }
          }
          return void 0;
        }
      );
    }
    /**
     * Processes an event (either error or message) and sends it to Sentry.
     *
     * This also adds breadcrumbs and context information to the event. However,
     * platform specific meta data (such as the User's IP address) must be added
     * by the SDK implementor.
     *
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
     */
    _processEvent(event, hint, scope) {
      const options = this.getOptions();
      const { sampleRate } = options;
      const isTransaction = isTransactionEvent(event);
      const isError2 = isErrorEvent2(event);
      const eventType = event.type || "error";
      const beforeSendLabel = `before send for type \`${eventType}\``;
      if (isError2 && typeof sampleRate === "number" && Math.random() > sampleRate) {
        this.recordDroppedEvent("sample_rate", "error", event);
        return rejectedSyncPromise(
          new SentryError(
            `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
            "log"
          )
        );
      }
      const dataCategory = eventType === "replay_event" ? "replay" : eventType;
      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
      const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
      return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope).then((prepared) => {
        if (prepared === null) {
          this.recordDroppedEvent("event_processor", dataCategory, event);
          throw new SentryError("An event processor returned `null`, will not send event.", "log");
        }
        const isInternalException = hint.data && hint.data.__sentry__ === true;
        if (isInternalException) {
          return prepared;
        }
        const result = processBeforeSend(options, prepared, hint);
        return _validateBeforeSendResult(result, beforeSendLabel);
      }).then((processedEvent) => {
        if (processedEvent === null) {
          this.recordDroppedEvent("before_send", dataCategory, event);
          throw new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
        }
        const session = scope && scope.getSession();
        if (!isTransaction && session) {
          this._updateSessionFromEvent(session, processedEvent);
        }
        const transactionInfo = processedEvent.transaction_info;
        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
          const source = "custom";
          processedEvent.transaction_info = {
            ...transactionInfo,
            source
          };
        }
        this.sendEvent(processedEvent, hint);
        return processedEvent;
      }).then(null, (reason) => {
        if (reason instanceof SentryError) {
          throw reason;
        }
        this.captureException(reason, {
          data: {
            __sentry__: true
          },
          originalException: reason
        });
        throw new SentryError(
          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
        );
      });
    }
    /**
     * Occupies the client with processing and event
     */
    _process(promise) {
      this._numProcessing++;
      void promise.then(
        (value) => {
          this._numProcessing--;
          return value;
        },
        (reason) => {
          this._numProcessing--;
          return reason;
        }
      );
    }
    /**
     * @inheritdoc
     */
    _sendEnvelope(envelope) {
      this.emit("beforeEnvelope", envelope);
      if (this._isEnabled() && this._transport) {
        return this._transport.send(envelope).then(null, (reason) => {
          DEBUG_BUILD2 && logger.error("Error while sending event:", reason);
        });
      } else {
        DEBUG_BUILD2 && logger.error("Transport disabled");
      }
    }
    /**
     * Clears outcomes on this client and returns them.
     */
    _clearOutcomes() {
      const outcomes = this._outcomes;
      this._outcomes = {};
      return Object.keys(outcomes).map((key) => {
        const [reason, category] = key.split(":");
        return {
          reason,
          category,
          quantity: outcomes[key]
        };
      });
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  };
  function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
    const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
    if (isThenable(beforeSendResult)) {
      return beforeSendResult.then(
        (event) => {
          if (!isPlainObject(event) && event !== null) {
            throw new SentryError(invalidValueError);
          }
          return event;
        },
        (e3) => {
          throw new SentryError(`${beforeSendLabel} rejected with ${e3}`);
        }
      );
    } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {
      throw new SentryError(invalidValueError);
    }
    return beforeSendResult;
  }
  function processBeforeSend(options, event, hint) {
    const { beforeSend, beforeSendTransaction } = options;
    if (isErrorEvent2(event) && beforeSend) {
      return beforeSend(event, hint);
    }
    if (isTransactionEvent(event) && beforeSendTransaction) {
      return beforeSendTransaction(event, hint);
    }
    return event;
  }
  function isErrorEvent2(event) {
    return event.type === void 0;
  }
  function isTransactionEvent(event) {
    return event.type === "transaction";
  }
  function addEventProcessor(callback) {
    const client = getClient();
    if (!client || !client.addEventProcessor) {
      return;
    }
    client.addEventProcessor(callback);
  }

  // node_modules/@sentry/core/esm/sdk.js
  function initAndBind(clientClass, options) {
    if (options.debug === true) {
      if (DEBUG_BUILD2) {
        logger.enable();
      } else {
        consoleSandbox(() => {
          console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
        });
      }
    }
    const scope = getCurrentScope();
    scope.update(options.initialScope);
    const client = new clientClass(options);
    setCurrentClient(client);
    initializeClient(client);
  }
  function setCurrentClient(client) {
    const hub = getCurrentHub();
    const top2 = hub.getStackTop();
    top2.client = client;
    top2.scope.setClient(client);
  }
  function initializeClient(client) {
    if (client.init) {
      client.init();
    } else if (client.setupIntegrations) {
      client.setupIntegrations();
    }
  }

  // node_modules/@sentry/core/esm/transports/base.js
  var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
  function createTransport(options, makeRequest, buffer = makePromiseBuffer(
    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
  )) {
    let rateLimits = {};
    const flush2 = (timeout) => buffer.drain(timeout);
    function send(envelope) {
      const filteredEnvelopeItems = [];
      forEachEnvelopeItem(envelope, (item, type) => {
        const dataCategory = envelopeItemTypeToDataCategory(type);
        if (isRateLimited(rateLimits, dataCategory)) {
          const event = getEventForEnvelopeItem(item, type);
          options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
        } else {
          filteredEnvelopeItems.push(item);
        }
      });
      if (filteredEnvelopeItems.length === 0) {
        return resolvedSyncPromise();
      }
      const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
      const recordEnvelopeLoss = (reason) => {
        forEachEnvelopeItem(filteredEnvelope, (item, type) => {
          const event = getEventForEnvelopeItem(item, type);
          options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);
        });
      };
      const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
        (response) => {
          if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
            DEBUG_BUILD2 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
          }
          rateLimits = updateRateLimits(rateLimits, response);
          return response;
        },
        (error2) => {
          recordEnvelopeLoss("network_error");
          throw error2;
        }
      );
      return buffer.add(requestTask).then(
        (result) => result,
        (error2) => {
          if (error2 instanceof SentryError) {
            DEBUG_BUILD2 && logger.error("Skipped sending event because buffer is full.");
            recordEnvelopeLoss("queue_overflow");
            return resolvedSyncPromise();
          } else {
            throw error2;
          }
        }
      );
    }
    send.__sentry__baseTransport__ = true;
    return {
      send,
      flush: flush2
    };
  }
  function getEventForEnvelopeItem(item, type) {
    if (type !== "event" && type !== "transaction") {
      return void 0;
    }
    return Array.isArray(item) ? item[1] : void 0;
  }

  // node_modules/@sentry/core/esm/span.js
  function createSpanEnvelope(spans, dsn) {
    const headers = {
      sent_at: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (dsn) {
      headers.dsn = dsnToString(dsn);
    }
    const items = spans.map(createSpanItem);
    return createEnvelope(headers, items);
  }
  function createSpanItem(span) {
    const spanHeaders = {
      type: "span"
    };
    return [spanHeaders, span];
  }

  // node_modules/@sentry/core/esm/utils/isSentryRequestUrl.js
  function isSentryRequestUrl(url, hubOrClient) {
    const client = hubOrClient && isHub(hubOrClient) ? (
      // eslint-disable-next-line deprecation/deprecation
      hubOrClient.getClient()
    ) : hubOrClient;
    const dsn = client && client.getDsn();
    const tunnel = client && client.getOptions().tunnel;
    return checkDsn(url, dsn) || checkTunnel(url, tunnel);
  }
  function checkTunnel(url, tunnel) {
    if (!tunnel) {
      return false;
    }
    return removeTrailingSlash(url) === removeTrailingSlash(tunnel);
  }
  function checkDsn(url, dsn) {
    return dsn ? url.includes(dsn.host) : false;
  }
  function removeTrailingSlash(str) {
    return str[str.length - 1] === "/" ? str.slice(0, -1) : str;
  }
  function isHub(hubOrClient) {
    return hubOrClient.getClient !== void 0;
  }

  // node_modules/@sentry/core/esm/utils/sdkMetadata.js
  function applySdkMetadata(options, name, names = [name], source = "npm") {
    const metadata = options._metadata || {};
    if (!metadata.sdk) {
      metadata.sdk = {
        name: `sentry.javascript.${name}`,
        packages: names.map((name2) => ({
          name: `${source}:@sentry/${name2}`,
          version: SDK_VERSION
        })),
        version: SDK_VERSION
      };
    }
    options._metadata = metadata;
  }

  // node_modules/@sentry/core/esm/integrations/inboundfilters.js
  var DEFAULT_IGNORE_ERRORS = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/
  ];
  var DEFAULT_IGNORE_TRANSACTIONS = [
    /^.*\/healthcheck$/,
    /^.*\/healthy$/,
    /^.*\/live$/,
    /^.*\/ready$/,
    /^.*\/heartbeat$/,
    /^.*\/health$/,
    /^.*\/healthz$/
  ];
  var INTEGRATION_NAME = "InboundFilters";
  var _inboundFiltersIntegration = (options = {}) => {
    return {
      name: INTEGRATION_NAME,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      processEvent(event, _hint, client) {
        const clientOptions = client.getOptions();
        const mergedOptions = _mergeOptions(options, clientOptions);
        return _shouldDropEvent(event, mergedOptions) ? null : event;
      }
    };
  };
  var inboundFiltersIntegration = defineIntegration(_inboundFiltersIntegration);
  var InboundFilters = convertIntegrationFnToClass(
    INTEGRATION_NAME,
    inboundFiltersIntegration
  );
  function _mergeOptions(internalOptions = {}, clientOptions = {}) {
    return {
      allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
      denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
      ignoreErrors: [
        ...internalOptions.ignoreErrors || [],
        ...clientOptions.ignoreErrors || [],
        ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
      ],
      ignoreTransactions: [
        ...internalOptions.ignoreTransactions || [],
        ...clientOptions.ignoreTransactions || [],
        ...internalOptions.disableTransactionDefaults ? [] : DEFAULT_IGNORE_TRANSACTIONS
      ],
      ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
    };
  }
  function _shouldDropEvent(event, options) {
    if (options.ignoreInternal && _isSentryError(event)) {
      DEBUG_BUILD2 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(event)}`);
      return true;
    }
    if (_isIgnoredError(event, options.ignoreErrors)) {
      DEBUG_BUILD2 && logger.warn(
        `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
      DEBUG_BUILD2 && logger.warn(
        `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      DEBUG_BUILD2 && logger.warn(
        `Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      DEBUG_BUILD2 && logger.warn(
        `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
    return false;
  }
  function _isIgnoredError(event, ignoreErrors) {
    if (event.type || !ignoreErrors || !ignoreErrors.length) {
      return false;
    }
    return _getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
  }
  function _isIgnoredTransaction(event, ignoreTransactions) {
    if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
      return false;
    }
    const name = event.transaction;
    return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
  }
  function _isDeniedUrl(event, denyUrls) {
    if (!denyUrls || !denyUrls.length) {
      return false;
    }
    const url = _getEventFilterUrl(event);
    return !url ? false : stringMatchesSomePattern(url, denyUrls);
  }
  function _isAllowedUrl(event, allowUrls) {
    if (!allowUrls || !allowUrls.length) {
      return true;
    }
    const url = _getEventFilterUrl(event);
    return !url ? true : stringMatchesSomePattern(url, allowUrls);
  }
  function _getPossibleEventMessages(event) {
    const possibleMessages = [];
    if (event.message) {
      possibleMessages.push(event.message);
    }
    let lastException;
    try {
      lastException = event.exception.values[event.exception.values.length - 1];
    } catch (e3) {
    }
    if (lastException) {
      if (lastException.value) {
        possibleMessages.push(lastException.value);
        if (lastException.type) {
          possibleMessages.push(`${lastException.type}: ${lastException.value}`);
        }
      }
    }
    if (DEBUG_BUILD2 && possibleMessages.length === 0) {
      logger.error(`Could not extract message for event ${getEventDescription(event)}`);
    }
    return possibleMessages;
  }
  function _isSentryError(event) {
    try {
      return event.exception.values[0].type === "SentryError";
    } catch (e3) {
    }
    return false;
  }
  function _getLastValidUrl(frames = []) {
    for (let i = frames.length - 1; i >= 0; i--) {
      const frame2 = frames[i];
      if (frame2 && frame2.filename !== "<anonymous>" && frame2.filename !== "[native code]") {
        return frame2.filename || null;
      }
    }
    return null;
  }
  function _getEventFilterUrl(event) {
    try {
      let frames;
      try {
        frames = event.exception.values[0].stacktrace.frames;
      } catch (e3) {
      }
      return frames ? _getLastValidUrl(frames) : null;
    } catch (oO) {
      DEBUG_BUILD2 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
      return null;
    }
  }

  // node_modules/@sentry/core/esm/integrations/functiontostring.js
  var originalFunctionToString;
  var INTEGRATION_NAME2 = "FunctionToString";
  var SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
  var _functionToStringIntegration = () => {
    return {
      name: INTEGRATION_NAME2,
      setupOnce() {
        originalFunctionToString = Function.prototype.toString;
        try {
          Function.prototype.toString = function(...args) {
            const originalFunction = getOriginalFunction(this);
            const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;
            return originalFunctionToString.apply(context, args);
          };
        } catch (e3) {
        }
      },
      setup(client) {
        SETUP_CLIENTS.set(client, true);
      }
    };
  };
  var functionToStringIntegration = defineIntegration(_functionToStringIntegration);
  var FunctionToString = convertIntegrationFnToClass(
    INTEGRATION_NAME2,
    functionToStringIntegration
  );

  // node_modules/@sentry/core/esm/integrations/linkederrors.js
  var DEFAULT_KEY = "cause";
  var DEFAULT_LIMIT = 5;
  var INTEGRATION_NAME3 = "LinkedErrors";
  var _linkedErrorsIntegration = (options = {}) => {
    const limit = options.limit || DEFAULT_LIMIT;
    const key = options.key || DEFAULT_KEY;
    return {
      name: INTEGRATION_NAME3,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      preprocessEvent(event, hint, client) {
        const options2 = client.getOptions();
        applyAggregateErrorsToEvent(
          exceptionFromError,
          options2.stackParser,
          options2.maxValueLength,
          key,
          limit,
          event,
          hint
        );
      }
    };
  };
  var linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);
  var LinkedErrors = convertIntegrationFnToClass(INTEGRATION_NAME3, linkedErrorsIntegration);

  // node_modules/@sentry/core/esm/integrations/index.js
  var integrations_exports = {};
  __export(integrations_exports, {
    FunctionToString: () => FunctionToString,
    InboundFilters: () => InboundFilters,
    LinkedErrors: () => LinkedErrors
  });

  // node_modules/@sentry/core/esm/index.js
  var Integrations = integrations_exports;

  // node_modules/@sentry-internal/tracing/esm/common/debug-build.js
  var DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

  // node_modules/@sentry-internal/tracing/esm/browser/types.js
  var WINDOW7 = GLOBAL_OBJ;

  // node_modules/@sentry-internal/tracing/esm/browser/backgroundtab.js
  function registerBackgroundTabDetection() {
    if (WINDOW7.document) {
      WINDOW7.document.addEventListener("visibilitychange", () => {
        const activeTransaction = getActiveTransaction();
        if (WINDOW7.document.hidden && activeTransaction) {
          const statusType = "cancelled";
          const { op, status } = spanToJSON(activeTransaction);
          DEBUG_BUILD3 && logger.log(`[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${op}`);
          if (!status) {
            activeTransaction.setStatus(statusType);
          }
          activeTransaction.setTag("visibilitychange", "document.hidden");
          activeTransaction.end();
        }
      });
    } else {
      DEBUG_BUILD3 && logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
    }
  }

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/bindReporter.js
  var bindReporter = (callback, metric, reportAllChanges) => {
    let prevValue;
    let delta;
    return (forceReport) => {
      if (metric.value >= 0) {
        if (forceReport || reportAllChanges) {
          delta = metric.value - (prevValue || 0);
          if (delta || prevValue === void 0) {
            prevValue = metric.value;
            metric.delta = delta;
            callback(metric);
          }
        }
      }
    };
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/generateUniqueID.js
  var generateUniqueID = () => {
    return `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/getNavigationEntry.js
  var getNavigationEntryFromPerformanceTiming = () => {
    const timing = WINDOW7.performance.timing;
    const type = WINDOW7.performance.navigation.type;
    const navigationEntry = {
      entryType: "navigation",
      startTime: 0,
      type: type == 2 ? "back_forward" : type === 1 ? "reload" : "navigate"
    };
    for (const key in timing) {
      if (key !== "navigationStart" && key !== "toJSON") {
        navigationEntry[key] = Math.max(timing[key] - timing.navigationStart, 0);
      }
    }
    return navigationEntry;
  };
  var getNavigationEntry = () => {
    if (WINDOW7.__WEB_VITALS_POLYFILL__) {
      return WINDOW7.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || getNavigationEntryFromPerformanceTiming());
    } else {
      return WINDOW7.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
    }
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/getActivationStart.js
  var getActivationStart = () => {
    const navEntry = getNavigationEntry();
    return navEntry && navEntry.activationStart || 0;
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/initMetric.js
  var initMetric = (name, value) => {
    const navEntry = getNavigationEntry();
    let navigationType = "navigate";
    if (navEntry) {
      if (WINDOW7.document && WINDOW7.document.prerendering || getActivationStart() > 0) {
        navigationType = "prerender";
      } else {
        navigationType = navEntry.type.replace(/_/g, "-");
      }
    }
    return {
      name,
      value: typeof value === "undefined" ? -1 : value,
      rating: "good",
      // Will be updated if the value changes.
      delta: 0,
      entries: [],
      id: generateUniqueID(),
      navigationType
    };
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/observe.js
  var observe = (type, callback, opts) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(type)) {
        const po2 = new PerformanceObserver((list2) => {
          callback(list2.getEntries());
        });
        po2.observe(
          Object.assign(
            {
              type,
              buffered: true
            },
            opts || {}
          )
        );
        return po2;
      }
    } catch (e3) {
    }
    return;
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/onHidden.js
  var onHidden = (cb, once2) => {
    const onHiddenOrPageHide = (event) => {
      if (event.type === "pagehide" || WINDOW7.document.visibilityState === "hidden") {
        cb(event);
        if (once2) {
          removeEventListener("visibilitychange", onHiddenOrPageHide, true);
          removeEventListener("pagehide", onHiddenOrPageHide, true);
        }
      }
    };
    if (WINDOW7.document) {
      addEventListener("visibilitychange", onHiddenOrPageHide, true);
      addEventListener("pagehide", onHiddenOrPageHide, true);
    }
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/getCLS.js
  var onCLS = (onReport) => {
    const metric = initMetric("CLS", 0);
    let report;
    let sessionValue = 0;
    let sessionEntries = [];
    const handleEntries = (entries) => {
      entries.forEach((entry) => {
        if (!entry.hadRecentInput) {
          const firstSessionEntry = sessionEntries[0];
          const lastSessionEntry = sessionEntries[sessionEntries.length - 1];
          if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
            sessionValue += entry.value;
            sessionEntries.push(entry);
          } else {
            sessionValue = entry.value;
            sessionEntries = [entry];
          }
          if (sessionValue > metric.value) {
            metric.value = sessionValue;
            metric.entries = sessionEntries;
            if (report) {
              report();
            }
          }
        }
      });
    };
    const po2 = observe("layout-shift", handleEntries);
    if (po2) {
      report = bindReporter(onReport, metric);
      const stopListening = () => {
        handleEntries(po2.takeRecords());
        report(true);
      };
      onHidden(stopListening);
      return stopListening;
    }
    return;
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js
  var firstHiddenTime = -1;
  var initHiddenTime = () => {
    if (WINDOW7.document && WINDOW7.document.visibilityState) {
      firstHiddenTime = WINDOW7.document.visibilityState === "hidden" && !WINDOW7.document.prerendering ? 0 : Infinity;
    }
  };
  var trackChanges = () => {
    onHidden(({ timeStamp }) => {
      firstHiddenTime = timeStamp;
    }, true);
  };
  var getVisibilityWatcher = () => {
    if (firstHiddenTime < 0) {
      initHiddenTime();
      trackChanges();
    }
    return {
      get firstHiddenTime() {
        return firstHiddenTime;
      }
    };
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/getFID.js
  var onFID = (onReport) => {
    const visibilityWatcher = getVisibilityWatcher();
    const metric = initMetric("FID");
    let report;
    const handleEntry = (entry) => {
      if (entry.startTime < visibilityWatcher.firstHiddenTime) {
        metric.value = entry.processingStart - entry.startTime;
        metric.entries.push(entry);
        report(true);
      }
    };
    const handleEntries = (entries) => {
      entries.forEach(handleEntry);
    };
    const po2 = observe("first-input", handleEntries);
    report = bindReporter(onReport, metric);
    if (po2) {
      onHidden(() => {
        handleEntries(po2.takeRecords());
        po2.disconnect();
      }, true);
    }
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/lib/polyfills/interactionCountPolyfill.js
  var interactionCountEstimate = 0;
  var minKnownInteractionId = Infinity;
  var maxKnownInteractionId = 0;
  var updateEstimate = (entries) => {
    entries.forEach((e3) => {
      if (e3.interactionId) {
        minKnownInteractionId = Math.min(minKnownInteractionId, e3.interactionId);
        maxKnownInteractionId = Math.max(maxKnownInteractionId, e3.interactionId);
        interactionCountEstimate = maxKnownInteractionId ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1 : 0;
      }
    });
  };
  var po;
  var getInteractionCount = () => {
    return po ? interactionCountEstimate : performance.interactionCount || 0;
  };
  var initInteractionCountPolyfill = () => {
    if ("interactionCount" in performance || po)
      return;
    po = observe("event", updateEstimate, {
      type: "event",
      buffered: true,
      durationThreshold: 0
    });
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/getINP.js
  var getInteractionCountForNavigation = () => {
    return getInteractionCount();
  };
  var MAX_INTERACTIONS_TO_CONSIDER = 10;
  var longestInteractionList = [];
  var longestInteractionMap = {};
  var processEntry = (entry) => {
    const minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];
    const existingInteraction = longestInteractionMap[entry.interactionId];
    if (existingInteraction || longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER || entry.duration > minLongestInteraction.latency) {
      if (existingInteraction) {
        existingInteraction.entries.push(entry);
        existingInteraction.latency = Math.max(existingInteraction.latency, entry.duration);
      } else {
        const interaction = {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          id: entry.interactionId,
          latency: entry.duration,
          entries: [entry]
        };
        longestInteractionMap[interaction.id] = interaction;
        longestInteractionList.push(interaction);
      }
      longestInteractionList.sort((a, b) => b.latency - a.latency);
      longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach((i) => {
        delete longestInteractionMap[i.id];
      });
    }
  };
  var estimateP98LongestInteraction = () => {
    const candidateInteractionIndex = Math.min(
      longestInteractionList.length - 1,
      Math.floor(getInteractionCountForNavigation() / 50)
    );
    return longestInteractionList[candidateInteractionIndex];
  };
  var onINP = (onReport, opts) => {
    opts = opts || {};
    initInteractionCountPolyfill();
    const metric = initMetric("INP");
    let report;
    const handleEntries = (entries) => {
      entries.forEach((entry) => {
        if (entry.interactionId) {
          processEntry(entry);
        }
        if (entry.entryType === "first-input") {
          const noMatchingEntry = !longestInteractionList.some((interaction) => {
            return interaction.entries.some((prevEntry) => {
              return entry.duration === prevEntry.duration && entry.startTime === prevEntry.startTime;
            });
          });
          if (noMatchingEntry) {
            processEntry(entry);
          }
        }
      });
      const inp = estimateP98LongestInteraction();
      if (inp && inp.latency !== metric.value) {
        metric.value = inp.latency;
        metric.entries = inp.entries;
        report();
      }
    };
    const po2 = observe("event", handleEntries, {
      // Event Timing entries have their durations rounded to the nearest 8ms,
      // so a duration of 40ms would be any event that spans 2.5 or more frames
      // at 60Hz. This threshold is chosen to strike a balance between usefulness
      // and performance. Running this callback for any interaction that spans
      // just one or two frames is likely not worth the insight that could be
      // gained.
      durationThreshold: opts.durationThreshold || 40
    });
    report = bindReporter(onReport, metric, opts.reportAllChanges);
    if (po2) {
      po2.observe({ type: "first-input", buffered: true });
      onHidden(() => {
        handleEntries(po2.takeRecords());
        if (metric.value < 0 && getInteractionCountForNavigation() > 0) {
          metric.value = 0;
          metric.entries = [];
        }
        report(true);
      });
    }
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/getLCP.js
  var reportedMetricIDs = {};
  var onLCP = (onReport) => {
    const visibilityWatcher = getVisibilityWatcher();
    const metric = initMetric("LCP");
    let report;
    const handleEntries = (entries) => {
      const lastEntry = entries[entries.length - 1];
      if (lastEntry) {
        const value = Math.max(lastEntry.startTime - getActivationStart(), 0);
        if (value < visibilityWatcher.firstHiddenTime) {
          metric.value = value;
          metric.entries = [lastEntry];
          report();
        }
      }
    };
    const po2 = observe("largest-contentful-paint", handleEntries);
    if (po2) {
      report = bindReporter(onReport, metric);
      const stopListening = () => {
        if (!reportedMetricIDs[metric.id]) {
          handleEntries(po2.takeRecords());
          po2.disconnect();
          reportedMetricIDs[metric.id] = true;
          report(true);
        }
      };
      ["keydown", "click"].forEach((type) => {
        if (WINDOW7.document) {
          addEventListener(type, stopListening, { once: true, capture: true });
        }
      });
      onHidden(stopListening, true);
      return stopListening;
    }
    return;
  };

  // node_modules/@sentry-internal/tracing/esm/browser/web-vitals/onTTFB.js
  var whenReady = (callback) => {
    if (!WINDOW7.document) {
      return;
    }
    if (WINDOW7.document.prerendering) {
      addEventListener("prerenderingchange", () => whenReady(callback), true);
    } else if (WINDOW7.document.readyState !== "complete") {
      addEventListener("load", () => whenReady(callback), true);
    } else {
      setTimeout(callback, 0);
    }
  };
  var onTTFB = (onReport, opts) => {
    opts = opts || {};
    const metric = initMetric("TTFB");
    const report = bindReporter(onReport, metric, opts.reportAllChanges);
    whenReady(() => {
      const navEntry = getNavigationEntry();
      if (navEntry) {
        metric.value = Math.max(navEntry.responseStart - getActivationStart(), 0);
        if (metric.value < 0 || metric.value > performance.now())
          return;
        metric.entries = [navEntry];
        report(true);
      }
    });
  };

  // node_modules/@sentry-internal/tracing/esm/browser/instrument.js
  var handlers2 = {};
  var instrumented2 = {};
  var _previousCls;
  var _previousFid;
  var _previousLcp;
  var _previousTtfb;
  var _previousInp;
  function addClsInstrumentationHandler(callback, stopOnCallback = false) {
    return addMetricObserver("cls", callback, instrumentCls, _previousCls, stopOnCallback);
  }
  function addLcpInstrumentationHandler(callback, stopOnCallback = false) {
    return addMetricObserver("lcp", callback, instrumentLcp, _previousLcp, stopOnCallback);
  }
  function addTtfbInstrumentationHandler(callback) {
    return addMetricObserver("ttfb", callback, instrumentTtfb, _previousTtfb);
  }
  function addFidInstrumentationHandler(callback) {
    return addMetricObserver("fid", callback, instrumentFid, _previousFid);
  }
  function addInpInstrumentationHandler(callback) {
    return addMetricObserver("inp", callback, instrumentInp, _previousInp);
  }
  function addPerformanceInstrumentationHandler(type, callback) {
    addHandler2(type, callback);
    if (!instrumented2[type]) {
      instrumentPerformanceObserver(type);
      instrumented2[type] = true;
    }
    return getCleanupCallback(type, callback);
  }
  function triggerHandlers2(type, data) {
    const typeHandlers = handlers2[type];
    if (!typeHandlers || !typeHandlers.length) {
      return;
    }
    for (const handler of typeHandlers) {
      try {
        handler(data);
      } catch (e3) {
        DEBUG_BUILD3 && logger.error(
          `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
          e3
        );
      }
    }
  }
  function instrumentCls() {
    return onCLS((metric) => {
      triggerHandlers2("cls", {
        metric
      });
      _previousCls = metric;
    });
  }
  function instrumentFid() {
    return onFID((metric) => {
      triggerHandlers2("fid", {
        metric
      });
      _previousFid = metric;
    });
  }
  function instrumentLcp() {
    return onLCP((metric) => {
      triggerHandlers2("lcp", {
        metric
      });
      _previousLcp = metric;
    });
  }
  function instrumentTtfb() {
    return onTTFB((metric) => {
      triggerHandlers2("ttfb", {
        metric
      });
      _previousTtfb = metric;
    });
  }
  function instrumentInp() {
    return onINP((metric) => {
      triggerHandlers2("inp", {
        metric
      });
      _previousInp = metric;
    });
  }
  function addMetricObserver(type, callback, instrumentFn, previousValue, stopOnCallback = false) {
    addHandler2(type, callback);
    let stopListening;
    if (!instrumented2[type]) {
      stopListening = instrumentFn();
      instrumented2[type] = true;
    }
    if (previousValue) {
      callback({ metric: previousValue });
    }
    return getCleanupCallback(type, callback, stopOnCallback ? stopListening : void 0);
  }
  function instrumentPerformanceObserver(type) {
    const options = {};
    if (type === "event") {
      options.durationThreshold = 0;
    }
    observe(
      type,
      (entries) => {
        triggerHandlers2(type, { entries });
      },
      options
    );
  }
  function addHandler2(type, handler) {
    handlers2[type] = handlers2[type] || [];
    handlers2[type].push(handler);
  }
  function getCleanupCallback(type, callback, stopListening) {
    return () => {
      if (stopListening) {
        stopListening();
      }
      const typeHandlers = handlers2[type];
      if (!typeHandlers) {
        return;
      }
      const index = typeHandlers.indexOf(callback);
      if (index !== -1) {
        typeHandlers.splice(index, 1);
      }
    };
  }

  // node_modules/@sentry-internal/tracing/esm/browser/metrics/utils.js
  function isMeasurementValue(value) {
    return typeof value === "number" && isFinite(value);
  }
  function _startChild(transaction, { startTimestamp, ...ctx }) {
    if (startTimestamp && transaction.startTimestamp > startTimestamp) {
      transaction.startTimestamp = startTimestamp;
    }
    return transaction.startChild({
      startTimestamp,
      ...ctx
    });
  }

  // node_modules/@sentry-internal/tracing/esm/browser/metrics/index.js
  var MAX_INT_AS_BYTES = 2147483647;
  function msToSec(time2) {
    return time2 / 1e3;
  }
  function getBrowserPerformanceAPI() {
    return WINDOW7 && WINDOW7.addEventListener && WINDOW7.performance;
  }
  var _performanceCursor = 0;
  var _measurements = {};
  var _lcpEntry;
  var _clsEntry;
  function startTrackingWebVitals() {
    const performance2 = getBrowserPerformanceAPI();
    if (performance2 && browserPerformanceTimeOrigin) {
      if (performance2.mark) {
        WINDOW7.performance.mark("sentry-tracing-init");
      }
      const fidCallback = _trackFID();
      const clsCallback = _trackCLS();
      const lcpCallback = _trackLCP();
      const ttfbCallback = _trackTtfb();
      return () => {
        fidCallback();
        clsCallback();
        lcpCallback();
        ttfbCallback();
      };
    }
    return () => void 0;
  }
  function startTrackingLongTasks() {
    addPerformanceInstrumentationHandler("longtask", ({ entries }) => {
      for (const entry of entries) {
        const transaction = getActiveTransaction();
        if (!transaction) {
          return;
        }
        const startTime = msToSec(browserPerformanceTimeOrigin + entry.startTime);
        const duration = msToSec(entry.duration);
        transaction.startChild({
          description: "Main UI thread blocked",
          op: "ui.long-task",
          origin: "auto.ui.browser.metrics",
          startTimestamp: startTime,
          endTimestamp: startTime + duration
        });
      }
    });
  }
  function startTrackingInteractions() {
    addPerformanceInstrumentationHandler("event", ({ entries }) => {
      for (const entry of entries) {
        const transaction = getActiveTransaction();
        if (!transaction) {
          return;
        }
        if (entry.name === "click") {
          const startTime = msToSec(browserPerformanceTimeOrigin + entry.startTime);
          const duration = msToSec(entry.duration);
          const span = {
            description: htmlTreeAsString(entry.target),
            op: `ui.interaction.${entry.name}`,
            origin: "auto.ui.browser.metrics",
            startTimestamp: startTime,
            endTimestamp: startTime + duration
          };
          const componentName = getComponentName(entry.target);
          if (componentName) {
            span.attributes = { "ui.component_name": componentName };
          }
          transaction.startChild(span);
        }
      }
    });
  }
  function startTrackingINP(interactionIdtoRouteNameMapping, interactionsSampleRate) {
    const performance2 = getBrowserPerformanceAPI();
    if (performance2 && browserPerformanceTimeOrigin) {
      const inpCallback = _trackINP(interactionIdtoRouteNameMapping, interactionsSampleRate);
      return () => {
        inpCallback();
      };
    }
    return () => void 0;
  }
  function _trackCLS() {
    return addClsInstrumentationHandler(({ metric }) => {
      const entry = metric.entries[metric.entries.length - 1];
      if (!entry) {
        return;
      }
      DEBUG_BUILD3 && logger.log("[Measurements] Adding CLS");
      _measurements["cls"] = { value: metric.value, unit: "" };
      _clsEntry = entry;
    }, true);
  }
  function _trackLCP() {
    return addLcpInstrumentationHandler(({ metric }) => {
      const entry = metric.entries[metric.entries.length - 1];
      if (!entry) {
        return;
      }
      DEBUG_BUILD3 && logger.log("[Measurements] Adding LCP");
      _measurements["lcp"] = { value: metric.value, unit: "millisecond" };
      _lcpEntry = entry;
    }, true);
  }
  function _trackFID() {
    return addFidInstrumentationHandler(({ metric }) => {
      const entry = metric.entries[metric.entries.length - 1];
      if (!entry) {
        return;
      }
      const timeOrigin = msToSec(browserPerformanceTimeOrigin);
      const startTime = msToSec(entry.startTime);
      DEBUG_BUILD3 && logger.log("[Measurements] Adding FID");
      _measurements["fid"] = { value: metric.value, unit: "millisecond" };
      _measurements["mark.fid"] = { value: timeOrigin + startTime, unit: "second" };
    });
  }
  function _trackTtfb() {
    return addTtfbInstrumentationHandler(({ metric }) => {
      const entry = metric.entries[metric.entries.length - 1];
      if (!entry) {
        return;
      }
      DEBUG_BUILD3 && logger.log("[Measurements] Adding TTFB");
      _measurements["ttfb"] = { value: metric.value, unit: "millisecond" };
    });
  }
  var INP_ENTRY_MAP = {
    click: "click",
    pointerdown: "click",
    pointerup: "click",
    mousedown: "click",
    mouseup: "click",
    touchstart: "click",
    touchend: "click",
    mouseover: "hover",
    mouseout: "hover",
    mouseenter: "hover",
    mouseleave: "hover",
    pointerover: "hover",
    pointerout: "hover",
    pointerenter: "hover",
    pointerleave: "hover",
    dragstart: "drag",
    dragend: "drag",
    drag: "drag",
    dragenter: "drag",
    dragleave: "drag",
    dragover: "drag",
    drop: "drag",
    keydown: "press",
    keyup: "press",
    keypress: "press",
    input: "press"
  };
  function _trackINP(interactionIdToRouteNameMapping, interactionsSampleRate) {
    return addInpInstrumentationHandler(({ metric }) => {
      if (metric.value === void 0) {
        return;
      }
      const entry = metric.entries.find(
        (entry2) => entry2.duration === metric.value && INP_ENTRY_MAP[entry2.name] !== void 0
      );
      const client = getClient();
      if (!entry || !client) {
        return;
      }
      const interactionType = INP_ENTRY_MAP[entry.name];
      const options = client.getOptions();
      const startTime = msToSec(browserPerformanceTimeOrigin + entry.startTime);
      const duration = msToSec(metric.value);
      const interaction = entry.interactionId !== void 0 ? interactionIdToRouteNameMapping[entry.interactionId] : void 0;
      if (interaction === void 0) {
        return;
      }
      const { routeName, parentContext, activeTransaction, user, replayId } = interaction;
      const userDisplay = user !== void 0 ? user.email || user.id || user.ip_address : void 0;
      const profileId = activeTransaction !== void 0 ? activeTransaction.getProfileId() : void 0;
      const span = new Span({
        startTimestamp: startTime,
        endTimestamp: startTime + duration,
        op: `ui.interaction.${interactionType}`,
        name: htmlTreeAsString(entry.target),
        attributes: {
          release: options.release,
          environment: options.environment,
          transaction: routeName,
          ...userDisplay !== void 0 && userDisplay !== "" ? { user: userDisplay } : {},
          ...profileId !== void 0 ? { profile_id: profileId } : {},
          ...replayId !== void 0 ? { replay_id: replayId } : {}
        },
        exclusiveTime: metric.value,
        measurements: {
          inp: { value: metric.value, unit: "millisecond" }
        }
      });
      const sampleRate = getSampleRate(parentContext, options, interactionsSampleRate);
      if (!sampleRate) {
        return;
      }
      if (Math.random() < sampleRate) {
        const envelope = span ? createSpanEnvelope([span], client.getDsn()) : void 0;
        const transport = client && client.getTransport();
        if (transport && envelope) {
          transport.send(envelope).then(null, (reason) => {
            DEBUG_BUILD3 && logger.error("Error while sending interaction:", reason);
          });
        }
        return;
      }
    });
  }
  function addPerformanceEntries(transaction) {
    const performance2 = getBrowserPerformanceAPI();
    if (!performance2 || !WINDOW7.performance.getEntries || !browserPerformanceTimeOrigin) {
      return;
    }
    DEBUG_BUILD3 && logger.log("[Tracing] Adding & adjusting spans using Performance API");
    const timeOrigin = msToSec(browserPerformanceTimeOrigin);
    const performanceEntries = performance2.getEntries();
    const { op, start_timestamp: transactionStartTime } = spanToJSON(transaction);
    performanceEntries.slice(_performanceCursor).forEach((entry) => {
      const startTime = msToSec(entry.startTime);
      const duration = msToSec(entry.duration);
      if (transaction.op === "navigation" && transactionStartTime && timeOrigin + startTime < transactionStartTime) {
        return;
      }
      switch (entry.entryType) {
        case "navigation": {
          _addNavigationSpans(transaction, entry, timeOrigin);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
          const firstHidden = getVisibilityWatcher();
          const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
          if (entry.name === "first-paint" && shouldRecord) {
            DEBUG_BUILD3 && logger.log("[Measurements] Adding FP");
            _measurements["fp"] = { value: entry.startTime, unit: "millisecond" };
          }
          if (entry.name === "first-contentful-paint" && shouldRecord) {
            DEBUG_BUILD3 && logger.log("[Measurements] Adding FCP");
            _measurements["fcp"] = { value: entry.startTime, unit: "millisecond" };
          }
          break;
        }
        case "resource": {
          _addResourceSpans(transaction, entry, entry.name, startTime, duration, timeOrigin);
          break;
        }
      }
    });
    _performanceCursor = Math.max(performanceEntries.length - 1, 0);
    _trackNavigator(transaction);
    if (op === "pageload") {
      _addTtfbRequestTimeToMeasurements(_measurements);
      ["fcp", "fp", "lcp"].forEach((name) => {
        if (!_measurements[name] || !transactionStartTime || timeOrigin >= transactionStartTime) {
          return;
        }
        const oldValue = _measurements[name].value;
        const measurementTimestamp = timeOrigin + msToSec(oldValue);
        const normalizedValue = Math.abs((measurementTimestamp - transactionStartTime) * 1e3);
        const delta = normalizedValue - oldValue;
        DEBUG_BUILD3 && logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);
        _measurements[name].value = normalizedValue;
      });
      const fidMark = _measurements["mark.fid"];
      if (fidMark && _measurements["fid"]) {
        _startChild(transaction, {
          description: "first input delay",
          endTimestamp: fidMark.value + msToSec(_measurements["fid"].value),
          op: "ui.action",
          origin: "auto.ui.browser.metrics",
          startTimestamp: fidMark.value
        });
        delete _measurements["mark.fid"];
      }
      if (!("fcp" in _measurements)) {
        delete _measurements.cls;
      }
      Object.keys(_measurements).forEach((measurementName) => {
        setMeasurement(measurementName, _measurements[measurementName].value, _measurements[measurementName].unit);
      });
      _tagMetricInfo(transaction);
    }
    _lcpEntry = void 0;
    _clsEntry = void 0;
    _measurements = {};
  }
  function _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
    const measureStartTimestamp = timeOrigin + startTime;
    const measureEndTimestamp = measureStartTimestamp + duration;
    _startChild(transaction, {
      description: entry.name,
      endTimestamp: measureEndTimestamp,
      op: entry.entryType,
      origin: "auto.resource.browser.metrics",
      startTimestamp: measureStartTimestamp
    });
    return measureStartTimestamp;
  }
  function _addNavigationSpans(transaction, entry, timeOrigin) {
    ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((event) => {
      _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
    });
    _addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
    _addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
    _addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
    _addRequest(transaction, entry, timeOrigin);
  }
  function _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
    const end2 = eventEnd ? entry[eventEnd] : entry[`${event}End`];
    const start2 = entry[`${event}Start`];
    if (!start2 || !end2) {
      return;
    }
    _startChild(transaction, {
      op: "browser",
      origin: "auto.browser.browser.metrics",
      description: description || event,
      startTimestamp: timeOrigin + msToSec(start2),
      endTimestamp: timeOrigin + msToSec(end2)
    });
  }
  function _addRequest(transaction, entry, timeOrigin) {
    if (entry.responseEnd) {
      _startChild(transaction, {
        op: "browser",
        origin: "auto.browser.browser.metrics",
        description: "request",
        startTimestamp: timeOrigin + msToSec(entry.requestStart),
        endTimestamp: timeOrigin + msToSec(entry.responseEnd)
      });
      _startChild(transaction, {
        op: "browser",
        origin: "auto.browser.browser.metrics",
        description: "response",
        startTimestamp: timeOrigin + msToSec(entry.responseStart),
        endTimestamp: timeOrigin + msToSec(entry.responseEnd)
      });
    }
  }
  function _addResourceSpans(transaction, entry, resourceUrl, startTime, duration, timeOrigin) {
    if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
      return;
    }
    const parsedUrl = parseUrl2(resourceUrl);
    const data = {};
    setResourceEntrySizeData(data, entry, "transferSize", "http.response_transfer_size");
    setResourceEntrySizeData(data, entry, "encodedBodySize", "http.response_content_length");
    setResourceEntrySizeData(data, entry, "decodedBodySize", "http.decoded_response_content_length");
    if ("renderBlockingStatus" in entry) {
      data["resource.render_blocking_status"] = entry.renderBlockingStatus;
    }
    if (parsedUrl.protocol) {
      data["url.scheme"] = parsedUrl.protocol.split(":").pop();
    }
    if (parsedUrl.host) {
      data["server.address"] = parsedUrl.host;
    }
    data["url.same_origin"] = resourceUrl.includes(WINDOW7.location.origin);
    const startTimestamp = timeOrigin + startTime;
    const endTimestamp = startTimestamp + duration;
    _startChild(transaction, {
      description: resourceUrl.replace(WINDOW7.location.origin, ""),
      endTimestamp,
      op: entry.initiatorType ? `resource.${entry.initiatorType}` : "resource.other",
      origin: "auto.resource.browser.metrics",
      startTimestamp,
      data
    });
  }
  function _trackNavigator(transaction) {
    const navigator2 = WINDOW7.navigator;
    if (!navigator2) {
      return;
    }
    const connection = navigator2.connection;
    if (connection) {
      if (connection.effectiveType) {
        transaction.setTag("effectiveConnectionType", connection.effectiveType);
      }
      if (connection.type) {
        transaction.setTag("connectionType", connection.type);
      }
      if (isMeasurementValue(connection.rtt)) {
        _measurements["connection.rtt"] = { value: connection.rtt, unit: "millisecond" };
      }
    }
    if (isMeasurementValue(navigator2.deviceMemory)) {
      transaction.setTag("deviceMemory", `${navigator2.deviceMemory} GB`);
    }
    if (isMeasurementValue(navigator2.hardwareConcurrency)) {
      transaction.setTag("hardwareConcurrency", String(navigator2.hardwareConcurrency));
    }
  }
  function _tagMetricInfo(transaction) {
    if (_lcpEntry) {
      DEBUG_BUILD3 && logger.log("[Measurements] Adding LCP Data");
      if (_lcpEntry.element) {
        transaction.setTag("lcp.element", htmlTreeAsString(_lcpEntry.element));
      }
      if (_lcpEntry.id) {
        transaction.setTag("lcp.id", _lcpEntry.id);
      }
      if (_lcpEntry.url) {
        transaction.setTag("lcp.url", _lcpEntry.url.trim().slice(0, 200));
      }
      transaction.setTag("lcp.size", _lcpEntry.size);
    }
    if (_clsEntry && _clsEntry.sources) {
      DEBUG_BUILD3 && logger.log("[Measurements] Adding CLS Data");
      _clsEntry.sources.forEach(
        (source, index) => (
          // TODO: Can we rewrite this to an attribute?
          // eslint-disable-next-line deprecation/deprecation
          transaction.setTag(`cls.source.${index + 1}`, htmlTreeAsString(source.node))
        )
      );
    }
  }
  function setResourceEntrySizeData(data, entry, key, dataKey) {
    const entryVal = entry[key];
    if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {
      data[dataKey] = entryVal;
    }
  }
  function _addTtfbRequestTimeToMeasurements(_measurements2) {
    const navEntry = getNavigationEntry();
    if (!navEntry) {
      return;
    }
    const { responseStart, requestStart } = navEntry;
    if (requestStart <= responseStart) {
      DEBUG_BUILD3 && logger.log("[Measurements] Adding TTFB Request Time");
      _measurements2["ttfb.requestTime"] = {
        value: responseStart - requestStart,
        unit: "millisecond"
      };
    }
  }
  function getSampleRate(transactionContext, options, interactionsSampleRate) {
    if (!hasTracingEnabled(options)) {
      return false;
    }
    let sampleRate;
    if (transactionContext !== void 0 && typeof options.tracesSampler === "function") {
      sampleRate = options.tracesSampler({
        transactionContext,
        name: transactionContext.name,
        parentSampled: transactionContext.parentSampled,
        attributes: {
          // eslint-disable-next-line deprecation/deprecation
          ...transactionContext.data,
          ...transactionContext.attributes
        },
        location: WINDOW7.location
      });
    } else if (transactionContext !== void 0 && transactionContext.sampled !== void 0) {
      sampleRate = transactionContext.sampled;
    } else if (typeof options.tracesSampleRate !== "undefined") {
      sampleRate = options.tracesSampleRate;
    } else {
      sampleRate = 1;
    }
    if (!isValidSampleRate(sampleRate)) {
      DEBUG_BUILD3 && logger.warn("[Tracing] Discarding interaction span because of invalid sample rate.");
      return false;
    }
    if (sampleRate === true) {
      return interactionsSampleRate;
    } else if (sampleRate === false) {
      return 0;
    }
    return sampleRate * interactionsSampleRate;
  }

  // node_modules/@sentry-internal/tracing/esm/common/fetch.js
  function instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeaders2, spans, spanOrigin = "auto.http.browser") {
    if (!hasTracingEnabled() || !handlerData.fetchData) {
      return void 0;
    }
    const shouldCreateSpanResult = shouldCreateSpan(handlerData.fetchData.url);
    if (handlerData.endTimestamp && shouldCreateSpanResult) {
      const spanId = handlerData.fetchData.__span;
      if (!spanId)
        return;
      const span2 = spans[spanId];
      if (span2) {
        endSpan(span2, handlerData);
        delete spans[spanId];
      }
      return void 0;
    }
    const scope = getCurrentScope();
    const client = getClient();
    const { method, url } = handlerData.fetchData;
    const fullUrl = getFullURL(url);
    const host = fullUrl ? parseUrl2(fullUrl).host : void 0;
    const span = shouldCreateSpanResult ? startInactiveSpan({
      name: `${method} ${url}`,
      onlyIfParent: true,
      attributes: {
        url,
        type: "fetch",
        "http.method": method,
        "http.url": fullUrl,
        "server.address": host,
        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin
      },
      op: "http.client"
    }) : void 0;
    if (span) {
      handlerData.fetchData.__span = span.spanContext().spanId;
      spans[span.spanContext().spanId] = span;
    }
    if (shouldAttachHeaders2(handlerData.fetchData.url) && client) {
      const request = handlerData.args[0];
      handlerData.args[1] = handlerData.args[1] || {};
      const options = handlerData.args[1];
      options.headers = addTracingHeadersToFetchRequest(request, client, scope, options, span);
    }
    return span;
  }
  function addTracingHeadersToFetchRequest(request, client, scope, options, requestSpan) {
    const span = requestSpan || scope.getSpan();
    const isolationScope = getIsolationScope();
    const { traceId, spanId, sampled, dsc } = {
      ...isolationScope.getPropagationContext(),
      ...scope.getPropagationContext()
    };
    const sentryTraceHeader = span ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);
    const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(
      dsc || (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client, scope))
    );
    const headers = options.headers || (typeof Request !== "undefined" && isInstanceOf(request, Request) ? request.headers : void 0);
    if (!headers) {
      return { "sentry-trace": sentryTraceHeader, baggage: sentryBaggageHeader };
    } else if (typeof Headers !== "undefined" && isInstanceOf(headers, Headers)) {
      const newHeaders = new Headers(headers);
      newHeaders.append("sentry-trace", sentryTraceHeader);
      if (sentryBaggageHeader) {
        newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);
      }
      return newHeaders;
    } else if (Array.isArray(headers)) {
      const newHeaders = [...headers, ["sentry-trace", sentryTraceHeader]];
      if (sentryBaggageHeader) {
        newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);
      }
      return newHeaders;
    } else {
      const existingBaggageHeader = "baggage" in headers ? headers.baggage : void 0;
      const newBaggageHeaders = [];
      if (Array.isArray(existingBaggageHeader)) {
        newBaggageHeaders.push(...existingBaggageHeader);
      } else if (existingBaggageHeader) {
        newBaggageHeaders.push(existingBaggageHeader);
      }
      if (sentryBaggageHeader) {
        newBaggageHeaders.push(sentryBaggageHeader);
      }
      return {
        ...headers,
        "sentry-trace": sentryTraceHeader,
        baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(",") : void 0
      };
    }
  }
  function getFullURL(url) {
    try {
      const parsed = new URL(url);
      return parsed.href;
    } catch (e3) {
      return void 0;
    }
  }
  function endSpan(span, handlerData) {
    if (handlerData.response) {
      setHttpStatus(span, handlerData.response.status);
      const contentLength = handlerData.response && handlerData.response.headers && handlerData.response.headers.get("content-length");
      if (contentLength) {
        const contentLengthNum = parseInt(contentLength);
        if (contentLengthNum > 0) {
          span.setAttribute("http.response_content_length", contentLengthNum);
        }
      }
    } else if (handlerData.error) {
      span.setStatus("internal_error");
    }
    span.end();
  }

  // node_modules/@sentry-internal/tracing/esm/browser/request.js
  var DEFAULT_TRACE_PROPAGATION_TARGETS = ["localhost", /^\/(?!\/)/];
  var defaultRequestInstrumentationOptions = {
    traceFetch: true,
    traceXHR: true,
    enableHTTPTimings: true,
    // TODO (v8): Remove this property
    tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,
    tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS
  };
  function instrumentOutgoingRequests(_options) {
    const {
      traceFetch,
      traceXHR,
      // eslint-disable-next-line deprecation/deprecation
      tracePropagationTargets,
      // eslint-disable-next-line deprecation/deprecation
      tracingOrigins,
      shouldCreateSpanForRequest,
      enableHTTPTimings
    } = {
      traceFetch: defaultRequestInstrumentationOptions.traceFetch,
      traceXHR: defaultRequestInstrumentationOptions.traceXHR,
      ..._options
    };
    const shouldCreateSpan = typeof shouldCreateSpanForRequest === "function" ? shouldCreateSpanForRequest : (_) => true;
    const shouldAttachHeadersWithTargets = (url) => shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);
    const spans = {};
    if (traceFetch) {
      addFetchInstrumentationHandler((handlerData) => {
        const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);
        if (createdSpan) {
          const fullUrl = getFullURL2(handlerData.fetchData.url);
          const host = fullUrl ? parseUrl2(fullUrl).host : void 0;
          createdSpan.setAttributes({
            "http.url": fullUrl,
            "server.address": host
          });
        }
        if (enableHTTPTimings && createdSpan) {
          addHTTPTimings(createdSpan);
        }
      });
    }
    if (traceXHR) {
      addXhrInstrumentationHandler((handlerData) => {
        const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);
        if (enableHTTPTimings && createdSpan) {
          addHTTPTimings(createdSpan);
        }
      });
    }
  }
  function isPerformanceResourceTiming(entry) {
    return entry.entryType === "resource" && "initiatorType" in entry && typeof entry.nextHopProtocol === "string" && (entry.initiatorType === "fetch" || entry.initiatorType === "xmlhttprequest");
  }
  function addHTTPTimings(span) {
    const { url } = spanToJSON(span).data || {};
    if (!url || typeof url !== "string") {
      return;
    }
    const cleanup = addPerformanceInstrumentationHandler("resource", ({ entries }) => {
      entries.forEach((entry) => {
        if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {
          const spanData = resourceTimingEntryToSpanData(entry);
          spanData.forEach((data) => span.setAttribute(...data));
          setTimeout(cleanup);
        }
      });
    });
  }
  function extractNetworkProtocol(nextHopProtocol) {
    let name = "unknown";
    let version = "unknown";
    let _name = "";
    for (const char2 of nextHopProtocol) {
      if (char2 === "/") {
        [name, version] = nextHopProtocol.split("/");
        break;
      }
      if (!isNaN(Number(char2))) {
        name = _name === "h" ? "http" : _name;
        version = nextHopProtocol.split(_name)[1];
        break;
      }
      _name += char2;
    }
    if (_name === nextHopProtocol) {
      name = _name;
    }
    return { name, version };
  }
  function getAbsoluteTime(time2 = 0) {
    return ((browserPerformanceTimeOrigin || performance.timeOrigin) + time2) / 1e3;
  }
  function resourceTimingEntryToSpanData(resourceTiming) {
    const { name, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);
    const timingSpanData = [];
    timingSpanData.push(["network.protocol.version", version], ["network.protocol.name", name]);
    if (!browserPerformanceTimeOrigin) {
      return timingSpanData;
    }
    return [
      ...timingSpanData,
      ["http.request.redirect_start", getAbsoluteTime(resourceTiming.redirectStart)],
      ["http.request.fetch_start", getAbsoluteTime(resourceTiming.fetchStart)],
      ["http.request.domain_lookup_start", getAbsoluteTime(resourceTiming.domainLookupStart)],
      ["http.request.domain_lookup_end", getAbsoluteTime(resourceTiming.domainLookupEnd)],
      ["http.request.connect_start", getAbsoluteTime(resourceTiming.connectStart)],
      ["http.request.secure_connection_start", getAbsoluteTime(resourceTiming.secureConnectionStart)],
      ["http.request.connection_end", getAbsoluteTime(resourceTiming.connectEnd)],
      ["http.request.request_start", getAbsoluteTime(resourceTiming.requestStart)],
      ["http.request.response_start", getAbsoluteTime(resourceTiming.responseStart)],
      ["http.request.response_end", getAbsoluteTime(resourceTiming.responseEnd)]
    ];
  }
  function shouldAttachHeaders(url, tracePropagationTargets) {
    return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);
  }
  function xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders2, spans) {
    const xhr = handlerData.xhr;
    const sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];
    if (!hasTracingEnabled() || !xhr || xhr.__sentry_own_request__ || !sentryXhrData) {
      return void 0;
    }
    const shouldCreateSpanResult = shouldCreateSpan(sentryXhrData.url);
    if (handlerData.endTimestamp && shouldCreateSpanResult) {
      const spanId = xhr.__sentry_xhr_span_id__;
      if (!spanId)
        return;
      const span2 = spans[spanId];
      if (span2 && sentryXhrData.status_code !== void 0) {
        setHttpStatus(span2, sentryXhrData.status_code);
        span2.end();
        delete spans[spanId];
      }
      return void 0;
    }
    const scope = getCurrentScope();
    const isolationScope = getIsolationScope();
    const fullUrl = getFullURL2(sentryXhrData.url);
    const host = fullUrl ? parseUrl2(fullUrl).host : void 0;
    const span = shouldCreateSpanResult ? startInactiveSpan({
      name: `${sentryXhrData.method} ${sentryXhrData.url}`,
      onlyIfParent: true,
      attributes: {
        type: "xhr",
        "http.method": sentryXhrData.method,
        "http.url": fullUrl,
        url: sentryXhrData.url,
        "server.address": host,
        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.browser"
      },
      op: "http.client"
    }) : void 0;
    if (span) {
      xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;
      spans[xhr.__sentry_xhr_span_id__] = span;
    }
    const client = getClient();
    if (xhr.setRequestHeader && shouldAttachHeaders2(sentryXhrData.url) && client) {
      const { traceId, spanId, sampled, dsc } = {
        ...isolationScope.getPropagationContext(),
        ...scope.getPropagationContext()
      };
      const sentryTraceHeader = span ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);
      const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(
        dsc || (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client, scope))
      );
      setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);
    }
    return span;
  }
  function setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader) {
    try {
      xhr.setRequestHeader("sentry-trace", sentryTraceHeader);
      if (sentryBaggageHeader) {
        xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);
      }
    } catch (_) {
    }
  }
  function getFullURL2(url) {
    try {
      const parsed = new URL(url, WINDOW7.location.origin);
      return parsed.href;
    } catch (e3) {
      return void 0;
    }
  }

  // node_modules/@sentry-internal/tracing/esm/browser/browserTracingIntegration.js
  var BROWSER_TRACING_INTEGRATION_ID = "BrowserTracing";
  var DEFAULT_BROWSER_TRACING_OPTIONS = {
    ...TRACING_DEFAULTS,
    instrumentNavigation: true,
    instrumentPageLoad: true,
    markBackgroundSpan: true,
    enableLongTask: true,
    enableInp: false,
    interactionsSampleRate: 1,
    _experiments: {},
    ...defaultRequestInstrumentationOptions
  };
  var browserTracingIntegration = (_options = {}) => {
    const _hasSetTracePropagationTargets = DEBUG_BUILD3 ? !!// eslint-disable-next-line deprecation/deprecation
    (_options.tracePropagationTargets || _options.tracingOrigins) : false;
    addTracingExtensions();
    if (!_options.tracePropagationTargets && _options.tracingOrigins) {
      _options.tracePropagationTargets = _options.tracingOrigins;
    }
    const options = {
      ...DEFAULT_BROWSER_TRACING_OPTIONS,
      ..._options
    };
    const _collectWebVitals = startTrackingWebVitals();
    const interactionIdToRouteNameMapping = {};
    if (options.enableInp) {
      startTrackingINP(interactionIdToRouteNameMapping, options.interactionsSampleRate);
    }
    if (options.enableLongTask) {
      startTrackingLongTasks();
    }
    if (options._experiments.enableInteractions) {
      startTrackingInteractions();
    }
    const latestRoute = {
      name: void 0,
      context: void 0
    };
    function _createRouteTransaction(context) {
      const hub = getCurrentHub();
      const { beforeStartSpan, idleTimeout, finalTimeout, heartbeatInterval } = options;
      const isPageloadTransaction = context.op === "pageload";
      let expandedContext;
      if (isPageloadTransaction) {
        const sentryTrace = isPageloadTransaction ? getMetaContent("sentry-trace") : "";
        const baggage = isPageloadTransaction ? getMetaContent("baggage") : void 0;
        const { traceId, dsc, parentSpanId, sampled } = propagationContextFromHeaders(sentryTrace, baggage);
        expandedContext = {
          traceId,
          parentSpanId,
          parentSampled: sampled,
          ...context,
          metadata: {
            // eslint-disable-next-line deprecation/deprecation
            ...context.metadata,
            dynamicSamplingContext: dsc
          },
          trimEnd: true
        };
      } else {
        expandedContext = {
          trimEnd: true,
          ...context
        };
      }
      const finalContext = beforeStartSpan ? beforeStartSpan(expandedContext) : expandedContext;
      finalContext.metadata = finalContext.name !== expandedContext.name ? (
        // eslint-disable-next-line deprecation/deprecation
        { ...finalContext.metadata, source: "custom" }
      ) : (
        // eslint-disable-next-line deprecation/deprecation
        finalContext.metadata
      );
      latestRoute.name = finalContext.name;
      latestRoute.context = finalContext;
      if (finalContext.sampled === false) {
        DEBUG_BUILD3 && logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);
      }
      DEBUG_BUILD3 && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);
      const { location } = WINDOW7;
      const idleTransaction = startIdleTransaction(
        hub,
        finalContext,
        idleTimeout,
        finalTimeout,
        true,
        { location },
        // for use in the tracesSampler
        heartbeatInterval,
        isPageloadTransaction
        // should wait for finish signal if it's a pageload transaction
      );
      if (isPageloadTransaction && WINDOW7.document) {
        WINDOW7.document.addEventListener("readystatechange", () => {
          if (["interactive", "complete"].includes(WINDOW7.document.readyState)) {
            idleTransaction.sendAutoFinishSignal();
          }
        });
        if (["interactive", "complete"].includes(WINDOW7.document.readyState)) {
          idleTransaction.sendAutoFinishSignal();
        }
      }
      idleTransaction.registerBeforeFinishCallback((transaction) => {
        _collectWebVitals();
        addPerformanceEntries(transaction);
      });
      return idleTransaction;
    }
    return {
      name: BROWSER_TRACING_INTEGRATION_ID,
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      setupOnce: () => {
      },
      afterAllSetup(client) {
        const clientOptions = client.getOptions();
        const { markBackgroundSpan, traceFetch, traceXHR, shouldCreateSpanForRequest, enableHTTPTimings, _experiments } = options;
        const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;
        const tracePropagationTargets = clientOptionsTracePropagationTargets || options.tracePropagationTargets;
        if (DEBUG_BUILD3 && _hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {
          logger.warn(
            "[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used."
          );
        }
        let activeSpan;
        let startingUrl = WINDOW7.location && WINDOW7.location.href;
        if (client.on) {
          client.on("startNavigationSpan", (context) => {
            if (activeSpan) {
              DEBUG_BUILD3 && logger.log(`[Tracing] Finishing current transaction with op: ${spanToJSON(activeSpan).op}`);
              activeSpan.end();
            }
            activeSpan = _createRouteTransaction({
              op: "navigation",
              ...context
            });
          });
          client.on("startPageLoadSpan", (context) => {
            if (activeSpan) {
              DEBUG_BUILD3 && logger.log(`[Tracing] Finishing current transaction with op: ${spanToJSON(activeSpan).op}`);
              activeSpan.end();
            }
            activeSpan = _createRouteTransaction({
              op: "pageload",
              ...context
            });
          });
        }
        if (options.instrumentPageLoad && client.emit && WINDOW7.location) {
          const context = {
            name: WINDOW7.location.pathname,
            // pageload should always start at timeOrigin (and needs to be in s, not ms)
            startTimestamp: browserPerformanceTimeOrigin ? browserPerformanceTimeOrigin / 1e3 : void 0,
            origin: "auto.pageload.browser",
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
            }
          };
          startBrowserTracingPageLoadSpan(client, context);
        }
        if (options.instrumentNavigation && client.emit && WINDOW7.location) {
          addHistoryInstrumentationHandler(({ to, from: from2 }) => {
            if (from2 === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
              startingUrl = void 0;
              return;
            }
            if (from2 !== to) {
              startingUrl = void 0;
              const context = {
                name: WINDOW7.location.pathname,
                origin: "auto.navigation.browser",
                attributes: {
                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
                }
              };
              startBrowserTracingNavigationSpan(client, context);
            }
          });
        }
        if (markBackgroundSpan) {
          registerBackgroundTabDetection();
        }
        if (_experiments.enableInteractions) {
          registerInteractionListener(options, latestRoute);
        }
        if (options.enableInp) {
          registerInpInteractionListener(interactionIdToRouteNameMapping, latestRoute);
        }
        instrumentOutgoingRequests({
          traceFetch,
          traceXHR,
          tracePropagationTargets,
          shouldCreateSpanForRequest,
          enableHTTPTimings
        });
      },
      // TODO v8: Remove this again
      // This is private API that we use to fix converted BrowserTracing integrations in Next.js & SvelteKit
      options
    };
  };
  function startBrowserTracingPageLoadSpan(client, spanOptions) {
    if (!client.emit) {
      return;
    }
    client.emit("startPageLoadSpan", spanOptions);
    const span = getActiveSpan();
    const op = span && spanToJSON(span).op;
    return op === "pageload" ? span : void 0;
  }
  function startBrowserTracingNavigationSpan(client, spanOptions) {
    if (!client.emit) {
      return;
    }
    client.emit("startNavigationSpan", spanOptions);
    const span = getActiveSpan();
    const op = span && spanToJSON(span).op;
    return op === "navigation" ? span : void 0;
  }
  function getMetaContent(metaName) {
    const metaTag = getDomElement(`meta[name=${metaName}]`);
    return metaTag ? metaTag.getAttribute("content") : void 0;
  }
  function registerInteractionListener(options, latestRoute) {
    let inflightInteractionTransaction;
    const registerInteractionTransaction = () => {
      const { idleTimeout, finalTimeout, heartbeatInterval } = options;
      const op = "ui.action.click";
      const currentTransaction = getActiveTransaction();
      if (currentTransaction && currentTransaction.op && ["navigation", "pageload"].includes(currentTransaction.op)) {
        DEBUG_BUILD3 && logger.warn(
          `[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`
        );
        return void 0;
      }
      if (inflightInteractionTransaction) {
        inflightInteractionTransaction.setFinishReason("interactionInterrupted");
        inflightInteractionTransaction.end();
        inflightInteractionTransaction = void 0;
      }
      if (!latestRoute.name) {
        DEBUG_BUILD3 && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);
        return void 0;
      }
      const { location } = WINDOW7;
      const context = {
        name: latestRoute.name,
        op,
        trimEnd: true,
        data: {
          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.context ? getSource(latestRoute.context) : "url"
        }
      };
      inflightInteractionTransaction = startIdleTransaction(
        // eslint-disable-next-line deprecation/deprecation
        getCurrentHub(),
        context,
        idleTimeout,
        finalTimeout,
        true,
        { location },
        // for use in the tracesSampler
        heartbeatInterval
      );
    };
    ["click"].forEach((type) => {
      if (WINDOW7.document) {
        addEventListener(type, registerInteractionTransaction, { once: false, capture: true });
      }
    });
  }
  function isPerformanceEventTiming(entry) {
    return "duration" in entry;
  }
  var MAX_INTERACTIONS = 10;
  function registerInpInteractionListener(interactionIdToRouteNameMapping, latestRoute) {
    const handleEntries = ({ entries }) => {
      const client = getClient();
      const replay = client !== void 0 && client.getIntegrationByName !== void 0 ? client.getIntegrationByName("Replay") : void 0;
      const replayId = replay !== void 0 ? replay.getReplayId() : void 0;
      const activeTransaction = getActiveTransaction();
      const currentScope = getCurrentScope();
      const user = currentScope !== void 0 ? currentScope.getUser() : void 0;
      entries.forEach((entry) => {
        if (isPerformanceEventTiming(entry)) {
          const interactionId = entry.interactionId;
          if (interactionId === void 0) {
            return;
          }
          const existingInteraction = interactionIdToRouteNameMapping[interactionId];
          const duration = entry.duration;
          const startTime = entry.startTime;
          const keys3 = Object.keys(interactionIdToRouteNameMapping);
          const minInteractionId = keys3.length > 0 ? keys3.reduce((a, b) => {
            return interactionIdToRouteNameMapping[a].duration < interactionIdToRouteNameMapping[b].duration ? a : b;
          }) : void 0;
          if (entry.entryType === "first-input") {
            const matchingEntry = keys3.map((key) => interactionIdToRouteNameMapping[key]).some((interaction) => {
              return interaction.duration === duration && interaction.startTime === startTime;
            });
            if (matchingEntry) {
              return;
            }
          }
          if (!interactionId) {
            return;
          }
          if (existingInteraction) {
            existingInteraction.duration = Math.max(existingInteraction.duration, duration);
          } else if (keys3.length < MAX_INTERACTIONS || minInteractionId === void 0 || duration > interactionIdToRouteNameMapping[minInteractionId].duration) {
            const routeName = latestRoute.name;
            const parentContext = latestRoute.context;
            if (routeName && parentContext) {
              if (minInteractionId && Object.keys(interactionIdToRouteNameMapping).length >= MAX_INTERACTIONS) {
                delete interactionIdToRouteNameMapping[minInteractionId];
              }
              interactionIdToRouteNameMapping[interactionId] = {
                routeName,
                duration,
                parentContext,
                user,
                activeTransaction,
                replayId,
                startTime
              };
            }
          }
        }
      });
    };
    addPerformanceInstrumentationHandler("event", handleEntries);
    addPerformanceInstrumentationHandler("first-input", handleEntries);
  }
  function getSource(context) {
    const sourceFromAttributes = context.attributes && context.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const sourceFromData = context.data && context.data[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const sourceFromMetadata = context.metadata && context.metadata.source;
    return sourceFromAttributes || sourceFromData || sourceFromMetadata;
  }

  // node_modules/@sentry/browser/esm/helpers.js
  var WINDOW8 = GLOBAL_OBJ;
  var ignoreOnError = 0;
  function shouldIgnoreOnError() {
    return ignoreOnError > 0;
  }
  function ignoreNextOnError() {
    ignoreOnError++;
    setTimeout(() => {
      ignoreOnError--;
    });
  }
  function wrap2(fn2, options = {}, before) {
    if (typeof fn2 !== "function") {
      return fn2;
    }
    try {
      const wrapper = fn2.__sentry_wrapped__;
      if (wrapper) {
        return wrapper;
      }
      if (getOriginalFunction(fn2)) {
        return fn2;
      }
    } catch (e3) {
      return fn2;
    }
    const sentryWrapped = function() {
      const args = Array.prototype.slice.call(arguments);
      try {
        if (before && typeof before === "function") {
          before.apply(this, arguments);
        }
        const wrappedArguments = args.map((arg) => wrap2(arg, options));
        return fn2.apply(this, wrappedArguments);
      } catch (ex) {
        ignoreNextOnError();
        withScope((scope) => {
          scope.addEventProcessor((event) => {
            if (options.mechanism) {
              addExceptionTypeValue(event, void 0, void 0);
              addExceptionMechanism(event, options.mechanism);
            }
            event.extra = {
              ...event.extra,
              arguments: args
            };
            return event;
          });
          captureException(ex);
        });
        throw ex;
      }
    };
    try {
      for (const property in fn2) {
        if (Object.prototype.hasOwnProperty.call(fn2, property)) {
          sentryWrapped[property] = fn2[property];
        }
      }
    } catch (_oO) {
    }
    markFunctionWrapped(sentryWrapped, fn2);
    addNonEnumerableProperty(fn2, "__sentry_wrapped__", sentryWrapped);
    try {
      const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
      if (descriptor.configurable) {
        Object.defineProperty(sentryWrapped, "name", {
          get() {
            return fn2.name;
          }
        });
      }
    } catch (_oO) {
    }
    return sentryWrapped;
  }

  // node_modules/@sentry/browser/esm/debug-build.js
  var DEBUG_BUILD4 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

  // node_modules/@sentry/browser/esm/eventbuilder.js
  function exceptionFromError2(stackParser, ex) {
    const frames = parseStackFrames2(stackParser, ex);
    const exception = {
      type: ex && ex.name,
      value: extractMessage(ex)
    };
    if (frames.length) {
      exception.stacktrace = { frames };
    }
    if (exception.type === void 0 && exception.value === "") {
      exception.value = "Unrecoverable error caught";
    }
    return exception;
  }
  function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {
    const client = getClient();
    const normalizeDepth = client && client.getOptions().normalizeDepth;
    const event = {
      exception: {
        values: [
          {
            type: isEvent2(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
            value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection })
          }
        ]
      },
      extra: {
        __serialized__: normalizeToSize(exception, normalizeDepth)
      }
    };
    if (syntheticException) {
      const frames = parseStackFrames2(stackParser, syntheticException);
      if (frames.length) {
        event.exception.values[0].stacktrace = { frames };
      }
    }
    return event;
  }
  function eventFromError(stackParser, ex) {
    return {
      exception: {
        values: [exceptionFromError2(stackParser, ex)]
      }
    };
  }
  function parseStackFrames2(stackParser, ex) {
    const stacktrace = ex.stacktrace || ex.stack || "";
    const popSize = getPopSize(ex);
    try {
      return stackParser(stacktrace, popSize);
    } catch (e3) {
    }
    return [];
  }
  var reactMinifiedRegexp = /Minified React error #\d+;/i;
  function getPopSize(ex) {
    if (ex) {
      if (typeof ex.framesToPop === "number") {
        return ex.framesToPop;
      }
      if (reactMinifiedRegexp.test(ex.message)) {
        return 1;
      }
    }
    return 0;
  }
  function extractMessage(ex) {
    const message = ex && ex.message;
    if (!message) {
      return "No error message";
    }
    if (message.error && typeof message.error.message === "string") {
      return message.error.message;
    }
    return message;
  }
  function eventFromException(stackParser, exception, hint, attachStacktrace) {
    const syntheticException = hint && hint.syntheticException || void 0;
    const event = eventFromUnknownInput2(stackParser, exception, syntheticException, attachStacktrace);
    addExceptionMechanism(event);
    event.level = "error";
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromMessage2(stackParser, message, level = "info", hint, attachStacktrace) {
    const syntheticException = hint && hint.syntheticException || void 0;
    const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
    event.level = level;
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromUnknownInput2(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
    let event;
    if (isErrorEvent(exception) && exception.error) {
      const errorEvent = exception;
      return eventFromError(stackParser, errorEvent.error);
    }
    if (isDOMError(exception) || isDOMException(exception)) {
      const domException = exception;
      if ("stack" in exception) {
        event = eventFromError(stackParser, exception);
      } else {
        const name = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
        const message = domException.message ? `${name}: ${domException.message}` : name;
        event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
        addExceptionTypeValue(event, message);
      }
      if ("code" in domException) {
        event.tags = { ...event.tags, "DOMException.code": `${domException.code}` };
      }
      return event;
    }
    if (isError(exception)) {
      return eventFromError(stackParser, exception);
    }
    if (isPlainObject(exception) || isEvent2(exception)) {
      const objectException = exception;
      event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
      addExceptionMechanism(event, {
        synthetic: true
      });
      return event;
    }
    event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);
    addExceptionTypeValue(event, `${exception}`, void 0);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  function eventFromString(stackParser, message, syntheticException, attachStacktrace) {
    const event = {};
    if (attachStacktrace && syntheticException) {
      const frames = parseStackFrames2(stackParser, syntheticException);
      if (frames.length) {
        event.exception = {
          values: [{ value: message, stacktrace: { frames } }]
        };
      }
    }
    if (isParameterizedString(message)) {
      const { __sentry_template_string__, __sentry_template_values__ } = message;
      event.logentry = {
        message: __sentry_template_string__,
        params: __sentry_template_values__
      };
      return event;
    }
    event.message = message;
    return event;
  }
  function getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }) {
    const keys3 = extractExceptionKeysForMessage(exception);
    const captureType = isUnhandledRejection ? "promise rejection" : "exception";
    if (isErrorEvent(exception)) {
      return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
    }
    if (isEvent2(exception)) {
      const className = getObjectClassName(exception);
      return `Event \`${className}\` (type=${exception.type}) captured as ${captureType}`;
    }
    return `Object captured as ${captureType} with keys: ${keys3}`;
  }
  function getObjectClassName(obj) {
    try {
      const prototype = Object.getPrototypeOf(obj);
      return prototype ? prototype.constructor.name : void 0;
    } catch (e3) {
    }
  }

  // node_modules/@sentry/browser/esm/userfeedback.js
  function createUserFeedbackEnvelope(feedback, {
    metadata,
    tunnel,
    dsn
  }) {
    const headers = {
      event_id: feedback.event_id,
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...metadata && metadata.sdk && {
        sdk: {
          name: metadata.sdk.name,
          version: metadata.sdk.version
        }
      },
      ...!!tunnel && !!dsn && { dsn: dsnToString(dsn) }
    };
    const item = createUserFeedbackEnvelopeItem(feedback);
    return createEnvelope(headers, [item]);
  }
  function createUserFeedbackEnvelopeItem(feedback) {
    const feedbackHeaders = {
      type: "user_report"
    };
    return [feedbackHeaders, feedback];
  }

  // node_modules/@sentry/browser/esm/client.js
  var BrowserClient = class extends BaseClient {
    /**
     * Creates a new Browser SDK instance.
     *
     * @param options Configuration options for this SDK.
     */
    constructor(options) {
      const sdkSource = WINDOW8.SENTRY_SDK_SOURCE || getSDKSource();
      applySdkMetadata(options, "browser", ["browser"], sdkSource);
      super(options);
      if (options.sendClientReports && WINDOW8.document) {
        WINDOW8.document.addEventListener("visibilitychange", () => {
          if (WINDOW8.document.visibilityState === "hidden") {
            this._flushOutcomes();
          }
        });
      }
    }
    /**
     * @inheritDoc
     */
    eventFromException(exception, hint) {
      return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
    }
    /**
     * @inheritDoc
     */
    eventFromMessage(message, level = "info", hint) {
      return eventFromMessage2(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
    }
    /**
     * Sends user feedback to Sentry.
     */
    captureUserFeedback(feedback) {
      if (!this._isEnabled()) {
        DEBUG_BUILD4 && logger.warn("SDK not enabled, will not capture user feedback.");
        return;
      }
      const envelope = createUserFeedbackEnvelope(feedback, {
        metadata: this.getSdkMetadata(),
        dsn: this.getDsn(),
        tunnel: this.getOptions().tunnel
      });
      this._sendEnvelope(envelope);
    }
    /**
     * @inheritDoc
     */
    _prepareEvent(event, hint, scope) {
      event.platform = event.platform || "javascript";
      return super._prepareEvent(event, hint, scope);
    }
    /**
     * Sends client reports as an envelope.
     */
    _flushOutcomes() {
      const outcomes = this._clearOutcomes();
      if (outcomes.length === 0) {
        DEBUG_BUILD4 && logger.log("No outcomes to send");
        return;
      }
      if (!this._dsn) {
        DEBUG_BUILD4 && logger.log("No dsn provided, will not send outcomes");
        return;
      }
      DEBUG_BUILD4 && logger.log("Sending outcomes:", outcomes);
      const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
      this._sendEnvelope(envelope);
    }
  };

  // node_modules/@sentry/browser/esm/transports/utils.js
  var cachedFetchImpl = void 0;
  function getNativeFetchImplementation() {
    if (cachedFetchImpl) {
      return cachedFetchImpl;
    }
    if (isNativeFetch(WINDOW8.fetch)) {
      return cachedFetchImpl = WINDOW8.fetch.bind(WINDOW8);
    }
    const document2 = WINDOW8.document;
    let fetchImpl = WINDOW8.fetch;
    if (document2 && typeof document2.createElement === "function") {
      try {
        const sandbox = document2.createElement("iframe");
        sandbox.hidden = true;
        document2.head.appendChild(sandbox);
        const contentWindow = sandbox.contentWindow;
        if (contentWindow && contentWindow.fetch) {
          fetchImpl = contentWindow.fetch;
        }
        document2.head.removeChild(sandbox);
      } catch (e3) {
        DEBUG_BUILD4 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e3);
      }
    }
    return cachedFetchImpl = fetchImpl.bind(WINDOW8);
  }
  function clearCachedFetchImplementation() {
    cachedFetchImpl = void 0;
  }

  // node_modules/@sentry/browser/esm/transports/fetch.js
  function makeFetchTransport(options, nativeFetch = getNativeFetchImplementation()) {
    let pendingBodySize = 0;
    let pendingCount = 0;
    function makeRequest(request) {
      const requestSize = request.body.length;
      pendingBodySize += requestSize;
      pendingCount++;
      const requestOptions = {
        body: request.body,
        method: "POST",
        referrerPolicy: "origin",
        headers: options.headers,
        // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
        // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
        // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
        // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
        // Gotchas:
        // - `keepalive` isn't supported by Firefox
        // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
        //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
        //   We will therefore only activate the flag when we're below that limit.
        // There is also a limit of requests that can be open at the same time, so we also limit this to 15
        // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
        keepalive: pendingBodySize <= 6e4 && pendingCount < 15,
        ...options.fetchOptions
      };
      try {
        return nativeFetch(options.url, requestOptions).then((response) => {
          pendingBodySize -= requestSize;
          pendingCount--;
          return {
            statusCode: response.status,
            headers: {
              "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": response.headers.get("Retry-After")
            }
          };
        });
      } catch (e3) {
        clearCachedFetchImplementation();
        pendingBodySize -= requestSize;
        pendingCount--;
        return rejectedSyncPromise(e3);
      }
    }
    return createTransport(options, makeRequest);
  }

  // node_modules/@sentry/browser/esm/transports/xhr.js
  var XHR_READYSTATE_DONE = 4;
  function makeXHRTransport(options) {
    function makeRequest(request) {
      return new SyncPromise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.onerror = reject;
        xhr.onreadystatechange = () => {
          if (xhr.readyState === XHR_READYSTATE_DONE) {
            resolve({
              statusCode: xhr.status,
              headers: {
                "x-sentry-rate-limits": xhr.getResponseHeader("X-Sentry-Rate-Limits"),
                "retry-after": xhr.getResponseHeader("Retry-After")
              }
            });
          }
        };
        xhr.open("POST", options.url);
        for (const header in options.headers) {
          if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
            xhr.setRequestHeader(header, options.headers[header]);
          }
        }
        xhr.send(request.body);
      });
    }
    return createTransport(options, makeRequest);
  }

  // node_modules/@sentry/browser/esm/stack-parsers.js
  var UNKNOWN_FUNCTION = "?";
  var CHROME_PRIORITY = 30;
  var WINJS_PRIORITY = 40;
  var GECKO_PRIORITY = 50;
  function createFrame(filename, func, lineno, colno) {
    const frame2 = {
      filename,
      function: func,
      in_app: true
      // All browser frames are considered in_app
    };
    if (lineno !== void 0) {
      frame2.lineno = lineno;
    }
    if (colno !== void 0) {
      frame2.colno = colno;
    }
    return frame2;
  }
  var chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var chromeStackParserFn = (line3) => {
    const parts = chromeRegex.exec(line3);
    if (parts) {
      const isEval = parts[2] && parts[2].indexOf("eval") === 0;
      if (isEval) {
        const subMatch = chromeEvalRegex.exec(parts[2]);
        if (subMatch) {
          parts[2] = subMatch[1];
          parts[3] = subMatch[2];
          parts[4] = subMatch[3];
        }
      }
      const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);
      return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
    }
    return;
  };
  var chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];
  var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var gecko = (line3) => {
    const parts = geckoREgex.exec(line3);
    if (parts) {
      const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
      if (isEval) {
        const subMatch = geckoEvalRegex.exec(parts[3]);
        if (subMatch) {
          parts[1] = parts[1] || "eval";
          parts[3] = subMatch[1];
          parts[4] = subMatch[2];
          parts[5] = "";
        }
      }
      let filename = parts[3];
      let func = parts[1] || UNKNOWN_FUNCTION;
      [func, filename] = extractSafariExtensionDetails(func, filename);
      return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
    }
    return;
  };
  var geckoStackLineParser = [GECKO_PRIORITY, gecko];
  var winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var winjs = (line3) => {
    const parts = winjsRegex.exec(line3);
    return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
  };
  var winjsStackLineParser = [WINJS_PRIORITY, winjs];
  var defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];
  var defaultStackParser = createStackParser(...defaultStackLineParsers);
  var extractSafariExtensionDetails = (func, filename) => {
    const isSafariExtension = func.indexOf("safari-extension") !== -1;
    const isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
    return isSafariExtension || isSafariWebExtension ? [
      func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
      isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`
    ] : [func, filename];
  };

  // node_modules/@sentry/browser/esm/integrations/breadcrumbs.js
  var MAX_ALLOWED_STRING_LENGTH = 1024;
  var INTEGRATION_NAME4 = "Breadcrumbs";
  var _breadcrumbsIntegration = (options = {}) => {
    const _options = {
      console: true,
      dom: true,
      fetch: true,
      history: true,
      sentry: true,
      xhr: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME4,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      setup(client) {
        if (_options.console) {
          addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client));
        }
        if (_options.dom) {
          addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client, _options.dom));
        }
        if (_options.xhr) {
          addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client));
        }
        if (_options.fetch) {
          addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client));
        }
        if (_options.history) {
          addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client));
        }
        if (_options.sentry && client.on) {
          client.on("beforeSendEvent", _getSentryBreadcrumbHandler(client));
        }
      }
    };
  };
  var breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);
  var Breadcrumbs = convertIntegrationFnToClass(INTEGRATION_NAME4, breadcrumbsIntegration);
  function _getSentryBreadcrumbHandler(client) {
    return function addSentryBreadcrumb(event) {
      if (getClient() !== client) {
        return;
      }
      addBreadcrumb(
        {
          category: `sentry.${event.type === "transaction" ? "transaction" : "event"}`,
          event_id: event.event_id,
          level: event.level,
          message: getEventDescription(event)
        },
        {
          event
        }
      );
    };
  }
  function _getDomBreadcrumbHandler(client, dom) {
    return function _innerDomBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      let target;
      let componentName;
      let keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
      let maxStringLength = typeof dom === "object" && typeof dom.maxStringLength === "number" ? dom.maxStringLength : void 0;
      if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {
        DEBUG_BUILD4 && logger.warn(
          `\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`
        );
        maxStringLength = MAX_ALLOWED_STRING_LENGTH;
      }
      if (typeof keyAttrs === "string") {
        keyAttrs = [keyAttrs];
      }
      try {
        const event = handlerData.event;
        const element = _isEvent(event) ? event.target : event;
        target = htmlTreeAsString(element, { keyAttrs, maxStringLength });
        componentName = getComponentName(element);
      } catch (e3) {
        target = "<unknown>";
      }
      if (target.length === 0) {
        return;
      }
      const breadcrumb = {
        category: `ui.${handlerData.name}`,
        message: target
      };
      if (componentName) {
        breadcrumb.data = { "ui.component_name": componentName };
      }
      addBreadcrumb(breadcrumb, {
        event: handlerData.event,
        name: handlerData.name,
        global: handlerData.global
      });
    };
  }
  function _getConsoleBreadcrumbHandler(client) {
    return function _consoleBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const breadcrumb = {
        category: "console",
        data: {
          arguments: handlerData.args,
          logger: "console"
        },
        level: severityLevelFromString(handlerData.level),
        message: safeJoin(handlerData.args, " ")
      };
      if (handlerData.level === "assert") {
        if (handlerData.args[0] === false) {
          breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`;
          breadcrumb.data.arguments = handlerData.args.slice(1);
        } else {
          return;
        }
      }
      addBreadcrumb(breadcrumb, {
        input: handlerData.args,
        level: handlerData.level
      });
    };
  }
  function _getXhrBreadcrumbHandler(client) {
    return function _xhrBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const { startTimestamp, endTimestamp } = handlerData;
      const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];
      if (!startTimestamp || !endTimestamp || !sentryXhrData) {
        return;
      }
      const { method, url, status_code, body } = sentryXhrData;
      const data = {
        method,
        url,
        status_code
      };
      const hint = {
        xhr: handlerData.xhr,
        input: body,
        startTimestamp,
        endTimestamp
      };
      addBreadcrumb(
        {
          category: "xhr",
          data,
          type: "http"
        },
        hint
      );
    };
  }
  function _getFetchBreadcrumbHandler(client) {
    return function _fetchBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const { startTimestamp, endTimestamp } = handlerData;
      if (!endTimestamp) {
        return;
      }
      if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
        return;
      }
      if (handlerData.error) {
        const data = handlerData.fetchData;
        const hint = {
          data: handlerData.error,
          input: handlerData.args,
          startTimestamp,
          endTimestamp
        };
        addBreadcrumb(
          {
            category: "fetch",
            data,
            level: "error",
            type: "http"
          },
          hint
        );
      } else {
        const response = handlerData.response;
        const data = {
          ...handlerData.fetchData,
          status_code: response && response.status
        };
        const hint = {
          input: handlerData.args,
          response,
          startTimestamp,
          endTimestamp
        };
        addBreadcrumb(
          {
            category: "fetch",
            data,
            type: "http"
          },
          hint
        );
      }
    };
  }
  function _getHistoryBreadcrumbHandler(client) {
    return function _historyBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      let from2 = handlerData.from;
      let to = handlerData.to;
      const parsedLoc = parseUrl2(WINDOW8.location.href);
      let parsedFrom = from2 ? parseUrl2(from2) : void 0;
      const parsedTo = parseUrl2(to);
      if (!parsedFrom || !parsedFrom.path) {
        parsedFrom = parsedLoc;
      }
      if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
        to = parsedTo.relative;
      }
      if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
        from2 = parsedFrom.relative;
      }
      addBreadcrumb({
        category: "navigation",
        data: {
          from: from2,
          to
        }
      });
    };
  }
  function _isEvent(event) {
    return !!event && !!event.target;
  }

  // node_modules/@sentry/browser/esm/integrations/dedupe.js
  var INTEGRATION_NAME5 = "Dedupe";
  var _dedupeIntegration = () => {
    let previousEvent;
    return {
      name: INTEGRATION_NAME5,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      processEvent(currentEvent) {
        if (currentEvent.type) {
          return currentEvent;
        }
        try {
          if (_shouldDropEvent2(currentEvent, previousEvent)) {
            DEBUG_BUILD4 && logger.warn("Event dropped due to being a duplicate of previously captured event.");
            return null;
          }
        } catch (_oO) {
        }
        return previousEvent = currentEvent;
      }
    };
  };
  var dedupeIntegration = defineIntegration(_dedupeIntegration);
  var Dedupe = convertIntegrationFnToClass(INTEGRATION_NAME5, dedupeIntegration);
  function _shouldDropEvent2(currentEvent, previousEvent) {
    if (!previousEvent) {
      return false;
    }
    if (_isSameMessageEvent(currentEvent, previousEvent)) {
      return true;
    }
    if (_isSameExceptionEvent(currentEvent, previousEvent)) {
      return true;
    }
    return false;
  }
  function _isSameMessageEvent(currentEvent, previousEvent) {
    const currentMessage = currentEvent.message;
    const previousMessage = previousEvent.message;
    if (!currentMessage && !previousMessage) {
      return false;
    }
    if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
      return false;
    }
    if (currentMessage !== previousMessage) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameExceptionEvent(currentEvent, previousEvent) {
    const previousException = _getExceptionFromEvent(previousEvent);
    const currentException = _getExceptionFromEvent(currentEvent);
    if (!previousException || !currentException) {
      return false;
    }
    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameStacktrace(currentEvent, previousEvent) {
    let currentFrames = _getFramesFromEvent(currentEvent);
    let previousFrames = _getFramesFromEvent(previousEvent);
    if (!currentFrames && !previousFrames) {
      return true;
    }
    if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
      return false;
    }
    currentFrames = currentFrames;
    previousFrames = previousFrames;
    if (previousFrames.length !== currentFrames.length) {
      return false;
    }
    for (let i = 0; i < previousFrames.length; i++) {
      const frameA = previousFrames[i];
      const frameB = currentFrames[i];
      if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
        return false;
      }
    }
    return true;
  }
  function _isSameFingerprint(currentEvent, previousEvent) {
    let currentFingerprint = currentEvent.fingerprint;
    let previousFingerprint = previousEvent.fingerprint;
    if (!currentFingerprint && !previousFingerprint) {
      return true;
    }
    if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
      return false;
    }
    currentFingerprint = currentFingerprint;
    previousFingerprint = previousFingerprint;
    try {
      return !!(currentFingerprint.join("") === previousFingerprint.join(""));
    } catch (_oO) {
      return false;
    }
  }
  function _getExceptionFromEvent(event) {
    return event.exception && event.exception.values && event.exception.values[0];
  }
  function _getFramesFromEvent(event) {
    const exception = event.exception;
    if (exception) {
      try {
        return exception.values[0].stacktrace.frames;
      } catch (_oO) {
        return void 0;
      }
    }
    return void 0;
  }

  // node_modules/@sentry/browser/esm/integrations/globalhandlers.js
  var INTEGRATION_NAME6 = "GlobalHandlers";
  var _globalHandlersIntegration = (options = {}) => {
    const _options = {
      onerror: true,
      onunhandledrejection: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME6,
      setupOnce() {
        Error.stackTraceLimit = 50;
      },
      setup(client) {
        if (_options.onerror) {
          _installGlobalOnErrorHandler(client);
          globalHandlerLog("onerror");
        }
        if (_options.onunhandledrejection) {
          _installGlobalOnUnhandledRejectionHandler(client);
          globalHandlerLog("onunhandledrejection");
        }
      }
    };
  };
  var globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);
  var GlobalHandlers = convertIntegrationFnToClass(
    INTEGRATION_NAME6,
    globalHandlersIntegration
  );
  function _installGlobalOnErrorHandler(client) {
    addGlobalErrorInstrumentationHandler((data) => {
      const { stackParser, attachStacktrace } = getOptions();
      if (getClient() !== client || shouldIgnoreOnError()) {
        return;
      }
      const { msg, url, line: line3, column: column2, error: error2 } = data;
      const event = error2 === void 0 && isString3(msg) ? _eventFromIncompleteOnError(msg, url, line3, column2) : _enhanceEventWithInitialFrame(
        eventFromUnknownInput2(stackParser, error2 || msg, void 0, attachStacktrace, false),
        url,
        line3,
        column2
      );
      event.level = "error";
      captureEvent(event, {
        originalException: error2,
        mechanism: {
          handled: false,
          type: "onerror"
        }
      });
    });
  }
  function _installGlobalOnUnhandledRejectionHandler(client) {
    addGlobalUnhandledRejectionInstrumentationHandler((e3) => {
      const { stackParser, attachStacktrace } = getOptions();
      if (getClient() !== client || shouldIgnoreOnError()) {
        return;
      }
      const error2 = _getUnhandledRejectionError(e3);
      const event = isPrimitive(error2) ? _eventFromRejectionWithPrimitive(error2) : eventFromUnknownInput2(stackParser, error2, void 0, attachStacktrace, true);
      event.level = "error";
      captureEvent(event, {
        originalException: error2,
        mechanism: {
          handled: false,
          type: "onunhandledrejection"
        }
      });
    });
  }
  function _getUnhandledRejectionError(error2) {
    if (isPrimitive(error2)) {
      return error2;
    }
    const e3 = error2;
    try {
      if ("reason" in e3) {
        return e3.reason;
      } else if ("detail" in e3 && "reason" in e3.detail) {
        return e3.detail.reason;
      }
    } catch (e22) {
    }
    return error2;
  }
  function _eventFromRejectionWithPrimitive(reason) {
    return {
      exception: {
        values: [
          {
            type: "UnhandledRejection",
            // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
            value: `Non-Error promise rejection captured with value: ${String(reason)}`
          }
        ]
      }
    };
  }
  function _eventFromIncompleteOnError(msg, url, line3, column2) {
    const ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
    let message = isErrorEvent(msg) ? msg.message : msg;
    let name = "Error";
    const groups = message.match(ERROR_TYPES_RE);
    if (groups) {
      name = groups[1];
      message = groups[2];
    }
    const event = {
      exception: {
        values: [
          {
            type: name,
            value: message
          }
        ]
      }
    };
    return _enhanceEventWithInitialFrame(event, url, line3, column2);
  }
  function _enhanceEventWithInitialFrame(event, url, line3, column2) {
    const e3 = event.exception = event.exception || {};
    const ev = e3.values = e3.values || [];
    const ev0 = ev[0] = ev[0] || {};
    const ev0s = ev0.stacktrace = ev0.stacktrace || {};
    const ev0sf = ev0s.frames = ev0s.frames || [];
    const colno = isNaN(parseInt(column2, 10)) ? void 0 : column2;
    const lineno = isNaN(parseInt(line3, 10)) ? void 0 : line3;
    const filename = isString3(url) && url.length > 0 ? url : getLocationHref();
    if (ev0sf.length === 0) {
      ev0sf.push({
        colno,
        filename,
        function: "?",
        in_app: true,
        lineno
      });
    }
    return event;
  }
  function globalHandlerLog(type) {
    DEBUG_BUILD4 && logger.log(`Global Handler attached: ${type}`);
  }
  function getOptions() {
    const client = getClient();
    const options = client && client.getOptions() || {
      stackParser: () => [],
      attachStacktrace: false
    };
    return options;
  }

  // node_modules/@sentry/browser/esm/integrations/httpcontext.js
  var INTEGRATION_NAME7 = "HttpContext";
  var _httpContextIntegration = () => {
    return {
      name: INTEGRATION_NAME7,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      preprocessEvent(event) {
        if (!WINDOW8.navigator && !WINDOW8.location && !WINDOW8.document) {
          return;
        }
        const url = event.request && event.request.url || WINDOW8.location && WINDOW8.location.href;
        const { referrer } = WINDOW8.document || {};
        const { userAgent } = WINDOW8.navigator || {};
        const headers = {
          ...event.request && event.request.headers,
          ...referrer && { Referer: referrer },
          ...userAgent && { "User-Agent": userAgent }
        };
        const request = { ...event.request, ...url && { url }, headers };
        event.request = request;
      }
    };
  };
  var httpContextIntegration = defineIntegration(_httpContextIntegration);
  var HttpContext = convertIntegrationFnToClass(INTEGRATION_NAME7, httpContextIntegration);

  // node_modules/@sentry/browser/esm/integrations/linkederrors.js
  var DEFAULT_KEY2 = "cause";
  var DEFAULT_LIMIT2 = 5;
  var INTEGRATION_NAME8 = "LinkedErrors";
  var _linkedErrorsIntegration2 = (options = {}) => {
    const limit = options.limit || DEFAULT_LIMIT2;
    const key = options.key || DEFAULT_KEY2;
    return {
      name: INTEGRATION_NAME8,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      preprocessEvent(event, hint, client) {
        const options2 = client.getOptions();
        applyAggregateErrorsToEvent(
          // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
          exceptionFromError2,
          options2.stackParser,
          options2.maxValueLength,
          key,
          limit,
          event,
          hint
        );
      }
    };
  };
  var linkedErrorsIntegration2 = defineIntegration(_linkedErrorsIntegration2);
  var LinkedErrors2 = convertIntegrationFnToClass(INTEGRATION_NAME8, linkedErrorsIntegration2);

  // node_modules/@sentry/browser/esm/integrations/trycatch.js
  var DEFAULT_EVENT_TARGET = [
    "EventTarget",
    "Window",
    "Node",
    "ApplicationCache",
    "AudioTrackList",
    "BroadcastChannel",
    "ChannelMergerNode",
    "CryptoOperation",
    "EventSource",
    "FileReader",
    "HTMLUnknownElement",
    "IDBDatabase",
    "IDBRequest",
    "IDBTransaction",
    "KeyOperation",
    "MediaController",
    "MessagePort",
    "ModalWindow",
    "Notification",
    "SVGElementInstance",
    "Screen",
    "SharedWorker",
    "TextTrack",
    "TextTrackCue",
    "TextTrackList",
    "WebSocket",
    "WebSocketWorker",
    "Worker",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload"
  ];
  var INTEGRATION_NAME9 = "TryCatch";
  var _browserApiErrorsIntegration = (options = {}) => {
    const _options = {
      XMLHttpRequest: true,
      eventTarget: true,
      requestAnimationFrame: true,
      setInterval: true,
      setTimeout: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME9,
      // TODO: This currently only works for the first client this is setup
      // We may want to adjust this to check for client etc.
      setupOnce() {
        if (_options.setTimeout) {
          fill(WINDOW8, "setTimeout", _wrapTimeFunction);
        }
        if (_options.setInterval) {
          fill(WINDOW8, "setInterval", _wrapTimeFunction);
        }
        if (_options.requestAnimationFrame) {
          fill(WINDOW8, "requestAnimationFrame", _wrapRAF);
        }
        if (_options.XMLHttpRequest && "XMLHttpRequest" in WINDOW8) {
          fill(XMLHttpRequest.prototype, "send", _wrapXHR);
        }
        const eventTargetOption = _options.eventTarget;
        if (eventTargetOption) {
          const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
          eventTarget.forEach(_wrapEventTarget);
        }
      }
    };
  };
  var browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);
  var TryCatch = convertIntegrationFnToClass(
    INTEGRATION_NAME9,
    browserApiErrorsIntegration
  );
  function _wrapTimeFunction(original) {
    return function(...args) {
      const originalCallback = args[0];
      args[0] = wrap2(originalCallback, {
        mechanism: {
          data: { function: getFunctionName(original) },
          handled: false,
          type: "instrument"
        }
      });
      return original.apply(this, args);
    };
  }
  function _wrapRAF(original) {
    return function(callback) {
      return original.apply(this, [
        wrap2(callback, {
          mechanism: {
            data: {
              function: "requestAnimationFrame",
              handler: getFunctionName(original)
            },
            handled: false,
            type: "instrument"
          }
        })
      ]);
    };
  }
  function _wrapXHR(originalSend) {
    return function(...args) {
      const xhr = this;
      const xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
      xmlHttpRequestProps.forEach((prop) => {
        if (prop in xhr && typeof xhr[prop] === "function") {
          fill(xhr, prop, function(original) {
            const wrapOptions = {
              mechanism: {
                data: {
                  function: prop,
                  handler: getFunctionName(original)
                },
                handled: false,
                type: "instrument"
              }
            };
            const originalFunction = getOriginalFunction(original);
            if (originalFunction) {
              wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
            }
            return wrap2(original, wrapOptions);
          });
        }
      });
      return originalSend.apply(this, args);
    };
  }
  function _wrapEventTarget(target) {
    const globalObject = WINDOW8;
    const proto = globalObject[target] && globalObject[target].prototype;
    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto, "addEventListener", function(original) {
      return function(eventName, fn2, options) {
        try {
          if (typeof fn2.handleEvent === "function") {
            fn2.handleEvent = wrap2(fn2.handleEvent, {
              mechanism: {
                data: {
                  function: "handleEvent",
                  handler: getFunctionName(fn2),
                  target
                },
                handled: false,
                type: "instrument"
              }
            });
          }
        } catch (err) {
        }
        return original.apply(this, [
          eventName,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          wrap2(fn2, {
            mechanism: {
              data: {
                function: "addEventListener",
                handler: getFunctionName(fn2),
                target
              },
              handled: false,
              type: "instrument"
            }
          }),
          options
        ]);
      };
    });
    fill(
      proto,
      "removeEventListener",
      function(originalRemoveEventListener) {
        return function(eventName, fn2, options) {
          const wrappedEventHandler = fn2;
          try {
            const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
            if (originalEventHandler) {
              originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
            }
          } catch (e3) {
          }
          return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
        };
      }
    );
  }

  // node_modules/@sentry/browser/esm/sdk.js
  var defaultIntegrations = [
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    browserApiErrorsIntegration(),
    breadcrumbsIntegration(),
    globalHandlersIntegration(),
    linkedErrorsIntegration2(),
    dedupeIntegration(),
    httpContextIntegration()
  ];
  function getDefaultIntegrations(_options) {
    return [
      // eslint-disable-next-line deprecation/deprecation
      ...defaultIntegrations
    ];
  }
  function init(options = {}) {
    if (options.defaultIntegrations === void 0) {
      options.defaultIntegrations = getDefaultIntegrations();
    }
    if (options.release === void 0) {
      if (typeof __SENTRY_RELEASE__ === "string") {
        options.release = __SENTRY_RELEASE__;
      }
      if (WINDOW8.SENTRY_RELEASE && WINDOW8.SENTRY_RELEASE.id) {
        options.release = WINDOW8.SENTRY_RELEASE.id;
      }
    }
    if (options.autoSessionTracking === void 0) {
      options.autoSessionTracking = true;
    }
    if (options.sendClientReports === void 0) {
      options.sendClientReports = true;
    }
    const clientOptions = {
      ...options,
      stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
      integrations: getIntegrationsToSetup(options),
      transport: options.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport)
    };
    initAndBind(BrowserClient, clientOptions);
    if (options.autoSessionTracking) {
      startSessionTracking();
    }
  }
  function startSessionTracking() {
    if (typeof WINDOW8.document === "undefined") {
      DEBUG_BUILD4 && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
      return;
    }
    startSession({ ignoreDuration: true });
    captureSession();
    addHistoryInstrumentationHandler(({ from: from2, to }) => {
      if (from2 !== void 0 && from2 !== to) {
        startSession({ ignoreDuration: true });
        captureSession();
      }
    });
  }

  // node_modules/@sentry/browser/esm/integrations/index.js
  var integrations_exports2 = {};
  __export(integrations_exports2, {
    Breadcrumbs: () => Breadcrumbs,
    Dedupe: () => Dedupe,
    GlobalHandlers: () => GlobalHandlers,
    HttpContext: () => HttpContext,
    LinkedErrors: () => LinkedErrors2,
    TryCatch: () => TryCatch
  });

  // node_modules/@sentry/replay/esm/index.js
  var WINDOW9 = GLOBAL_OBJ;
  var REPLAY_SESSION_KEY = "sentryReplaySession";
  var REPLAY_EVENT_NAME = "replay_event";
  var UNABLE_TO_SEND_REPLAY = "Unable to send Replay";
  var SESSION_IDLE_PAUSE_DURATION = 3e5;
  var SESSION_IDLE_EXPIRE_DURATION = 9e5;
  var DEFAULT_FLUSH_MIN_DELAY = 5e3;
  var DEFAULT_FLUSH_MAX_DELAY = 5500;
  var BUFFER_CHECKOUT_TIME = 6e4;
  var RETRY_BASE_INTERVAL = 5e3;
  var RETRY_MAX_COUNT = 3;
  var NETWORK_BODY_MAX_SIZE = 15e4;
  var CONSOLE_ARG_MAX_SIZE = 5e3;
  var SLOW_CLICK_THRESHOLD = 3e3;
  var SLOW_CLICK_SCROLL_TIMEOUT = 300;
  var REPLAY_MAX_EVENT_BUFFER_SIZE = 2e7;
  var MIN_REPLAY_DURATION = 4999;
  var MIN_REPLAY_DURATION_LIMIT = 15e3;
  var MAX_REPLAY_DURATION = 36e5;
  function _nullishCoalesce$1(lhs, rhsFn) {
    if (lhs != null) {
      return lhs;
    } else {
      return rhsFn();
    }
  }
  function _optionalChain$5(ops) {
    let lastAccessLHS = void 0;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn2 = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return void 0;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn2(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn2((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = void 0;
      }
    }
    return value;
  }
  var NodeType$1;
  (function(NodeType2) {
    NodeType2[NodeType2["Document"] = 0] = "Document";
    NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
    NodeType2[NodeType2["Element"] = 2] = "Element";
    NodeType2[NodeType2["Text"] = 3] = "Text";
    NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
    NodeType2[NodeType2["Comment"] = 5] = "Comment";
  })(NodeType$1 || (NodeType$1 = {}));
  function isElement$1(n2) {
    return n2.nodeType === n2.ELEMENT_NODE;
  }
  function isShadowRoot2(n2) {
    const host = _optionalChain$5([n2, "optionalAccess", (_) => _.host]);
    return Boolean(_optionalChain$5([host, "optionalAccess", (_2) => _2.shadowRoot]) === n2);
  }
  function isNativeShadowDom(shadowRoot) {
    return Object.prototype.toString.call(shadowRoot) === "[object ShadowRoot]";
  }
  function fixBrowserCompatibilityIssuesInCSS(cssText) {
    if (cssText.includes(" background-clip: text;") && !cssText.includes(" -webkit-background-clip: text;")) {
      cssText = cssText.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;");
    }
    return cssText;
  }
  function escapeImportStatement(rule) {
    const { cssText } = rule;
    if (cssText.split('"').length < 3)
      return cssText;
    const statement = ["@import", `url(${JSON.stringify(rule.href)})`];
    if (rule.layerName === "") {
      statement.push(`layer`);
    } else if (rule.layerName) {
      statement.push(`layer(${rule.layerName})`);
    }
    if (rule.supportsText) {
      statement.push(`supports(${rule.supportsText})`);
    }
    if (rule.media.length) {
      statement.push(rule.media.mediaText);
    }
    return statement.join(" ") + ";";
  }
  function stringifyStylesheet(s2) {
    try {
      const rules = s2.rules || s2.cssRules;
      return rules ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join("")) : null;
    } catch (error2) {
      return null;
    }
  }
  function stringifyRule(rule) {
    let importStringified;
    if (isCSSImportRule(rule)) {
      try {
        importStringified = stringifyStylesheet(rule.styleSheet) || escapeImportStatement(rule);
      } catch (error2) {
      }
    } else if (isCSSStyleRule(rule) && rule.selectorText.includes(":")) {
      return fixSafariColons(rule.cssText);
    }
    return importStringified || rule.cssText;
  }
  function fixSafariColons(cssStringified) {
    const regex = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
    return cssStringified.replace(regex, "$1\\$2");
  }
  function isCSSImportRule(rule) {
    return "styleSheet" in rule;
  }
  function isCSSStyleRule(rule) {
    return "selectorText" in rule;
  }
  var Mirror = class {
    constructor() {
      this.idNodeMap = /* @__PURE__ */ new Map();
      this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
    }
    getId(n2) {
      if (!n2)
        return -1;
      const id3 = _optionalChain$5([this, "access", (_3) => _3.getMeta, "call", (_4) => _4(n2), "optionalAccess", (_5) => _5.id]);
      return _nullishCoalesce$1(id3, () => -1);
    }
    getNode(id3) {
      return this.idNodeMap.get(id3) || null;
    }
    getIds() {
      return Array.from(this.idNodeMap.keys());
    }
    getMeta(n2) {
      return this.nodeMetaMap.get(n2) || null;
    }
    removeNodeFromMap(n2) {
      const id3 = this.getId(n2);
      this.idNodeMap.delete(id3);
      if (n2.childNodes) {
        n2.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));
      }
    }
    has(id3) {
      return this.idNodeMap.has(id3);
    }
    hasNode(node2) {
      return this.nodeMetaMap.has(node2);
    }
    add(n2, meta) {
      const id3 = meta.id;
      this.idNodeMap.set(id3, n2);
      this.nodeMetaMap.set(n2, meta);
    }
    replace(id3, n2) {
      const oldNode = this.getNode(id3);
      if (oldNode) {
        const meta = this.nodeMetaMap.get(oldNode);
        if (meta)
          this.nodeMetaMap.set(n2, meta);
      }
      this.idNodeMap.set(id3, n2);
    }
    reset() {
      this.idNodeMap = /* @__PURE__ */ new Map();
      this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
    }
  };
  function createMirror() {
    return new Mirror();
  }
  function shouldMaskInput({ maskInputOptions, tagName, type }) {
    if (tagName === "OPTION") {
      tagName = "SELECT";
    }
    return Boolean(maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === "password" || tagName === "INPUT" && !type && maskInputOptions["text"]);
  }
  function maskInputValue({ isMasked, element, value, maskInputFn }) {
    let text = value || "";
    if (!isMasked) {
      return text;
    }
    if (maskInputFn) {
      text = maskInputFn(text, element);
    }
    return "*".repeat(text.length);
  }
  function toLowerCase(str) {
    return str.toLowerCase();
  }
  function toUpperCase(str) {
    return str.toUpperCase();
  }
  var ORIGINAL_ATTRIBUTE_NAME = "__rrweb_original__";
  function is2DCanvasBlank(canvas) {
    const ctx = canvas.getContext("2d");
    if (!ctx)
      return true;
    const chunkSize = 50;
    for (let x = 0; x < canvas.width; x += chunkSize) {
      for (let y = 0; y < canvas.height; y += chunkSize) {
        const getImageData = ctx.getImageData;
        const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;
        const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);
        if (pixelBuffer.some((pixel) => pixel !== 0))
          return false;
      }
    }
    return true;
  }
  function getInputType(element) {
    const type = element.type;
    return element.hasAttribute("data-rr-is-password") ? "password" : type ? toLowerCase(type) : null;
  }
  function getInputValue(el, tagName, type) {
    if (tagName === "INPUT" && (type === "radio" || type === "checkbox")) {
      return el.getAttribute("value") || "";
    }
    return el.value;
  }
  var _id = 1;
  var tagNameRegex = new RegExp("[^a-z0-9-_:]");
  var IGNORED_NODE = -2;
  function genId() {
    return _id++;
  }
  function getValidTagName(element) {
    if (element instanceof HTMLFormElement) {
      return "form";
    }
    const processedTagName = toLowerCase(element.tagName);
    if (tagNameRegex.test(processedTagName)) {
      return "div";
    }
    return processedTagName;
  }
  function extractOrigin(url) {
    let origin = "";
    if (url.indexOf("//") > -1) {
      origin = url.split("/").slice(0, 3).join("/");
    } else {
      origin = url.split("/")[0];
    }
    origin = origin.split("?")[0];
    return origin;
  }
  var canvasService;
  var canvasCtx;
  var URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
  var URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\/\//i;
  var URL_WWW_MATCH = /^www\..*/i;
  var DATA_URI = /^(data:)([^,]*),(.*)/i;
  function absoluteToStylesheet(cssText, href) {
    return (cssText || "").replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {
      const filePath = path1 || path2 || path3;
      const maybeQuote = quote1 || quote2 || "";
      if (!filePath) {
        return origin;
      }
      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {
        return `url(${maybeQuote}${filePath}${maybeQuote})`;
      }
      if (DATA_URI.test(filePath)) {
        return `url(${maybeQuote}${filePath}${maybeQuote})`;
      }
      if (filePath[0] === "/") {
        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;
      }
      const stack = href.split("/");
      const parts = filePath.split("/");
      stack.pop();
      for (const part of parts) {
        if (part === ".") {
          continue;
        } else if (part === "..") {
          stack.pop();
        } else {
          stack.push(part);
        }
      }
      return `url(${maybeQuote}${stack.join("/")}${maybeQuote})`;
    });
  }
  var SRCSET_NOT_SPACES = /^[^ \t\n\r\u000c]+/;
  var SRCSET_COMMAS_OR_SPACES = /^[, \t\n\r\u000c]+/;
  function getAbsoluteSrcsetString(doc, attributeValue) {
    if (attributeValue.trim() === "") {
      return attributeValue;
    }
    let pos = 0;
    function collectCharacters(regEx) {
      let chars;
      const match3 = regEx.exec(attributeValue.substring(pos));
      if (match3) {
        chars = match3[0];
        pos += chars.length;
        return chars;
      }
      return "";
    }
    const output = [];
    while (true) {
      collectCharacters(SRCSET_COMMAS_OR_SPACES);
      if (pos >= attributeValue.length) {
        break;
      }
      let url = collectCharacters(SRCSET_NOT_SPACES);
      if (url.slice(-1) === ",") {
        url = absoluteToDoc(doc, url.substring(0, url.length - 1));
        output.push(url);
      } else {
        let descriptorsStr = "";
        url = absoluteToDoc(doc, url);
        let inParens = false;
        while (true) {
          const c = attributeValue.charAt(pos);
          if (c === "") {
            output.push((url + descriptorsStr).trim());
            break;
          } else if (!inParens) {
            if (c === ",") {
              pos += 1;
              output.push((url + descriptorsStr).trim());
              break;
            } else if (c === "(") {
              inParens = true;
            }
          } else {
            if (c === ")") {
              inParens = false;
            }
          }
          descriptorsStr += c;
          pos += 1;
        }
      }
    }
    return output.join(", ");
  }
  function absoluteToDoc(doc, attributeValue) {
    if (!attributeValue || attributeValue.trim() === "") {
      return attributeValue;
    }
    const a = doc.createElement("a");
    a.href = attributeValue;
    return a.href;
  }
  function isSVGElement3(el) {
    return Boolean(el.tagName === "svg" || el.ownerSVGElement);
  }
  function getHref() {
    const a = document.createElement("a");
    a.href = "";
    return a.href;
  }
  function transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {
    if (!value) {
      return value;
    }
    if (name === "src" || name === "href" && !(tagName === "use" && value[0] === "#")) {
      return absoluteToDoc(doc, value);
    } else if (name === "xlink:href" && value[0] !== "#") {
      return absoluteToDoc(doc, value);
    } else if (name === "background" && (tagName === "table" || tagName === "td" || tagName === "th")) {
      return absoluteToDoc(doc, value);
    } else if (name === "srcset") {
      return getAbsoluteSrcsetString(doc, value);
    } else if (name === "style") {
      return absoluteToStylesheet(value, getHref());
    } else if (tagName === "object" && name === "data") {
      return absoluteToDoc(doc, value);
    }
    if (typeof maskAttributeFn === "function") {
      return maskAttributeFn(name, value, element);
    }
    return value;
  }
  function ignoreAttribute(tagName, name, _value) {
    return (tagName === "video" || tagName === "audio") && name === "autoplay";
  }
  function _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {
    try {
      if (unblockSelector && element.matches(unblockSelector)) {
        return false;
      }
      if (typeof blockClass === "string") {
        if (element.classList.contains(blockClass)) {
          return true;
        }
      } else {
        for (let eIndex = element.classList.length; eIndex--; ) {
          const className = element.classList[eIndex];
          if (blockClass.test(className)) {
            return true;
          }
        }
      }
      if (blockSelector) {
        return element.matches(blockSelector);
      }
    } catch (e3) {
    }
    return false;
  }
  function elementClassMatchesRegex(el, regex) {
    for (let eIndex = el.classList.length; eIndex--; ) {
      const className = el.classList[eIndex];
      if (regex.test(className)) {
        return true;
      }
    }
    return false;
  }
  function distanceToMatch(node2, matchPredicate, limit = Infinity, distance3 = 0) {
    if (!node2)
      return -1;
    if (node2.nodeType !== node2.ELEMENT_NODE)
      return -1;
    if (distance3 > limit)
      return -1;
    if (matchPredicate(node2))
      return distance3;
    return distanceToMatch(node2.parentNode, matchPredicate, limit, distance3 + 1);
  }
  function createMatchPredicate(className, selector) {
    return (node2) => {
      const el = node2;
      if (el === null)
        return false;
      try {
        if (className) {
          if (typeof className === "string") {
            if (el.matches(`.${className}`))
              return true;
          } else if (elementClassMatchesRegex(el, className)) {
            return true;
          }
        }
        if (selector && el.matches(selector))
          return true;
        return false;
      } catch (e22) {
        return false;
      }
    };
  }
  function needMaskingText(node2, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {
    try {
      const el = node2.nodeType === node2.ELEMENT_NODE ? node2 : node2.parentElement;
      if (el === null)
        return false;
      if (el.tagName === "INPUT") {
        const autocomplete = el.getAttribute("autocomplete");
        const disallowedAutocompleteValues = [
          "current-password",
          "new-password",
          "cc-number",
          "cc-exp",
          "cc-exp-month",
          "cc-exp-year",
          "cc-csc"
        ];
        if (disallowedAutocompleteValues.includes(autocomplete)) {
          return true;
        }
      }
      let maskDistance = -1;
      let unmaskDistance = -1;
      if (maskAllText) {
        unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector));
        if (unmaskDistance < 0) {
          return true;
        }
        maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector), unmaskDistance >= 0 ? unmaskDistance : Infinity);
      } else {
        maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector));
        if (maskDistance < 0) {
          return false;
        }
        unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector), maskDistance >= 0 ? maskDistance : Infinity);
      }
      return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;
    } catch (e3) {
    }
    return !!maskAllText;
  }
  function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
    const win = iframeEl.contentWindow;
    if (!win) {
      return;
    }
    let fired = false;
    let readyState;
    try {
      readyState = win.document.readyState;
    } catch (error2) {
      return;
    }
    if (readyState !== "complete") {
      const timer = setTimeout(() => {
        if (!fired) {
          listener();
          fired = true;
        }
      }, iframeLoadTimeout);
      iframeEl.addEventListener("load", () => {
        clearTimeout(timer);
        fired = true;
        listener();
      });
      return;
    }
    const blankUrl = "about:blank";
    if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === "") {
      setTimeout(listener, 0);
      return iframeEl.addEventListener("load", listener);
    }
    iframeEl.addEventListener("load", listener);
  }
  function onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {
    let fired = false;
    let styleSheetLoaded;
    try {
      styleSheetLoaded = link.sheet;
    } catch (error2) {
      return;
    }
    if (styleSheetLoaded)
      return;
    const timer = setTimeout(() => {
      if (!fired) {
        listener();
        fired = true;
      }
    }, styleSheetLoadTimeout);
    link.addEventListener("load", () => {
      clearTimeout(timer);
      fired = true;
      listener();
    });
  }
  function serializeNode(n2, options) {
    const { doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, maskAllText, maskAttributeFn, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false } = options;
    const rootId = getRootId(doc, mirror2);
    switch (n2.nodeType) {
      case n2.DOCUMENT_NODE:
        if (n2.compatMode !== "CSS1Compat") {
          return {
            type: NodeType$1.Document,
            childNodes: [],
            compatMode: n2.compatMode
          };
        } else {
          return {
            type: NodeType$1.Document,
            childNodes: []
          };
        }
      case n2.DOCUMENT_TYPE_NODE:
        return {
          type: NodeType$1.DocumentType,
          name: n2.name,
          publicId: n2.publicId,
          systemId: n2.systemId,
          rootId
        };
      case n2.ELEMENT_NODE:
        return serializeElementNode(n2, {
          doc,
          blockClass,
          blockSelector,
          unblockSelector,
          inlineStylesheet,
          maskAttributeFn,
          maskInputOptions,
          maskInputFn,
          dataURLOptions,
          inlineImages,
          recordCanvas,
          keepIframeSrcFn,
          newlyAddedElement,
          rootId,
          maskAllText,
          maskTextClass,
          unmaskTextClass,
          maskTextSelector,
          unmaskTextSelector
        });
      case n2.TEXT_NODE:
        return serializeTextNode(n2, {
          maskAllText,
          maskTextClass,
          unmaskTextClass,
          maskTextSelector,
          unmaskTextSelector,
          maskTextFn,
          maskInputOptions,
          maskInputFn,
          rootId
        });
      case n2.CDATA_SECTION_NODE:
        return {
          type: NodeType$1.CDATA,
          textContent: "",
          rootId
        };
      case n2.COMMENT_NODE:
        return {
          type: NodeType$1.Comment,
          textContent: n2.textContent || "",
          rootId
        };
      default:
        return false;
    }
  }
  function getRootId(doc, mirror2) {
    if (!mirror2.hasNode(doc))
      return void 0;
    const docId = mirror2.getId(doc);
    return docId === 1 ? void 0 : docId;
  }
  function serializeTextNode(n2, options) {
    const { maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, maskTextFn, maskInputOptions, maskInputFn, rootId } = options;
    const parentTagName = n2.parentNode && n2.parentNode.tagName;
    let textContent = n2.textContent;
    const isStyle = parentTagName === "STYLE" ? true : void 0;
    const isScript = parentTagName === "SCRIPT" ? true : void 0;
    const isTextarea = parentTagName === "TEXTAREA" ? true : void 0;
    if (isStyle && textContent) {
      try {
        if (n2.nextSibling || n2.previousSibling) {
        } else if (_optionalChain$5([n2, "access", (_6) => _6.parentNode, "access", (_7) => _7.sheet, "optionalAccess", (_8) => _8.cssRules])) {
          textContent = stringifyStylesheet(n2.parentNode.sheet);
        }
      } catch (err) {
        console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n2);
      }
      textContent = absoluteToStylesheet(textContent, getHref());
    }
    if (isScript) {
      textContent = "SCRIPT_PLACEHOLDER";
    }
    const forceMask = needMaskingText(n2, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText);
    if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {
      textContent = maskTextFn ? maskTextFn(textContent) : textContent.replace(/[\S]/g, "*");
    }
    if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {
      textContent = maskInputFn ? maskInputFn(textContent, n2.parentNode) : textContent.replace(/[\S]/g, "*");
    }
    if (parentTagName === "OPTION" && textContent) {
      const isInputMasked = shouldMaskInput({
        type: null,
        tagName: parentTagName,
        maskInputOptions
      });
      textContent = maskInputValue({
        isMasked: needMaskingText(n2, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked),
        element: n2,
        value: textContent,
        maskInputFn
      });
    }
    return {
      type: NodeType$1.Text,
      textContent: textContent || "",
      isStyle,
      rootId
    };
  }
  function serializeElementNode(n2, options) {
    const { doc, blockClass, blockSelector, unblockSelector, inlineStylesheet, maskInputOptions = {}, maskAttributeFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector } = options;
    const needBlock = _isBlockedElement(n2, blockClass, blockSelector, unblockSelector);
    const tagName = getValidTagName(n2);
    let attributes = {};
    const len = n2.attributes.length;
    for (let i = 0; i < len; i++) {
      const attr = n2.attributes[i];
      if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {
        attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value, n2, maskAttributeFn);
      }
    }
    if (tagName === "link" && inlineStylesheet) {
      const stylesheet = Array.from(doc.styleSheets).find((s2) => {
        return s2.href === n2.href;
      });
      let cssText = null;
      if (stylesheet) {
        cssText = stringifyStylesheet(stylesheet);
      }
      if (cssText) {
        delete attributes.rel;
        delete attributes.href;
        attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);
      }
    }
    if (tagName === "style" && n2.sheet && !(n2.innerText || n2.textContent || "").trim().length) {
      const cssText = stringifyStylesheet(n2.sheet);
      if (cssText) {
        attributes._cssText = absoluteToStylesheet(cssText, getHref());
      }
    }
    if (tagName === "input" || tagName === "textarea" || tagName === "select" || tagName === "option") {
      const el = n2;
      const type = getInputType(el);
      const value = getInputValue(el, toUpperCase(tagName), type);
      const checked = el.checked;
      if (type !== "submit" && type !== "button" && value) {
        const forceMask = needMaskingText(el, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, shouldMaskInput({
          type,
          tagName: toUpperCase(tagName),
          maskInputOptions
        }));
        attributes.value = maskInputValue({
          isMasked: forceMask,
          element: el,
          value,
          maskInputFn
        });
      }
      if (checked) {
        attributes.checked = checked;
      }
    }
    if (tagName === "option") {
      if (n2.selected && !maskInputOptions["select"]) {
        attributes.selected = true;
      } else {
        delete attributes.selected;
      }
    }
    if (tagName === "canvas" && recordCanvas) {
      if (n2.__context === "2d") {
        if (!is2DCanvasBlank(n2)) {
          attributes.rr_dataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);
        }
      } else if (!("__context" in n2)) {
        const canvasDataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);
        const blankCanvas = document.createElement("canvas");
        blankCanvas.width = n2.width;
        blankCanvas.height = n2.height;
        const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);
        if (canvasDataURL !== blankCanvasDataURL) {
          attributes.rr_dataURL = canvasDataURL;
        }
      }
    }
    if (tagName === "img" && inlineImages) {
      if (!canvasService) {
        canvasService = doc.createElement("canvas");
        canvasCtx = canvasService.getContext("2d");
      }
      const image = n2;
      const oldValue = image.crossOrigin;
      image.crossOrigin = "anonymous";
      const recordInlineImage = () => {
        image.removeEventListener("load", recordInlineImage);
        try {
          canvasService.width = image.naturalWidth;
          canvasService.height = image.naturalHeight;
          canvasCtx.drawImage(image, 0, 0);
          attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);
        } catch (err) {
          console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);
        }
        oldValue ? attributes.crossOrigin = oldValue : image.removeAttribute("crossorigin");
      };
      if (image.complete && image.naturalWidth !== 0)
        recordInlineImage();
      else
        image.addEventListener("load", recordInlineImage);
    }
    if (tagName === "audio" || tagName === "video") {
      attributes.rr_mediaState = n2.paused ? "paused" : "played";
      attributes.rr_mediaCurrentTime = n2.currentTime;
    }
    if (!newlyAddedElement) {
      if (n2.scrollLeft) {
        attributes.rr_scrollLeft = n2.scrollLeft;
      }
      if (n2.scrollTop) {
        attributes.rr_scrollTop = n2.scrollTop;
      }
    }
    if (needBlock) {
      const { width, height } = n2.getBoundingClientRect();
      attributes = {
        class: attributes.class,
        rr_width: `${width}px`,
        rr_height: `${height}px`
      };
    }
    if (tagName === "iframe" && !keepIframeSrcFn(attributes.src)) {
      if (!n2.contentDocument) {
        attributes.rr_src = attributes.src;
      }
      delete attributes.src;
    }
    let isCustomElement;
    try {
      if (customElements.get(tagName))
        isCustomElement = true;
    } catch (e3) {
    }
    return {
      type: NodeType$1.Element,
      tagName,
      attributes,
      childNodes: [],
      isSVG: isSVGElement3(n2) || void 0,
      needBlock,
      rootId,
      isCustom: isCustomElement
    };
  }
  function lowerIfExists(maybeAttr) {
    if (maybeAttr === void 0 || maybeAttr === null) {
      return "";
    } else {
      return maybeAttr.toLowerCase();
    }
  }
  function slimDOMExcluded(sn, slimDOMOptions) {
    if (slimDOMOptions.comment && sn.type === NodeType$1.Comment) {
      return true;
    } else if (sn.type === NodeType$1.Element) {
      if (slimDOMOptions.script && (sn.tagName === "script" || sn.tagName === "link" && (sn.attributes.rel === "preload" || sn.attributes.rel === "modulepreload") && sn.attributes.as === "script" || sn.tagName === "link" && sn.attributes.rel === "prefetch" && typeof sn.attributes.href === "string" && sn.attributes.href.endsWith(".js"))) {
        return true;
      } else if (slimDOMOptions.headFavicon && (sn.tagName === "link" && sn.attributes.rel === "shortcut icon" || sn.tagName === "meta" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === "application-name" || lowerIfExists(sn.attributes.rel) === "icon" || lowerIfExists(sn.attributes.rel) === "apple-touch-icon" || lowerIfExists(sn.attributes.rel) === "shortcut icon"))) {
        return true;
      } else if (sn.tagName === "meta") {
        if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {
          return true;
        } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === "pinterest")) {
          return true;
        } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === "robots" || lowerIfExists(sn.attributes.name) === "googlebot" || lowerIfExists(sn.attributes.name) === "bingbot")) {
          return true;
        } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes["http-equiv"] !== void 0) {
          return true;
        } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === "author" || lowerIfExists(sn.attributes.name) === "generator" || lowerIfExists(sn.attributes.name) === "framework" || lowerIfExists(sn.attributes.name) === "publisher" || lowerIfExists(sn.attributes.name) === "progid" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {
          return true;
        } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === "google-site-verification" || lowerIfExists(sn.attributes.name) === "yandex-verification" || lowerIfExists(sn.attributes.name) === "csrf-token" || lowerIfExists(sn.attributes.name) === "p:domain_verify" || lowerIfExists(sn.attributes.name) === "verify-v1" || lowerIfExists(sn.attributes.name) === "verification" || lowerIfExists(sn.attributes.name) === "shopify-checkout-api-token")) {
          return true;
        }
      }
    }
    return false;
  }
  function serializeNodeWithId(n2, options) {
    const { doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskAttributeFn, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5e3, onStylesheetLoad, stylesheetLoadTimeout = 5e3, keepIframeSrcFn = () => false, newlyAddedElement = false } = options;
    let { preserveWhiteSpace = true } = options;
    const _serializedNode = serializeNode(n2, {
      doc,
      mirror: mirror2,
      blockClass,
      blockSelector,
      maskAllText,
      unblockSelector,
      maskTextClass,
      unmaskTextClass,
      maskTextSelector,
      unmaskTextSelector,
      inlineStylesheet,
      maskInputOptions,
      maskAttributeFn,
      maskTextFn,
      maskInputFn,
      dataURLOptions,
      inlineImages,
      recordCanvas,
      keepIframeSrcFn,
      newlyAddedElement
    });
    if (!_serializedNode) {
      console.warn(n2, "not serialized");
      return null;
    }
    let id3;
    if (mirror2.hasNode(n2)) {
      id3 = mirror2.getId(n2);
    } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$1.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\s+|\s+$/gm, "").length) {
      id3 = IGNORED_NODE;
    } else {
      id3 = genId();
    }
    const serializedNode = Object.assign(_serializedNode, { id: id3 });
    mirror2.add(n2, serializedNode);
    if (id3 === IGNORED_NODE) {
      return null;
    }
    if (onSerialize) {
      onSerialize(n2);
    }
    let recordChild = !skipChild;
    if (serializedNode.type === NodeType$1.Element) {
      recordChild = recordChild && !serializedNode.needBlock;
      delete serializedNode.needBlock;
      const shadowRoot = n2.shadowRoot;
      if (shadowRoot && isNativeShadowDom(shadowRoot))
        serializedNode.isShadowHost = true;
    }
    if ((serializedNode.type === NodeType$1.Document || serializedNode.type === NodeType$1.Element) && recordChild) {
      if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$1.Element && serializedNode.tagName === "head") {
        preserveWhiteSpace = false;
      }
      const bypassOptions = {
        doc,
        mirror: mirror2,
        blockClass,
        blockSelector,
        maskAllText,
        unblockSelector,
        maskTextClass,
        unmaskTextClass,
        maskTextSelector,
        unmaskTextSelector,
        skipChild,
        inlineStylesheet,
        maskInputOptions,
        maskAttributeFn,
        maskTextFn,
        maskInputFn,
        slimDOMOptions,
        dataURLOptions,
        inlineImages,
        recordCanvas,
        preserveWhiteSpace,
        onSerialize,
        onIframeLoad,
        iframeLoadTimeout,
        onStylesheetLoad,
        stylesheetLoadTimeout,
        keepIframeSrcFn
      };
      for (const childN of Array.from(n2.childNodes)) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
      if (isElement$1(n2) && n2.shadowRoot) {
        for (const childN of Array.from(n2.shadowRoot.childNodes)) {
          const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
          if (serializedChildNode) {
            isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);
            serializedNode.childNodes.push(serializedChildNode);
          }
        }
      }
    }
    if (n2.parentNode && isShadowRoot2(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {
      serializedNode.isShadow = true;
    }
    if (serializedNode.type === NodeType$1.Element && serializedNode.tagName === "iframe") {
      onceIframeLoaded(n2, () => {
        const iframeDoc = n2.contentDocument;
        if (iframeDoc && onIframeLoad) {
          const serializedIframeNode = serializeNodeWithId(iframeDoc, {
            doc: iframeDoc,
            mirror: mirror2,
            blockClass,
            blockSelector,
            unblockSelector,
            maskAllText,
            maskTextClass,
            unmaskTextClass,
            maskTextSelector,
            unmaskTextSelector,
            skipChild: false,
            inlineStylesheet,
            maskInputOptions,
            maskAttributeFn,
            maskTextFn,
            maskInputFn,
            slimDOMOptions,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            preserveWhiteSpace,
            onSerialize,
            onIframeLoad,
            iframeLoadTimeout,
            onStylesheetLoad,
            stylesheetLoadTimeout,
            keepIframeSrcFn
          });
          if (serializedIframeNode) {
            onIframeLoad(n2, serializedIframeNode);
          }
        }
      }, iframeLoadTimeout);
    }
    if (serializedNode.type === NodeType$1.Element && serializedNode.tagName === "link" && serializedNode.attributes.rel === "stylesheet") {
      onceStylesheetLoaded(n2, () => {
        if (onStylesheetLoad) {
          const serializedLinkNode = serializeNodeWithId(n2, {
            doc,
            mirror: mirror2,
            blockClass,
            blockSelector,
            unblockSelector,
            maskAllText,
            maskTextClass,
            unmaskTextClass,
            maskTextSelector,
            unmaskTextSelector,
            skipChild: false,
            inlineStylesheet,
            maskInputOptions,
            maskAttributeFn,
            maskTextFn,
            maskInputFn,
            slimDOMOptions,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            preserveWhiteSpace,
            onSerialize,
            onIframeLoad,
            iframeLoadTimeout,
            onStylesheetLoad,
            stylesheetLoadTimeout,
            keepIframeSrcFn
          });
          if (serializedLinkNode) {
            onStylesheetLoad(n2, serializedLinkNode);
          }
        }
      }, stylesheetLoadTimeout);
    }
    return serializedNode;
  }
  function snapshot(n2, options) {
    const { mirror: mirror2 = new Mirror(), blockClass = "rr-block", blockSelector = null, unblockSelector = null, maskAllText = false, maskTextClass = "rr-mask", unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskAttributeFn, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false } = options || {};
    const maskInputOptions = maskAllInputs === true ? {
      color: true,
      date: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true,
      textarea: true,
      select: true
    } : maskAllInputs === false ? {} : maskAllInputs;
    const slimDOMOptions = slimDOM === true || slimDOM === "all" ? {
      script: true,
      comment: true,
      headFavicon: true,
      headWhitespace: true,
      headMetaDescKeywords: slimDOM === "all",
      headMetaSocial: true,
      headMetaRobots: true,
      headMetaHttpEquiv: true,
      headMetaAuthorship: true,
      headMetaVerification: true
    } : slimDOM === false ? {} : slimDOM;
    return serializeNodeWithId(n2, {
      doc: n2,
      mirror: mirror2,
      blockClass,
      blockSelector,
      unblockSelector,
      maskAllText,
      maskTextClass,
      unmaskTextClass,
      maskTextSelector,
      unmaskTextSelector,
      skipChild: false,
      inlineStylesheet,
      maskInputOptions,
      maskAttributeFn,
      maskTextFn,
      maskInputFn,
      slimDOMOptions,
      dataURLOptions,
      inlineImages,
      recordCanvas,
      preserveWhiteSpace,
      onSerialize,
      onIframeLoad,
      iframeLoadTimeout,
      onStylesheetLoad,
      stylesheetLoadTimeout,
      keepIframeSrcFn,
      newlyAddedElement: false
    });
  }
  function _optionalChain$4(ops) {
    let lastAccessLHS = void 0;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn2 = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return void 0;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn2(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn2((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = void 0;
      }
    }
    return value;
  }
  function on(type, fn2, target = document) {
    const options = { capture: true, passive: true };
    target.addEventListener(type, fn2, options);
    return () => target.removeEventListener(type, fn2, options);
  }
  var DEPARTED_MIRROR_ACCESS_WARNING = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
  var _mirror = {
    map: {},
    getId() {
      console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      return -1;
    },
    getNode() {
      console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      return null;
    },
    removeNodeFromMap() {
      console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    },
    has() {
      console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      return false;
    },
    reset() {
      console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    }
  };
  if (typeof window !== "undefined" && window.Proxy && window.Reflect) {
    _mirror = new Proxy(_mirror, {
      get(target, prop, receiver) {
        if (prop === "map") {
          console.error(DEPARTED_MIRROR_ACCESS_WARNING);
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  function throttle$1(func, wait, options = {}) {
    let timeout = null;
    let previous = 0;
    return function(...args) {
      const now3 = Date.now();
      if (!previous && options.leading === false) {
        previous = now3;
      }
      const remaining = wait - (now3 - previous);
      const context = this;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now3;
        func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(() => {
          previous = options.leading === false ? 0 : Date.now();
          timeout = null;
          func.apply(context, args);
        }, remaining);
      }
    };
  }
  function hookSetter(target, key, d, isRevoked, win = window) {
    const original = win.Object.getOwnPropertyDescriptor(target, key);
    win.Object.defineProperty(target, key, isRevoked ? d : {
      set(value) {
        setTimeout(() => {
          d.set.call(this, value);
        }, 0);
        if (original && original.set) {
          original.set.call(this, value);
        }
      }
    });
    return () => hookSetter(target, key, original || {}, true);
  }
  function patch(source, name, replacement) {
    try {
      if (!(name in source)) {
        return () => {
        };
      }
      const original = source[name];
      const wrapped = replacement(original);
      if (typeof wrapped === "function") {
        wrapped.prototype = wrapped.prototype || {};
        Object.defineProperties(wrapped, {
          __rrweb_original__: {
            enumerable: false,
            value: original
          }
        });
      }
      source[name] = wrapped;
      return () => {
        source[name] = original;
      };
    } catch (e22) {
      return () => {
      };
    }
  }
  var nowTimestamp = Date.now;
  if (!/[1-9][0-9]{12}/.test(Date.now().toString())) {
    nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();
  }
  function getWindowScroll2(win) {
    const doc = win.document;
    return {
      left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : _optionalChain$4([doc, "optionalAccess", (_) => _.documentElement, "access", (_2) => _2.scrollLeft]) || _optionalChain$4([doc, "optionalAccess", (_3) => _3.body, "optionalAccess", (_4) => _4.parentElement, "optionalAccess", (_5) => _5.scrollLeft]) || _optionalChain$4([doc, "optionalAccess", (_6) => _6.body, "optionalAccess", (_7) => _7.scrollLeft]) || 0,
      top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : _optionalChain$4([doc, "optionalAccess", (_8) => _8.documentElement, "access", (_9) => _9.scrollTop]) || _optionalChain$4([doc, "optionalAccess", (_10) => _10.body, "optionalAccess", (_11) => _11.parentElement, "optionalAccess", (_12) => _12.scrollTop]) || _optionalChain$4([doc, "optionalAccess", (_13) => _13.body, "optionalAccess", (_14) => _14.scrollTop]) || 0
    };
  }
  function getWindowHeight() {
    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
  }
  function getWindowWidth() {
    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
  }
  function isBlocked(node2, blockClass, blockSelector, unblockSelector, checkAncestors) {
    if (!node2) {
      return false;
    }
    const el = node2.nodeType === node2.ELEMENT_NODE ? node2 : node2.parentElement;
    if (!el)
      return false;
    const blockedPredicate = createMatchPredicate(blockClass, blockSelector);
    if (!checkAncestors) {
      const isUnblocked = unblockSelector && el.matches(unblockSelector);
      return blockedPredicate(el) && !isUnblocked;
    }
    const blockDistance = distanceToMatch(el, blockedPredicate);
    let unblockDistance = -1;
    if (blockDistance < 0) {
      return false;
    }
    if (unblockSelector) {
      unblockDistance = distanceToMatch(el, createMatchPredicate(null, unblockSelector));
    }
    if (blockDistance > -1 && unblockDistance < 0) {
      return true;
    }
    return blockDistance < unblockDistance;
  }
  function isSerialized(n2, mirror2) {
    return mirror2.getId(n2) !== -1;
  }
  function isIgnored(n2, mirror2) {
    return mirror2.getId(n2) === IGNORED_NODE;
  }
  function isAncestorRemoved(target, mirror2) {
    if (isShadowRoot2(target)) {
      return false;
    }
    const id3 = mirror2.getId(target);
    if (!mirror2.has(id3)) {
      return true;
    }
    if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {
      return false;
    }
    if (!target.parentNode) {
      return true;
    }
    return isAncestorRemoved(target.parentNode, mirror2);
  }
  function legacy_isTouchEvent(event) {
    return Boolean(event.changedTouches);
  }
  function polyfill(win = window) {
    if ("NodeList" in win && !win.NodeList.prototype.forEach) {
      win.NodeList.prototype.forEach = Array.prototype.forEach;
    }
    if ("DOMTokenList" in win && !win.DOMTokenList.prototype.forEach) {
      win.DOMTokenList.prototype.forEach = Array.prototype.forEach;
    }
    if (!Node.prototype.contains) {
      Node.prototype.contains = (...args) => {
        let node2 = args[0];
        if (!(0 in args)) {
          throw new TypeError("1 argument is required");
        }
        do {
          if (this === node2) {
            return true;
          }
        } while (node2 = node2 && node2.parentNode);
        return false;
      };
    }
  }
  function isSerializedIframe(n2, mirror2) {
    return Boolean(n2.nodeName === "IFRAME" && mirror2.getMeta(n2));
  }
  function isSerializedStylesheet(n2, mirror2) {
    return Boolean(n2.nodeName === "LINK" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute("rel") === "stylesheet" && mirror2.getMeta(n2));
  }
  function hasShadowRoot(n2) {
    return Boolean(_optionalChain$4([n2, "optionalAccess", (_18) => _18.shadowRoot]));
  }
  var StyleSheetMirror = class {
    constructor() {
      this.id = 1;
      this.styleIDMap = /* @__PURE__ */ new WeakMap();
      this.idStyleMap = /* @__PURE__ */ new Map();
    }
    getId(stylesheet) {
      return _nullishCoalesce(this.styleIDMap.get(stylesheet), () => -1);
    }
    has(stylesheet) {
      return this.styleIDMap.has(stylesheet);
    }
    add(stylesheet, id3) {
      if (this.has(stylesheet))
        return this.getId(stylesheet);
      let newId;
      if (id3 === void 0) {
        newId = this.id++;
      } else
        newId = id3;
      this.styleIDMap.set(stylesheet, newId);
      this.idStyleMap.set(newId, stylesheet);
      return newId;
    }
    getStyle(id3) {
      return this.idStyleMap.get(id3) || null;
    }
    reset() {
      this.styleIDMap = /* @__PURE__ */ new WeakMap();
      this.idStyleMap = /* @__PURE__ */ new Map();
      this.id = 1;
    }
    generateId() {
      return this.id++;
    }
  };
  function getShadowHost(n2) {
    let shadowHost = null;
    if (_optionalChain$4([n2, "access", (_19) => _19.getRootNode, "optionalCall", (_20) => _20(), "optionalAccess", (_21) => _21.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host)
      shadowHost = n2.getRootNode().host;
    return shadowHost;
  }
  function getRootShadowHost(n2) {
    let rootShadowHost = n2;
    let shadowHost;
    while (shadowHost = getShadowHost(rootShadowHost))
      rootShadowHost = shadowHost;
    return rootShadowHost;
  }
  function shadowHostInDom(n2) {
    const doc = n2.ownerDocument;
    if (!doc)
      return false;
    const shadowHost = getRootShadowHost(n2);
    return doc.contains(shadowHost);
  }
  function inDom(n2) {
    const doc = n2.ownerDocument;
    if (!doc)
      return false;
    return doc.contains(n2) || shadowHostInDom(n2);
  }
  var cachedRequestAnimationFrameImplementation;
  function getRequestAnimationFrameImplementation() {
    if (cachedRequestAnimationFrameImplementation) {
      return cachedRequestAnimationFrameImplementation;
    }
    const document2 = window.document;
    let requestAnimationFrameImplementation = window.requestAnimationFrame;
    if (document2 && typeof document2.createElement === "function") {
      try {
        const sandbox = document2.createElement("iframe");
        sandbox.hidden = true;
        document2.head.appendChild(sandbox);
        const contentWindow = sandbox.contentWindow;
        if (contentWindow && contentWindow.requestAnimationFrame) {
          requestAnimationFrameImplementation = contentWindow.requestAnimationFrame;
        }
        document2.head.removeChild(sandbox);
      } catch (e3) {
      }
    }
    return cachedRequestAnimationFrameImplementation = requestAnimationFrameImplementation.bind(window);
  }
  function onRequestAnimationFrame(...rest) {
    return getRequestAnimationFrameImplementation()(...rest);
  }
  var EventType = /* @__PURE__ */ ((EventType2) => {
    EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
    EventType2[EventType2["Load"] = 1] = "Load";
    EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
    EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
    EventType2[EventType2["Meta"] = 4] = "Meta";
    EventType2[EventType2["Custom"] = 5] = "Custom";
    EventType2[EventType2["Plugin"] = 6] = "Plugin";
    return EventType2;
  })(EventType || {});
  var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
    IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
    IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
    IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
    IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
    IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
    IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
    IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
    IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
    IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
    IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
    IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
    IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
    IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
    IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
    IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
    IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
    IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
    return IncrementalSource2;
  })(IncrementalSource || {});
  var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
    MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
    MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
    MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
    MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
    MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
    MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
    MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
    MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
    MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
    MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
    MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
    return MouseInteractions2;
  })(MouseInteractions || {});
  var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
    PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
    PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
    PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
    return PointerTypes2;
  })(PointerTypes || {});
  function _optionalChain$3(ops) {
    let lastAccessLHS = void 0;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn2 = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return void 0;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn2(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn2((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = void 0;
      }
    }
    return value;
  }
  function isNodeInLinkedList(n2) {
    return "__ln" in n2;
  }
  var DoubleLinkedList = class {
    constructor() {
      this.length = 0;
      this.head = null;
      this.tail = null;
    }
    get(position3) {
      if (position3 >= this.length) {
        throw new Error("Position outside of list range");
      }
      let current = this.head;
      for (let index = 0; index < position3; index++) {
        current = _optionalChain$3([current, "optionalAccess", (_) => _.next]) || null;
      }
      return current;
    }
    addNode(n2) {
      const node2 = {
        value: n2,
        previous: null,
        next: null
      };
      n2.__ln = node2;
      if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {
        const current = n2.previousSibling.__ln.next;
        node2.next = current;
        node2.previous = n2.previousSibling.__ln;
        n2.previousSibling.__ln.next = node2;
        if (current) {
          current.previous = node2;
        }
      } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {
        const current = n2.nextSibling.__ln.previous;
        node2.previous = current;
        node2.next = n2.nextSibling.__ln;
        n2.nextSibling.__ln.previous = node2;
        if (current) {
          current.next = node2;
        }
      } else {
        if (this.head) {
          this.head.previous = node2;
        }
        node2.next = this.head;
        this.head = node2;
      }
      if (node2.next === null) {
        this.tail = node2;
      }
      this.length++;
    }
    removeNode(n2) {
      const current = n2.__ln;
      if (!this.head) {
        return;
      }
      if (!current.previous) {
        this.head = current.next;
        if (this.head) {
          this.head.previous = null;
        } else {
          this.tail = null;
        }
      } else {
        current.previous.next = current.next;
        if (current.next) {
          current.next.previous = current.previous;
        } else {
          this.tail = current.previous;
        }
      }
      if (n2.__ln) {
        delete n2.__ln;
      }
      this.length--;
    }
  };
  var moveKey = (id3, parentId) => `${id3}@${parentId}`;
  var MutationBuffer = class {
    constructor() {
      this.frozen = false;
      this.locked = false;
      this.texts = [];
      this.attributes = [];
      this.removes = [];
      this.mapRemoves = [];
      this.movedMap = {};
      this.addedSet = /* @__PURE__ */ new Set();
      this.movedSet = /* @__PURE__ */ new Set();
      this.droppedSet = /* @__PURE__ */ new Set();
      this.processMutations = (mutations) => {
        mutations.forEach(this.processMutation);
        this.emit();
      };
      this.emit = () => {
        if (this.frozen || this.locked) {
          return;
        }
        const adds = [];
        const addedIds = /* @__PURE__ */ new Set();
        const addList = new DoubleLinkedList();
        const getNextId = (n2) => {
          let ns = n2;
          let nextId = IGNORED_NODE;
          while (nextId === IGNORED_NODE) {
            ns = ns && ns.nextSibling;
            nextId = ns && this.mirror.getId(ns);
          }
          return nextId;
        };
        const pushAdd = (n2) => {
          if (!n2.parentNode || !inDom(n2)) {
            return;
          }
          const parentId = isShadowRoot2(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);
          const nextId = getNextId(n2);
          if (parentId === -1 || nextId === -1) {
            return addList.addNode(n2);
          }
          const sn = serializeNodeWithId(n2, {
            doc: this.doc,
            mirror: this.mirror,
            blockClass: this.blockClass,
            blockSelector: this.blockSelector,
            maskAllText: this.maskAllText,
            unblockSelector: this.unblockSelector,
            maskTextClass: this.maskTextClass,
            unmaskTextClass: this.unmaskTextClass,
            maskTextSelector: this.maskTextSelector,
            unmaskTextSelector: this.unmaskTextSelector,
            skipChild: true,
            newlyAddedElement: true,
            inlineStylesheet: this.inlineStylesheet,
            maskInputOptions: this.maskInputOptions,
            maskAttributeFn: this.maskAttributeFn,
            maskTextFn: this.maskTextFn,
            maskInputFn: this.maskInputFn,
            slimDOMOptions: this.slimDOMOptions,
            dataURLOptions: this.dataURLOptions,
            recordCanvas: this.recordCanvas,
            inlineImages: this.inlineImages,
            onSerialize: (currentN) => {
              if (isSerializedIframe(currentN, this.mirror)) {
                this.iframeManager.addIframe(currentN);
              }
              if (isSerializedStylesheet(currentN, this.mirror)) {
                this.stylesheetManager.trackLinkElement(currentN);
              }
              if (hasShadowRoot(n2)) {
                this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);
              }
            },
            onIframeLoad: (iframe, childSn) => {
              this.iframeManager.attachIframe(iframe, childSn);
              this.shadowDomManager.observeAttachShadow(iframe);
            },
            onStylesheetLoad: (link, childSn) => {
              this.stylesheetManager.attachLinkElement(link, childSn);
            }
          });
          if (sn) {
            adds.push({
              parentId,
              nextId,
              node: sn
            });
            addedIds.add(sn.id);
          }
        };
        while (this.mapRemoves.length) {
          this.mirror.removeNodeFromMap(this.mapRemoves.shift());
        }
        for (const n2 of this.movedSet) {
          if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {
            continue;
          }
          pushAdd(n2);
        }
        for (const n2 of this.addedSet) {
          if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {
            pushAdd(n2);
          } else if (isAncestorInSet(this.movedSet, n2)) {
            pushAdd(n2);
          } else {
            this.droppedSet.add(n2);
          }
        }
        let candidate = null;
        while (addList.length) {
          let node2 = null;
          if (candidate) {
            const parentId = this.mirror.getId(candidate.value.parentNode);
            const nextId = getNextId(candidate.value);
            if (parentId !== -1 && nextId !== -1) {
              node2 = candidate;
            }
          }
          if (!node2) {
            let tailNode = addList.tail;
            while (tailNode) {
              const _node = tailNode;
              tailNode = tailNode.previous;
              if (_node) {
                const parentId = this.mirror.getId(_node.value.parentNode);
                const nextId = getNextId(_node.value);
                if (nextId === -1)
                  continue;
                else if (parentId !== -1) {
                  node2 = _node;
                  break;
                } else {
                  const unhandledNode = _node.value;
                  if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    const shadowHost = unhandledNode.parentNode.host;
                    const parentId2 = this.mirror.getId(shadowHost);
                    if (parentId2 !== -1) {
                      node2 = _node;
                      break;
                    }
                  }
                }
              }
            }
          }
          if (!node2) {
            while (addList.head) {
              addList.removeNode(addList.head.value);
            }
            break;
          }
          candidate = node2.previous;
          addList.removeNode(node2.value);
          pushAdd(node2.value);
        }
        const payload = {
          texts: this.texts.map((text) => ({
            id: this.mirror.getId(text.node),
            value: text.value
          })).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),
          attributes: this.attributes.map((attribute) => {
            const { attributes } = attribute;
            if (typeof attributes.style === "string") {
              const diffAsStr = JSON.stringify(attribute.styleDiff);
              const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);
              if (diffAsStr.length < attributes.style.length) {
                if ((diffAsStr + unchangedAsStr).split("var(").length === attributes.style.split("var(").length) {
                  attributes.style = attribute.styleDiff;
                }
              }
            }
            return {
              id: this.mirror.getId(attribute.node),
              attributes
            };
          }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),
          removes: this.removes,
          adds
        };
        if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {
          return;
        }
        this.texts = [];
        this.attributes = [];
        this.removes = [];
        this.addedSet = /* @__PURE__ */ new Set();
        this.movedSet = /* @__PURE__ */ new Set();
        this.droppedSet = /* @__PURE__ */ new Set();
        this.movedMap = {};
        this.mutationCb(payload);
      };
      this.processMutation = (m) => {
        if (isIgnored(m.target, this.mirror)) {
          return;
        }
        let unattachedDoc;
        try {
          unattachedDoc = document.implementation.createHTMLDocument();
        } catch (e3) {
          unattachedDoc = this.doc;
        }
        switch (m.type) {
          case "characterData": {
            const value = m.target.textContent;
            if (!isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) && value !== m.oldValue) {
              this.texts.push({
                value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && value ? this.maskTextFn ? this.maskTextFn(value) : value.replace(/[\S]/g, "*") : value,
                node: m.target
              });
            }
            break;
          }
          case "attributes": {
            const target = m.target;
            let attributeName = m.attributeName;
            let value = m.target.getAttribute(attributeName);
            if (attributeName === "value") {
              const type = getInputType(target);
              const tagName = target.tagName;
              value = getInputValue(target, tagName, type);
              const isInputMasked = shouldMaskInput({
                maskInputOptions: this.maskInputOptions,
                tagName,
                type
              });
              const forceMask = needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, isInputMasked);
              value = maskInputValue({
                isMasked: forceMask,
                element: target,
                value,
                maskInputFn: this.maskInputFn
              });
            }
            if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || value === m.oldValue) {
              return;
            }
            let item = this.attributes.find((a) => a.node === m.target);
            if (target.tagName === "IFRAME" && attributeName === "src" && !this.keepIframeSrcFn(value)) {
              if (!target.contentDocument) {
                attributeName = "rr_src";
              } else {
                return;
              }
            }
            if (!item) {
              item = {
                node: m.target,
                attributes: {},
                styleDiff: {},
                _unchangedStyles: {}
              };
              this.attributes.push(item);
            }
            if (attributeName === "type" && target.tagName === "INPUT" && (m.oldValue || "").toLowerCase() === "password") {
              target.setAttribute("data-rr-is-password", "true");
            }
            if (!ignoreAttribute(target.tagName, attributeName)) {
              item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value, target, this.maskAttributeFn);
              if (attributeName === "style") {
                const old = unattachedDoc.createElement("span");
                if (m.oldValue) {
                  old.setAttribute("style", m.oldValue);
                }
                for (const pname of Array.from(target.style)) {
                  const newValue = target.style.getPropertyValue(pname);
                  const newPriority = target.style.getPropertyPriority(pname);
                  if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {
                    if (newPriority === "") {
                      item.styleDiff[pname] = newValue;
                    } else {
                      item.styleDiff[pname] = [newValue, newPriority];
                    }
                  } else {
                    item._unchangedStyles[pname] = [newValue, newPriority];
                  }
                }
                for (const pname of Array.from(old.style)) {
                  if (target.style.getPropertyValue(pname) === "") {
                    item.styleDiff[pname] = false;
                  }
                }
              }
            }
            break;
          }
          case "childList": {
            if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, true)) {
              return;
            }
            m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));
            m.removedNodes.forEach((n2) => {
              const nodeId = this.mirror.getId(n2);
              const parentId = isShadowRoot2(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);
              if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {
                return;
              }
              if (this.addedSet.has(n2)) {
                deepDelete(this.addedSet, n2);
                this.droppedSet.add(n2);
              } else if (this.addedSet.has(m.target) && nodeId === -1)
                ;
              else if (isAncestorRemoved(m.target, this.mirror))
                ;
              else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {
                deepDelete(this.movedSet, n2);
              } else {
                this.removes.push({
                  parentId,
                  id: nodeId,
                  isShadow: isShadowRoot2(m.target) && isNativeShadowDom(m.target) ? true : void 0
                });
              }
              this.mapRemoves.push(n2);
            });
            break;
          }
        }
      };
      this.genAdds = (n2, target) => {
        if (this.processedNodeManager.inOtherBuffer(n2, this))
          return;
        if (this.addedSet.has(n2) || this.movedSet.has(n2))
          return;
        if (this.mirror.hasNode(n2)) {
          if (isIgnored(n2, this.mirror)) {
            return;
          }
          this.movedSet.add(n2);
          let targetId = null;
          if (target && this.mirror.hasNode(target)) {
            targetId = this.mirror.getId(target);
          }
          if (targetId && targetId !== -1) {
            this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;
          }
        } else {
          this.addedSet.add(n2);
          this.droppedSet.delete(n2);
        }
        if (!isBlocked(n2, this.blockClass, this.blockSelector, this.unblockSelector, false)) {
          n2.childNodes.forEach((childN) => this.genAdds(childN));
          if (hasShadowRoot(n2)) {
            n2.shadowRoot.childNodes.forEach((childN) => {
              this.processedNodeManager.add(childN, this);
              this.genAdds(childN, n2);
            });
          }
        }
      };
    }
    init(options) {
      [
        "mutationCb",
        "blockClass",
        "blockSelector",
        "unblockSelector",
        "maskAllText",
        "maskTextClass",
        "unmaskTextClass",
        "maskTextSelector",
        "unmaskTextSelector",
        "inlineStylesheet",
        "maskInputOptions",
        "maskAttributeFn",
        "maskTextFn",
        "maskInputFn",
        "keepIframeSrcFn",
        "recordCanvas",
        "inlineImages",
        "slimDOMOptions",
        "dataURLOptions",
        "doc",
        "mirror",
        "iframeManager",
        "stylesheetManager",
        "shadowDomManager",
        "canvasManager",
        "processedNodeManager"
      ].forEach((key) => {
        this[key] = options[key];
      });
    }
    freeze() {
      this.frozen = true;
      this.canvasManager.freeze();
    }
    unfreeze() {
      this.frozen = false;
      this.canvasManager.unfreeze();
      this.emit();
    }
    isFrozen() {
      return this.frozen;
    }
    lock() {
      this.locked = true;
      this.canvasManager.lock();
    }
    unlock() {
      this.locked = false;
      this.canvasManager.unlock();
      this.emit();
    }
    reset() {
      this.shadowDomManager.reset();
      this.canvasManager.reset();
    }
  };
  function deepDelete(addsSet, n2) {
    addsSet.delete(n2);
    n2.childNodes.forEach((childN) => deepDelete(addsSet, childN));
  }
  function isParentRemoved(removes, n2, mirror2) {
    if (removes.length === 0)
      return false;
    return _isParentRemoved(removes, n2, mirror2);
  }
  function _isParentRemoved(removes, n2, mirror2) {
    const { parentNode } = n2;
    if (!parentNode) {
      return false;
    }
    const parentId = mirror2.getId(parentNode);
    if (removes.some((r3) => r3.id === parentId)) {
      return true;
    }
    return _isParentRemoved(removes, parentNode, mirror2);
  }
  function isAncestorInSet(set, n2) {
    if (set.size === 0)
      return false;
    return _isAncestorInSet(set, n2);
  }
  function _isAncestorInSet(set, n2) {
    const { parentNode } = n2;
    if (!parentNode) {
      return false;
    }
    if (set.has(parentNode)) {
      return true;
    }
    return _isAncestorInSet(set, parentNode);
  }
  var errorHandler;
  function registerErrorHandler(handler) {
    errorHandler = handler;
  }
  function unregisterErrorHandler() {
    errorHandler = void 0;
  }
  var callbackWrapper = (cb) => {
    if (!errorHandler) {
      return cb;
    }
    const rrwebWrapped = (...rest) => {
      try {
        return cb(...rest);
      } catch (error2) {
        if (errorHandler && errorHandler(error2) === true) {
          return () => {
          };
        }
        throw error2;
      }
    };
    return rrwebWrapped;
  };
  function _optionalChain$2(ops) {
    let lastAccessLHS = void 0;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn2 = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return void 0;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn2(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn2((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = void 0;
      }
    }
    return value;
  }
  var mutationBuffers = [];
  function getEventTarget2(event) {
    try {
      if ("composedPath" in event) {
        const path = event.composedPath();
        if (path.length) {
          return path[0];
        }
      } else if ("path" in event && event.path.length) {
        return event.path[0];
      }
    } catch (e22) {
    }
    return event && event.target;
  }
  function initMutationObserver(options, rootEl) {
    const mutationBuffer = new MutationBuffer();
    mutationBuffers.push(mutationBuffer);
    mutationBuffer.init(options);
    let mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;
    const angularZoneSymbol = _optionalChain$2([window, "optionalAccess", (_) => _.Zone, "optionalAccess", (_2) => _2.__symbol__, "optionalCall", (_3) => _3("MutationObserver")]);
    if (angularZoneSymbol && window[angularZoneSymbol]) {
      mutationObserverCtor = window[angularZoneSymbol];
    }
    const observer = new mutationObserverCtor(callbackWrapper((mutations) => {
      if (options.onMutation && options.onMutation(mutations) === false) {
        return;
      }
      mutationBuffer.processMutations.bind(mutationBuffer)(mutations);
    }));
    observer.observe(rootEl, {
      attributes: true,
      attributeOldValue: true,
      characterData: true,
      characterDataOldValue: true,
      childList: true,
      subtree: true
    });
    return observer;
  }
  function initMoveObserver({ mousemoveCb, sampling, doc, mirror: mirror2 }) {
    if (sampling.mousemove === false) {
      return () => {
      };
    }
    const threshold = typeof sampling.mousemove === "number" ? sampling.mousemove : 50;
    const callbackThreshold = typeof sampling.mousemoveCallback === "number" ? sampling.mousemoveCallback : 500;
    let positions = [];
    let timeBaseline;
    const wrappedCb = throttle$1(callbackWrapper((source) => {
      const totalOffset = Date.now() - timeBaseline;
      mousemoveCb(positions.map((p) => {
        p.timeOffset -= totalOffset;
        return p;
      }), source);
      positions = [];
      timeBaseline = null;
    }), callbackThreshold);
    const updatePosition = callbackWrapper(throttle$1(callbackWrapper((evt) => {
      const target = getEventTarget2(evt);
      const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;
      if (!timeBaseline) {
        timeBaseline = nowTimestamp();
      }
      positions.push({
        x: clientX,
        y: clientY,
        id: mirror2.getId(target),
        timeOffset: nowTimestamp() - timeBaseline
      });
      wrappedCb(typeof DragEvent !== "undefined" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);
    }), threshold, {
      trailing: false
    }));
    const handlers4 = [
      on("mousemove", updatePosition, doc),
      on("touchmove", updatePosition, doc),
      on("drag", updatePosition, doc)
    ];
    return callbackWrapper(() => {
      handlers4.forEach((h) => h());
    });
  }
  function initMouseInteractionObserver({ mouseInteractionCb, doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, sampling }) {
    if (sampling.mouseInteraction === false) {
      return () => {
      };
    }
    const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;
    const handlers4 = [];
    let currentPointerType = null;
    const getHandler = (eventKey) => {
      return (event) => {
        const target = getEventTarget2(event);
        if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {
          return;
        }
        let pointerType = null;
        let thisEventKey = eventKey;
        if ("pointerType" in event) {
          switch (event.pointerType) {
            case "mouse":
              pointerType = PointerTypes.Mouse;
              break;
            case "touch":
              pointerType = PointerTypes.Touch;
              break;
            case "pen":
              pointerType = PointerTypes.Pen;
              break;
          }
          if (pointerType === PointerTypes.Touch) {
            if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {
              thisEventKey = "TouchStart";
            } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {
              thisEventKey = "TouchEnd";
            }
          } else if (pointerType === PointerTypes.Pen)
            ;
        } else if (legacy_isTouchEvent(event)) {
          pointerType = PointerTypes.Touch;
        }
        if (pointerType !== null) {
          currentPointerType = pointerType;
          if (thisEventKey.startsWith("Touch") && pointerType === PointerTypes.Touch || thisEventKey.startsWith("Mouse") && pointerType === PointerTypes.Mouse) {
            pointerType = null;
          }
        } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {
          pointerType = currentPointerType;
          currentPointerType = null;
        }
        const e3 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;
        if (!e3) {
          return;
        }
        const id3 = mirror2.getId(target);
        const { clientX, clientY } = e3;
        callbackWrapper(mouseInteractionCb)({
          type: MouseInteractions[thisEventKey],
          id: id3,
          x: clientX,
          y: clientY,
          ...pointerType !== null && { pointerType }
        });
      };
    };
    Object.keys(MouseInteractions).filter((key) => Number.isNaN(Number(key)) && !key.endsWith("_Departed") && disableMap[key] !== false).forEach((eventKey) => {
      let eventName = toLowerCase(eventKey);
      const handler = getHandler(eventKey);
      if (window.PointerEvent) {
        switch (MouseInteractions[eventKey]) {
          case MouseInteractions.MouseDown:
          case MouseInteractions.MouseUp:
            eventName = eventName.replace("mouse", "pointer");
            break;
          case MouseInteractions.TouchStart:
          case MouseInteractions.TouchEnd:
            return;
        }
      }
      handlers4.push(on(eventName, handler, doc));
    });
    return callbackWrapper(() => {
      handlers4.forEach((h) => h());
    });
  }
  function initScrollObserver({ scrollCb, doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, sampling }) {
    const updatePosition = callbackWrapper(throttle$1(callbackWrapper((evt) => {
      const target = getEventTarget2(evt);
      if (!target || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {
        return;
      }
      const id3 = mirror2.getId(target);
      if (target === doc && doc.defaultView) {
        const scrollLeftTop = getWindowScroll2(doc.defaultView);
        scrollCb({
          id: id3,
          x: scrollLeftTop.left,
          y: scrollLeftTop.top
        });
      } else {
        scrollCb({
          id: id3,
          x: target.scrollLeft,
          y: target.scrollTop
        });
      }
    }), sampling.scroll || 100));
    return on("scroll", updatePosition, doc);
  }
  function initViewportResizeObserver({ viewportResizeCb }, { win }) {
    let lastH = -1;
    let lastW = -1;
    const updateDimension = callbackWrapper(throttle$1(callbackWrapper(() => {
      const height = getWindowHeight();
      const width = getWindowWidth();
      if (lastH !== height || lastW !== width) {
        viewportResizeCb({
          width: Number(width),
          height: Number(height)
        });
        lastH = height;
        lastW = width;
      }
    }), 200));
    return on("resize", updateDimension, win);
  }
  var INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];
  var lastInputValueMap = /* @__PURE__ */ new WeakMap();
  function initInputObserver({ inputCb, doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector }) {
    function eventHandler(event) {
      let target = getEventTarget2(event);
      const userTriggered = event.isTrusted;
      const tagName = target && toUpperCase(target.tagName);
      if (tagName === "OPTION")
        target = target.parentElement;
      if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {
        return;
      }
      const el = target;
      if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {
        return;
      }
      const type = getInputType(target);
      let text = getInputValue(el, tagName, type);
      let isChecked = false;
      const isInputMasked = shouldMaskInput({
        maskInputOptions,
        tagName,
        type
      });
      const forceMask = needMaskingText(target, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked);
      if (type === "radio" || type === "checkbox") {
        isChecked = target.checked;
      }
      text = maskInputValue({
        isMasked: forceMask,
        element: target,
        value: text,
        maskInputFn
      });
      cbWithDedup(target, userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked });
      const name = target.name;
      if (type === "radio" && name && isChecked) {
        doc.querySelectorAll(`input[type="radio"][name="${name}"]`).forEach((el2) => {
          if (el2 !== target) {
            const text2 = maskInputValue({
              isMasked: forceMask,
              element: el2,
              value: getInputValue(el2, tagName, type),
              maskInputFn
            });
            cbWithDedup(el2, userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked });
          }
        });
      }
    }
    function cbWithDedup(target, v) {
      const lastInputValue = lastInputValueMap.get(target);
      if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {
        lastInputValueMap.set(target, v);
        const id3 = mirror2.getId(target);
        callbackWrapper(inputCb)({
          ...v,
          id: id3
        });
      }
    }
    const events = sampling.input === "last" ? ["change"] : ["input", "change"];
    const handlers4 = events.map((eventName) => on(eventName, callbackWrapper(eventHandler), doc));
    const currentWindow = doc.defaultView;
    if (!currentWindow) {
      return () => {
        handlers4.forEach((h) => h());
      };
    }
    const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, "value");
    const hookProperties = [
      [currentWindow.HTMLInputElement.prototype, "value"],
      [currentWindow.HTMLInputElement.prototype, "checked"],
      [currentWindow.HTMLSelectElement.prototype, "value"],
      [currentWindow.HTMLTextAreaElement.prototype, "value"],
      [currentWindow.HTMLSelectElement.prototype, "selectedIndex"],
      [currentWindow.HTMLOptionElement.prototype, "selected"]
    ];
    if (propertyDescriptor && propertyDescriptor.set) {
      handlers4.push(...hookProperties.map((p) => hookSetter(p[0], p[1], {
        set() {
          callbackWrapper(eventHandler)({
            target: this,
            isTrusted: false
          });
        }
      }, false, currentWindow)));
    }
    return callbackWrapper(() => {
      handlers4.forEach((h) => h());
    });
  }
  function getNestedCSSRulePositions(rule) {
    const positions = [];
    function recurse(childRule, pos) {
      if (hasNestedCSSRule("CSSGroupingRule") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && childRule.parentRule instanceof CSSConditionRule) {
        const rules = Array.from(childRule.parentRule.cssRules);
        const index = rules.indexOf(childRule);
        pos.unshift(index);
      } else if (childRule.parentStyleSheet) {
        const rules = Array.from(childRule.parentStyleSheet.cssRules);
        const index = rules.indexOf(childRule);
        pos.unshift(index);
      }
      return pos;
    }
    return recurse(rule, positions);
  }
  function getIdAndStyleId(sheet, mirror2, styleMirror) {
    let id3, styleId;
    if (!sheet)
      return {};
    if (sheet.ownerNode)
      id3 = mirror2.getId(sheet.ownerNode);
    else
      styleId = styleMirror.getId(sheet);
    return {
      styleId,
      id: id3
    };
  }
  function initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {
    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {
      return () => {
      };
    }
    const insertRule = win.CSSStyleSheet.prototype.insertRule;
    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {
      apply: callbackWrapper((target, thisArg, argumentsList) => {
        const [rule, index] = argumentsList;
        const { id: id3, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);
        if (id3 && id3 !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id: id3,
            styleId,
            adds: [{ rule, index }]
          });
        }
        return target.apply(thisArg, argumentsList);
      })
    });
    const deleteRule = win.CSSStyleSheet.prototype.deleteRule;
    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {
      apply: callbackWrapper((target, thisArg, argumentsList) => {
        const [index] = argumentsList;
        const { id: id3, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);
        if (id3 && id3 !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id: id3,
            styleId,
            removes: [{ index }]
          });
        }
        return target.apply(thisArg, argumentsList);
      })
    });
    let replace2;
    if (win.CSSStyleSheet.prototype.replace) {
      replace2 = win.CSSStyleSheet.prototype.replace;
      win.CSSStyleSheet.prototype.replace = new Proxy(replace2, {
        apply: callbackWrapper((target, thisArg, argumentsList) => {
          const [text] = argumentsList;
          const { id: id3, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);
          if (id3 && id3 !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id: id3,
              styleId,
              replace: text
            });
          }
          return target.apply(thisArg, argumentsList);
        })
      });
    }
    let replaceSync;
    if (win.CSSStyleSheet.prototype.replaceSync) {
      replaceSync = win.CSSStyleSheet.prototype.replaceSync;
      win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {
        apply: callbackWrapper((target, thisArg, argumentsList) => {
          const [text] = argumentsList;
          const { id: id3, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);
          if (id3 && id3 !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id: id3,
              styleId,
              replaceSync: text
            });
          }
          return target.apply(thisArg, argumentsList);
        })
      });
    }
    const supportedNestedCSSRuleTypes = {};
    if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {
      supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;
    } else {
      if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {
        supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;
      }
      if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {
        supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;
      }
      if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {
        supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;
      }
    }
    const unmodifiedFunctions = {};
    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
      unmodifiedFunctions[typeKey] = {
        insertRule: type.prototype.insertRule,
        deleteRule: type.prototype.deleteRule
      };
      type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {
        apply: callbackWrapper((target, thisArg, argumentsList) => {
          const [rule, index] = argumentsList;
          const { id: id3, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror);
          if (id3 && id3 !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id: id3,
              styleId,
              adds: [
                {
                  rule,
                  index: [
                    ...getNestedCSSRulePositions(thisArg),
                    index || 0
                  ]
                }
              ]
            });
          }
          return target.apply(thisArg, argumentsList);
        })
      });
      type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {
        apply: callbackWrapper((target, thisArg, argumentsList) => {
          const [index] = argumentsList;
          const { id: id3, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror);
          if (id3 && id3 !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id: id3,
              styleId,
              removes: [
                { index: [...getNestedCSSRulePositions(thisArg), index] }
              ]
            });
          }
          return target.apply(thisArg, argumentsList);
        })
      });
    });
    return callbackWrapper(() => {
      win.CSSStyleSheet.prototype.insertRule = insertRule;
      win.CSSStyleSheet.prototype.deleteRule = deleteRule;
      replace2 && (win.CSSStyleSheet.prototype.replace = replace2);
      replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);
      Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
        type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;
        type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;
      });
    });
  }
  function initAdoptedStyleSheetObserver({ mirror: mirror2, stylesheetManager }, host) {
    let hostId = null;
    if (host.nodeName === "#document")
      hostId = mirror2.getId(host);
    else
      hostId = mirror2.getId(host.host);
    const patchTarget = host.nodeName === "#document" ? _optionalChain$2([host, "access", (_4) => _4.defaultView, "optionalAccess", (_5) => _5.Document]) : _optionalChain$2([host, "access", (_6) => _6.ownerDocument, "optionalAccess", (_7) => _7.defaultView, "optionalAccess", (_8) => _8.ShadowRoot]);
    const originalPropertyDescriptor = _optionalChain$2([patchTarget, "optionalAccess", (_9) => _9.prototype]) ? Object.getOwnPropertyDescriptor(_optionalChain$2([patchTarget, "optionalAccess", (_10) => _10.prototype]), "adoptedStyleSheets") : void 0;
    if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)
      return () => {
      };
    Object.defineProperty(host, "adoptedStyleSheets", {
      configurable: originalPropertyDescriptor.configurable,
      enumerable: originalPropertyDescriptor.enumerable,
      get() {
        return _optionalChain$2([originalPropertyDescriptor, "access", (_11) => _11.get, "optionalAccess", (_12) => _12.call, "call", (_13) => _13(this)]);
      },
      set(sheets) {
        const result = _optionalChain$2([originalPropertyDescriptor, "access", (_14) => _14.set, "optionalAccess", (_15) => _15.call, "call", (_16) => _16(this, sheets)]);
        if (hostId !== null && hostId !== -1) {
          try {
            stylesheetManager.adoptStyleSheets(sheets, hostId);
          } catch (e3) {
          }
        }
        return result;
      }
    });
    return callbackWrapper(() => {
      Object.defineProperty(host, "adoptedStyleSheets", {
        configurable: originalPropertyDescriptor.configurable,
        enumerable: originalPropertyDescriptor.enumerable,
        get: originalPropertyDescriptor.get,
        set: originalPropertyDescriptor.set
      });
    });
  }
  function initStyleDeclarationObserver({ styleDeclarationCb, mirror: mirror2, ignoreCSSAttributes, stylesheetManager }, { win }) {
    const setProperty = win.CSSStyleDeclaration.prototype.setProperty;
    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {
      apply: callbackWrapper((target, thisArg, argumentsList) => {
        const [property, value, priority] = argumentsList;
        if (ignoreCSSAttributes.has(property)) {
          return setProperty.apply(thisArg, [property, value, priority]);
        }
        const { id: id3, styleId } = getIdAndStyleId(_optionalChain$2([thisArg, "access", (_17) => _17.parentRule, "optionalAccess", (_18) => _18.parentStyleSheet]), mirror2, stylesheetManager.styleMirror);
        if (id3 && id3 !== -1 || styleId && styleId !== -1) {
          styleDeclarationCb({
            id: id3,
            styleId,
            set: {
              property,
              value,
              priority
            },
            index: getNestedCSSRulePositions(thisArg.parentRule)
          });
        }
        return target.apply(thisArg, argumentsList);
      })
    });
    const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;
    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {
      apply: callbackWrapper((target, thisArg, argumentsList) => {
        const [property] = argumentsList;
        if (ignoreCSSAttributes.has(property)) {
          return removeProperty.apply(thisArg, [property]);
        }
        const { id: id3, styleId } = getIdAndStyleId(_optionalChain$2([thisArg, "access", (_19) => _19.parentRule, "optionalAccess", (_20) => _20.parentStyleSheet]), mirror2, stylesheetManager.styleMirror);
        if (id3 && id3 !== -1 || styleId && styleId !== -1) {
          styleDeclarationCb({
            id: id3,
            styleId,
            remove: {
              property
            },
            index: getNestedCSSRulePositions(thisArg.parentRule)
          });
        }
        return target.apply(thisArg, argumentsList);
      })
    });
    return callbackWrapper(() => {
      win.CSSStyleDeclaration.prototype.setProperty = setProperty;
      win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;
    });
  }
  function initMediaInteractionObserver({ mediaInteractionCb, blockClass, blockSelector, unblockSelector, mirror: mirror2, sampling, doc }) {
    const handler = callbackWrapper((type) => throttle$1(callbackWrapper((event) => {
      const target = getEventTarget2(event);
      if (!target || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {
        return;
      }
      const { currentTime, volume, muted, playbackRate } = target;
      mediaInteractionCb({
        type,
        id: mirror2.getId(target),
        currentTime,
        volume,
        muted,
        playbackRate
      });
    }), sampling.media || 500));
    const handlers4 = [
      on("play", handler(0), doc),
      on("pause", handler(1), doc),
      on("seeked", handler(2), doc),
      on("volumechange", handler(3), doc),
      on("ratechange", handler(4), doc)
    ];
    return callbackWrapper(() => {
      handlers4.forEach((h) => h());
    });
  }
  function initFontObserver({ fontCb, doc }) {
    const win = doc.defaultView;
    if (!win) {
      return () => {
      };
    }
    const handlers4 = [];
    const fontMap = /* @__PURE__ */ new WeakMap();
    const originalFontFace = win.FontFace;
    win.FontFace = function FontFace(family, source, descriptors) {
      const fontFace = new originalFontFace(family, source, descriptors);
      fontMap.set(fontFace, {
        family,
        buffer: typeof source !== "string",
        descriptors,
        fontSource: typeof source === "string" ? source : JSON.stringify(Array.from(new Uint8Array(source)))
      });
      return fontFace;
    };
    const restoreHandler = patch(doc.fonts, "add", function(original) {
      return function(fontFace) {
        setTimeout(callbackWrapper(() => {
          const p = fontMap.get(fontFace);
          if (p) {
            fontCb(p);
            fontMap.delete(fontFace);
          }
        }), 0);
        return original.apply(this, [fontFace]);
      };
    });
    handlers4.push(() => {
      win.FontFace = originalFontFace;
    });
    handlers4.push(restoreHandler);
    return callbackWrapper(() => {
      handlers4.forEach((h) => h());
    });
  }
  function initSelectionObserver(param) {
    const { doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, selectionCb } = param;
    let collapsed = true;
    const updateSelection = callbackWrapper(() => {
      const selection = doc.getSelection();
      if (!selection || collapsed && _optionalChain$2([selection, "optionalAccess", (_21) => _21.isCollapsed]))
        return;
      collapsed = selection.isCollapsed || false;
      const ranges = [];
      const count = selection.rangeCount || 0;
      for (let i = 0; i < count; i++) {
        const range2 = selection.getRangeAt(i);
        const { startContainer, startOffset, endContainer, endOffset } = range2;
        const blocked = isBlocked(startContainer, blockClass, blockSelector, unblockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, unblockSelector, true);
        if (blocked)
          continue;
        ranges.push({
          start: mirror2.getId(startContainer),
          startOffset,
          end: mirror2.getId(endContainer),
          endOffset
        });
      }
      selectionCb({ ranges });
    });
    updateSelection();
    return on("selectionchange", updateSelection);
  }
  function initCustomElementObserver({ doc, customElementCb }) {
    const win = doc.defaultView;
    if (!win || !win.customElements)
      return () => {
      };
    const restoreHandler = patch(win.customElements, "define", function(original) {
      return function(name, constructor, options) {
        try {
          customElementCb({
            define: {
              name
            }
          });
        } catch (e3) {
        }
        return original.apply(this, [name, constructor, options]);
      };
    });
    return restoreHandler;
  }
  function initObservers(o, _hooks = {}) {
    const currentWindow = o.doc.defaultView;
    if (!currentWindow) {
      return () => {
      };
    }
    const mutationObserver = initMutationObserver(o, o.doc);
    const mousemoveHandler = initMoveObserver(o);
    const mouseInteractionHandler = initMouseInteractionObserver(o);
    const scrollHandler = initScrollObserver(o);
    const viewportResizeHandler = initViewportResizeObserver(o, {
      win: currentWindow
    });
    const inputHandler = initInputObserver(o);
    const mediaInteractionHandler = initMediaInteractionObserver(o);
    const styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });
    const adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);
    const styleDeclarationObserver = initStyleDeclarationObserver(o, {
      win: currentWindow
    });
    const fontObserver = o.collectFonts ? initFontObserver(o) : () => {
    };
    const selectionObserver = initSelectionObserver(o);
    const customElementObserver = initCustomElementObserver(o);
    const pluginHandlers = [];
    for (const plugin of o.plugins) {
      pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));
    }
    return callbackWrapper(() => {
      mutationBuffers.forEach((b) => b.reset());
      mutationObserver.disconnect();
      mousemoveHandler();
      mouseInteractionHandler();
      scrollHandler();
      viewportResizeHandler();
      inputHandler();
      mediaInteractionHandler();
      styleSheetObserver();
      adoptedStyleSheetObserver();
      styleDeclarationObserver();
      fontObserver();
      selectionObserver();
      customElementObserver();
      pluginHandlers.forEach((h) => h());
    });
  }
  function hasNestedCSSRule(prop) {
    return typeof window[prop] !== "undefined";
  }
  function canMonkeyPatchNestedCSSRule(prop) {
    return Boolean(typeof window[prop] !== "undefined" && window[prop].prototype && "insertRule" in window[prop].prototype && "deleteRule" in window[prop].prototype);
  }
  var CrossOriginIframeMirror = class {
    constructor(generateIdFn) {
      this.generateIdFn = generateIdFn;
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
    }
    getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {
      const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);
      const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);
      let id3 = idToRemoteIdMap.get(remoteId);
      if (!id3) {
        id3 = this.generateIdFn();
        idToRemoteIdMap.set(remoteId, id3);
        remoteIdToIdMap.set(id3, remoteId);
      }
      return id3;
    }
    getIds(iframe, remoteId) {
      const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);
      const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
      return remoteId.map((id3) => this.getId(iframe, id3, idToRemoteIdMap, remoteIdToIdMap));
    }
    getRemoteId(iframe, id3, map2) {
      const remoteIdToIdMap = map2 || this.getRemoteIdToIdMap(iframe);
      if (typeof id3 !== "number")
        return id3;
      const remoteId = remoteIdToIdMap.get(id3);
      if (!remoteId)
        return -1;
      return remoteId;
    }
    getRemoteIds(iframe, ids) {
      const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
      return ids.map((id3) => this.getRemoteId(iframe, id3, remoteIdToIdMap));
    }
    reset(iframe) {
      if (!iframe) {
        this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
        this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
        return;
      }
      this.iframeIdToRemoteIdMap.delete(iframe);
      this.iframeRemoteIdToIdMap.delete(iframe);
    }
    getIdToRemoteIdMap(iframe) {
      let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);
      if (!idToRemoteIdMap) {
        idToRemoteIdMap = /* @__PURE__ */ new Map();
        this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);
      }
      return idToRemoteIdMap;
    }
    getRemoteIdToIdMap(iframe) {
      let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);
      if (!remoteIdToIdMap) {
        remoteIdToIdMap = /* @__PURE__ */ new Map();
        this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);
      }
      return remoteIdToIdMap;
    }
  };
  function _optionalChain$1(ops) {
    let lastAccessLHS = void 0;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn2 = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return void 0;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn2(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn2((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = void 0;
      }
    }
    return value;
  }
  var IframeManagerNoop = class {
    constructor() {
      this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);
      this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();
    }
    addIframe() {
    }
    addLoadListener() {
    }
    attachIframe() {
    }
  };
  var IframeManager = class {
    constructor(options) {
      this.iframes = /* @__PURE__ */ new WeakMap();
      this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();
      this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);
      this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();
      this.mutationCb = options.mutationCb;
      this.wrappedEmit = options.wrappedEmit;
      this.stylesheetManager = options.stylesheetManager;
      this.recordCrossOriginIframes = options.recordCrossOriginIframes;
      this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));
      this.mirror = options.mirror;
      if (this.recordCrossOriginIframes) {
        window.addEventListener("message", this.handleMessage.bind(this));
      }
    }
    addIframe(iframeEl) {
      this.iframes.set(iframeEl, true);
      if (iframeEl.contentWindow)
        this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);
    }
    addLoadListener(cb) {
      this.loadListener = cb;
    }
    attachIframe(iframeEl, childSn) {
      this.mutationCb({
        adds: [
          {
            parentId: this.mirror.getId(iframeEl),
            nextId: null,
            node: childSn
          }
        ],
        removes: [],
        texts: [],
        attributes: [],
        isAttachIframe: true
      });
      _optionalChain$1([this, "access", (_) => _.loadListener, "optionalCall", (_2) => _2(iframeEl)]);
      if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0)
        this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));
    }
    handleMessage(message) {
      const crossOriginMessageEvent = message;
      if (crossOriginMessageEvent.data.type !== "rrweb" || crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)
        return;
      const iframeSourceWindow = message.source;
      if (!iframeSourceWindow)
        return;
      const iframeEl = this.crossOriginIframeMap.get(message.source);
      if (!iframeEl)
        return;
      const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);
      if (transformedEvent)
        this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);
    }
    transformCrossOriginEvent(iframeEl, e3) {
      switch (e3.type) {
        case EventType.FullSnapshot: {
          this.crossOriginIframeMirror.reset(iframeEl);
          this.crossOriginIframeStyleMirror.reset(iframeEl);
          this.replaceIdOnNode(e3.data.node, iframeEl);
          const rootId = e3.data.node.id;
          this.crossOriginIframeRootIdMap.set(iframeEl, rootId);
          this.patchRootIdOnNode(e3.data.node, rootId);
          return {
            timestamp: e3.timestamp,
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Mutation,
              adds: [
                {
                  parentId: this.mirror.getId(iframeEl),
                  nextId: null,
                  node: e3.data.node
                }
              ],
              removes: [],
              texts: [],
              attributes: [],
              isAttachIframe: true
            }
          };
        }
        case EventType.Meta:
        case EventType.Load:
        case EventType.DomContentLoaded: {
          return false;
        }
        case EventType.Plugin: {
          return e3;
        }
        case EventType.Custom: {
          this.replaceIds(e3.data.payload, iframeEl, ["id", "parentId", "previousId", "nextId"]);
          return e3;
        }
        case EventType.IncrementalSnapshot: {
          switch (e3.data.source) {
            case IncrementalSource.Mutation: {
              e3.data.adds.forEach((n2) => {
                this.replaceIds(n2, iframeEl, [
                  "parentId",
                  "nextId",
                  "previousId"
                ]);
                this.replaceIdOnNode(n2.node, iframeEl);
                const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);
                rootId && this.patchRootIdOnNode(n2.node, rootId);
              });
              e3.data.removes.forEach((n2) => {
                this.replaceIds(n2, iframeEl, ["parentId", "id"]);
              });
              e3.data.attributes.forEach((n2) => {
                this.replaceIds(n2, iframeEl, ["id"]);
              });
              e3.data.texts.forEach((n2) => {
                this.replaceIds(n2, iframeEl, ["id"]);
              });
              return e3;
            }
            case IncrementalSource.Drag:
            case IncrementalSource.TouchMove:
            case IncrementalSource.MouseMove: {
              e3.data.positions.forEach((p) => {
                this.replaceIds(p, iframeEl, ["id"]);
              });
              return e3;
            }
            case IncrementalSource.ViewportResize: {
              return false;
            }
            case IncrementalSource.MediaInteraction:
            case IncrementalSource.MouseInteraction:
            case IncrementalSource.Scroll:
            case IncrementalSource.CanvasMutation:
            case IncrementalSource.Input: {
              this.replaceIds(e3.data, iframeEl, ["id"]);
              return e3;
            }
            case IncrementalSource.StyleSheetRule:
            case IncrementalSource.StyleDeclaration: {
              this.replaceIds(e3.data, iframeEl, ["id"]);
              this.replaceStyleIds(e3.data, iframeEl, ["styleId"]);
              return e3;
            }
            case IncrementalSource.Font: {
              return e3;
            }
            case IncrementalSource.Selection: {
              e3.data.ranges.forEach((range2) => {
                this.replaceIds(range2, iframeEl, ["start", "end"]);
              });
              return e3;
            }
            case IncrementalSource.AdoptedStyleSheet: {
              this.replaceIds(e3.data, iframeEl, ["id"]);
              this.replaceStyleIds(e3.data, iframeEl, ["styleIds"]);
              _optionalChain$1([e3, "access", (_3) => _3.data, "access", (_4) => _4.styles, "optionalAccess", (_5) => _5.forEach, "call", (_6) => _6((style) => {
                this.replaceStyleIds(style, iframeEl, ["styleId"]);
              })]);
              return e3;
            }
          }
        }
      }
      return false;
    }
    replace(iframeMirror, obj, iframeEl, keys3) {
      for (const key of keys3) {
        if (!Array.isArray(obj[key]) && typeof obj[key] !== "number")
          continue;
        if (Array.isArray(obj[key])) {
          obj[key] = iframeMirror.getIds(iframeEl, obj[key]);
        } else {
          obj[key] = iframeMirror.getId(iframeEl, obj[key]);
        }
      }
      return obj;
    }
    replaceIds(obj, iframeEl, keys3) {
      return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys3);
    }
    replaceStyleIds(obj, iframeEl, keys3) {
      return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys3);
    }
    replaceIdOnNode(node2, iframeEl) {
      this.replaceIds(node2, iframeEl, ["id", "rootId"]);
      if ("childNodes" in node2) {
        node2.childNodes.forEach((child) => {
          this.replaceIdOnNode(child, iframeEl);
        });
      }
    }
    patchRootIdOnNode(node2, rootId) {
      if (node2.type !== NodeType$1.Document && !node2.rootId)
        node2.rootId = rootId;
      if ("childNodes" in node2) {
        node2.childNodes.forEach((child) => {
          this.patchRootIdOnNode(child, rootId);
        });
      }
    }
  };
  var ShadowDomManagerNoop = class {
    init() {
    }
    addShadowRoot() {
    }
    observeAttachShadow() {
    }
    reset() {
    }
  };
  var ShadowDomManager = class {
    constructor(options) {
      this.shadowDoms = /* @__PURE__ */ new WeakSet();
      this.restoreHandlers = [];
      this.mutationCb = options.mutationCb;
      this.scrollCb = options.scrollCb;
      this.bypassOptions = options.bypassOptions;
      this.mirror = options.mirror;
      this.init();
    }
    init() {
      this.reset();
      this.patchAttachShadow(Element, document);
    }
    addShadowRoot(shadowRoot, doc) {
      if (!isNativeShadowDom(shadowRoot))
        return;
      if (this.shadowDoms.has(shadowRoot))
        return;
      this.shadowDoms.add(shadowRoot);
      const observer = initMutationObserver({
        ...this.bypassOptions,
        doc,
        mutationCb: this.mutationCb,
        mirror: this.mirror,
        shadowDomManager: this
      }, shadowRoot);
      this.restoreHandlers.push(() => observer.disconnect());
      this.restoreHandlers.push(initScrollObserver({
        ...this.bypassOptions,
        scrollCb: this.scrollCb,
        doc: shadowRoot,
        mirror: this.mirror
      }));
      setTimeout(() => {
        if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)
          this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));
        this.restoreHandlers.push(initAdoptedStyleSheetObserver({
          mirror: this.mirror,
          stylesheetManager: this.bypassOptions.stylesheetManager
        }, shadowRoot));
      }, 0);
    }
    observeAttachShadow(iframeElement) {
      if (!iframeElement.contentWindow || !iframeElement.contentDocument)
        return;
      this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);
    }
    patchAttachShadow(element, doc) {
      const manager = this;
      this.restoreHandlers.push(patch(element.prototype, "attachShadow", function(original) {
        return function(option) {
          const shadowRoot = original.call(this, option);
          if (this.shadowRoot && inDom(this))
            manager.addShadowRoot(this.shadowRoot, doc);
          return shadowRoot;
        };
      }));
    }
    reset() {
      this.restoreHandlers.forEach((handler) => {
        try {
          handler();
        } catch (e3) {
        }
      });
      this.restoreHandlers = [];
      this.shadowDoms = /* @__PURE__ */ new WeakSet();
    }
  };
  var CanvasManagerNoop = class {
    reset() {
    }
    freeze() {
    }
    unfreeze() {
    }
    lock() {
    }
    unlock() {
    }
    snapshot() {
    }
  };
  var StylesheetManager = class {
    constructor(options) {
      this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
      this.styleMirror = new StyleSheetMirror();
      this.mutationCb = options.mutationCb;
      this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;
    }
    attachLinkElement(linkEl, childSn) {
      if ("_cssText" in childSn.attributes)
        this.mutationCb({
          adds: [],
          removes: [],
          texts: [],
          attributes: [
            {
              id: childSn.id,
              attributes: childSn.attributes
            }
          ]
        });
      this.trackLinkElement(linkEl);
    }
    trackLinkElement(linkEl) {
      if (this.trackedLinkElements.has(linkEl))
        return;
      this.trackedLinkElements.add(linkEl);
      this.trackStylesheetInLinkElement(linkEl);
    }
    adoptStyleSheets(sheets, hostId) {
      if (sheets.length === 0)
        return;
      const adoptedStyleSheetData = {
        id: hostId,
        styleIds: []
      };
      const styles2 = [];
      for (const sheet of sheets) {
        let styleId;
        if (!this.styleMirror.has(sheet)) {
          styleId = this.styleMirror.add(sheet);
          styles2.push({
            styleId,
            rules: Array.from(sheet.rules || CSSRule, (r3, index) => ({
              rule: stringifyRule(r3),
              index
            }))
          });
        } else
          styleId = this.styleMirror.getId(sheet);
        adoptedStyleSheetData.styleIds.push(styleId);
      }
      if (styles2.length > 0)
        adoptedStyleSheetData.styles = styles2;
      this.adoptedStyleSheetCb(adoptedStyleSheetData);
    }
    reset() {
      this.styleMirror.reset();
      this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
    }
    trackStylesheetInLinkElement(linkEl) {
    }
  };
  var ProcessedNodeManager = class {
    constructor() {
      this.nodeMap = /* @__PURE__ */ new WeakMap();
      this.loop = true;
      this.periodicallyClear();
    }
    periodicallyClear() {
      onRequestAnimationFrame(() => {
        this.clear();
        if (this.loop)
          this.periodicallyClear();
      });
    }
    inOtherBuffer(node2, thisBuffer) {
      const buffers = this.nodeMap.get(node2);
      return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);
    }
    add(node2, buffer) {
      this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer));
    }
    clear() {
      this.nodeMap = /* @__PURE__ */ new WeakMap();
    }
    destroy() {
      this.loop = false;
    }
  };
  function wrapEvent(e3) {
    const eWithTime = e3;
    eWithTime.timestamp = nowTimestamp();
    return eWithTime;
  }
  var _takeFullSnapshot;
  var mirror = createMirror();
  function record2(options = {}) {
    const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = "rr-block", blockSelector = null, unblockSelector = null, ignoreClass = "rr-ignore", ignoreSelector = null, maskAllText = false, maskTextClass = "rr-mask", unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskAttributeFn, maskInputFn, maskTextFn, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === "DOMContentLoaded" ? options.recordAfter : "load", userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = () => false, ignoreCSSAttributes = /* @__PURE__ */ new Set([]), errorHandler: errorHandler2, onMutation, getCanvasManager } = options;
    registerErrorHandler(errorHandler2);
    const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;
    let passEmitsToParent = false;
    if (!inEmittingFrame) {
      try {
        if (window.parent.document) {
          passEmitsToParent = false;
        }
      } catch (e3) {
        passEmitsToParent = true;
      }
    }
    if (inEmittingFrame && !emit) {
      throw new Error("emit function is required");
    }
    if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {
      sampling.mousemove = mousemoveWait;
    }
    mirror.reset();
    const maskInputOptions = maskAllInputs === true ? {
      color: true,
      date: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true,
      textarea: true,
      select: true,
      radio: true,
      checkbox: true
    } : _maskInputOptions !== void 0 ? _maskInputOptions : {};
    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === "all" ? {
      script: true,
      comment: true,
      headFavicon: true,
      headWhitespace: true,
      headMetaSocial: true,
      headMetaRobots: true,
      headMetaHttpEquiv: true,
      headMetaVerification: true,
      headMetaAuthorship: _slimDOMOptions === "all",
      headMetaDescKeywords: _slimDOMOptions === "all"
    } : _slimDOMOptions ? _slimDOMOptions : {};
    polyfill();
    let lastFullSnapshotEvent;
    let incrementalSnapshotCount = 0;
    const eventProcessor = (e3) => {
      for (const plugin of plugins || []) {
        if (plugin.eventProcessor) {
          e3 = plugin.eventProcessor(e3);
        }
      }
      if (packFn && !passEmitsToParent) {
        e3 = packFn(e3);
      }
      return e3;
    };
    const wrappedEmit = (e3, isCheckout) => {
      if (_optionalChain([mutationBuffers, "access", (_) => _[0], "optionalAccess", (_2) => _2.isFrozen, "call", (_3) => _3()]) && e3.type !== EventType.FullSnapshot && !(e3.type === EventType.IncrementalSnapshot && e3.data.source === IncrementalSource.Mutation)) {
        mutationBuffers.forEach((buf) => buf.unfreeze());
      }
      if (inEmittingFrame) {
        _optionalChain([emit, "optionalCall", (_4) => _4(eventProcessor(e3), isCheckout)]);
      } else if (passEmitsToParent) {
        const message = {
          type: "rrweb",
          event: eventProcessor(e3),
          origin: window.location.origin,
          isCheckout
        };
        window.parent.postMessage(message, "*");
      }
      if (e3.type === EventType.FullSnapshot) {
        lastFullSnapshotEvent = e3;
        incrementalSnapshotCount = 0;
      } else if (e3.type === EventType.IncrementalSnapshot) {
        if (e3.data.source === IncrementalSource.Mutation && e3.data.isAttachIframe) {
          return;
        }
        incrementalSnapshotCount++;
        const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
        const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e3.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;
        if (exceedCount || exceedTime) {
          takeFullSnapshot2(true);
        }
      }
    };
    const wrappedMutationEmit = (m) => {
      wrappedEmit(wrapEvent({
        type: EventType.IncrementalSnapshot,
        data: {
          source: IncrementalSource.Mutation,
          ...m
        }
      }));
    };
    const wrappedScrollEmit = (p) => wrappedEmit(wrapEvent({
      type: EventType.IncrementalSnapshot,
      data: {
        source: IncrementalSource.Scroll,
        ...p
      }
    }));
    const wrappedCanvasMutationEmit = (p) => wrappedEmit(wrapEvent({
      type: EventType.IncrementalSnapshot,
      data: {
        source: IncrementalSource.CanvasMutation,
        ...p
      }
    }));
    const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit(wrapEvent({
      type: EventType.IncrementalSnapshot,
      data: {
        source: IncrementalSource.AdoptedStyleSheet,
        ...a
      }
    }));
    const stylesheetManager = new StylesheetManager({
      mutationCb: wrappedMutationEmit,
      adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit
    });
    const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === "boolean" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({
      mirror,
      mutationCb: wrappedMutationEmit,
      stylesheetManager,
      recordCrossOriginIframes,
      wrappedEmit
    });
    for (const plugin of plugins || []) {
      if (plugin.getMirror)
        plugin.getMirror({
          nodeMirror: mirror,
          crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,
          crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror
        });
    }
    const processedNodeManager = new ProcessedNodeManager();
    const canvasManager = _getCanvasManager(getCanvasManager, {
      mirror,
      win: window,
      mutationCb: (p) => wrappedEmit(wrapEvent({
        type: EventType.IncrementalSnapshot,
        data: {
          source: IncrementalSource.CanvasMutation,
          ...p
        }
      })),
      recordCanvas,
      blockClass,
      blockSelector,
      unblockSelector,
      sampling: sampling["canvas"],
      dataURLOptions,
      errorHandler: errorHandler2
    });
    const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === "boolean" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({
      mutationCb: wrappedMutationEmit,
      scrollCb: wrappedScrollEmit,
      bypassOptions: {
        onMutation,
        blockClass,
        blockSelector,
        unblockSelector,
        maskAllText,
        maskTextClass,
        unmaskTextClass,
        maskTextSelector,
        unmaskTextSelector,
        inlineStylesheet,
        maskInputOptions,
        dataURLOptions,
        maskAttributeFn,
        maskTextFn,
        maskInputFn,
        recordCanvas,
        inlineImages,
        sampling,
        slimDOMOptions,
        iframeManager,
        stylesheetManager,
        canvasManager,
        keepIframeSrcFn,
        processedNodeManager
      },
      mirror
    });
    const takeFullSnapshot2 = (isCheckout = false) => {
      wrappedEmit(wrapEvent({
        type: EventType.Meta,
        data: {
          href: window.location.href,
          width: getWindowWidth(),
          height: getWindowHeight()
        }
      }), isCheckout);
      stylesheetManager.reset();
      shadowDomManager.init();
      mutationBuffers.forEach((buf) => buf.lock());
      const node2 = snapshot(document, {
        mirror,
        blockClass,
        blockSelector,
        unblockSelector,
        maskAllText,
        maskTextClass,
        unmaskTextClass,
        maskTextSelector,
        unmaskTextSelector,
        inlineStylesheet,
        maskAllInputs: maskInputOptions,
        maskAttributeFn,
        maskInputFn,
        maskTextFn,
        slimDOM: slimDOMOptions,
        dataURLOptions,
        recordCanvas,
        inlineImages,
        onSerialize: (n2) => {
          if (isSerializedIframe(n2, mirror)) {
            iframeManager.addIframe(n2);
          }
          if (isSerializedStylesheet(n2, mirror)) {
            stylesheetManager.trackLinkElement(n2);
          }
          if (hasShadowRoot(n2)) {
            shadowDomManager.addShadowRoot(n2.shadowRoot, document);
          }
        },
        onIframeLoad: (iframe, childSn) => {
          iframeManager.attachIframe(iframe, childSn);
          shadowDomManager.observeAttachShadow(iframe);
        },
        onStylesheetLoad: (linkEl, childSn) => {
          stylesheetManager.attachLinkElement(linkEl, childSn);
        },
        keepIframeSrcFn
      });
      if (!node2) {
        return console.warn("Failed to snapshot the document");
      }
      wrappedEmit(wrapEvent({
        type: EventType.FullSnapshot,
        data: {
          node: node2,
          initialOffset: getWindowScroll2(window)
        }
      }));
      mutationBuffers.forEach((buf) => buf.unlock());
      if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)
        stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));
    };
    _takeFullSnapshot = takeFullSnapshot2;
    try {
      const handlers4 = [];
      const observe2 = (doc) => {
        return callbackWrapper(initObservers)({
          onMutation,
          mutationCb: wrappedMutationEmit,
          mousemoveCb: (positions, source) => wrappedEmit(wrapEvent({
            type: EventType.IncrementalSnapshot,
            data: {
              source,
              positions
            }
          })),
          mouseInteractionCb: (d) => wrappedEmit(wrapEvent({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.MouseInteraction,
              ...d
            }
          })),
          scrollCb: wrappedScrollEmit,
          viewportResizeCb: (d) => wrappedEmit(wrapEvent({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.ViewportResize,
              ...d
            }
          })),
          inputCb: (v) => wrappedEmit(wrapEvent({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Input,
              ...v
            }
          })),
          mediaInteractionCb: (p) => wrappedEmit(wrapEvent({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.MediaInteraction,
              ...p
            }
          })),
          styleSheetRuleCb: (r3) => wrappedEmit(wrapEvent({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.StyleSheetRule,
              ...r3
            }
          })),
          styleDeclarationCb: (r3) => wrappedEmit(wrapEvent({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.StyleDeclaration,
              ...r3
            }
          })),
          canvasMutationCb: wrappedCanvasMutationEmit,
          fontCb: (p) => wrappedEmit(wrapEvent({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Font,
              ...p
            }
          })),
          selectionCb: (p) => {
            wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.Selection,
                ...p
              }
            }));
          },
          customElementCb: (c) => {
            wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.CustomElement,
                ...c
              }
            }));
          },
          blockClass,
          ignoreClass,
          ignoreSelector,
          maskAllText,
          maskTextClass,
          unmaskTextClass,
          maskTextSelector,
          unmaskTextSelector,
          maskInputOptions,
          inlineStylesheet,
          sampling,
          recordCanvas,
          inlineImages,
          userTriggeredOnInput,
          collectFonts,
          doc,
          maskAttributeFn,
          maskInputFn,
          maskTextFn,
          keepIframeSrcFn,
          blockSelector,
          unblockSelector,
          slimDOMOptions,
          dataURLOptions,
          mirror,
          iframeManager,
          stylesheetManager,
          shadowDomManager,
          processedNodeManager,
          canvasManager,
          ignoreCSSAttributes,
          plugins: _optionalChain([
            plugins,
            "optionalAccess",
            (_5) => _5.filter,
            "call",
            (_6) => _6((p) => p.observer),
            "optionalAccess",
            (_7) => _7.map,
            "call",
            (_8) => _8((p) => ({
              observer: p.observer,
              options: p.options,
              callback: (payload) => wrappedEmit(wrapEvent({
                type: EventType.Plugin,
                data: {
                  plugin: p.name,
                  payload
                }
              }))
            }))
          ]) || []
        }, {});
      };
      iframeManager.addLoadListener((iframeEl) => {
        try {
          handlers4.push(observe2(iframeEl.contentDocument));
        } catch (error2) {
          console.warn(error2);
        }
      });
      const init3 = () => {
        takeFullSnapshot2();
        handlers4.push(observe2(document));
      };
      if (document.readyState === "interactive" || document.readyState === "complete") {
        init3();
      } else {
        handlers4.push(on("DOMContentLoaded", () => {
          wrappedEmit(wrapEvent({
            type: EventType.DomContentLoaded,
            data: {}
          }));
          if (recordAfter === "DOMContentLoaded")
            init3();
        }));
        handlers4.push(on("load", () => {
          wrappedEmit(wrapEvent({
            type: EventType.Load,
            data: {}
          }));
          if (recordAfter === "load")
            init3();
        }, window));
      }
      return () => {
        handlers4.forEach((h) => h());
        processedNodeManager.destroy();
        _takeFullSnapshot = void 0;
        unregisterErrorHandler();
      };
    } catch (error2) {
      console.warn(error2);
    }
  }
  function takeFullSnapshot(isCheckout) {
    if (!_takeFullSnapshot) {
      throw new Error("please take full snapshot after start recording");
    }
    _takeFullSnapshot(isCheckout);
  }
  record2.mirror = mirror;
  record2.takeFullSnapshot = takeFullSnapshot;
  function _getCanvasManager(getCanvasManagerFn, options) {
    try {
      return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();
    } catch (e22) {
      console.warn("Unable to initialize CanvasManager");
      return new CanvasManagerNoop();
    }
  }
  var ReplayEventTypeIncrementalSnapshot = 3;
  var ReplayEventTypeCustom = 5;
  function timestampToMs(timestamp) {
    const isMs = timestamp > 9999999999;
    return isMs ? timestamp : timestamp * 1e3;
  }
  function timestampToS(timestamp) {
    const isMs = timestamp > 9999999999;
    return isMs ? timestamp / 1e3 : timestamp;
  }
  function addBreadcrumbEvent(replay, breadcrumb) {
    if (breadcrumb.category === "sentry.transaction") {
      return;
    }
    if (["ui.click", "ui.input"].includes(breadcrumb.category)) {
      replay.triggerUserActivity();
    } else {
      replay.checkAndHandleExpiredSession();
    }
    replay.addUpdate(() => {
      replay.throttledAddEvent({
        type: EventType.Custom,
        // TODO: We were converting from ms to seconds for breadcrumbs, spans,
        // but maybe we should just keep them as milliseconds
        timestamp: (breadcrumb.timestamp || 0) * 1e3,
        data: {
          tag: "breadcrumb",
          // normalize to max. 10 depth and 1_000 properties per object
          payload: normalize4(breadcrumb, 10, 1e3)
        }
      });
      return breadcrumb.category === "console";
    });
  }
  var INTERACTIVE_SELECTOR = "button,a";
  function getClosestInteractive(element) {
    const closestInteractive = element.closest(INTERACTIVE_SELECTOR);
    return closestInteractive || element;
  }
  function getClickTargetNode(event) {
    const target = getTargetNode(event);
    if (!target || !(target instanceof Element)) {
      return target;
    }
    return getClosestInteractive(target);
  }
  function getTargetNode(event) {
    if (isEventWithTarget(event)) {
      return event.target;
    }
    return event;
  }
  function isEventWithTarget(event) {
    return typeof event === "object" && !!event && "target" in event;
  }
  var handlers3;
  function onWindowOpen(cb) {
    if (!handlers3) {
      handlers3 = [];
      monkeyPatchWindowOpen();
    }
    handlers3.push(cb);
    return () => {
      const pos = handlers3 ? handlers3.indexOf(cb) : -1;
      if (pos > -1) {
        handlers3.splice(pos, 1);
      }
    };
  }
  function monkeyPatchWindowOpen() {
    fill(WINDOW9, "open", function(originalWindowOpen) {
      return function(...args) {
        if (handlers3) {
          try {
            handlers3.forEach((handler) => handler());
          } catch (e3) {
          }
        }
        return originalWindowOpen.apply(WINDOW9, args);
      };
    });
  }
  function handleClick(clickDetector, clickBreadcrumb, node2) {
    clickDetector.handleClick(clickBreadcrumb, node2);
  }
  var ClickDetector = class {
    // protected for testing
    constructor(replay, slowClickConfig, _addBreadcrumbEvent = addBreadcrumbEvent) {
      this._lastMutation = 0;
      this._lastScroll = 0;
      this._clicks = [];
      this._timeout = slowClickConfig.timeout / 1e3;
      this._threshold = slowClickConfig.threshold / 1e3;
      this._scollTimeout = slowClickConfig.scrollTimeout / 1e3;
      this._replay = replay;
      this._ignoreSelector = slowClickConfig.ignoreSelector;
      this._addBreadcrumbEvent = _addBreadcrumbEvent;
    }
    /** Register click detection handlers on mutation or scroll. */
    addListeners() {
      const cleanupWindowOpen = onWindowOpen(() => {
        this._lastMutation = nowInSeconds();
      });
      this._teardown = () => {
        cleanupWindowOpen();
        this._clicks = [];
        this._lastMutation = 0;
        this._lastScroll = 0;
      };
    }
    /** Clean up listeners. */
    removeListeners() {
      if (this._teardown) {
        this._teardown();
      }
      if (this._checkClickTimeout) {
        clearTimeout(this._checkClickTimeout);
      }
    }
    /** @inheritDoc */
    handleClick(breadcrumb, node2) {
      if (ignoreElement(node2, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {
        return;
      }
      const newClick = {
        timestamp: timestampToS(breadcrumb.timestamp),
        clickBreadcrumb: breadcrumb,
        // Set this to 0 so we know it originates from the click breadcrumb
        clickCount: 0,
        node: node2
      };
      if (this._clicks.some((click) => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)) {
        return;
      }
      this._clicks.push(newClick);
      if (this._clicks.length === 1) {
        this._scheduleCheckClicks();
      }
    }
    /** @inheritDoc */
    registerMutation(timestamp = Date.now()) {
      this._lastMutation = timestampToS(timestamp);
    }
    /** @inheritDoc */
    registerScroll(timestamp = Date.now()) {
      this._lastScroll = timestampToS(timestamp);
    }
    /** @inheritDoc */
    registerClick(element) {
      const node2 = getClosestInteractive(element);
      this._handleMultiClick(node2);
    }
    /** Count multiple clicks on elements. */
    _handleMultiClick(node2) {
      this._getClicks(node2).forEach((click) => {
        click.clickCount++;
      });
    }
    /** Get all pending clicks for a given node. */
    _getClicks(node2) {
      return this._clicks.filter((click) => click.node === node2);
    }
    /** Check the clicks that happened. */
    _checkClicks() {
      const timedOutClicks = [];
      const now3 = nowInSeconds();
      this._clicks.forEach((click) => {
        if (!click.mutationAfter && this._lastMutation) {
          click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : void 0;
        }
        if (!click.scrollAfter && this._lastScroll) {
          click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : void 0;
        }
        if (click.timestamp + this._timeout <= now3) {
          timedOutClicks.push(click);
        }
      });
      for (const click of timedOutClicks) {
        const pos = this._clicks.indexOf(click);
        if (pos > -1) {
          this._generateBreadcrumbs(click);
          this._clicks.splice(pos, 1);
        }
      }
      if (this._clicks.length) {
        this._scheduleCheckClicks();
      }
    }
    /** Generate matching breadcrumb(s) for the click. */
    _generateBreadcrumbs(click) {
      const replay = this._replay;
      const hadScroll = click.scrollAfter && click.scrollAfter <= this._scollTimeout;
      const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;
      const isSlowClick = !hadScroll && !hadMutation;
      const { clickCount, clickBreadcrumb } = click;
      if (isSlowClick) {
        const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1e3;
        const endReason = timeAfterClickMs < this._timeout * 1e3 ? "mutation" : "timeout";
        const breadcrumb = {
          type: "default",
          message: clickBreadcrumb.message,
          timestamp: clickBreadcrumb.timestamp,
          category: "ui.slowClickDetected",
          data: {
            ...clickBreadcrumb.data,
            url: WINDOW9.location.href,
            route: replay.getCurrentRoute(),
            timeAfterClickMs,
            endReason,
            // If clickCount === 0, it means multiClick was not correctly captured here
            // - we still want to send 1 in this case
            clickCount: clickCount || 1
          }
        };
        this._addBreadcrumbEvent(replay, breadcrumb);
        return;
      }
      if (clickCount > 1) {
        const breadcrumb = {
          type: "default",
          message: clickBreadcrumb.message,
          timestamp: clickBreadcrumb.timestamp,
          category: "ui.multiClick",
          data: {
            ...clickBreadcrumb.data,
            url: WINDOW9.location.href,
            route: replay.getCurrentRoute(),
            clickCount,
            metric: true
          }
        };
        this._addBreadcrumbEvent(replay, breadcrumb);
      }
    }
    /** Schedule to check current clicks. */
    _scheduleCheckClicks() {
      if (this._checkClickTimeout) {
        clearTimeout(this._checkClickTimeout);
      }
      this._checkClickTimeout = setTimeout(() => this._checkClicks(), 1e3);
    }
  };
  var SLOW_CLICK_TAGS = ["A", "BUTTON", "INPUT"];
  function ignoreElement(node2, ignoreSelector) {
    if (!SLOW_CLICK_TAGS.includes(node2.tagName)) {
      return true;
    }
    if (node2.tagName === "INPUT" && !["submit", "button"].includes(node2.getAttribute("type") || "")) {
      return true;
    }
    if (node2.tagName === "A" && (node2.hasAttribute("download") || node2.hasAttribute("target") && node2.getAttribute("target") !== "_self")) {
      return true;
    }
    if (ignoreSelector && node2.matches(ignoreSelector)) {
      return true;
    }
    return false;
  }
  function isClickBreadcrumb(breadcrumb) {
    return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === "number" && breadcrumb.timestamp);
  }
  function nowInSeconds() {
    return Date.now() / 1e3;
  }
  function updateClickDetectorForRecordingEvent(clickDetector, event) {
    try {
      if (!isIncrementalEvent(event)) {
        return;
      }
      const { source } = event.data;
      if (source === IncrementalSource.Mutation) {
        clickDetector.registerMutation(event.timestamp);
      }
      if (source === IncrementalSource.Scroll) {
        clickDetector.registerScroll(event.timestamp);
      }
      if (isIncrementalMouseInteraction(event)) {
        const { type, id: id3 } = event.data;
        const node2 = record2.mirror.getNode(id3);
        if (node2 instanceof HTMLElement && type === MouseInteractions.Click) {
          clickDetector.registerClick(node2);
        }
      }
    } catch (e3) {
    }
  }
  function isIncrementalEvent(event) {
    return event.type === ReplayEventTypeIncrementalSnapshot;
  }
  function isIncrementalMouseInteraction(event) {
    return event.data.source === IncrementalSource.MouseInteraction;
  }
  function createBreadcrumb(breadcrumb) {
    return {
      timestamp: Date.now() / 1e3,
      type: "default",
      ...breadcrumb
    };
  }
  var NodeType;
  (function(NodeType2) {
    NodeType2[NodeType2["Document"] = 0] = "Document";
    NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
    NodeType2[NodeType2["Element"] = 2] = "Element";
    NodeType2[NodeType2["Text"] = 3] = "Text";
    NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
    NodeType2[NodeType2["Comment"] = 5] = "Comment";
  })(NodeType || (NodeType = {}));
  var ATTRIBUTES_TO_RECORD = /* @__PURE__ */ new Set([
    "id",
    "class",
    "aria-label",
    "role",
    "name",
    "alt",
    "title",
    "data-test-id",
    "data-testid",
    "disabled",
    "aria-disabled",
    "data-sentry-component"
  ]);
  function getAttributesToRecord(attributes) {
    const obj = {};
    for (const key in attributes) {
      if (ATTRIBUTES_TO_RECORD.has(key)) {
        let normalizedKey = key;
        if (key === "data-testid" || key === "data-test-id") {
          normalizedKey = "testId";
        }
        obj[normalizedKey] = attributes[key];
      }
    }
    return obj;
  }
  var handleDomListener = (replay) => {
    return (handlerData) => {
      if (!replay.isEnabled()) {
        return;
      }
      const result = handleDom(handlerData);
      if (!result) {
        return;
      }
      const isClick = handlerData.name === "click";
      const event = isClick ? handlerData.event : void 0;
      if (isClick && replay.clickDetector && event && event.target && !event.altKey && !event.metaKey && !event.ctrlKey && !event.shiftKey) {
        handleClick(
          replay.clickDetector,
          result,
          getClickTargetNode(handlerData.event)
        );
      }
      addBreadcrumbEvent(replay, result);
    };
  };
  function getBaseDomBreadcrumb(target, message) {
    const nodeId = record2.mirror.getId(target);
    const node2 = nodeId && record2.mirror.getNode(nodeId);
    const meta = node2 && record2.mirror.getMeta(node2);
    const element = meta && isElement6(meta) ? meta : null;
    return {
      message,
      data: element ? {
        nodeId,
        node: {
          id: nodeId,
          tagName: element.tagName,
          textContent: Array.from(element.childNodes).map((node3) => node3.type === NodeType.Text && node3.textContent).filter(Boolean).map((text) => text.trim()).join(""),
          attributes: getAttributesToRecord(element.attributes)
        }
      } : {}
    };
  }
  function handleDom(handlerData) {
    const { target, message } = getDomTarget(handlerData);
    return createBreadcrumb({
      category: `ui.${handlerData.name}`,
      ...getBaseDomBreadcrumb(target, message)
    });
  }
  function getDomTarget(handlerData) {
    const isClick = handlerData.name === "click";
    let message;
    let target = null;
    try {
      target = isClick ? getClickTargetNode(handlerData.event) : getTargetNode(handlerData.event);
      message = htmlTreeAsString(target, { maxStringLength: 200 }) || "<unknown>";
    } catch (e3) {
      message = "<unknown>";
    }
    return { target, message };
  }
  function isElement6(node2) {
    return node2.type === NodeType.Element;
  }
  function handleKeyboardEvent(replay, event) {
    if (!replay.isEnabled()) {
      return;
    }
    replay.updateUserActivity();
    const breadcrumb = getKeyboardBreadcrumb(event);
    if (!breadcrumb) {
      return;
    }
    addBreadcrumbEvent(replay, breadcrumb);
  }
  function getKeyboardBreadcrumb(event) {
    const { metaKey, shiftKey, ctrlKey, altKey, key, target } = event;
    if (!target || isInputElement(target) || !key) {
      return null;
    }
    const hasModifierKey = metaKey || ctrlKey || altKey;
    const isCharacterKey = key.length === 1;
    if (!hasModifierKey && isCharacterKey) {
      return null;
    }
    const message = htmlTreeAsString(target, { maxStringLength: 200 }) || "<unknown>";
    const baseBreadcrumb = getBaseDomBreadcrumb(target, message);
    return createBreadcrumb({
      category: "ui.keyDown",
      message,
      data: {
        ...baseBreadcrumb.data,
        metaKey,
        shiftKey,
        ctrlKey,
        altKey,
        key
      }
    });
  }
  function isInputElement(target) {
    return target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable;
  }
  var ENTRY_TYPES = {
    // @ts-expect-error TODO: entry type does not fit the create* functions entry type
    resource: createResourceEntry,
    paint: createPaintEntry,
    // @ts-expect-error TODO: entry type does not fit the create* functions entry type
    navigation: createNavigationEntry
  };
  function createPerformanceEntries(entries) {
    return entries.map(createPerformanceEntry).filter(Boolean);
  }
  function createPerformanceEntry(entry) {
    if (!ENTRY_TYPES[entry.entryType]) {
      return null;
    }
    return ENTRY_TYPES[entry.entryType](entry);
  }
  function getAbsoluteTime2(time2) {
    return ((browserPerformanceTimeOrigin || WINDOW9.performance.timeOrigin) + time2) / 1e3;
  }
  function createPaintEntry(entry) {
    const { duration, entryType, name, startTime } = entry;
    const start2 = getAbsoluteTime2(startTime);
    return {
      type: entryType,
      name,
      start: start2,
      end: start2 + duration,
      data: void 0
    };
  }
  function createNavigationEntry(entry) {
    const {
      entryType,
      name,
      decodedBodySize,
      duration,
      domComplete,
      encodedBodySize,
      domContentLoadedEventStart,
      domContentLoadedEventEnd,
      domInteractive,
      loadEventStart,
      loadEventEnd,
      redirectCount,
      startTime,
      transferSize,
      type
    } = entry;
    if (duration === 0) {
      return null;
    }
    return {
      type: `${entryType}.${type}`,
      start: getAbsoluteTime2(startTime),
      end: getAbsoluteTime2(domComplete),
      name,
      data: {
        size: transferSize,
        decodedBodySize,
        encodedBodySize,
        duration,
        domInteractive,
        domContentLoadedEventStart,
        domContentLoadedEventEnd,
        loadEventStart,
        loadEventEnd,
        domComplete,
        redirectCount
      }
    };
  }
  function createResourceEntry(entry) {
    const {
      entryType,
      initiatorType,
      name,
      responseEnd,
      startTime,
      decodedBodySize,
      encodedBodySize,
      responseStatus,
      transferSize
    } = entry;
    if (["fetch", "xmlhttprequest"].includes(initiatorType)) {
      return null;
    }
    return {
      type: `${entryType}.${initiatorType}`,
      start: getAbsoluteTime2(startTime),
      end: getAbsoluteTime2(responseEnd),
      name,
      data: {
        size: transferSize,
        statusCode: responseStatus,
        decodedBodySize,
        encodedBodySize
      }
    };
  }
  function getLargestContentfulPaint(metric) {
    const entries = metric.entries;
    const lastEntry = entries[entries.length - 1];
    const element = lastEntry ? lastEntry.element : void 0;
    const value = metric.value;
    const end2 = getAbsoluteTime2(value);
    const data = {
      type: "largest-contentful-paint",
      name: "largest-contentful-paint",
      start: end2,
      end: end2,
      data: {
        value,
        size: value,
        nodeId: element ? record2.mirror.getId(element) : void 0
      }
    };
    return data;
  }
  function setupPerformanceObserver(replay) {
    function addPerformanceEntry(entry) {
      if (!replay.performanceEntries.includes(entry)) {
        replay.performanceEntries.push(entry);
      }
    }
    function onEntries({ entries }) {
      entries.forEach(addPerformanceEntry);
    }
    const clearCallbacks = [];
    ["navigation", "paint", "resource"].forEach((type) => {
      clearCallbacks.push(addPerformanceInstrumentationHandler(type, onEntries));
    });
    clearCallbacks.push(
      addLcpInstrumentationHandler(({ metric }) => {
        replay.replayPerformanceEntries.push(getLargestContentfulPaint(metric));
      })
    );
    return () => {
      clearCallbacks.forEach((clearCallback) => clearCallback());
    };
  }
  var DEBUG_BUILD5 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  var r2 = `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},L=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},O=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},j=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(L(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();function q(t,n){n||(n={});var r=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}}(),e=t.length;r.p(t);var i,a=L(t,n,10+((i=n).filename?i.filename.length+1:0),8),s=a.length;return function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&O(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}}(a,n),O(a,s-8,r.d()),O(a,s-4,e),a}var B=function(){function t(t,n){this.c=S(),this.v=1,j.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),j.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=L(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=S();i.p(n.dictionary),O(t,2,i.d())}}(r,this.o),this.v=0),n&&O(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),G="undefined"!=typeof TextEncoder&&new TextEncoder,H="undefined"!=typeof TextDecoder&&new TextDecoder;try{H.decode(F,{stream:!0})}catch(t){}var J=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(K(t),this.d=n||!1)},t}();function K(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(G)return G.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}const N=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(let r=0,e=t.length;r<e;r++)n+=t[r].length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new B,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new J(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},P={clear:()=>{N.clear()},addEvent:t=>N.addEvent(t),finish:()=>N.finish(),compress:t=>function(t){return q(K(t))}(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in P&&"function"==typeof P[n])try{const t=P[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});`;
  function e() {
    const e3 = new Blob([r2]);
    return URL.createObjectURL(e3);
  }
  function logInfo(message, shouldAddBreadcrumb) {
    if (!DEBUG_BUILD5) {
      return;
    }
    logger.info(message);
    if (shouldAddBreadcrumb) {
      addLogBreadcrumb(message);
    }
  }
  function logInfoNextTick(message, shouldAddBreadcrumb) {
    if (!DEBUG_BUILD5) {
      return;
    }
    logger.info(message);
    if (shouldAddBreadcrumb) {
      setTimeout(() => {
        addLogBreadcrumb(message);
      }, 0);
    }
  }
  function addLogBreadcrumb(message) {
    addBreadcrumb(
      {
        category: "console",
        data: {
          logger: "replay"
        },
        level: "info",
        message
      },
      { level: "info" }
    );
  }
  var EventBufferSizeExceededError = class extends Error {
    constructor() {
      super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);
    }
  };
  var EventBufferArray = class {
    /** All the events that are buffered to be sent. */
    /** @inheritdoc */
    constructor() {
      this.events = [];
      this._totalSize = 0;
      this.hasCheckout = false;
    }
    /** @inheritdoc */
    get hasEvents() {
      return this.events.length > 0;
    }
    /** @inheritdoc */
    get type() {
      return "sync";
    }
    /** @inheritdoc */
    destroy() {
      this.events = [];
    }
    /** @inheritdoc */
    async addEvent(event) {
      const eventSize = JSON.stringify(event).length;
      this._totalSize += eventSize;
      if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {
        throw new EventBufferSizeExceededError();
      }
      this.events.push(event);
    }
    /** @inheritdoc */
    finish() {
      return new Promise((resolve) => {
        const eventsRet = this.events;
        this.clear();
        resolve(JSON.stringify(eventsRet));
      });
    }
    /** @inheritdoc */
    clear() {
      this.events = [];
      this._totalSize = 0;
      this.hasCheckout = false;
    }
    /** @inheritdoc */
    getEarliestTimestamp() {
      const timestamp = this.events.map((event) => event.timestamp).sort()[0];
      if (!timestamp) {
        return null;
      }
      return timestampToMs(timestamp);
    }
  };
  var WorkerHandler = class {
    constructor(worker) {
      this._worker = worker;
      this._id = 0;
    }
    /**
     * Ensure the worker is ready (or not).
     * This will either resolve when the worker is ready, or reject if an error occured.
     */
    ensureReady() {
      if (this._ensureReadyPromise) {
        return this._ensureReadyPromise;
      }
      this._ensureReadyPromise = new Promise((resolve, reject) => {
        this._worker.addEventListener(
          "message",
          ({ data }) => {
            if (data.success) {
              resolve();
            } else {
              reject();
            }
          },
          { once: true }
        );
        this._worker.addEventListener(
          "error",
          (error2) => {
            reject(error2);
          },
          { once: true }
        );
      });
      return this._ensureReadyPromise;
    }
    /**
     * Destroy the worker.
     */
    destroy() {
      logInfo("[Replay] Destroying compression worker");
      this._worker.terminate();
    }
    /**
     * Post message to worker and wait for response before resolving promise.
     */
    postMessage(method, arg) {
      const id3 = this._getAndIncrementId();
      return new Promise((resolve, reject) => {
        const listener = ({ data }) => {
          const response = data;
          if (response.method !== method) {
            return;
          }
          if (response.id !== id3) {
            return;
          }
          this._worker.removeEventListener("message", listener);
          if (!response.success) {
            DEBUG_BUILD5 && logger.error("[Replay]", response.response);
            reject(new Error("Error in compression worker"));
            return;
          }
          resolve(response.response);
        };
        this._worker.addEventListener("message", listener);
        this._worker.postMessage({ id: id3, method, arg });
      });
    }
    /** Get the current ID and increment it for the next call. */
    _getAndIncrementId() {
      return this._id++;
    }
  };
  var EventBufferCompressionWorker = class {
    /** @inheritdoc */
    constructor(worker) {
      this._worker = new WorkerHandler(worker);
      this._earliestTimestamp = null;
      this._totalSize = 0;
      this.hasCheckout = false;
    }
    /** @inheritdoc */
    get hasEvents() {
      return !!this._earliestTimestamp;
    }
    /** @inheritdoc */
    get type() {
      return "worker";
    }
    /**
     * Ensure the worker is ready (or not).
     * This will either resolve when the worker is ready, or reject if an error occured.
     */
    ensureReady() {
      return this._worker.ensureReady();
    }
    /**
     * Destroy the event buffer.
     */
    destroy() {
      this._worker.destroy();
    }
    /**
     * Add an event to the event buffer.
     *
     * Returns true if event was successfuly received and processed by worker.
     */
    addEvent(event) {
      const timestamp = timestampToMs(event.timestamp);
      if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {
        this._earliestTimestamp = timestamp;
      }
      const data = JSON.stringify(event);
      this._totalSize += data.length;
      if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {
        return Promise.reject(new EventBufferSizeExceededError());
      }
      return this._sendEventToWorker(data);
    }
    /**
     * Finish the event buffer and return the compressed data.
     */
    finish() {
      return this._finishRequest();
    }
    /** @inheritdoc */
    clear() {
      this._earliestTimestamp = null;
      this._totalSize = 0;
      this.hasCheckout = false;
      this._worker.postMessage("clear").then(null, (e3) => {
        DEBUG_BUILD5 && logger.warn('[Replay] Sending "clear" message to worker failed', e3);
      });
    }
    /** @inheritdoc */
    getEarliestTimestamp() {
      return this._earliestTimestamp;
    }
    /**
     * Send the event to the worker.
     */
    _sendEventToWorker(data) {
      return this._worker.postMessage("addEvent", data);
    }
    /**
     * Finish the request and return the compressed data from the worker.
     */
    async _finishRequest() {
      const response = await this._worker.postMessage("finish");
      this._earliestTimestamp = null;
      this._totalSize = 0;
      return response;
    }
  };
  var EventBufferProxy = class {
    constructor(worker) {
      this._fallback = new EventBufferArray();
      this._compression = new EventBufferCompressionWorker(worker);
      this._used = this._fallback;
      this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();
    }
    /** @inheritdoc */
    get type() {
      return this._used.type;
    }
    /** @inheritDoc */
    get hasEvents() {
      return this._used.hasEvents;
    }
    /** @inheritdoc */
    get hasCheckout() {
      return this._used.hasCheckout;
    }
    /** @inheritdoc */
    set hasCheckout(value) {
      this._used.hasCheckout = value;
    }
    /** @inheritDoc */
    destroy() {
      this._fallback.destroy();
      this._compression.destroy();
    }
    /** @inheritdoc */
    clear() {
      return this._used.clear();
    }
    /** @inheritdoc */
    getEarliestTimestamp() {
      return this._used.getEarliestTimestamp();
    }
    /**
     * Add an event to the event buffer.
     *
     * Returns true if event was successfully added.
     */
    addEvent(event) {
      return this._used.addEvent(event);
    }
    /** @inheritDoc */
    async finish() {
      await this.ensureWorkerIsLoaded();
      return this._used.finish();
    }
    /** Ensure the worker has loaded. */
    ensureWorkerIsLoaded() {
      return this._ensureWorkerIsLoadedPromise;
    }
    /** Actually check if the worker has been loaded. */
    async _ensureWorkerIsLoaded() {
      try {
        await this._compression.ensureReady();
      } catch (error2) {
        logInfo("[Replay] Failed to load the compression worker, falling back to simple buffer");
        return;
      }
      await this._switchToCompressionWorker();
    }
    /** Switch the used buffer to the compression worker. */
    async _switchToCompressionWorker() {
      const { events, hasCheckout } = this._fallback;
      const addEventPromises = [];
      for (const event of events) {
        addEventPromises.push(this._compression.addEvent(event));
      }
      this._compression.hasCheckout = hasCheckout;
      this._used = this._compression;
      try {
        await Promise.all(addEventPromises);
      } catch (error2) {
        DEBUG_BUILD5 && logger.warn("[Replay] Failed to add events when switching buffers.", error2);
      }
    }
  };
  function createEventBuffer({
    useCompression,
    workerUrl: customWorkerUrl
  }) {
    if (useCompression && // eslint-disable-next-line no-restricted-globals
    window.Worker) {
      const worker = _loadWorker(customWorkerUrl);
      if (worker) {
        return worker;
      }
    }
    logInfo("[Replay] Using simple buffer");
    return new EventBufferArray();
  }
  function _loadWorker(customWorkerUrl) {
    try {
      const workerUrl = customWorkerUrl || _getWorkerUrl();
      if (!workerUrl) {
        return;
      }
      logInfo(`[Replay] Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : ""}`);
      const worker = new Worker(workerUrl);
      return new EventBufferProxy(worker);
    } catch (error2) {
      logInfo("[Replay] Failed to create compression worker");
    }
  }
  function _getWorkerUrl() {
    if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === "undefined" || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {
      return e();
    }
    return "";
  }
  function hasSessionStorage() {
    try {
      return "sessionStorage" in WINDOW9 && !!WINDOW9.sessionStorage;
    } catch (e3) {
      return false;
    }
  }
  function clearSession(replay) {
    deleteSession();
    replay.session = void 0;
  }
  function deleteSession() {
    if (!hasSessionStorage()) {
      return;
    }
    try {
      WINDOW9.sessionStorage.removeItem(REPLAY_SESSION_KEY);
    } catch (e3) {
    }
  }
  function isSampled(sampleRate) {
    if (sampleRate === void 0) {
      return false;
    }
    return Math.random() < sampleRate;
  }
  function makeSession2(session) {
    const now3 = Date.now();
    const id3 = session.id || uuid4();
    const started = session.started || now3;
    const lastActivity = session.lastActivity || now3;
    const segmentId = session.segmentId || 0;
    const sampled = session.sampled;
    const previousSessionId = session.previousSessionId;
    return {
      id: id3,
      started,
      lastActivity,
      segmentId,
      sampled,
      previousSessionId
    };
  }
  function saveSession(session) {
    if (!hasSessionStorage()) {
      return;
    }
    try {
      WINDOW9.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));
    } catch (e3) {
    }
  }
  function getSessionSampleType(sessionSampleRate, allowBuffering) {
    return isSampled(sessionSampleRate) ? "session" : allowBuffering ? "buffer" : false;
  }
  function createSession({ sessionSampleRate, allowBuffering, stickySession = false }, { previousSessionId } = {}) {
    const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);
    const session = makeSession2({
      sampled,
      previousSessionId
    });
    if (stickySession) {
      saveSession(session);
    }
    return session;
  }
  function fetchSession(traceInternals) {
    if (!hasSessionStorage()) {
      return null;
    }
    try {
      const sessionStringFromStorage = WINDOW9.sessionStorage.getItem(REPLAY_SESSION_KEY);
      if (!sessionStringFromStorage) {
        return null;
      }
      const sessionObj = JSON.parse(sessionStringFromStorage);
      logInfoNextTick("[Replay] Loading existing session", traceInternals);
      return makeSession2(sessionObj);
    } catch (e3) {
      return null;
    }
  }
  function isExpired(initialTime, expiry, targetTime = +/* @__PURE__ */ new Date()) {
    if (initialTime === null || expiry === void 0 || expiry < 0) {
      return true;
    }
    if (expiry === 0) {
      return false;
    }
    return initialTime + expiry <= targetTime;
  }
  function isSessionExpired(session, {
    maxReplayDuration,
    sessionIdleExpire,
    targetTime = Date.now()
  }) {
    return (
      // First, check that maximum session length has not been exceeded
      isExpired(session.started, maxReplayDuration, targetTime) || // check that the idle timeout has not been exceeded (i.e. user has
      // performed an action within the last `sessionIdleExpire` ms)
      isExpired(session.lastActivity, sessionIdleExpire, targetTime)
    );
  }
  function shouldRefreshSession(session, { sessionIdleExpire, maxReplayDuration }) {
    if (!isSessionExpired(session, { sessionIdleExpire, maxReplayDuration })) {
      return false;
    }
    if (session.sampled === "buffer" && session.segmentId === 0) {
      return false;
    }
    return true;
  }
  function loadOrCreateSession({
    traceInternals,
    sessionIdleExpire,
    maxReplayDuration,
    previousSessionId
  }, sessionOptions) {
    const existingSession = sessionOptions.stickySession && fetchSession(traceInternals);
    if (!existingSession) {
      logInfoNextTick("[Replay] Creating new session", traceInternals);
      return createSession(sessionOptions, { previousSessionId });
    }
    if (!shouldRefreshSession(existingSession, { sessionIdleExpire, maxReplayDuration })) {
      return existingSession;
    }
    logInfoNextTick("[Replay] Session in sessionStorage is expired, creating new one...");
    return createSession(sessionOptions, { previousSessionId: existingSession.id });
  }
  function isCustomEvent(event) {
    return event.type === EventType.Custom;
  }
  function addEventSync(replay, event, isCheckout) {
    if (!shouldAddEvent(replay, event)) {
      return false;
    }
    _addEvent(replay, event, isCheckout);
    return true;
  }
  function addEvent(replay, event, isCheckout) {
    if (!shouldAddEvent(replay, event)) {
      return Promise.resolve(null);
    }
    return _addEvent(replay, event, isCheckout);
  }
  async function _addEvent(replay, event, isCheckout) {
    if (!replay.eventBuffer) {
      return null;
    }
    try {
      if (isCheckout && replay.recordingMode === "buffer") {
        replay.eventBuffer.clear();
      }
      if (isCheckout) {
        replay.eventBuffer.hasCheckout = true;
      }
      const replayOptions = replay.getOptions();
      const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);
      if (!eventAfterPossibleCallback) {
        return;
      }
      return await replay.eventBuffer.addEvent(eventAfterPossibleCallback);
    } catch (error2) {
      const reason = error2 && error2 instanceof EventBufferSizeExceededError ? "addEventSizeExceeded" : "addEvent";
      DEBUG_BUILD5 && logger.error(error2);
      await replay.stop({ reason });
      const client = getClient();
      if (client) {
        client.recordDroppedEvent("internal_sdk_error", "replay");
      }
    }
  }
  function shouldAddEvent(replay, event) {
    if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {
      return false;
    }
    const timestampInMs = timestampToMs(event.timestamp);
    if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {
      return false;
    }
    if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {
      logInfo(
        `[Replay] Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`,
        replay.getOptions()._experiments.traceInternals
      );
      return false;
    }
    return true;
  }
  function maybeApplyCallback(event, callback) {
    try {
      if (typeof callback === "function" && isCustomEvent(event)) {
        return callback(event);
      }
    } catch (error2) {
      DEBUG_BUILD5 && logger.error("[Replay] An error occured in the `beforeAddRecordingEvent` callback, skipping the event...", error2);
      return null;
    }
    return event;
  }
  function isErrorEvent3(event) {
    return !event.type;
  }
  function isTransactionEvent2(event) {
    return event.type === "transaction";
  }
  function isReplayEvent(event) {
    return event.type === "replay_event";
  }
  function isFeedbackEvent(event) {
    return event.type === "feedback";
  }
  function handleAfterSendEvent(replay) {
    const enforceStatusCode = isBaseTransportSend();
    return (event, sendResponse) => {
      if (!replay.isEnabled() || !isErrorEvent3(event) && !isTransactionEvent2(event)) {
        return;
      }
      const statusCode = sendResponse && sendResponse.statusCode;
      if (enforceStatusCode && (!statusCode || statusCode < 200 || statusCode >= 300)) {
        return;
      }
      if (isTransactionEvent2(event)) {
        handleTransactionEvent(replay, event);
        return;
      }
      handleErrorEvent(replay, event);
    };
  }
  function handleTransactionEvent(replay, event) {
    const replayContext = replay.getContext();
    if (event.contexts && event.contexts.trace && event.contexts.trace.trace_id && replayContext.traceIds.size < 100) {
      replayContext.traceIds.add(event.contexts.trace.trace_id);
    }
  }
  function handleErrorEvent(replay, event) {
    const replayContext = replay.getContext();
    if (event.event_id && replayContext.errorIds.size < 100) {
      replayContext.errorIds.add(event.event_id);
    }
    if (replay.recordingMode !== "buffer" || !event.tags || !event.tags.replayId) {
      return;
    }
    const { beforeErrorSampling } = replay.getOptions();
    if (typeof beforeErrorSampling === "function" && !beforeErrorSampling(event)) {
      return;
    }
    setTimeout(() => {
      replay.sendBufferedReplayOrFlush();
    });
  }
  function isBaseTransportSend() {
    const client = getClient();
    if (!client) {
      return false;
    }
    const transport = client.getTransport();
    if (!transport) {
      return false;
    }
    return transport.send.__sentry__baseTransport__ || false;
  }
  function handleBeforeSendEvent(replay) {
    return (event) => {
      if (!replay.isEnabled() || !isErrorEvent3(event)) {
        return;
      }
      handleHydrationError(replay, event);
    };
  }
  function handleHydrationError(replay, event) {
    const exceptionValue = event.exception && event.exception.values && event.exception.values[0].value;
    if (typeof exceptionValue !== "string") {
      return;
    }
    if (
      // Only matches errors in production builds of react-dom
      // Example https://reactjs.org/docs/error-decoder.html?invariant=423
      exceptionValue.match(/reactjs\.org\/docs\/error-decoder\.html\?invariant=(418|419|422|423|425)/) || // Development builds of react-dom
      // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.
      // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.
      exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)
    ) {
      const breadcrumb = createBreadcrumb({
        category: "replay.hydrate-error"
      });
      addBreadcrumbEvent(replay, breadcrumb);
    }
  }
  function isRrwebError(event, hint) {
    if (event.type || !event.exception || !event.exception.values || !event.exception.values.length) {
      return false;
    }
    if (hint.originalException && hint.originalException.__rrweb__) {
      return true;
    }
    return false;
  }
  function addFeedbackBreadcrumb(replay, event) {
    replay.triggerUserActivity();
    replay.addUpdate(() => {
      if (!event.timestamp) {
        return true;
      }
      replay.throttledAddEvent({
        type: EventType.Custom,
        timestamp: event.timestamp * 1e3,
        data: {
          tag: "breadcrumb",
          payload: {
            timestamp: event.timestamp,
            type: "default",
            category: "sentry.feedback",
            data: {
              feedbackId: event.event_id
            }
          }
        }
      });
      return false;
    });
  }
  function shouldSampleForBufferEvent(replay, event) {
    if (replay.recordingMode !== "buffer") {
      return false;
    }
    if (event.message === UNABLE_TO_SEND_REPLAY) {
      return false;
    }
    if (!event.exception || event.type) {
      return false;
    }
    return isSampled(replay.getOptions().errorSampleRate);
  }
  function handleGlobalEventListener(replay, includeAfterSendEventHandling = false) {
    const afterSendHandler = includeAfterSendEventHandling ? handleAfterSendEvent(replay) : void 0;
    return Object.assign(
      (event, hint) => {
        if (!replay.isEnabled()) {
          return event;
        }
        if (isReplayEvent(event)) {
          delete event.breadcrumbs;
          return event;
        }
        if (!isErrorEvent3(event) && !isTransactionEvent2(event) && !isFeedbackEvent(event)) {
          return event;
        }
        const isSessionActive = replay.checkAndHandleExpiredSession();
        if (!isSessionActive) {
          return event;
        }
        if (isFeedbackEvent(event)) {
          replay.flush();
          event.contexts.feedback.replay_id = replay.getSessionId();
          addFeedbackBreadcrumb(replay, event);
          return event;
        }
        if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {
          DEBUG_BUILD5 && logger.log("[Replay] Ignoring error from rrweb internals", event);
          return null;
        }
        const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);
        const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === "session";
        if (shouldTagReplayId) {
          event.tags = { ...event.tags, replayId: replay.getSessionId() };
        }
        if (afterSendHandler) {
          afterSendHandler(event, { statusCode: 200 });
        }
        return event;
      },
      { id: "Replay" }
    );
  }
  function createPerformanceSpans(replay, entries) {
    return entries.map(({ type, start: start2, end: end2, name, data }) => {
      const response = replay.throttledAddEvent({
        type: EventType.Custom,
        timestamp: start2,
        data: {
          tag: "performanceSpan",
          payload: {
            op: type,
            description: name,
            startTimestamp: start2,
            endTimestamp: end2,
            data
          }
        }
      });
      return typeof response === "string" ? Promise.resolve(null) : response;
    });
  }
  function handleHistory(handlerData) {
    const { from: from2, to } = handlerData;
    const now3 = Date.now() / 1e3;
    return {
      type: "navigation.push",
      start: now3,
      end: now3,
      name: to,
      data: {
        previous: from2
      }
    };
  }
  function handleHistorySpanListener(replay) {
    return (handlerData) => {
      if (!replay.isEnabled()) {
        return;
      }
      const result = handleHistory(handlerData);
      if (result === null) {
        return;
      }
      replay.getContext().urls.push(result.name);
      replay.triggerUserActivity();
      replay.addUpdate(() => {
        createPerformanceSpans(replay, [result]);
        return false;
      });
    };
  }
  function shouldFilterRequest(replay, url) {
    if (DEBUG_BUILD5 && replay.getOptions()._experiments.traceInternals) {
      return false;
    }
    return isSentryRequestUrl(url, getClient());
  }
  function addNetworkBreadcrumb(replay, result) {
    if (!replay.isEnabled()) {
      return;
    }
    if (result === null) {
      return;
    }
    if (shouldFilterRequest(replay, result.name)) {
      return;
    }
    replay.addUpdate(() => {
      createPerformanceSpans(replay, [result]);
      return true;
    });
  }
  function handleFetch(handlerData) {
    const { startTimestamp, endTimestamp, fetchData, response } = handlerData;
    if (!endTimestamp) {
      return null;
    }
    const { method, url } = fetchData;
    return {
      type: "resource.fetch",
      start: startTimestamp / 1e3,
      end: endTimestamp / 1e3,
      name: url,
      data: {
        method,
        statusCode: response ? response.status : void 0
      }
    };
  }
  function handleFetchSpanListener(replay) {
    return (handlerData) => {
      if (!replay.isEnabled()) {
        return;
      }
      const result = handleFetch(handlerData);
      addNetworkBreadcrumb(replay, result);
    };
  }
  function handleXhr(handlerData) {
    const { startTimestamp, endTimestamp, xhr } = handlerData;
    const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];
    if (!startTimestamp || !endTimestamp || !sentryXhrData) {
      return null;
    }
    const { method, url, status_code: statusCode } = sentryXhrData;
    if (url === void 0) {
      return null;
    }
    return {
      type: "resource.xhr",
      name: url,
      start: startTimestamp / 1e3,
      end: endTimestamp / 1e3,
      data: {
        method,
        statusCode
      }
    };
  }
  function handleXhrSpanListener(replay) {
    return (handlerData) => {
      if (!replay.isEnabled()) {
        return;
      }
      const result = handleXhr(handlerData);
      addNetworkBreadcrumb(replay, result);
    };
  }
  function getBodySize(body, textEncoder) {
    if (!body) {
      return void 0;
    }
    try {
      if (typeof body === "string") {
        return textEncoder.encode(body).length;
      }
      if (body instanceof URLSearchParams) {
        return textEncoder.encode(body.toString()).length;
      }
      if (body instanceof FormData) {
        const formDataStr = _serializeFormData(body);
        return textEncoder.encode(formDataStr).length;
      }
      if (body instanceof Blob) {
        return body.size;
      }
      if (body instanceof ArrayBuffer) {
        return body.byteLength;
      }
    } catch (e3) {
    }
    return void 0;
  }
  function parseContentLengthHeader(header) {
    if (!header) {
      return void 0;
    }
    const size2 = parseInt(header, 10);
    return isNaN(size2) ? void 0 : size2;
  }
  function getBodyString(body) {
    try {
      if (typeof body === "string") {
        return [body];
      }
      if (body instanceof URLSearchParams) {
        return [body.toString()];
      }
      if (body instanceof FormData) {
        return [_serializeFormData(body)];
      }
      if (!body) {
        return [void 0];
      }
    } catch (e22) {
      DEBUG_BUILD5 && logger.warn("[Replay] Failed to serialize body", body);
      return [void 0, "BODY_PARSE_ERROR"];
    }
    DEBUG_BUILD5 && logger.info("[Replay] Skipping network body because of body type", body);
    return [void 0, "UNPARSEABLE_BODY_TYPE"];
  }
  function mergeWarning(info, warning2) {
    if (!info) {
      return {
        headers: {},
        size: void 0,
        _meta: {
          warnings: [warning2]
        }
      };
    }
    const newMeta = { ...info._meta };
    const existingWarnings = newMeta.warnings || [];
    newMeta.warnings = [...existingWarnings, warning2];
    info._meta = newMeta;
    return info;
  }
  function makeNetworkReplayBreadcrumb(type, data) {
    if (!data) {
      return null;
    }
    const { startTimestamp, endTimestamp, url, method, statusCode, request, response } = data;
    const result = {
      type,
      start: startTimestamp / 1e3,
      end: endTimestamp / 1e3,
      name: url,
      data: dropUndefinedKeys({
        method,
        statusCode,
        request,
        response
      })
    };
    return result;
  }
  function buildSkippedNetworkRequestOrResponse(bodySize) {
    return {
      headers: {},
      size: bodySize,
      _meta: {
        warnings: ["URL_SKIPPED"]
      }
    };
  }
  function buildNetworkRequestOrResponse(headers, bodySize, body) {
    if (!bodySize && Object.keys(headers).length === 0) {
      return void 0;
    }
    if (!bodySize) {
      return {
        headers
      };
    }
    if (!body) {
      return {
        headers,
        size: bodySize
      };
    }
    const info = {
      headers,
      size: bodySize
    };
    const { body: normalizedBody, warnings } = normalizeNetworkBody(body);
    info.body = normalizedBody;
    if (warnings && warnings.length > 0) {
      info._meta = {
        warnings
      };
    }
    return info;
  }
  function getAllowedHeaders(headers, allowedHeaders) {
    return Object.keys(headers).reduce((filteredHeaders, key) => {
      const normalizedKey = key.toLowerCase();
      if (allowedHeaders.includes(normalizedKey) && headers[key]) {
        filteredHeaders[normalizedKey] = headers[key];
      }
      return filteredHeaders;
    }, {});
  }
  function _serializeFormData(formData) {
    return new URLSearchParams(formData).toString();
  }
  function normalizeNetworkBody(body) {
    if (!body || typeof body !== "string") {
      return {
        body
      };
    }
    const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;
    const isProbablyJson = _strIsProbablyJson(body);
    if (exceedsSizeLimit) {
      const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);
      if (isProbablyJson) {
        return {
          body: truncatedBody,
          warnings: ["MAYBE_JSON_TRUNCATED"]
        };
      }
      return {
        body: `${truncatedBody}\u2026`,
        warnings: ["TEXT_TRUNCATED"]
      };
    }
    if (isProbablyJson) {
      try {
        const jsonBody = JSON.parse(body);
        return {
          body: jsonBody
        };
      } catch (e3) {
      }
    }
    return {
      body
    };
  }
  function _strIsProbablyJson(str) {
    const first = str[0];
    const last = str[str.length - 1];
    return first === "[" && last === "]" || first === "{" && last === "}";
  }
  function urlMatches(url, urls) {
    const fullUrl = getFullUrl(url);
    return stringMatchesSomePattern(fullUrl, urls);
  }
  function getFullUrl(url, baseURI = WINDOW9.document.baseURI) {
    if (url.startsWith("http://") || url.startsWith("https://") || url.startsWith(WINDOW9.location.origin)) {
      return url;
    }
    const fixedUrl = new URL(url, baseURI);
    if (fixedUrl.origin !== new URL(baseURI).origin) {
      return url;
    }
    const fullUrl = fixedUrl.href;
    if (!url.endsWith("/") && fullUrl.endsWith("/")) {
      return fullUrl.slice(0, -1);
    }
    return fullUrl;
  }
  async function captureFetchBreadcrumbToReplay(breadcrumb, hint, options) {
    try {
      const data = await _prepareFetchData(breadcrumb, hint, options);
      const result = makeNetworkReplayBreadcrumb("resource.fetch", data);
      addNetworkBreadcrumb(options.replay, result);
    } catch (error2) {
      DEBUG_BUILD5 && logger.error("[Replay] Failed to capture fetch breadcrumb", error2);
    }
  }
  function enrichFetchBreadcrumb(breadcrumb, hint, options) {
    const { input, response } = hint;
    const body = input ? _getFetchRequestArgBody(input) : void 0;
    const reqSize = getBodySize(body, options.textEncoder);
    const resSize = response ? parseContentLengthHeader(response.headers.get("content-length")) : void 0;
    if (reqSize !== void 0) {
      breadcrumb.data.request_body_size = reqSize;
    }
    if (resSize !== void 0) {
      breadcrumb.data.response_body_size = resSize;
    }
  }
  async function _prepareFetchData(breadcrumb, hint, options) {
    const now3 = Date.now();
    const { startTimestamp = now3, endTimestamp = now3 } = hint;
    const {
      url,
      method,
      status_code: statusCode = 0,
      request_body_size: requestBodySize,
      response_body_size: responseBodySize
    } = breadcrumb.data;
    const captureDetails = urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);
    const request = captureDetails ? _getRequestInfo(options, hint.input, requestBodySize) : buildSkippedNetworkRequestOrResponse(requestBodySize);
    const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);
    return {
      startTimestamp,
      endTimestamp,
      url,
      method,
      statusCode,
      request,
      response
    };
  }
  function _getRequestInfo({ networkCaptureBodies, networkRequestHeaders }, input, requestBodySize) {
    const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};
    if (!networkCaptureBodies) {
      return buildNetworkRequestOrResponse(headers, requestBodySize, void 0);
    }
    const requestBody = _getFetchRequestArgBody(input);
    const [bodyStr, warning2] = getBodyString(requestBody);
    const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);
    if (warning2) {
      return mergeWarning(data, warning2);
    }
    return data;
  }
  async function _getResponseInfo(captureDetails, {
    networkCaptureBodies,
    textEncoder,
    networkResponseHeaders
  }, response, responseBodySize) {
    if (!captureDetails && responseBodySize !== void 0) {
      return buildSkippedNetworkRequestOrResponse(responseBodySize);
    }
    const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};
    if (!response || !networkCaptureBodies && responseBodySize !== void 0) {
      return buildNetworkRequestOrResponse(headers, responseBodySize, void 0);
    }
    const [bodyText, warning2] = await _parseFetchResponseBody(response);
    const result = getResponseData(bodyText, {
      networkCaptureBodies,
      textEncoder,
      responseBodySize,
      captureDetails,
      headers
    });
    if (warning2) {
      return mergeWarning(result, warning2);
    }
    return result;
  }
  function getResponseData(bodyText, {
    networkCaptureBodies,
    textEncoder,
    responseBodySize,
    captureDetails,
    headers
  }) {
    try {
      const size2 = bodyText && bodyText.length && responseBodySize === void 0 ? getBodySize(bodyText, textEncoder) : responseBodySize;
      if (!captureDetails) {
        return buildSkippedNetworkRequestOrResponse(size2);
      }
      if (networkCaptureBodies) {
        return buildNetworkRequestOrResponse(headers, size2, bodyText);
      }
      return buildNetworkRequestOrResponse(headers, size2, void 0);
    } catch (error2) {
      DEBUG_BUILD5 && logger.warn("[Replay] Failed to serialize response body", error2);
      return buildNetworkRequestOrResponse(headers, responseBodySize, void 0);
    }
  }
  async function _parseFetchResponseBody(response) {
    const res = _tryCloneResponse(response);
    if (!res) {
      return [void 0, "BODY_PARSE_ERROR"];
    }
    try {
      const text = await _tryGetResponseText(res);
      return [text];
    } catch (error2) {
      DEBUG_BUILD5 && logger.warn("[Replay] Failed to get text body from response", error2);
      return [void 0, "BODY_PARSE_ERROR"];
    }
  }
  function _getFetchRequestArgBody(fetchArgs = []) {
    if (fetchArgs.length !== 2 || typeof fetchArgs[1] !== "object") {
      return void 0;
    }
    return fetchArgs[1].body;
  }
  function getAllHeaders(headers, allowedHeaders) {
    const allHeaders = {};
    allowedHeaders.forEach((header) => {
      if (headers.get(header)) {
        allHeaders[header] = headers.get(header);
      }
    });
    return allHeaders;
  }
  function getRequestHeaders(fetchArgs, allowedHeaders) {
    if (fetchArgs.length === 1 && typeof fetchArgs[0] !== "string") {
      return getHeadersFromOptions(fetchArgs[0], allowedHeaders);
    }
    if (fetchArgs.length === 2) {
      return getHeadersFromOptions(fetchArgs[1], allowedHeaders);
    }
    return {};
  }
  function getHeadersFromOptions(input, allowedHeaders) {
    if (!input) {
      return {};
    }
    const headers = input.headers;
    if (!headers) {
      return {};
    }
    if (headers instanceof Headers) {
      return getAllHeaders(headers, allowedHeaders);
    }
    if (Array.isArray(headers)) {
      return {};
    }
    return getAllowedHeaders(headers, allowedHeaders);
  }
  function _tryCloneResponse(response) {
    try {
      return response.clone();
    } catch (error2) {
      DEBUG_BUILD5 && logger.warn("[Replay] Failed to clone response body", error2);
    }
  }
  function _tryGetResponseText(response) {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error("Timeout while trying to read response body")), 500);
      _getResponseText(response).then(
        (txt) => resolve(txt),
        (reason) => reject(reason)
      ).finally(() => clearTimeout(timeout));
    });
  }
  async function _getResponseText(response) {
    return await response.text();
  }
  async function captureXhrBreadcrumbToReplay(breadcrumb, hint, options) {
    try {
      const data = _prepareXhrData(breadcrumb, hint, options);
      const result = makeNetworkReplayBreadcrumb("resource.xhr", data);
      addNetworkBreadcrumb(options.replay, result);
    } catch (error2) {
      DEBUG_BUILD5 && logger.error("[Replay] Failed to capture xhr breadcrumb", error2);
    }
  }
  function enrichXhrBreadcrumb(breadcrumb, hint, options) {
    const { xhr, input } = hint;
    if (!xhr) {
      return;
    }
    const reqSize = getBodySize(input, options.textEncoder);
    const resSize = xhr.getResponseHeader("content-length") ? parseContentLengthHeader(xhr.getResponseHeader("content-length")) : _getBodySize(xhr.response, xhr.responseType, options.textEncoder);
    if (reqSize !== void 0) {
      breadcrumb.data.request_body_size = reqSize;
    }
    if (resSize !== void 0) {
      breadcrumb.data.response_body_size = resSize;
    }
  }
  function _prepareXhrData(breadcrumb, hint, options) {
    const now3 = Date.now();
    const { startTimestamp = now3, endTimestamp = now3, input, xhr } = hint;
    const {
      url,
      method,
      status_code: statusCode = 0,
      request_body_size: requestBodySize,
      response_body_size: responseBodySize
    } = breadcrumb.data;
    if (!url) {
      return null;
    }
    if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {
      const request2 = buildSkippedNetworkRequestOrResponse(requestBodySize);
      const response2 = buildSkippedNetworkRequestOrResponse(responseBodySize);
      return {
        startTimestamp,
        endTimestamp,
        url,
        method,
        statusCode,
        request: request2,
        response: response2
      };
    }
    const xhrInfo = xhr[SENTRY_XHR_DATA_KEY];
    const networkRequestHeaders = xhrInfo ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders) : {};
    const networkResponseHeaders = getAllowedHeaders(getResponseHeaders(xhr), options.networkResponseHeaders);
    const [requestBody, requestWarning] = options.networkCaptureBodies ? getBodyString(input) : [void 0];
    const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [void 0];
    const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);
    const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);
    return {
      startTimestamp,
      endTimestamp,
      url,
      method,
      statusCode,
      request: requestWarning ? mergeWarning(request, requestWarning) : request,
      response: responseWarning ? mergeWarning(response, responseWarning) : response
    };
  }
  function getResponseHeaders(xhr) {
    const headers = xhr.getAllResponseHeaders();
    if (!headers) {
      return {};
    }
    return headers.split("\r\n").reduce((acc, line3) => {
      const [key, value] = line3.split(": ");
      acc[key.toLowerCase()] = value;
      return acc;
    }, {});
  }
  function _getXhrResponseBody(xhr) {
    const errors = [];
    try {
      return [xhr.responseText];
    } catch (e3) {
      errors.push(e3);
    }
    try {
      return _parseXhrResponse(xhr.response, xhr.responseType);
    } catch (e3) {
      errors.push(e3);
    }
    DEBUG_BUILD5 && logger.warn("[Replay] Failed to get xhr response body", ...errors);
    return [void 0];
  }
  function _parseXhrResponse(body, responseType) {
    try {
      if (typeof body === "string") {
        return [body];
      }
      if (body instanceof Document) {
        return [body.body.outerHTML];
      }
      if (responseType === "json" && body && typeof body === "object") {
        return [JSON.stringify(body)];
      }
      if (!body) {
        return [void 0];
      }
    } catch (e22) {
      DEBUG_BUILD5 && logger.warn("[Replay] Failed to serialize body", body);
      return [void 0, "BODY_PARSE_ERROR"];
    }
    DEBUG_BUILD5 && logger.info("[Replay] Skipping network body because of body type", body);
    return [void 0, "UNPARSEABLE_BODY_TYPE"];
  }
  function _getBodySize(body, responseType, textEncoder) {
    try {
      const bodyStr = responseType === "json" && body && typeof body === "object" ? JSON.stringify(body) : body;
      return getBodySize(bodyStr, textEncoder);
    } catch (e3) {
      return void 0;
    }
  }
  function handleNetworkBreadcrumbs(replay) {
    const client = getClient();
    try {
      const textEncoder = new TextEncoder();
      const {
        networkDetailAllowUrls,
        networkDetailDenyUrls,
        networkCaptureBodies,
        networkRequestHeaders,
        networkResponseHeaders
      } = replay.getOptions();
      const options = {
        replay,
        textEncoder,
        networkDetailAllowUrls,
        networkDetailDenyUrls,
        networkCaptureBodies,
        networkRequestHeaders,
        networkResponseHeaders
      };
      if (client && client.on) {
        client.on("beforeAddBreadcrumb", (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));
      } else {
        addFetchInstrumentationHandler(handleFetchSpanListener(replay));
        addXhrInstrumentationHandler(handleXhrSpanListener(replay));
      }
    } catch (e22) {
    }
  }
  function beforeAddNetworkBreadcrumb(options, breadcrumb, hint) {
    if (!breadcrumb.data) {
      return;
    }
    try {
      if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {
        enrichXhrBreadcrumb(breadcrumb, hint, options);
        captureXhrBreadcrumbToReplay(breadcrumb, hint, options);
      }
      if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {
        enrichFetchBreadcrumb(breadcrumb, hint, options);
        captureFetchBreadcrumbToReplay(breadcrumb, hint, options);
      }
    } catch (e3) {
      DEBUG_BUILD5 && logger.warn("Error when enriching network breadcrumb");
    }
  }
  function _isXhrBreadcrumb(breadcrumb) {
    return breadcrumb.category === "xhr";
  }
  function _isFetchBreadcrumb(breadcrumb) {
    return breadcrumb.category === "fetch";
  }
  function _isXhrHint(hint) {
    return hint && hint.xhr;
  }
  function _isFetchHint(hint) {
    return hint && hint.response;
  }
  var _LAST_BREADCRUMB = null;
  function isBreadcrumbWithCategory(breadcrumb) {
    return !!breadcrumb.category;
  }
  var handleScopeListener = (replay) => (scope) => {
    if (!replay.isEnabled()) {
      return;
    }
    const result = handleScope(scope);
    if (!result) {
      return;
    }
    addBreadcrumbEvent(replay, result);
  };
  function handleScope(scope) {
    const newBreadcrumb = scope.getLastBreadcrumb && scope.getLastBreadcrumb();
    if (_LAST_BREADCRUMB === newBreadcrumb || !newBreadcrumb) {
      return null;
    }
    _LAST_BREADCRUMB = newBreadcrumb;
    if (!isBreadcrumbWithCategory(newBreadcrumb) || ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(newBreadcrumb.category) || newBreadcrumb.category.startsWith("ui.")) {
      return null;
    }
    if (newBreadcrumb.category === "console") {
      return normalizeConsoleBreadcrumb(newBreadcrumb);
    }
    return createBreadcrumb(newBreadcrumb);
  }
  function normalizeConsoleBreadcrumb(breadcrumb) {
    const args = breadcrumb.data && breadcrumb.data.arguments;
    if (!Array.isArray(args) || args.length === 0) {
      return createBreadcrumb(breadcrumb);
    }
    let isTruncated = false;
    const normalizedArgs = args.map((arg) => {
      if (!arg) {
        return arg;
      }
      if (typeof arg === "string") {
        if (arg.length > CONSOLE_ARG_MAX_SIZE) {
          isTruncated = true;
          return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}\u2026`;
        }
        return arg;
      }
      if (typeof arg === "object") {
        try {
          const normalizedArg = normalize4(arg, 7);
          const stringified = JSON.stringify(normalizedArg);
          if (stringified.length > CONSOLE_ARG_MAX_SIZE) {
            isTruncated = true;
            return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}\u2026`;
          }
          return normalizedArg;
        } catch (e3) {
        }
      }
      return arg;
    });
    return createBreadcrumb({
      ...breadcrumb,
      data: {
        ...breadcrumb.data,
        arguments: normalizedArgs,
        ...isTruncated ? { _meta: { warnings: ["CONSOLE_ARG_TRUNCATED"] } } : {}
      }
    });
  }
  function addGlobalListeners(replay) {
    const scope = getCurrentScope();
    const client = getClient();
    scope.addScopeListener(handleScopeListener(replay));
    addClickKeypressInstrumentationHandler(handleDomListener(replay));
    addHistoryInstrumentationHandler(handleHistorySpanListener(replay));
    handleNetworkBreadcrumbs(replay);
    const eventProcessor = handleGlobalEventListener(replay, !hasHooks(client));
    if (client && client.addEventProcessor) {
      client.addEventProcessor(eventProcessor);
    } else {
      addEventProcessor(eventProcessor);
    }
    if (hasHooks(client)) {
      client.on("beforeSendEvent", handleBeforeSendEvent(replay));
      client.on("afterSendEvent", handleAfterSendEvent(replay));
      client.on("createDsc", (dsc) => {
        const replayId = replay.getSessionId();
        if (replayId && replay.isEnabled() && replay.recordingMode === "session") {
          const isSessionActive = replay.checkAndHandleExpiredSession();
          if (isSessionActive) {
            dsc.replay_id = replayId;
          }
        }
      });
      client.on("startTransaction", (transaction) => {
        replay.lastTransaction = transaction;
      });
      client.on("finishTransaction", (transaction) => {
        replay.lastTransaction = transaction;
      });
      client.on("beforeSendFeedback", (feedbackEvent, options) => {
        const replayId = replay.getSessionId();
        if (options && options.includeReplay && replay.isEnabled() && replayId) {
          if (feedbackEvent.contexts && feedbackEvent.contexts.feedback) {
            feedbackEvent.contexts.feedback.replay_id = replayId;
          }
        }
      });
    }
  }
  function hasHooks(client) {
    return !!(client && client.on);
  }
  async function addMemoryEntry(replay) {
    try {
      return Promise.all(
        createPerformanceSpans(replay, [
          // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)
          createMemoryEntry(WINDOW9.performance.memory)
        ])
      );
    } catch (error2) {
      return [];
    }
  }
  function createMemoryEntry(memoryEntry) {
    const { jsHeapSizeLimit, totalJSHeapSize, usedJSHeapSize } = memoryEntry;
    const time2 = Date.now() / 1e3;
    return {
      type: "memory",
      name: "memory",
      start: time2,
      end: time2,
      data: {
        memory: {
          jsHeapSizeLimit,
          totalJSHeapSize,
          usedJSHeapSize
        }
      }
    };
  }
  function debounce2(func, wait, options) {
    let callbackReturnValue;
    let timerId;
    let maxTimerId;
    const maxWait = options && options.maxWait ? Math.max(options.maxWait, wait) : 0;
    function invokeFunc() {
      cancelTimers();
      callbackReturnValue = func();
      return callbackReturnValue;
    }
    function cancelTimers() {
      timerId !== void 0 && clearTimeout(timerId);
      maxTimerId !== void 0 && clearTimeout(maxTimerId);
      timerId = maxTimerId = void 0;
    }
    function flush2() {
      if (timerId !== void 0 || maxTimerId !== void 0) {
        return invokeFunc();
      }
      return callbackReturnValue;
    }
    function debounced() {
      if (timerId) {
        clearTimeout(timerId);
      }
      timerId = setTimeout(invokeFunc, wait);
      if (maxWait && maxTimerId === void 0) {
        maxTimerId = setTimeout(invokeFunc, maxWait);
      }
      return callbackReturnValue;
    }
    debounced.cancel = cancelTimers;
    debounced.flush = flush2;
    return debounced;
  }
  function getHandleRecordingEmit(replay) {
    let hadFirstEvent = false;
    return (event, _isCheckout) => {
      if (!replay.checkAndHandleExpiredSession()) {
        DEBUG_BUILD5 && logger.warn("[Replay] Received replay event after session expired.");
        return;
      }
      const isCheckout = _isCheckout || !hadFirstEvent;
      hadFirstEvent = true;
      if (replay.clickDetector) {
        updateClickDetectorForRecordingEvent(replay.clickDetector, event);
      }
      replay.addUpdate(() => {
        if (replay.recordingMode === "buffer" && isCheckout) {
          replay.setInitialState();
        }
        if (!addEventSync(replay, event, isCheckout)) {
          return true;
        }
        if (!isCheckout) {
          return false;
        }
        addSettingsEvent(replay, isCheckout);
        if (replay.session && replay.session.previousSessionId) {
          return true;
        }
        if (replay.recordingMode === "buffer" && replay.session && replay.eventBuffer) {
          const earliestEvent = replay.eventBuffer.getEarliestTimestamp();
          if (earliestEvent) {
            logInfo(
              `[Replay] Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`,
              replay.getOptions()._experiments.traceInternals
            );
            replay.session.started = earliestEvent;
            if (replay.getOptions().stickySession) {
              saveSession(replay.session);
            }
          }
        }
        if (replay.recordingMode === "session") {
          void replay.flush();
        }
        return true;
      });
    };
  }
  function createOptionsEvent(replay) {
    const options = replay.getOptions();
    return {
      type: EventType.Custom,
      timestamp: Date.now(),
      data: {
        tag: "options",
        payload: {
          shouldRecordCanvas: replay.isRecordingCanvas(),
          sessionSampleRate: options.sessionSampleRate,
          errorSampleRate: options.errorSampleRate,
          useCompressionOption: options.useCompression,
          blockAllMedia: options.blockAllMedia,
          maskAllText: options.maskAllText,
          maskAllInputs: options.maskAllInputs,
          useCompression: replay.eventBuffer ? replay.eventBuffer.type === "worker" : false,
          networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,
          networkCaptureBodies: options.networkCaptureBodies,
          networkRequestHasHeaders: options.networkRequestHeaders.length > 0,
          networkResponseHasHeaders: options.networkResponseHeaders.length > 0
        }
      }
    };
  }
  function addSettingsEvent(replay, isCheckout) {
    if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {
      return;
    }
    addEventSync(replay, createOptionsEvent(replay), false);
  }
  function createReplayEnvelope(replayEvent, recordingData, dsn, tunnel) {
    return createEnvelope(
      createEventEnvelopeHeaders(replayEvent, getSdkMetadataForEnvelopeHeader(replayEvent), tunnel, dsn),
      [
        [{ type: "replay_event" }, replayEvent],
        [
          {
            type: "replay_recording",
            // If string then we need to encode to UTF8, otherwise will have
            // wrong size. TextEncoder has similar browser support to
            // MutationObserver, although it does not accept IE11.
            length: typeof recordingData === "string" ? new TextEncoder().encode(recordingData).length : recordingData.length
          },
          recordingData
        ]
      ]
    );
  }
  function prepareRecordingData({
    recordingData,
    headers
  }) {
    let payloadWithSequence;
    const replayHeaders = `${JSON.stringify(headers)}
`;
    if (typeof recordingData === "string") {
      payloadWithSequence = `${replayHeaders}${recordingData}`;
    } else {
      const enc = new TextEncoder();
      const sequence = enc.encode(replayHeaders);
      payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);
      payloadWithSequence.set(sequence);
      payloadWithSequence.set(recordingData, sequence.length);
    }
    return payloadWithSequence;
  }
  async function prepareReplayEvent({
    client,
    scope,
    replayId: event_id,
    event
  }) {
    const integrations = typeof client._integrations === "object" && client._integrations !== null && !Array.isArray(client._integrations) ? Object.keys(client._integrations) : void 0;
    const eventHint = { event_id, integrations };
    if (client.emit) {
      client.emit("preprocessEvent", event, eventHint);
    }
    const preparedEvent = await prepareEvent(
      client.getOptions(),
      event,
      eventHint,
      scope,
      client,
      getIsolationScope()
    );
    if (!preparedEvent) {
      return null;
    }
    preparedEvent.platform = preparedEvent.platform || "javascript";
    const metadata = client.getSdkMetadata && client.getSdkMetadata();
    const { name, version } = metadata && metadata.sdk || {};
    preparedEvent.sdk = {
      ...preparedEvent.sdk,
      name: name || "sentry.javascript.unknown",
      version: version || "0.0.0"
    };
    return preparedEvent;
  }
  async function sendReplayRequest({
    recordingData,
    replayId,
    segmentId: segment_id,
    eventContext,
    timestamp,
    session
  }) {
    const preparedRecordingData = prepareRecordingData({
      recordingData,
      headers: {
        segment_id
      }
    });
    const { urls, errorIds, traceIds, initialTimestamp } = eventContext;
    const client = getClient();
    const scope = getCurrentScope();
    const transport = client && client.getTransport();
    const dsn = client && client.getDsn();
    if (!client || !transport || !dsn || !session.sampled) {
      return;
    }
    const baseEvent = {
      type: REPLAY_EVENT_NAME,
      replay_start_timestamp: initialTimestamp / 1e3,
      timestamp: timestamp / 1e3,
      error_ids: errorIds,
      trace_ids: traceIds,
      urls,
      replay_id: replayId,
      segment_id,
      replay_type: session.sampled
    };
    const replayEvent = await prepareReplayEvent({ scope, client, replayId, event: baseEvent });
    if (!replayEvent) {
      client.recordDroppedEvent("event_processor", "replay", baseEvent);
      logInfo("An event processor returned `null`, will not send event.");
      return;
    }
    delete replayEvent.sdkProcessingMetadata;
    const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);
    let response;
    try {
      response = await transport.send(envelope);
    } catch (err) {
      const error2 = new Error(UNABLE_TO_SEND_REPLAY);
      try {
        error2.cause = err;
      } catch (e3) {
      }
      throw error2;
    }
    if (!response) {
      return response;
    }
    if (typeof response.statusCode === "number" && (response.statusCode < 200 || response.statusCode >= 300)) {
      throw new TransportStatusCodeError(response.statusCode);
    }
    const rateLimits = updateRateLimits({}, response);
    if (isRateLimited(rateLimits, "replay")) {
      throw new RateLimitError(rateLimits);
    }
    return response;
  }
  var TransportStatusCodeError = class extends Error {
    constructor(statusCode) {
      super(`Transport returned status code ${statusCode}`);
    }
  };
  var RateLimitError = class extends Error {
    constructor(rateLimits) {
      super("Rate limit hit");
      this.rateLimits = rateLimits;
    }
  };
  async function sendReplay(replayData, retryConfig = {
    count: 0,
    interval: RETRY_BASE_INTERVAL
  }) {
    const { recordingData, options } = replayData;
    if (!recordingData.length) {
      return;
    }
    try {
      await sendReplayRequest(replayData);
      return true;
    } catch (err) {
      if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {
        throw err;
      }
      setContext("Replays", {
        _retryCount: retryConfig.count
      });
      if (DEBUG_BUILD5 && options._experiments && options._experiments.captureExceptions) {
        captureException(err);
      }
      if (retryConfig.count >= RETRY_MAX_COUNT) {
        const error2 = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);
        try {
          error2.cause = err;
        } catch (e3) {
        }
        throw error2;
      }
      retryConfig.interval *= ++retryConfig.count;
      return new Promise((resolve, reject) => {
        setTimeout(async () => {
          try {
            await sendReplay(replayData, retryConfig);
            resolve(true);
          } catch (err2) {
            reject(err2);
          }
        }, retryConfig.interval);
      });
    }
  }
  var THROTTLED = "__THROTTLED";
  var SKIPPED = "__SKIPPED";
  function throttle(fn2, maxCount, durationSeconds) {
    const counter2 = /* @__PURE__ */ new Map();
    const _cleanup = (now3) => {
      const threshold = now3 - durationSeconds;
      counter2.forEach((_value, key) => {
        if (key < threshold) {
          counter2.delete(key);
        }
      });
    };
    const _getTotalCount = () => {
      return [...counter2.values()].reduce((a, b) => a + b, 0);
    };
    let isThrottled = false;
    return (...rest) => {
      const now3 = Math.floor(Date.now() / 1e3);
      _cleanup(now3);
      if (_getTotalCount() >= maxCount) {
        const wasThrottled = isThrottled;
        isThrottled = true;
        return wasThrottled ? SKIPPED : THROTTLED;
      }
      isThrottled = false;
      const count = counter2.get(now3) || 0;
      counter2.set(now3, count + 1);
      return fn2(...rest);
    };
  }
  var ReplayContainer = class _ReplayContainer {
    /**
     * Recording can happen in one of three modes:
     *   - session: Record the whole session, sending it continuously
     *   - buffer: Always keep the last 60s of recording, requires:
     *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs
     *     - or calling `flush()` to send the replay
     */
    /**
     * The current or last active transcation.
     * This is only available when performance is enabled.
     */
    /**
     * These are here so we can overwrite them in tests etc.
     * @hidden
     */
    /**
     * Options to pass to `rrweb.record()`
     */
    /**
     * Timestamp of the last user activity. This lives across sessions.
     */
    /**
     * Is the integration currently active?
     */
    /**
     * Paused is a state where:
     * - DOM Recording is not listening at all
     * - Nothing will be added to event buffer (e.g. core SDK events)
     */
    /**
     * Have we attached listeners to the core SDK?
     * Note we have to track this as there is no way to remove instrumentation handlers.
     */
    /**
     * Function to stop recording
     */
    /**
     * Internal use for canvas recording options
     */
    constructor({
      options,
      recordingOptions
    }) {
      _ReplayContainer.prototype.__init.call(this);
      _ReplayContainer.prototype.__init2.call(this);
      _ReplayContainer.prototype.__init3.call(this);
      _ReplayContainer.prototype.__init4.call(this);
      _ReplayContainer.prototype.__init5.call(this);
      _ReplayContainer.prototype.__init6.call(this);
      this.eventBuffer = null;
      this.performanceEntries = [];
      this.replayPerformanceEntries = [];
      this.recordingMode = "session";
      this.timeouts = {
        sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,
        sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION
      };
      this._lastActivity = Date.now();
      this._isEnabled = false;
      this._isPaused = false;
      this._hasInitializedCoreListeners = false;
      this._context = {
        errorIds: /* @__PURE__ */ new Set(),
        traceIds: /* @__PURE__ */ new Set(),
        urls: [],
        initialTimestamp: Date.now(),
        initialUrl: ""
      };
      this._recordingOptions = recordingOptions;
      this._options = options;
      this._debouncedFlush = debounce2(() => this._flush(), this._options.flushMinDelay, {
        maxWait: this._options.flushMaxDelay
      });
      this._throttledAddEvent = throttle(
        (event, isCheckout) => addEvent(this, event, isCheckout),
        // Max 300 events...
        300,
        // ... per 5s
        5
      );
      const { slowClickTimeout, slowClickIgnoreSelectors } = this.getOptions();
      const slowClickConfig = slowClickTimeout ? {
        threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),
        timeout: slowClickTimeout,
        scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,
        ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(",") : ""
      } : void 0;
      if (slowClickConfig) {
        this.clickDetector = new ClickDetector(this, slowClickConfig);
      }
    }
    /** Get the event context. */
    getContext() {
      return this._context;
    }
    /** If recording is currently enabled. */
    isEnabled() {
      return this._isEnabled;
    }
    /** If recording is currently paused. */
    isPaused() {
      return this._isPaused;
    }
    /**
     * Determine if canvas recording is enabled
     */
    isRecordingCanvas() {
      return Boolean(this._canvas);
    }
    /** Get the replay integration options. */
    getOptions() {
      return this._options;
    }
    /**
     * Initializes the plugin based on sampling configuration. Should not be
     * called outside of constructor.
     */
    initializeSampling(previousSessionId) {
      const { errorSampleRate, sessionSampleRate } = this._options;
      if (errorSampleRate <= 0 && sessionSampleRate <= 0) {
        return;
      }
      this._initializeSessionForSampling(previousSessionId);
      if (!this.session) {
        this._handleException(new Error("Unable to initialize and create session"));
        return;
      }
      if (this.session.sampled === false) {
        return;
      }
      this.recordingMode = this.session.sampled === "buffer" && this.session.segmentId === 0 ? "buffer" : "session";
      logInfoNextTick(
        `[Replay] Starting replay in ${this.recordingMode} mode`,
        this._options._experiments.traceInternals
      );
      this._initializeRecording();
    }
    /**
     * Start a replay regardless of sampling rate. Calling this will always
     * create a new session. Will throw an error if replay is already in progress.
     *
     * Creates or loads a session, attaches listeners to varying events (DOM,
     * _performanceObserver, Recording, Sentry SDK, etc)
     */
    start() {
      if (this._isEnabled && this.recordingMode === "session") {
        throw new Error("Replay recording is already in progress");
      }
      if (this._isEnabled && this.recordingMode === "buffer") {
        throw new Error("Replay buffering is in progress, call `flush()` to save the replay");
      }
      logInfoNextTick("[Replay] Starting replay in session mode", this._options._experiments.traceInternals);
      const session = loadOrCreateSession(
        {
          maxReplayDuration: this._options.maxReplayDuration,
          sessionIdleExpire: this.timeouts.sessionIdleExpire,
          traceInternals: this._options._experiments.traceInternals
        },
        {
          stickySession: this._options.stickySession,
          // This is intentional: create a new session-based replay when calling `start()`
          sessionSampleRate: 1,
          allowBuffering: false
        }
      );
      this.session = session;
      this._initializeRecording();
    }
    /**
     * Start replay buffering. Buffers until `flush()` is called or, if
     * `replaysOnErrorSampleRate` > 0, an error occurs.
     */
    startBuffering() {
      if (this._isEnabled) {
        throw new Error("Replay recording is already in progress");
      }
      logInfoNextTick("[Replay] Starting replay in buffer mode", this._options._experiments.traceInternals);
      const session = loadOrCreateSession(
        {
          sessionIdleExpire: this.timeouts.sessionIdleExpire,
          maxReplayDuration: this._options.maxReplayDuration,
          traceInternals: this._options._experiments.traceInternals
        },
        {
          stickySession: this._options.stickySession,
          sessionSampleRate: 0,
          allowBuffering: true
        }
      );
      this.session = session;
      this.recordingMode = "buffer";
      this._initializeRecording();
    }
    /**
     * Start recording.
     *
     * Note that this will cause a new DOM checkout
     */
    startRecording() {
      try {
        const canvasOptions = this._canvas;
        this._stopRecording = record2({
          ...this._recordingOptions,
          // When running in error sampling mode, we need to overwrite `checkoutEveryNms`
          // Without this, it would record forever, until an error happens, which we don't want
          // instead, we'll always keep the last 60 seconds of replay before an error happened
          ...this.recordingMode === "buffer" && { checkoutEveryNms: BUFFER_CHECKOUT_TIME },
          emit: getHandleRecordingEmit(this),
          onMutation: this._onMutationHandler,
          ...canvasOptions ? {
            recordCanvas: canvasOptions.recordCanvas,
            getCanvasManager: canvasOptions.getCanvasManager,
            sampling: canvasOptions.sampling,
            dataURLOptions: canvasOptions.dataURLOptions
          } : {}
        });
      } catch (err) {
        this._handleException(err);
      }
    }
    /**
     * Stops the recording, if it was running.
     *
     * Returns true if it was previously stopped, or is now stopped,
     * otherwise false.
     */
    stopRecording() {
      try {
        if (this._stopRecording) {
          this._stopRecording();
          this._stopRecording = void 0;
        }
        return true;
      } catch (err) {
        this._handleException(err);
        return false;
      }
    }
    /**
     * Currently, this needs to be manually called (e.g. for tests). Sentry SDK
     * does not support a teardown
     */
    async stop({ forceFlush = false, reason } = {}) {
      if (!this._isEnabled) {
        return;
      }
      this._isEnabled = false;
      try {
        logInfo(
          `[Replay] Stopping Replay${reason ? ` triggered by ${reason}` : ""}`,
          this._options._experiments.traceInternals
        );
        this._removeListeners();
        this.stopRecording();
        this._debouncedFlush.cancel();
        if (forceFlush) {
          await this._flush({ force: true });
        }
        this.eventBuffer && this.eventBuffer.destroy();
        this.eventBuffer = null;
        clearSession(this);
      } catch (err) {
        this._handleException(err);
      }
    }
    /**
     * Pause some replay functionality. See comments for `_isPaused`.
     * This differs from stop as this only stops DOM recording, it is
     * not as thorough of a shutdown as `stop()`.
     */
    pause() {
      if (this._isPaused) {
        return;
      }
      this._isPaused = true;
      this.stopRecording();
      logInfo("[Replay] Pausing replay", this._options._experiments.traceInternals);
    }
    /**
     * Resumes recording, see notes for `pause().
     *
     * Note that calling `startRecording()` here will cause a
     * new DOM checkout.`
     */
    resume() {
      if (!this._isPaused || !this._checkSession()) {
        return;
      }
      this._isPaused = false;
      this.startRecording();
      logInfo("[Replay] Resuming replay", this._options._experiments.traceInternals);
    }
    /**
     * If not in "session" recording mode, flush event buffer which will create a new replay.
     * Unless `continueRecording` is false, the replay will continue to record and
     * behave as a "session"-based replay.
     *
     * Otherwise, queue up a flush.
     */
    async sendBufferedReplayOrFlush({ continueRecording = true } = {}) {
      if (this.recordingMode === "session") {
        return this.flushImmediate();
      }
      const activityTime = Date.now();
      logInfo("[Replay] Converting buffer to session", this._options._experiments.traceInternals);
      await this.flushImmediate();
      const hasStoppedRecording = this.stopRecording();
      if (!continueRecording || !hasStoppedRecording) {
        return;
      }
      if (this.recordingMode === "session") {
        return;
      }
      this.recordingMode = "session";
      if (this.session) {
        this._updateUserActivity(activityTime);
        this._updateSessionActivity(activityTime);
        this._maybeSaveSession();
      }
      this.startRecording();
    }
    /**
     * We want to batch uploads of replay events. Save events only if
     * `<flushMinDelay>` milliseconds have elapsed since the last event
     * *OR* if `<flushMaxDelay>` milliseconds have elapsed.
     *
     * Accepts a callback to perform side-effects and returns true to stop batch
     * processing and hand back control to caller.
     */
    addUpdate(cb) {
      const cbResult = cb();
      if (this.recordingMode === "buffer") {
        return;
      }
      if (cbResult === true) {
        return;
      }
      this._debouncedFlush();
    }
    /**
     * Updates the user activity timestamp and resumes recording. This should be
     * called in an event handler for a user action that we consider as the user
     * being "active" (e.g. a mouse click).
     */
    triggerUserActivity() {
      this._updateUserActivity();
      if (!this._stopRecording) {
        if (!this._checkSession()) {
          return;
        }
        this.resume();
        return;
      }
      this.checkAndHandleExpiredSession();
      this._updateSessionActivity();
    }
    /**
     * Updates the user activity timestamp *without* resuming
     * recording. Some user events (e.g. keydown) can be create
     * low-value replays that only contain the keypress as a
     * breadcrumb. Instead this would require other events to
     * create a new replay after a session has expired.
     */
    updateUserActivity() {
      this._updateUserActivity();
      this._updateSessionActivity();
    }
    /**
     * Only flush if `this.recordingMode === 'session'`
     */
    conditionalFlush() {
      if (this.recordingMode === "buffer") {
        return Promise.resolve();
      }
      return this.flushImmediate();
    }
    /**
     * Flush using debounce flush
     */
    flush() {
      return this._debouncedFlush();
    }
    /**
     * Always flush via `_debouncedFlush` so that we do not have flushes triggered
     * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be
     * cases of mulitple flushes happening closely together.
     */
    flushImmediate() {
      this._debouncedFlush();
      return this._debouncedFlush.flush();
    }
    /**
     * Cancels queued up flushes.
     */
    cancelFlush() {
      this._debouncedFlush.cancel();
    }
    /** Get the current sesion (=replay) ID */
    getSessionId() {
      return this.session && this.session.id;
    }
    /**
     * Checks if recording should be stopped due to user inactivity. Otherwise
     * check if session is expired and create a new session if so. Triggers a new
     * full snapshot on new session.
     *
     * Returns true if session is not expired, false otherwise.
     * @hidden
     */
    checkAndHandleExpiredSession() {
      if (this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === "session") {
        this.pause();
        return;
      }
      if (!this._checkSession()) {
        return false;
      }
      return true;
    }
    /**
     * Capture some initial state that can change throughout the lifespan of the
     * replay. This is required because otherwise they would be captured at the
     * first flush.
     */
    setInitialState() {
      const urlPath = `${WINDOW9.location.pathname}${WINDOW9.location.hash}${WINDOW9.location.search}`;
      const url = `${WINDOW9.location.origin}${urlPath}`;
      this.performanceEntries = [];
      this.replayPerformanceEntries = [];
      this._clearContext();
      this._context.initialUrl = url;
      this._context.initialTimestamp = Date.now();
      this._context.urls.push(url);
    }
    /**
     * Add a breadcrumb event, that may be throttled.
     * If it was throttled, we add a custom breadcrumb to indicate that.
     */
    throttledAddEvent(event, isCheckout) {
      const res = this._throttledAddEvent(event, isCheckout);
      if (res === THROTTLED) {
        const breadcrumb = createBreadcrumb({
          category: "replay.throttled"
        });
        this.addUpdate(() => {
          return !addEventSync(this, {
            type: ReplayEventTypeCustom,
            timestamp: breadcrumb.timestamp || 0,
            data: {
              tag: "breadcrumb",
              payload: breadcrumb,
              metric: true
            }
          });
        });
      }
      return res;
    }
    /**
     * This will get the parametrized route name of the current page.
     * This is only available if performance is enabled, and if an instrumented router is used.
     */
    getCurrentRoute() {
      const lastTransaction = this.lastTransaction || getCurrentScope().getTransaction();
      const attributes = lastTransaction && spanToJSON(lastTransaction).data || {};
      const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
      if (!lastTransaction || !source || !["route", "custom"].includes(source)) {
        return void 0;
      }
      return spanToJSON(lastTransaction).description;
    }
    /**
     * Initialize and start all listeners to varying events (DOM,
     * Performance Observer, Recording, Sentry SDK, etc)
     */
    _initializeRecording() {
      this.setInitialState();
      this._updateSessionActivity();
      this.eventBuffer = createEventBuffer({
        useCompression: this._options.useCompression,
        workerUrl: this._options.workerUrl
      });
      this._removeListeners();
      this._addListeners();
      this._isEnabled = true;
      this._isPaused = false;
      this.startRecording();
    }
    /** A wrapper to conditionally capture exceptions. */
    _handleException(error2) {
      DEBUG_BUILD5 && logger.error("[Replay]", error2);
      if (DEBUG_BUILD5 && this._options._experiments && this._options._experiments.captureExceptions) {
        captureException(error2);
      }
    }
    /**
     * Loads (or refreshes) the current session.
     */
    _initializeSessionForSampling(previousSessionId) {
      const allowBuffering = this._options.errorSampleRate > 0;
      const session = loadOrCreateSession(
        {
          sessionIdleExpire: this.timeouts.sessionIdleExpire,
          maxReplayDuration: this._options.maxReplayDuration,
          traceInternals: this._options._experiments.traceInternals,
          previousSessionId
        },
        {
          stickySession: this._options.stickySession,
          sessionSampleRate: this._options.sessionSampleRate,
          allowBuffering
        }
      );
      this.session = session;
    }
    /**
     * Checks and potentially refreshes the current session.
     * Returns false if session is not recorded.
     */
    _checkSession() {
      if (!this.session) {
        return false;
      }
      const currentSession = this.session;
      if (shouldRefreshSession(currentSession, {
        sessionIdleExpire: this.timeouts.sessionIdleExpire,
        maxReplayDuration: this._options.maxReplayDuration
      })) {
        this._refreshSession(currentSession);
        return false;
      }
      return true;
    }
    /**
     * Refresh a session with a new one.
     * This stops the current session (without forcing a flush, as that would never work since we are expired),
     * and then does a new sampling based on the refreshed session.
     */
    async _refreshSession(session) {
      if (!this._isEnabled) {
        return;
      }
      await this.stop({ reason: "refresh session" });
      this.initializeSampling(session.id);
    }
    /**
     * Adds listeners to record events for the replay
     */
    _addListeners() {
      try {
        WINDOW9.document.addEventListener("visibilitychange", this._handleVisibilityChange);
        WINDOW9.addEventListener("blur", this._handleWindowBlur);
        WINDOW9.addEventListener("focus", this._handleWindowFocus);
        WINDOW9.addEventListener("keydown", this._handleKeyboardEvent);
        if (this.clickDetector) {
          this.clickDetector.addListeners();
        }
        if (!this._hasInitializedCoreListeners) {
          addGlobalListeners(this);
          this._hasInitializedCoreListeners = true;
        }
      } catch (err) {
        this._handleException(err);
      }
      this._performanceCleanupCallback = setupPerformanceObserver(this);
    }
    /**
     * Cleans up listeners that were created in `_addListeners`
     */
    _removeListeners() {
      try {
        WINDOW9.document.removeEventListener("visibilitychange", this._handleVisibilityChange);
        WINDOW9.removeEventListener("blur", this._handleWindowBlur);
        WINDOW9.removeEventListener("focus", this._handleWindowFocus);
        WINDOW9.removeEventListener("keydown", this._handleKeyboardEvent);
        if (this.clickDetector) {
          this.clickDetector.removeListeners();
        }
        if (this._performanceCleanupCallback) {
          this._performanceCleanupCallback();
        }
      } catch (err) {
        this._handleException(err);
      }
    }
    /**
     * Handle when visibility of the page content changes. Opening a new tab will
     * cause the state to change to hidden because of content of current page will
     * be hidden. Likewise, moving a different window to cover the contents of the
     * page will also trigger a change to a hidden state.
     */
    __init() {
      this._handleVisibilityChange = () => {
        if (WINDOW9.document.visibilityState === "visible") {
          this._doChangeToForegroundTasks();
        } else {
          this._doChangeToBackgroundTasks();
        }
      };
    }
    /**
     * Handle when page is blurred
     */
    __init2() {
      this._handleWindowBlur = () => {
        const breadcrumb = createBreadcrumb({
          category: "ui.blur"
        });
        this._doChangeToBackgroundTasks(breadcrumb);
      };
    }
    /**
     * Handle when page is focused
     */
    __init3() {
      this._handleWindowFocus = () => {
        const breadcrumb = createBreadcrumb({
          category: "ui.focus"
        });
        this._doChangeToForegroundTasks(breadcrumb);
      };
    }
    /** Ensure page remains active when a key is pressed. */
    __init4() {
      this._handleKeyboardEvent = (event) => {
        handleKeyboardEvent(this, event);
      };
    }
    /**
     * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)
     */
    _doChangeToBackgroundTasks(breadcrumb) {
      if (!this.session) {
        return;
      }
      const expired = isSessionExpired(this.session, {
        maxReplayDuration: this._options.maxReplayDuration,
        sessionIdleExpire: this.timeouts.sessionIdleExpire
      });
      if (expired) {
        return;
      }
      if (breadcrumb) {
        this._createCustomBreadcrumb(breadcrumb);
      }
      void this.conditionalFlush();
    }
    /**
     * Tasks to run when we consider a page to be visible (via focus and/or visibility)
     */
    _doChangeToForegroundTasks(breadcrumb) {
      if (!this.session) {
        return;
      }
      const isSessionActive = this.checkAndHandleExpiredSession();
      if (!isSessionActive) {
        logInfo("[Replay] Document has become active, but session has expired");
        return;
      }
      if (breadcrumb) {
        this._createCustomBreadcrumb(breadcrumb);
      }
    }
    /**
     * Update user activity (across session lifespans)
     */
    _updateUserActivity(_lastActivity = Date.now()) {
      this._lastActivity = _lastActivity;
    }
    /**
     * Updates the session's last activity timestamp
     */
    _updateSessionActivity(_lastActivity = Date.now()) {
      if (this.session) {
        this.session.lastActivity = _lastActivity;
        this._maybeSaveSession();
      }
    }
    /**
     * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb
     */
    _createCustomBreadcrumb(breadcrumb) {
      this.addUpdate(() => {
        this.throttledAddEvent({
          type: EventType.Custom,
          timestamp: breadcrumb.timestamp || 0,
          data: {
            tag: "breadcrumb",
            payload: breadcrumb
          }
        });
      });
    }
    /**
     * Observed performance events are added to `this.performanceEntries`. These
     * are included in the replay event before it is finished and sent to Sentry.
     */
    _addPerformanceEntries() {
      const performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);
      this.performanceEntries = [];
      this.replayPerformanceEntries = [];
      return Promise.all(createPerformanceSpans(this, performanceEntries));
    }
    /**
     * Clear _context
     */
    _clearContext() {
      this._context.errorIds.clear();
      this._context.traceIds.clear();
      this._context.urls = [];
    }
    /** Update the initial timestamp based on the buffer content. */
    _updateInitialTimestampFromEventBuffer() {
      const { session, eventBuffer } = this;
      if (!session || !eventBuffer) {
        return;
      }
      if (session.segmentId) {
        return;
      }
      const earliestEvent = eventBuffer.getEarliestTimestamp();
      if (earliestEvent && earliestEvent < this._context.initialTimestamp) {
        this._context.initialTimestamp = earliestEvent;
      }
    }
    /**
     * Return and clear _context
     */
    _popEventContext() {
      const _context = {
        initialTimestamp: this._context.initialTimestamp,
        initialUrl: this._context.initialUrl,
        errorIds: Array.from(this._context.errorIds),
        traceIds: Array.from(this._context.traceIds),
        urls: this._context.urls
      };
      this._clearContext();
      return _context;
    }
    /**
     * Flushes replay event buffer to Sentry.
     *
     * Performance events are only added right before flushing - this is
     * due to the buffered performance observer events.
     *
     * Should never be called directly, only by `flush`
     */
    async _runFlush() {
      const replayId = this.getSessionId();
      if (!this.session || !this.eventBuffer || !replayId) {
        DEBUG_BUILD5 && logger.error("[Replay] No session or eventBuffer found to flush.");
        return;
      }
      await this._addPerformanceEntries();
      if (!this.eventBuffer || !this.eventBuffer.hasEvents) {
        return;
      }
      await addMemoryEntry(this);
      if (!this.eventBuffer) {
        return;
      }
      if (replayId !== this.getSessionId()) {
        return;
      }
      try {
        this._updateInitialTimestampFromEventBuffer();
        const timestamp = Date.now();
        if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4) {
          throw new Error("Session is too long, not sending replay");
        }
        const eventContext = this._popEventContext();
        const segmentId = this.session.segmentId++;
        this._maybeSaveSession();
        const recordingData = await this.eventBuffer.finish();
        await sendReplay({
          replayId,
          recordingData,
          segmentId,
          eventContext,
          session: this.session,
          options: this.getOptions(),
          timestamp
        });
      } catch (err) {
        this._handleException(err);
        this.stop({ reason: "sendReplay" });
        const client = getClient();
        if (client) {
          client.recordDroppedEvent("send_error", "replay");
        }
      }
    }
    /**
     * Flush recording data to Sentry. Creates a lock so that only a single flush
     * can be active at a time. Do not call this directly.
     */
    __init5() {
      this._flush = async ({
        force = false
      } = {}) => {
        if (!this._isEnabled && !force) {
          return;
        }
        if (!this.checkAndHandleExpiredSession()) {
          DEBUG_BUILD5 && logger.error("[Replay] Attempting to finish replay event after session expired.");
          return;
        }
        if (!this.session) {
          return;
        }
        const start2 = this.session.started;
        const now3 = Date.now();
        const duration = now3 - start2;
        this._debouncedFlush.cancel();
        const tooShort = duration < this._options.minReplayDuration;
        const tooLong = duration > this._options.maxReplayDuration + 5e3;
        if (tooShort || tooLong) {
          logInfo(
            `[Replay] Session duration (${Math.floor(duration / 1e3)}s) is too ${tooShort ? "short" : "long"}, not sending replay.`,
            this._options._experiments.traceInternals
          );
          if (tooShort) {
            this._debouncedFlush();
          }
          return;
        }
        const eventBuffer = this.eventBuffer;
        if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {
          logInfo("[Replay] Flushing initial segment without checkout.", this._options._experiments.traceInternals);
        }
        if (!this._flushLock) {
          this._flushLock = this._runFlush();
          await this._flushLock;
          this._flushLock = void 0;
          return;
        }
        try {
          await this._flushLock;
        } catch (err) {
          DEBUG_BUILD5 && logger.error(err);
        } finally {
          this._debouncedFlush();
        }
      };
    }
    /** Save the session, if it is sticky */
    _maybeSaveSession() {
      if (this.session && this._options.stickySession) {
        saveSession(this.session);
      }
    }
    /** Handler for rrweb.record.onMutation */
    __init6() {
      this._onMutationHandler = (mutations) => {
        const count = mutations.length;
        const mutationLimit = this._options.mutationLimit;
        const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;
        const overMutationLimit = mutationLimit && count > mutationLimit;
        if (count > mutationBreadcrumbLimit || overMutationLimit) {
          const breadcrumb = createBreadcrumb({
            category: "replay.mutations",
            data: {
              count,
              limit: overMutationLimit
            }
          });
          this._createCustomBreadcrumb(breadcrumb);
        }
        if (overMutationLimit) {
          this.stop({ reason: "mutationLimit", forceFlush: this.recordingMode === "session" });
          return false;
        }
        return true;
      };
    }
  };
  function getOption(selectors, defaultSelectors, deprecatedClassOption, deprecatedSelectorOption) {
    const deprecatedSelectors = typeof deprecatedSelectorOption === "string" ? deprecatedSelectorOption.split(",") : [];
    const allSelectors = [
      ...selectors,
      // @deprecated
      ...deprecatedSelectors,
      // sentry defaults
      ...defaultSelectors
    ];
    if (typeof deprecatedClassOption !== "undefined") {
      if (typeof deprecatedClassOption === "string") {
        allSelectors.push(`.${deprecatedClassOption}`);
      }
      consoleSandbox(() => {
        console.warn(
          "[Replay] You are using a deprecated configuration item for privacy. Read the documentation on how to use the new privacy configuration."
        );
      });
    }
    return allSelectors.join(",");
  }
  function getPrivacyOptions({
    mask,
    unmask,
    block,
    unblock,
    ignore,
    // eslint-disable-next-line deprecation/deprecation
    blockClass,
    // eslint-disable-next-line deprecation/deprecation
    blockSelector,
    // eslint-disable-next-line deprecation/deprecation
    maskTextClass,
    // eslint-disable-next-line deprecation/deprecation
    maskTextSelector,
    // eslint-disable-next-line deprecation/deprecation
    ignoreClass
  }) {
    const defaultBlockedElements = ['base[href="/"]'];
    const maskSelector = getOption(mask, [".sentry-mask", "[data-sentry-mask]"], maskTextClass, maskTextSelector);
    const unmaskSelector = getOption(unmask, [".sentry-unmask", "[data-sentry-unmask]"]);
    const options = {
      // We are making the decision to make text and input selectors the same
      maskTextSelector: maskSelector,
      unmaskTextSelector: unmaskSelector,
      blockSelector: getOption(
        block,
        [".sentry-block", "[data-sentry-block]", ...defaultBlockedElements],
        blockClass,
        blockSelector
      ),
      unblockSelector: getOption(unblock, [".sentry-unblock", "[data-sentry-unblock]"]),
      ignoreSelector: getOption(ignore, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'], ignoreClass)
    };
    if (blockClass instanceof RegExp) {
      options.blockClass = blockClass;
    }
    if (maskTextClass instanceof RegExp) {
      options.maskTextClass = maskTextClass;
    }
    return options;
  }
  function maskAttribute({
    el,
    key,
    maskAttributes,
    maskAllText,
    privacyOptions,
    value
  }) {
    if (!maskAllText) {
      return value;
    }
    if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {
      return value;
    }
    if (maskAttributes.includes(key) || // Need to mask `value` attribute for `<input>` if it's a button-like
    // type
    key === "value" && el.tagName === "INPUT" && ["submit", "button"].includes(el.getAttribute("type") || "")) {
      return value.replace(/[\S]/g, "*");
    }
    return value;
  }
  var MEDIA_SELECTORS = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]';
  var DEFAULT_NETWORK_HEADERS = ["content-length", "content-type", "accept"];
  var _initialized = false;
  var replayIntegration$1 = (options) => {
    return new Replay$1(options);
  };
  var Replay$1 = class _Replay$1 {
    /**
     * @inheritDoc
     */
    static __initStatic() {
      this.id = "Replay";
    }
    /**
     * @inheritDoc
     */
    /**
     * Options to pass to `rrweb.record()`
     */
    /**
     * Initial options passed to the replay integration, merged with default values.
     * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they
     * can only be finally set when setupOnce() is called.
     *
     * @private
     */
    constructor({
      flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,
      flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,
      minReplayDuration = MIN_REPLAY_DURATION,
      maxReplayDuration = MAX_REPLAY_DURATION,
      stickySession = true,
      useCompression = true,
      workerUrl,
      _experiments = {},
      sessionSampleRate,
      errorSampleRate,
      maskAllText = true,
      maskAllInputs = true,
      blockAllMedia = true,
      mutationBreadcrumbLimit = 750,
      mutationLimit = 1e4,
      slowClickTimeout = 7e3,
      slowClickIgnoreSelectors = [],
      networkDetailAllowUrls = [],
      networkDetailDenyUrls = [],
      networkCaptureBodies = true,
      networkRequestHeaders = [],
      networkResponseHeaders = [],
      mask = [],
      maskAttributes = ["title", "placeholder"],
      unmask = [],
      block = [],
      unblock = [],
      ignore = [],
      maskFn,
      beforeAddRecordingEvent,
      beforeErrorSampling,
      // eslint-disable-next-line deprecation/deprecation
      blockClass,
      // eslint-disable-next-line deprecation/deprecation
      blockSelector,
      // eslint-disable-next-line deprecation/deprecation
      maskInputOptions,
      // eslint-disable-next-line deprecation/deprecation
      maskTextClass,
      // eslint-disable-next-line deprecation/deprecation
      maskTextSelector,
      // eslint-disable-next-line deprecation/deprecation
      ignoreClass
    } = {}) {
      this.name = _Replay$1.id;
      const privacyOptions = getPrivacyOptions({
        mask,
        unmask,
        block,
        unblock,
        ignore,
        blockClass,
        blockSelector,
        maskTextClass,
        maskTextSelector,
        ignoreClass
      });
      this._recordingOptions = {
        maskAllInputs,
        maskAllText,
        maskInputOptions: { ...maskInputOptions || {}, password: true },
        maskTextFn: maskFn,
        maskInputFn: maskFn,
        maskAttributeFn: (key, value, el) => maskAttribute({
          maskAttributes,
          maskAllText,
          privacyOptions,
          key,
          value,
          el
        }),
        ...privacyOptions,
        // Our defaults
        slimDOMOptions: "all",
        inlineStylesheet: true,
        // Disable inline images as it will increase segment/replay size
        inlineImages: false,
        // collect fonts, but be aware that `sentry.io` needs to be an allowed
        // origin for playback
        collectFonts: true,
        errorHandler: (err) => {
          try {
            err.__rrweb__ = true;
          } catch (error2) {
          }
        }
      };
      this._initialOptions = {
        flushMinDelay,
        flushMaxDelay,
        minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),
        maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),
        stickySession,
        sessionSampleRate,
        errorSampleRate,
        useCompression,
        workerUrl,
        blockAllMedia,
        maskAllInputs,
        maskAllText,
        mutationBreadcrumbLimit,
        mutationLimit,
        slowClickTimeout,
        slowClickIgnoreSelectors,
        networkDetailAllowUrls,
        networkDetailDenyUrls,
        networkCaptureBodies,
        networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),
        networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),
        beforeAddRecordingEvent,
        beforeErrorSampling,
        _experiments
      };
      if (typeof sessionSampleRate === "number") {
        console.warn(
          `[Replay] You are passing \`sessionSampleRate\` to the Replay integration.
This option is deprecated and will be removed soon.
Instead, configure \`replaysSessionSampleRate\` directly in the SDK init options, e.g.:
Sentry.init({ replaysSessionSampleRate: ${sessionSampleRate} })`
        );
        this._initialOptions.sessionSampleRate = sessionSampleRate;
      }
      if (typeof errorSampleRate === "number") {
        console.warn(
          `[Replay] You are passing \`errorSampleRate\` to the Replay integration.
This option is deprecated and will be removed soon.
Instead, configure \`replaysOnErrorSampleRate\` directly in the SDK init options, e.g.:
Sentry.init({ replaysOnErrorSampleRate: ${errorSampleRate} })`
        );
        this._initialOptions.errorSampleRate = errorSampleRate;
      }
      if (this._initialOptions.blockAllMedia) {
        this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector ? MEDIA_SELECTORS : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;
      }
      if (this._isInitialized && isBrowser5()) {
        throw new Error("Multiple Sentry Session Replay instances are not supported");
      }
      this._isInitialized = true;
    }
    /** If replay has already been initialized */
    get _isInitialized() {
      return _initialized;
    }
    /** Update _isInitialized */
    set _isInitialized(value) {
      _initialized = value;
    }
    /**
     * Setup and initialize replay container
     */
    setupOnce() {
      if (!isBrowser5()) {
        return;
      }
      this._setup();
      setTimeout(() => this._initialize());
    }
    /**
     * Start a replay regardless of sampling rate. Calling this will always
     * create a new session. Will throw an error if replay is already in progress.
     *
     * Creates or loads a session, attaches listeners to varying events (DOM,
     * PerformanceObserver, Recording, Sentry SDK, etc)
     */
    start() {
      if (!this._replay) {
        return;
      }
      this._replay.start();
    }
    /**
     * Start replay buffering. Buffers until `flush()` is called or, if
     * `replaysOnErrorSampleRate` > 0, until an error occurs.
     */
    startBuffering() {
      if (!this._replay) {
        return;
      }
      this._replay.startBuffering();
    }
    /**
     * Currently, this needs to be manually called (e.g. for tests). Sentry SDK
     * does not support a teardown
     */
    stop() {
      if (!this._replay) {
        return Promise.resolve();
      }
      return this._replay.stop({ forceFlush: this._replay.recordingMode === "session" });
    }
    /**
     * If not in "session" recording mode, flush event buffer which will create a new replay.
     * Unless `continueRecording` is false, the replay will continue to record and
     * behave as a "session"-based replay.
     *
     * Otherwise, queue up a flush.
     */
    flush(options) {
      if (!this._replay || !this._replay.isEnabled()) {
        return Promise.resolve();
      }
      return this._replay.sendBufferedReplayOrFlush(options);
    }
    /**
     * Get the current session ID.
     */
    getReplayId() {
      if (!this._replay || !this._replay.isEnabled()) {
        return;
      }
      return this._replay.getSessionId();
    }
    /**
     * Initializes replay.
     */
    _initialize() {
      if (!this._replay) {
        return;
      }
      this._maybeLoadFromReplayCanvasIntegration();
      this._replay.initializeSampling();
    }
    /** Setup the integration. */
    _setup() {
      const finalOptions = loadReplayOptionsFromClient(this._initialOptions);
      this._replay = new ReplayContainer({
        options: finalOptions,
        recordingOptions: this._recordingOptions
      });
    }
    /** Get canvas options from ReplayCanvas integration, if it is also added. */
    _maybeLoadFromReplayCanvasIntegration() {
      try {
        const client = getClient();
        const canvasIntegration = client.getIntegrationByName("ReplayCanvas");
        if (!canvasIntegration) {
          return;
        }
        this._replay["_canvas"] = canvasIntegration.getOptions();
      } catch (e3) {
      }
    }
  };
  Replay$1.__initStatic();
  function loadReplayOptionsFromClient(initialOptions) {
    const client = getClient();
    const opt = client && client.getOptions();
    const finalOptions = { sessionSampleRate: 0, errorSampleRate: 0, ...dropUndefinedKeys(initialOptions) };
    if (!opt) {
      consoleSandbox(() => {
        console.warn("SDK client is not available.");
      });
      return finalOptions;
    }
    if (initialOptions.sessionSampleRate == null && // TODO remove once deprecated rates are removed
    initialOptions.errorSampleRate == null && // TODO remove once deprecated rates are removed
    opt.replaysSessionSampleRate == null && opt.replaysOnErrorSampleRate == null) {
      consoleSandbox(() => {
        console.warn(
          "Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set."
        );
      });
    }
    if (typeof opt.replaysSessionSampleRate === "number") {
      finalOptions.sessionSampleRate = opt.replaysSessionSampleRate;
    }
    if (typeof opt.replaysOnErrorSampleRate === "number") {
      finalOptions.errorSampleRate = opt.replaysOnErrorSampleRate;
    }
    return finalOptions;
  }
  function _getMergedNetworkHeaders(headers) {
    return [...DEFAULT_NETWORK_HEADERS, ...headers.map((header) => header.toLowerCase())];
  }

  // node_modules/@sentry/browser/esm/index.js
  var windowIntegrations = {};
  if (WINDOW8.Sentry && WINDOW8.Sentry.Integrations) {
    windowIntegrations = WINDOW8.Sentry.Integrations;
  }
  var INTEGRATIONS = {
    ...windowIntegrations,
    // eslint-disable-next-line deprecation/deprecation
    ...Integrations,
    ...integrations_exports2
  };

  // node_modules/@sentry/react/esm/sdk.js
  function init2(options) {
    const opts = {
      ...options
    };
    applySdkMetadata(opts, "react");
    init(opts);
  }

  // src/app/app.tsx
  var theme2 = extendTheme({
    styles: {
      global: {
        html: {
          fontSize: "12px"
        }
      }
    }
  });
  var App = (props) => {
    return /* @__PURE__ */ import_react130.default.createElement(ChakraProvider2, { theme: theme2 }, /* @__PURE__ */ import_react130.default.createElement(CalculatorAppView, null));
  };
  function main2() {
    init2({
      dsn: "https://524c6df58e35c7a92c235c4e211debcd@o4507091991396352.ingest.us.sentry.io/4507111559397376",
      integrations: [
        browserTracingIntegration(),
        replayIntegration$1()
      ],
      // Performance Monitoring
      tracesSampleRate: 1,
      //  Capture 100% of the transactions
      // Set 'tracePropagationTargets' to control for which URLs distributed tracing should be enabled
      tracePropagationTargets: [
        "localhost",
        /^https:\/\/hvac-sim-app.onrender.com\//
      ],
      // Session Replay
      replaysSessionSampleRate: 1,
      // This sets the sample rate at 10%. You may want to change it to 100% while in development and then sample at a lower rate in production.
      replaysOnErrorSampleRate: 1
      // If you're not already sampling the entire session, change the sample rate to 100% when sampling sessions where errors occur.
    });
    const rootNode = document.createElement("div");
    document.body.appendChild(rootNode);
    const root = (0, import_client2.createRoot)(rootNode);
    root.render(/* @__PURE__ */ import_react130.default.createElement(App, null));
  }
  main2();
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=app.js.map
